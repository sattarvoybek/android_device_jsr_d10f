From 9798f1cd50bb2bf50ae046d11d02c053b32701b3 Mon Sep 17 00:00:00 2001
From: proDOOMman <prodoomman@gmail.com>
Date: Mon, 15 Dec 2014 12:07:21 +0300
Subject: [PATCH] X9180: initial commit

Change-Id: I7e104875778082d5460c3e86294b4805a7baa6fe
---
 AndroidKernel.mk                                   |    4 +-
 arch/arm/boot/dts/msm-pm8226.dtsi                  |   88 +-
 arch/arm/boot/dts/msm8226-mdss.dtsi                |   46 +-
 arch/arm/boot/dts/msm8226-regulator.dtsi           |   16 +-
 arch/arm/boot/dts/msm8226.dtsi                     |   21 +-
 arch/arm/boot/dts/msm8926-ne501j.dts               |   26 +
 arch/arm/boot/dts/msm8926-ne504h.dts               |   25 +
 arch/arm/boot/dts/msm8926-nx404h.dts               |   28 +
 .../dts/zte/ne501j/batterydata-zte-2400mah.dtsi    |  112 +
 .../ne501j/dsi-cs-panel-nt35592-720p-video.dtsi    |  579 +++
 .../dsi-lianchuang-panel-nt35592-720p-video.dtsi   |  567 +++
 .../dsi-success-panel-hx8392b-720p-video.dtsi      |  105 +
 arch/arm/boot/dts/zte/ne501j/msm8226-720p-mtp.dtsi |  636 +++
 .../dts/zte/ne501j/msm8226-camera-sensor-mtp.dtsi  |  258 ++
 .../dts/zte/ne504h/batterydata-zte-2400mah.dtsi    |  112 +
 .../ne504h/dsi-cs-panel-nt35592-720p-video.dtsi    |  568 +++
 .../dsi-success-panel-hx8392b-720p-video.dtsi      |   98 +
 arch/arm/boot/dts/zte/ne504h/msm8226-720p-mtp.dtsi |  590 +++
 .../dts/zte/ne504h/msm8226-camera-sensor-mtp.dtsi  |  258 ++
 .../dts/zte/nx404h/batterydata-zte-2000mah.dtsi    |  110 +
 .../nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi |   82 +
 .../nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi    |   83 +
 .../nx404h/dsi-sharp-panel-r69431-720p-video.dtsi  |   75 +
 .../nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi |  195 +
 .../dsi-tianma-panel-otm1282a-720p-video.dtsi      |  191 +
 arch/arm/boot/dts/zte/nx404h/msm8226-720p-mtp.dtsi |  597 +++
 .../dts/zte/nx404h/msm8226-camera-sensor-mtp.dtsi  |  172 +
 arch/arm/configs/msm8926-ne501j_defconfig          |  525 +++
 arch/arm/configs/msm8926-nx404h_defconfig          |  525 +++
 arch/arm/mach-msm/Makefile                         |    4 +
 arch/arm/mach-msm/bms_ztemt_batterydata_2000mAh.c  |  103 +
 arch/arm/mach-msm/bms_ztemt_batterydata_2400mAh.c  |  202 +
 arch/arm/mach-msm/board-8226-gpiomux.c             |  115 +-
 arch/arm/mach-msm/clock-8226.c                     |   13 +
 arch/arm/mach-msm/include/mach/board.h             |    3 +
 arch/arm/mach-msm/include/mach/restart.h           |    3 +
 drivers/base/power/wakeup.c                        |   36 +-
 drivers/hwmon/Kconfig                              |  118 +
 drivers/hwmon/Makefile                             |   25 +
 drivers/hwmon/aw_9106b.c                           | 1246 ++++++
 drivers/hwmon/aw_9106b.h                           |   57 +
 drivers/hwmon/maxq616.c                            |  218 +
 drivers/hwmon/qpnp-adc-common.c                    |   28 +
 drivers/hwmon/sensor_common.c                      |  265 ++
 drivers/hwmon/shtc1.c                              |  807 ++++
 drivers/hwmon/tmd2772.c                            | 3540 +++++++++++++++
 drivers/hwmon/tmd2772_ne501j.c                     | 3142 ++++++++++++++
 drivers/hwmon/tmd2772_nx404h.c                     | 3142 ++++++++++++++
 drivers/hwmon/tmg399x.c                            | 4526 +++++++++++++++++++
 drivers/input/touchscreen/Kconfig                  |    2 +
 drivers/input/touchscreen/Makefile                 |    2 +
 drivers/input/touchscreen/gt915/Kconfig            |   81 +
 drivers/input/touchscreen/gt915/Makefile           |   11 +
 drivers/input/touchscreen/gt915/goodix_tool.c      |  627 +++
 drivers/input/touchscreen/gt915/gt9xx.c            | 3416 +++++++++++++++
 drivers/input/touchscreen/gt915/gt9xx.h            |  351 ++
 .../input/touchscreen/gt915/gt9xx_firmware-1030.h  | 4528 ++++++++++++++++++++
 drivers/input/touchscreen/gt915/gt9xx_openshort.c  | 2186 ++++++++++
 drivers/input/touchscreen/gt915/gt9xx_openshort.h  |  448 ++
 drivers/input/touchscreen/gt915/gt9xx_update.c     | 3684 ++++++++++++++++
 drivers/leds/Kconfig                               |   14 +
 drivers/leds/Makefile                              |    2 +
 drivers/leds/ztemt-leds-qpnp.c                     | 4101 ++++++++++++++++++
 drivers/platform/msm/qpnp-power-on.c               |   77 +
 drivers/platform/msm/qpnp-pwm.c                    |   36 +-
 drivers/power/Kconfig                              |   59 +-
 drivers/power/Makefile                             |    1 +
 drivers/power/power_supply_core.c                  |   14 +
 drivers/power/power_supply_sysfs.c                 |    5 +
 drivers/power/qpnp-bms.c                           |   13 +-
 drivers/power/qpnp-charger.c                       |  624 ++-
 drivers/power/ztemt_hw_version.c                   |  402 ++
 drivers/power/ztemt_hw_version.h                   |   65 +
 drivers/rtc/Kconfig                                |    5 +
 drivers/rtc/alarm.c                                |   22 +-
 drivers/rtc/qpnp-rtc.c                             |   54 +
 drivers/spmi/spmi.c                                |   14 +-
 drivers/usb/dwc3/dwc3-msm.c                        |   16 +
 drivers/usb/dwc3/dwc3_otg.c                        |   18 +
 drivers/usb/gadget/android.c                       |    6 +-
 drivers/usb/otg/msm_otg.c                          |   25 +
 drivers/video/msm/mdss/Kconfig                     |   35 +
 drivers/video/msm/mdss/Makefile                    |    2 +
 drivers/video/msm/mdss/mdss_dsi.c                  |  125 +
 drivers/video/msm/mdss/mdss_dsi.h                  |   19 +
 drivers/video/msm/mdss/mdss_dsi_panel.c            |  169 +-
 drivers/video/msm/mdss/mdss_dsi_status.c           |   40 +-
 drivers/video/msm/mdss/mdss_fb.c                   |   46 +
 drivers/video/msm/mdss/mdss_mdp.c                  |    1 +
 drivers/video/msm/mdss/mdss_mdp_rotator.c          |   10 +
 drivers/video/msm/mdss/mdss_panel.h                |    6 +
 drivers/video/msm/mdss/zte_disp_enhance.c          |  241 ++
 include/linux/batterydata-lib.h                    |    6 +
 include/linux/i2c/sensor_common.h                  |   16 +
 include/linux/i2c/shtc1.h                          |   72 +
 include/linux/i2c/taos_common.h                    |   85 +
 include/linux/i2c/tmg399x.h                        |  458 ++
 include/linux/mfd/wcd9xxx/wcd9306_registers.h      |    8 +
 include/linux/power_supply.h                       |    5 +
 include/linux/usb/android.h                        |    3 +-
 kernel/power/suspend.c                             |    7 +-
 sound/Kconfig                                      |   10 +
 sound/soc/codecs/wcd9306.c                         |   11 +
 sound/soc/codecs/wcd9xxx-mbhc.c                    |    2 +-
 sound/soc/msm/msm8226.c                            |   22 +-
 105 files changed, 46508 insertions(+), 85 deletions(-)
 mode change 100644 => 100755 arch/arm/boot/dts/msm-pm8226.dtsi
 mode change 100644 => 100755 arch/arm/boot/dts/msm8226-mdss.dtsi
 mode change 100644 => 100755 arch/arm/boot/dts/msm8226-regulator.dtsi
 create mode 100755 arch/arm/boot/dts/msm8926-ne501j.dts
 create mode 100755 arch/arm/boot/dts/msm8926-ne504h.dts
 create mode 100755 arch/arm/boot/dts/msm8926-nx404h.dts
 create mode 100755 arch/arm/boot/dts/zte/ne501j/batterydata-zte-2400mah.dtsi
 create mode 100644 arch/arm/boot/dts/zte/ne501j/dsi-cs-panel-nt35592-720p-video.dtsi
 create mode 100644 arch/arm/boot/dts/zte/ne501j/dsi-lianchuang-panel-nt35592-720p-video.dtsi
 create mode 100644 arch/arm/boot/dts/zte/ne501j/dsi-success-panel-hx8392b-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne501j/msm8226-720p-mtp.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne501j/msm8226-camera-sensor-mtp.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne504h/batterydata-zte-2400mah.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne504h/dsi-cs-panel-nt35592-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne504h/dsi-success-panel-hx8392b-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne504h/msm8226-720p-mtp.dtsi
 create mode 100755 arch/arm/boot/dts/zte/ne504h/msm8226-camera-sensor-mtp.dtsi
 create mode 100644 arch/arm/boot/dts/zte/nx404h/batterydata-zte-2000mah.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-video.dtsi
 create mode 100755 arch/arm/boot/dts/zte/nx404h/msm8226-720p-mtp.dtsi
 create mode 100644 arch/arm/boot/dts/zte/nx404h/msm8226-camera-sensor-mtp.dtsi
 create mode 100644 arch/arm/configs/msm8926-ne501j_defconfig
 create mode 100755 arch/arm/configs/msm8926-nx404h_defconfig
 mode change 100644 => 100755 arch/arm/mach-msm/Makefile
 create mode 100755 arch/arm/mach-msm/bms_ztemt_batterydata_2000mAh.c
 create mode 100755 arch/arm/mach-msm/bms_ztemt_batterydata_2400mAh.c
 mode change 100644 => 100755 arch/arm/mach-msm/board-8226-gpiomux.c
 mode change 100644 => 100755 arch/arm/mach-msm/clock-8226.c
 mode change 100644 => 100755 arch/arm/mach-msm/include/mach/board.h
 mode change 100644 => 100755 arch/arm/mach-msm/include/mach/restart.h
 mode change 100644 => 100755 drivers/base/power/wakeup.c
 mode change 100644 => 100755 drivers/hwmon/Kconfig
 mode change 100644 => 100755 drivers/hwmon/Makefile
 create mode 100755 drivers/hwmon/aw_9106b.c
 create mode 100755 drivers/hwmon/aw_9106b.h
 create mode 100644 drivers/hwmon/maxq616.c
 mode change 100644 => 100755 drivers/hwmon/qpnp-adc-common.c
 create mode 100644 drivers/hwmon/sensor_common.c
 create mode 100644 drivers/hwmon/shtc1.c
 create mode 100755 drivers/hwmon/tmd2772.c
 create mode 100644 drivers/hwmon/tmd2772_ne501j.c
 create mode 100644 drivers/hwmon/tmd2772_nx404h.c
 create mode 100644 drivers/hwmon/tmg399x.c
 mode change 100644 => 100755 drivers/input/touchscreen/Kconfig
 mode change 100644 => 100755 drivers/input/touchscreen/Makefile
 create mode 100755 drivers/input/touchscreen/gt915/Kconfig
 create mode 100755 drivers/input/touchscreen/gt915/Makefile
 create mode 100755 drivers/input/touchscreen/gt915/goodix_tool.c
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx.c
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx.h
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx_firmware-1030.h
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx_openshort.c
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx_openshort.h
 create mode 100755 drivers/input/touchscreen/gt915/gt9xx_update.c
 mode change 100644 => 100755 drivers/leds/Kconfig
 mode change 100644 => 100755 drivers/leds/Makefile
 create mode 100755 drivers/leds/ztemt-leds-qpnp.c
 mode change 100644 => 100755 drivers/platform/msm/qpnp-power-on.c
 mode change 100644 => 100755 drivers/platform/msm/qpnp-pwm.c
 mode change 100644 => 100755 drivers/power/Kconfig
 mode change 100644 => 100755 drivers/power/Makefile
 mode change 100644 => 100755 drivers/power/power_supply_core.c
 mode change 100644 => 100755 drivers/power/power_supply_sysfs.c
 mode change 100644 => 100755 drivers/power/qpnp-bms.c
 mode change 100644 => 100755 drivers/power/qpnp-charger.c
 create mode 100755 drivers/power/ztemt_hw_version.c
 create mode 100755 drivers/power/ztemt_hw_version.h
 mode change 100644 => 100755 drivers/rtc/Kconfig
 mode change 100644 => 100755 drivers/rtc/alarm.c
 mode change 100644 => 100755 drivers/rtc/qpnp-rtc.c
 mode change 100644 => 100755 drivers/spmi/spmi.c
 mode change 100644 => 100755 drivers/usb/dwc3/dwc3-msm.c
 mode change 100644 => 100755 drivers/usb/dwc3/dwc3_otg.c
 mode change 100644 => 100755 drivers/usb/gadget/android.c
 mode change 100644 => 100755 drivers/usb/otg/msm_otg.c
 mode change 100644 => 100755 drivers/video/msm/mdss/Makefile
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi.h
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_dsi_status.c
 mode change 100644 => 100755 drivers/video/msm/mdss/mdss_mdp_rotator.c
 create mode 100755 drivers/video/msm/mdss/zte_disp_enhance.c
 mode change 100644 => 100755 include/linux/batterydata-lib.h
 create mode 100644 include/linux/i2c/sensor_common.h
 create mode 100644 include/linux/i2c/shtc1.h
 create mode 100755 include/linux/i2c/taos_common.h
 create mode 100644 include/linux/i2c/tmg399x.h
 mode change 100644 => 100755 include/linux/power_supply.h
 mode change 100644 => 100755 include/linux/usb/android.h
 mode change 100644 => 100755 kernel/power/suspend.c

diff --git a/AndroidKernel.mk b/AndroidKernel.mk
index d97d3c3..478c37d 100644
--- a/AndroidKernel.mk
+++ b/AndroidKernel.mk
@@ -26,6 +26,8 @@ ZIMG_FILE = $(addprefix $(KERNEL_OUT)/arch/arm/boot/,$(patsubst %.dts,%-zImage,$
 KERNEL_ZIMG = $(KERNEL_OUT)/arch/arm/boot/zImage
 DTC = $(KERNEL_OUT)/scripts/dtc/dtc
 
+export CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE_NAMES=$(DTS_NAME)
+
 define append-dtb
 mkdir -p $(KERNEL_OUT)/arch/arm/boot;\
 $(foreach DTS_NAME, $(DTS_NAMES), \
@@ -77,7 +79,7 @@ $(TARGET_PREBUILT_INT_KERNEL): $(KERNEL_OUT) $(KERNEL_CONFIG) $(KERNEL_HEADERS_I
 	$(MAKE) -C kernel O=../$(KERNEL_OUT) INSTALL_MOD_PATH=../../$(KERNEL_MODULES_INSTALL) INSTALL_MOD_STRIP=1 ARCH=arm CROSS_COMPILE=arm-eabi- modules_install
 	$(mv-modules)
 	$(clean-module-folder)
-	$(append-dtb)
+#	$(append-dtb)
 
 $(KERNEL_HEADERS_INSTALL): $(KERNEL_OUT) $(KERNEL_CONFIG)
 	$(MAKE) -C kernel O=../$(KERNEL_OUT) ARCH=arm CROSS_COMPILE=arm-eabi- headers_install
diff --git a/arch/arm/boot/dts/msm-pm8226.dtsi b/arch/arm/boot/dts/msm-pm8226.dtsi
old mode 100644
new mode 100755
index dcc29ce..f3afe49
--- a/arch/arm/boot/dts/msm-pm8226.dtsi
+++ b/arch/arm/boot/dts/msm-pm8226.dtsi
@@ -47,11 +47,13 @@
 				linux,code = <116>;
 			};
 
+			/*
 			qcom,pon_2 {
 				qcom,pon-type = <1>;
 				qcom,pull-up = <1>;
 				linux,code = <114>;
 			};
+			*/
 
 			qcom,pon_3 {
 				qcom,pon-type = <3>;
@@ -64,6 +66,10 @@
 			};
 		};
 
+/* Charger
+*
+* CONFIG_ZTEMT_CHARGE
+*/
 		pm8226_chg: qcom,charger {
 			spmi-dev-container;
 			compatible = "qcom,qpnp-charger";
@@ -71,13 +77,20 @@
 			#size-cells = <1>;
 			status = "disabled";
 
-			qcom,vddmax-mv = <4200>;
-			qcom,vddsafe-mv = <4230>;
-			qcom,vinmin-mv = <4300>;
+			/*qcom,vddmax-mv = <4200>;*/
+			/*qcom,vddsafe-mv = <4230>;*/
+			qcom,vddmax-mv = <4350>;
+			qcom,vddsafe-mv = <4360>;
+
+			/*qcom,vinmin-mv = <4300>;*/
+                        qcom,vinmin-mv = <4400>;
 			qcom,vbatdet-delta-mv = <100>;
-			qcom,ibatmax-ma = <1500>;
+			
+			/* qcom,ibatmax-ma = <1500>;*/
+			qcom,ibatmax-ma = <1000>;
 			qcom,ibatterm-ma = <100>;
-			qcom,ibatsafe-ma = <1500>;
+			/*qcom,ibatsafe-ma = <1500>;*/
+			qcom,ibatsafe-ma = <1000>;
 			qcom,thermal-mitigation = <1500 700 600 325>;
 			qcom,resume-soc = <99>;
 			qcom,tchg-mins = <150>;
@@ -85,12 +98,24 @@
 			qcom,chg-adc_tm = <&pm8226_adc_tm>;
 			qcom,pmic-revid = <&pm8226_revid>;
 			qcom,ibatmax-warm-ma = <350>;
-			qcom,warm-bat-decidegc = <450>;
+			/*qcom,warm-bat-decidegc = <450>;*/
+			qcom,warm-bat-decidegc = <999>;
 			qcom,warm-bat-mv = <4100>;
-			qcom,cool-bat-decidegc = <100>;
-			qcom,cool-bat-mv = <4100>;
+			/*qcom,cool-bat-decidegc = <100>;*/
+			qcom,cool-bat-decidegc = <0>;
+                        qcom,cool-bat-mv = <4100>;
 			qcom,ibatmax-cool-ma = <350>;
 
+			 /*Add By ZTEMT -begin -Use Extended Battery Temperature Range*/
+			qcom,batt-hot-percentage = <25>;
+			qcom,batt-cold-percentage = <80>;
+		         /*Add By ZTEMT -end*/
+
+		  /* ZTEMT Add*/
+		  qcom,use-external-rsense = <1>;
+		         
+      /*qcom,btc-disabled;*/
+		         
 			qcom,chgr@1000 {
 				status = "disabled";
 				reg = <0x1000 0x100>;
@@ -180,6 +205,18 @@
 			};
 		};
 
+    ztemt_hw_version{
+		  spmi-dev-container;
+		  compatible = "qcom,qpnp-ztemt_hw_version";
+		  #address-cells = <1>;
+		  #size-cells = <1>;
+		  status = "ok";	
+	  };
+
+/*  BMS
+*
+* CONFIG_ZTEMT_CHARGE
+*/
 		pm8226_bms: qcom,bms {
 			spmi-dev-container;
 			compatible = "qcom,qpnp-bms";
@@ -189,7 +226,10 @@
 
 			qcom,r-sense-uohm = <10000>;
 			qcom,v-cutoff-uv = <3400000>;
-			qcom,max-voltage-uv = <4200000>;
+			
+			/*qcom,max-voltage-uv = <4200000>;*/
+			qcom,max-voltage-uv = <4350000>;
+		
 			qcom,r-conn-mohm = <0>;
 			qcom,shutdown-soc-valid-limit = <100>;
 			qcom,adjust-soc-low-threshold = <15>;
@@ -200,7 +240,10 @@
 			qcom,low-soc-calculate-soc-ms = <5000>;
 			qcom,calculate-soc-ms = <20000>;
 			qcom,chg-term-ua = <100000>;
-			qcom,batt-type = <0>;
+
+			/*qcom,batt-type = <0>;*/
+				qcom,batt-type = <1>;
+			
 			qcom,tm-temp-margin = <5000>;
 			qcom,low-ocv-correction-limit-uv = <100>;
 			qcom,high-ocv-correction-limit-uv = <250>;
@@ -485,7 +528,7 @@
 			#address-cells = <1>;
 			#size-cells = <1>;
 			qcom,qpnp-rtc-write = <0>;
-			qcom,qpnp-rtc-alarm-pwrup = <0>;
+			qcom,qpnp-rtc-alarm-pwrup = <1>;
 
 			qcom,pm8226_rtc_rw@6000 {
 				reg = <0x6000 0x100>;
@@ -768,7 +811,8 @@
 			regulator-name = "8226_l27";
 			reg = <0x5a00 0x100>;
 			compatible = "qcom,qpnp-regulator";
-			status = "disabled";
+			qcom,pull-down-enable = <1>;
+			status = "okay";
 		};
 
 		regulator@5b00 {
@@ -865,7 +909,23 @@
 						"flash0_trigger";
 				qcom,id = <1>;
 				linux,name = "led:flash_0";
-				qcom,current = <625>;
+				qcom,current = <500>;
+			};
+
+			pm8226_flash1: qcom,flash_1 {
+				qcom,max-current = <1000>;
+				qcom,default-state = "off";
+				qcom,headroom = <3>;
+				qcom,duration = <1280>;
+				qcom,clamp-curr = <200>;
+				qcom,startup-dly = <3>;
+				qcom,safety-timer;
+				linux,default-trigger =
+						"flash1_trigger";
+				label = "flash";
+				qcom,id = <2>;
+				linux,name = "led:flash_1";
+				qcom,current = <500>;
 			};
 
 			pm8226_torch: qcom,flash_torch {
@@ -876,7 +936,7 @@
 				label = "flash";
 				qcom,id = <1>;
 				linux,name = "led:flash_torch";
-				qcom,current = <120>;
+				qcom,current = <75>;
 				qcom,torch-enable;
 			};
                 };
diff --git a/arch/arm/boot/dts/msm8226-mdss.dtsi b/arch/arm/boot/dts/msm8226-mdss.dtsi
old mode 100644
new mode 100755
index 36bf00e..cbd9384
--- a/arch/arm/boot/dts/msm8226-mdss.dtsi
+++ b/arch/arm/boot/dts/msm8226-mdss.dtsi
@@ -103,6 +103,7 @@
 		vdd-supply = <&pm8226_l15>;
 		vddio-supply = <&pm8226_l8>;
 		vdda-supply = <&pm8226_l4>;
+        vddi-supply = <&pm8226_l27>;
 		qcom,platform-reset-gpio = <&msmgpio 25 0>;
 		qcom,platform-te-gpio = <&msmgpio 24 0>;
 		qcom,platform-strength-ctrl = [ff 06];
@@ -113,38 +114,49 @@
 			00 00 00 00 0a 00 00 01 97
 			00 00 00 00 0f 00 00 01 97
 			00 c0 00 00 00 00 00 01 bb];
-		qcom,platform-supply-entry1 {
-			qcom,supply-name = "vdd";
-			qcom,supply-min-voltage = <2800000>;
-			qcom,supply-max-voltage = <2800000>;
-			qcom,supply-enable-load = <100000>;
-			qcom,supply-disable-load = <100>;
-			qcom,supply-pre-on-sleep = <0>;
-			qcom,supply-post-on-sleep = <0>;
-			qcom,supply-pre-off-sleep = <0>;
-			qcom,supply-post-off-sleep = <0>;
-		};
-		qcom,platform-supply-entry2 {
+        qcom,platform-supply-entry1 {
 			qcom,supply-name = "vddio";
 			qcom,supply-min-voltage = <1800000>;
 			qcom,supply-max-voltage = <1800000>;
 			qcom,supply-enable-load = <100000>;
 			qcom,supply-disable-load = <100>;
 			qcom,supply-pre-on-sleep = <0>;
-			qcom,supply-post-on-sleep = <0>;
+			qcom,supply-post-on-sleep = <1>;
 			qcom,supply-pre-off-sleep = <0>;
-			qcom,supply-post-off-sleep = <0>;
+			qcom,supply-post-off-sleep = <1>;
 		};
-		qcom,platform-supply-entry3 {
+        qcom,platform-supply-entry2 {
+            qcom,supply-name = "vddi";
+            qcom,supply-min-voltage = <1800000>;
+            qcom,supply-max-voltage = <1800000>;
+            qcom,supply-enable-load = <100000>;
+            qcom,supply-disable-load = <100>;
+            qcom,supply-pre-on-sleep = <0>;
+            qcom,supply-post-on-sleep = <1>;
+            qcom,supply-pre-off-sleep = <0>;
+            qcom,supply-post-off-sleep = <2>;
+        };
+        qcom,platform-supply-entry3 {
 			qcom,supply-name = "vdda";
 			qcom,supply-min-voltage = <1200000>;
 			qcom,supply-max-voltage = <1200000>;
 			qcom,supply-enable-load = <100000>;
 			qcom,supply-disable-load = <100>;
 			qcom,supply-pre-on-sleep = <0>;
-			qcom,supply-post-on-sleep = <20>;
+			qcom,supply-post-on-sleep = <1>;
+			qcom,supply-pre-off-sleep = <0>;
+			qcom,supply-post-off-sleep = <1>;
+		};
+		qcom,platform-supply-entry4 {
+			qcom,supply-name = "vdd";
+			qcom,supply-min-voltage = <2800000>;
+			qcom,supply-max-voltage = <2800000>;
+			qcom,supply-enable-load = <100000>;
+			qcom,supply-disable-load = <100>;
+			qcom,supply-pre-on-sleep = <0>;
+			qcom,supply-post-on-sleep = <21>;
 			qcom,supply-pre-off-sleep = <0>;
-			qcom,supply-post-off-sleep = <0>;
+			qcom,supply-post-off-sleep = <1>;
 		};
 	};
 
diff --git a/arch/arm/boot/dts/msm8226-regulator.dtsi b/arch/arm/boot/dts/msm8226-regulator.dtsi
old mode 100644
new mode 100755
index 78e1a63..d353297
--- a/arch/arm/boot/dts/msm8226-regulator.dtsi
+++ b/arch/arm/boot/dts/msm8226-regulator.dtsi
@@ -247,9 +247,9 @@
 		status = "okay";
 		pm8226_l5: regulator-l5 {
 			regulator-name = "8226_l5";
-			regulator-min-microvolt = <1200000>;
-			regulator-max-microvolt = <1200000>;
-			qcom,init-voltage = <1200000>;
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1050000>;
+			qcom,init-voltage = <1050000>;
 			status = "okay";
 		};
 	};
@@ -485,9 +485,9 @@
 		status = "okay";
 		pm8226_l27: regulator-l27 {
 			regulator-name = "8226_l27";
-			regulator-min-microvolt = <2050000>;
-			regulator-max-microvolt = <2050000>;
-			qcom,init-voltage = <2050000>;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
 			status = "okay";
 		};
 	};
@@ -497,8 +497,8 @@
 		pm8226_l28: regulator-l28 {
 			regulator-name = "8226_l28";
 			regulator-min-microvolt = <1800000>;
-			regulator-max-microvolt = <2950000>;
-			qcom,init-voltage = <2950000>;
+			regulator-max-microvolt = <1800000>;
+			qcom,init-voltage = <1800000>;
 			status = "okay";
 		};
 	};
diff --git a/arch/arm/boot/dts/msm8226.dtsi b/arch/arm/boot/dts/msm8226.dtsi
index 3df10cd..5dd07d5 100644
--- a/arch/arm/boot/dts/msm8226.dtsi
+++ b/arch/arm/boot/dts/msm8226.dtsi
@@ -278,7 +278,7 @@
 		qcom,vdd-voltage-level = <1 5 7>;
 
 		qcom,hsusb-otg-phy-init-seq =
-			<0x44 0x80 0x68 0x81 0x24 0x82 0x13 0x83 0xffffffff>;
+			<0x74 0x80 0x68 0x81 0x24 0x82 0x13 0x83 0xffffffff>;
 		qcom,hsusb-otg-phy-type = <2>;
 		qcom,hsusb-otg-mode = <1>;
 		qcom,hsusb-otg-otg-control = <2>;
@@ -300,7 +300,9 @@
 		reg = <0xfe8050c8 0xc8>;
 		qcom,android-usb-swfi-latency = <1>;
 		qcom,streaming-func = "rndis";
-		qcom,android-usb-uicc-nluns = <1>;
+ 		qcom,android-usb-cdrom;
+		qcom,android-usb-external-ums;
+		qcom,android-usb-uicc-nluns = <0>;
 	};
 
 	smsc_hub: hsic_hub {
@@ -985,7 +987,20 @@
 		qcom,pmic-arb-ee = <0>;
 		qcom,pmic-arb-channel = <0>;
 	};
-
+//+++ add ,2014.3.31,for sensor
+	i2c@f9923000 { /* BLSP-1 QUP-0 */
+		cell-index = <1>;
+		compatible = "qcom,i2c-qup";
+		reg = <0xf9923000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 95 0>;
+		interrupt-names = "qup_err_intr";
+		qcom,i2c-bus-freq = <400000>;
+		qcom,i2c-src-freq = <19200000>;
+	};
+//--- add end
 	i2c@f9925000 { /* BLSP-1 QUP-3 */
 		cell-index = <2>;
 		compatible = "qcom,i2c-qup";
diff --git a/arch/arm/boot/dts/msm8926-ne501j.dts b/arch/arm/boot/dts/msm8926-ne501j.dts
new file mode 100755
index 0000000..1e40f86
--- /dev/null
+++ b/arch/arm/boot/dts/msm8926-ne501j.dts
@@ -0,0 +1,26 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/dts-v1/;
+/include/ "msm8926-v1.dtsi"
+/include/ "zte/ne501j/dsi-cs-panel-nt35592-720p-video.dtsi"
+/include/ "zte/ne501j/dsi-success-panel-hx8392b-720p-video.dtsi"
+/include/ "zte/ne501j/dsi-lianchuang-panel-nt35592-720p-video.dtsi"
+/include/ "zte/ne501j/msm8226-720p-mtp.dtsi"
+/include/ "zte/ne501j/msm8226-camera-sensor-mtp.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8926 MTP";
+	compatible = "qcom,msm8926-mtp", "qcom,msm8926", "qcom,mtp";
+	qcom,board-id = <8 0>;
+};
diff --git a/arch/arm/boot/dts/msm8926-ne504h.dts b/arch/arm/boot/dts/msm8926-ne504h.dts
new file mode 100755
index 0000000..e154005
--- /dev/null
+++ b/arch/arm/boot/dts/msm8926-ne504h.dts
@@ -0,0 +1,25 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/dts-v1/;
+/include/ "msm8926-v1.dtsi"
+/include/ "zte/ne504h/dsi-cs-panel-nt35592-720p-video.dtsi"
+/include/ "zte/ne504h/dsi-success-panel-hx8392b-720p-video.dtsi"
+/include/ "zte/ne504h/msm8226-720p-mtp.dtsi"
+/include/ "zte/ne504h/msm8226-camera-sensor-mtp.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8926 MTP";
+	compatible = "qcom,msm8926-mtp", "qcom,msm8926", "qcom,mtp";
+	qcom,board-id = <8 0>;
+};
diff --git a/arch/arm/boot/dts/msm8926-nx404h.dts b/arch/arm/boot/dts/msm8926-nx404h.dts
new file mode 100755
index 0000000..9f4f4e5
--- /dev/null
+++ b/arch/arm/boot/dts/msm8926-nx404h.dts
@@ -0,0 +1,28 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+/dts-v1/;
+/include/ "msm8926-v1.dtsi"
+/include/ "zte/nx404h/dsi-sharp-panel-r69431-720p-video.dtsi"
+/include/ "zte/nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi"
+/include/ "zte/nx404h/dsi-tianma-panel-otm1282a-720p-video.dtsi"
+/include/ "zte/nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi"
+/include/ "zte/nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi"
+/include/ "zte/nx404h/msm8226-720p-mtp.dtsi"
+/include/ "zte/nx404h/msm8226-camera-sensor-mtp.dtsi"
+
+/ {
+	model = "Qualcomm MSM 8926 MTP";
+	compatible = "qcom,msm8926-mtp", "qcom,msm8926", "qcom,mtp";
+	qcom,board-id = <8 0>;
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/batterydata-zte-2400mah.dtsi b/arch/arm/boot/dts/zte/ne501j/batterydata-zte-2400mah.dtsi
new file mode 100755
index 0000000..ce74257
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/batterydata-zte-2400mah.dtsi
@@ -0,0 +1,112 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+qcom,zte-2400mah {
+	qcom,fcc-mah = <2400>;
+	qcom,default-rbatt-mohm = <129>;
+	qcom,max-voltage-uv = <4350000>;
+	qcom,rbatt-capacitive-mohm = <50>;
+	qcom,v-cutoff-uv = <3400000>;
+	qcom,chg-term-ua = <100000>;
+	qcom,batt-id-kohm = <300>;
+
+	qcom,fcc-temp-lut {
+		qcom,lut-col-legend = <(-20)  0 25 40 60>;
+		qcom,lut-data = <2469  2472  2469  2456  2450>;
+	};
+
+	qcom,pc-temp-ocv-lut {
+		qcom,lut-col-legend = <(-20)  0 25 40 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>,
+				<0>;
+		qcom,lut-data = <4333 4332 4327 4323 4315>,
+							<4247 4259 4261 4260 4255>,
+							<4177 4200 4206 4205 4200>,
+							<4114 4144 4152 4151 4147>,
+							<4056 4091 4100 4100 4096>,
+							<3989 4039 4053 4053 4048>,
+							<3942 3980 4005 4006 4003>,
+							<3902 3934 3963 3966 3963>,
+							<3865 3895 3920 3924 3922>,
+							<3835 3860 3869 3873 3871>,
+							<3810 3830 3840 3842 3841>,
+							<3789 3806 3817 3819 3818>,
+							<3770 3788 3797 3799 3798>,
+							<3753 3773 3782 3781 3780>,
+							<3737 3759 3769 3765 3759>,
+							<3720 3742 3753 3746 3733>,
+							<3702 3723 3729 3722 3707>,
+							<3683 3707 3697 3691 3677>,
+							<3665 3695 3683 3677 3665>,
+							<3650 3686 3681 3674 3663>,
+							<3641 3681 3679 3673 3661>,
+							<3629 3676 3677 3671 3659>,
+							<3615 3669 3673 3668 3655>,
+							<3598 3658 3666 3661 3644>,
+							<3577 3639 3643 3642 3614>,
+							<3548 3606 3603 3604 3573>,
+							<3507 3556 3549 3555 3523>,
+							<3449 3488 3483 3497 3463>,
+							<3363 3392 3403 3425 3382>,
+							<3233 3263 3284 3316 3256>,
+							<3000 3000 3000 3000 3000>;
+			};
+
+	qcom,rbatt-sf-lut {
+		qcom,lut-col-legend = <(-20) 0 25 40 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>,
+				<0>;
+		qcom,lut-data = <1438 321 100 77 69>,
+												<1437 321 100 78 69>,
+												<1407 332 106 82 72>,
+												<1380 343 111 86 74>,
+												<1373 351 117 89 77>,
+												<1363 365 125 95 81>,
+												<1389 355 133 99 84>,
+												<1417 353 141 105 87>,
+												<1445 359 136 107 89>,
+												<1482 368 108 86 74>,
+												<1535 382 109 82 74>,
+												<1600 406 114 87 78>,
+												<1675 437 122 93 82>,
+												<1762 475 130 96 85>,
+												<1926 518 137 96 82>,
+												<2218 559 140 93 78>,
+												<2544 603 140 93 76>,
+												<2794 648 137 91 74>,
+												<2714 664 138 91 75>,
+												<2811 684 149 97 79>,
+												<2997 705 155 100 80>,
+												<3219 725 162 103 81>,
+												<3494 753 168 105 82>,
+												<3824 775 173 106 79>,
+												<4250 796 169 103 79>,
+												<4806 821 169 102 82>,
+												<5523 853 177 106 89>,
+												<6575 903 193 120 103>,
+												<8443 981 233 142 111>,
+												<14044 1566 277 162 137>,
+												<39526 12585 2471 2394 668>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/dsi-cs-panel-nt35592-720p-video.dtsi b/arch/arm/boot/dts/zte/ne501j/dsi-cs-panel-nt35592-720p-video.dtsi
new file mode 100644
index 0000000..1f76708
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/dsi-cs-panel-nt35592-720p-video.dtsi
@@ -0,0 +1,579 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_cs_nt35592_720_vid: qcom,mdss_dsi_cs_nt35592_720p_video {
+		qcom,mdss-dsi-panel-name = "cs nt35592 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <12>;
+		qcom,mdss-dsi-h-back-porch = <12>;
+		qcom,mdss-dsi-h-pulse-width = <4>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <2>;
+		qcom,mdss-dsi-v-front-porch = <6>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+            //CMD2 Page0 -Power 
+            15 01 00 00 00 00 02 FF 01
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 00 2A
+            15 01 00 00 00 00 02 01 33
+            15 01 00 00 00 00 02 02 53
+            15 01 00 00 00 00 02 03 55
+            15 01 00 00 00 00 02 04 55
+            15 01 00 00 00 00 02 05 00
+            15 01 00 00 00 00 02 06 44
+            15 01 00 00 00 00 02 08 26
+            15 01 00 00 00 00 02 09 09
+            //// GVDDP  GVDDN 
+            15 01 00 00 00 00 02 0B CA
+            15 01 00 00 00 00 02 0C CA
+            15 01 00 00 00 00 02 0D 24
+            15 01 00 00 00 00 02 0E 2B
+            //VGLO = -6.2V  
+            15 01 00 00 00 00 02 0F 96
+            15 01 00 00 00 00 02 10 0F
+            //VCOMDC 
+            15 01 00 00 00 00 02 11 72
+            15 01 00 00 00 00 02 12 03
+            //power mode 
+            15 01 00 00 00 00 02 14 01
+            //Gate EQ 
+            15 01 00 00 00 00 02 36 73
+            //VGLO pull GND
+            15 01 00 00 00 00 02 37 02
+			15 01 00 00 00 00 02 4c 01
+			15 01 00 00 00 00 02 6f 00
+            15 01 00 00 00 00 02 71 2C
+			15 01 00 00 00 00 02 ff 00
+			15 01 00 00 00 00 02 fb 01
+			//gamma begin
+			//Page Select CMD2,Page0 
+            15 01 00 00 00 00 02 FF 01
+            //Don't reload MTP 
+            15 01 00 00 00 00 02 FB 01
+            //Gamma R+ 
+            15 01 00 00 00 00 02 75 00
+            15 01 00 00 00 00 02 76 5F
+            15 01 00 00 00 00 02 77 00
+            15 01 00 00 00 00 02 78 97
+            15 01 00 00 00 00 02 79 00
+            15 01 00 00 00 00 02 7A A1
+            15 01 00 00 00 00 02 7B 00
+            15 01 00 00 00 00 02 7C B8
+            15 01 00 00 00 00 02 7D 00
+            15 01 00 00 00 00 02 7E CC
+            15 01 00 00 00 00 02 7F 00
+            15 01 00 00 00 00 02 80 E2
+            15 01 00 00 00 00 02 81 00
+            15 01 00 00 00 00 02 82 EC
+            15 01 00 00 00 00 02 83 00
+            15 01 00 00 00 00 02 84 F9
+            15 01 00 00 00 00 02 85 01
+            15 01 00 00 00 00 02 86 08
+            15 01 00 00 00 00 02 87 01
+            15 01 00 00 00 00 02 88 2F
+            15 01 00 00 00 00 02 89 01
+            15 01 00 00 00 00 02 8A 50
+            15 01 00 00 00 00 02 8B 01
+            15 01 00 00 00 00 02 8C 8E
+            15 01 00 00 00 00 02 8D 01
+            15 01 00 00 00 00 02 8E B6
+            15 01 00 00 00 00 02 8F 01
+            15 01 00 00 00 00 02 90 FD
+            15 01 00 00 00 00 02 91 02
+            15 01 00 00 00 00 02 92 2E
+            15 01 00 00 00 00 02 93 02
+            15 01 00 00 00 00 02 94 2E
+            15 01 00 00 00 00 02 95 02
+            15 01 00 00 00 00 02 96 5E
+            15 01 00 00 00 00 02 97 02
+            15 01 00 00 00 00 02 98 94
+            15 01 00 00 00 00 02 99 02
+            15 01 00 00 00 00 02 9A B4
+            15 01 00 00 00 00 02 9B 02
+            15 01 00 00 00 00 02 9C DB
+            15 01 00 00 00 00 02 9D 02
+            15 01 00 00 00 00 02 9E FD
+            15 01 00 00 00 00 02 9F 03
+            15 01 00 00 00 00 02 A0 24
+            05 01 00 00 00 00 01 A1
+            15 01 00 00 00 00 02 A2 03
+            15 01 00 00 00 00 02 A3 30
+            15 01 00 00 00 00 02 A4 03
+            15 01 00 00 00 00 02 A5 3C
+            15 01 00 00 00 00 02 A6 03
+            15 01 00 00 00 00 02 A7 5B
+            05 01 00 00 00 00 01 A8
+            15 01 00 00 00 00 02 A9 03
+            15 01 00 00 00 00 02 AA 80
+            15 01 00 00 00 00 02 AB 03
+            15 01 00 00 00 00 02 AC A3
+            15 01 00 00 00 00 02 AD 03
+            15 01 00 00 00 00 02 AE B1
+            15 01 00 00 00 00 02 AF 03
+            15 01 00 00 00 00 02 B0 BE
+            15 01 00 00 00 00 02 B1 03
+            15 01 00 00 00 00 02 B2 BD
+            //Gamma R- 
+            15 01 00 00 00 00 02 B3 00
+            15 01 00 00 00 00 02 B4 D9
+            15 01 00 00 00 00 02 B5 01
+            15 01 00 00 00 00 02 B6 0D
+            15 01 00 00 00 00 02 B7 01
+            15 01 00 00 00 00 02 B8 13
+            15 01 00 00 00 00 02 B9 01
+            15 01 00 00 00 00 02 BA 26
+            15 01 00 00 00 00 02 BB 01
+            15 01 00 00 00 00 02 BC 3A
+            15 01 00 00 00 00 02 BD 01
+            15 01 00 00 00 00 02 BE 4F
+            15 01 00 00 00 00 02 BF 01
+            15 01 00 00 00 00 02 C0 5A
+            15 01 00 00 00 00 02 C1 01
+            15 01 00 00 00 00 02 C2 66
+            15 01 00 00 00 00 02 C3 01
+            15 01 00 00 00 00 02 C4 6B
+            15 01 00 00 00 00 02 C5 01
+            15 01 00 00 00 00 02 C6 97
+            15 01 00 00 00 00 02 C7 01
+            15 01 00 00 00 00 02 C8 B1
+            15 01 00 00 00 00 02 C9 01
+            15 01 00 00 00 00 02 CA E8
+            15 01 00 00 00 00 02 CB 02
+            15 01 00 00 00 00 02 CC 0C
+            15 01 00 00 00 00 02 CD 02
+            15 01 00 00 00 00 02 CE 48
+            15 01 00 00 00 00 02 CF 02
+            15 01 00 00 00 00 02 D0 7E
+            15 01 00 00 00 00 02 D1 02
+            15 01 00 00 00 00 02 D2 7E
+            15 01 00 00 00 00 02 D3 02
+            15 01 00 00 00 00 02 D4 AE
+            15 01 00 00 00 00 02 D5 02
+            15 01 00 00 00 00 02 D6 E4
+            15 01 00 00 00 00 02 D7 03
+            15 01 00 00 00 00 02 D8 03
+            15 01 00 00 00 00 02 D9 03
+            15 01 00 00 00 00 02 DA 33
+            15 01 00 00 00 00 02 DB 03
+            15 01 00 00 00 00 02 DC 57
+            15 01 00 00 00 00 02 DD 03
+            15 01 00 00 00 00 02 DE 83
+            15 01 00 00 00 00 02 DF 03
+            15 01 00 00 00 00 02 E0 8D
+            15 01 00 00 00 00 02 E1 03
+            15 01 00 00 00 00 02 E2 99
+            15 01 00 00 00 00 02 E3 03
+            15 01 00 00 00 00 02 E4 B7
+            15 01 00 00 00 00 02 E5 03
+            15 01 00 00 00 00 02 E6 CF
+            15 01 00 00 00 00 02 E7 03
+            15 01 00 00 00 00 02 E8 D8
+            15 01 00 00 00 00 02 E9 03
+            15 01 00 00 00 00 02 EA E6
+            15 01 00 00 00 00 02 EB 03
+            15 01 00 00 00 00 02 EC E8
+            15 01 00 00 00 00 02 ED 03
+            15 01 00 00 00 00 02 EE EA
+            //Gamma G+ 
+            15 01 00 00 00 00 02 EF 00
+            15 01 00 00 00 00 02 F0 2D
+            15 01 00 00 00 00 02 F1 00
+            15 01 00 00 00 00 02 F2 71
+            15 01 00 00 00 00 02 F3 00
+            15 01 00 00 00 00 02 F4 87
+            15 01 00 00 00 00 02 F5 00
+            15 01 00 00 00 00 02 F6 A1
+            15 01 00 00 00 00 02 F7 00
+            15 01 00 00 00 00 02 F8 B2
+            15 01 00 00 00 00 02 F9 00
+            15 01 00 00 00 00 02 FA CB
+            15 01 00 00 00 00 02 FB 01
+            //Page Select CMD1 
+            15 01 00 00 00 00 02 FF 00
+            //Don't reload MTP 
+            15 01 00 00 00 00 02 FB 01
+            //Page Select CMD2,Page1 
+            15 01 00 00 00 00 02 FF 02
+            //Don't reload MTP 
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 00 00
+            15 01 00 00 00 00 02 01 D7
+            15 01 00 00 00 00 02 02 00
+            15 01 00 00 00 00 02 03 E6
+            15 01 00 00 00 00 02 04 00
+            15 01 00 00 00 00 02 05 F9
+            15 01 00 00 00 00 02 06 01
+            15 01 00 00 00 00 02 07 2C
+            15 01 00 00 00 00 02 08 01
+            15 01 00 00 00 00 02 09 4F
+            15 01 00 00 00 00 02 0A 01
+            15 01 00 00 00 00 02 0B 86
+            15 01 00 00 00 00 02 0C 01
+            15 01 00 00 00 00 02 0D B3
+            15 01 00 00 00 00 02 0E 01
+            15 01 00 00 00 00 02 0F FC
+            15 01 00 00 00 00 02 10 02
+            15 01 00 00 00 00 02 11 2E
+            15 01 00 00 00 00 02 12 02
+            15 01 00 00 00 00 02 13 2E
+            15 01 00 00 00 00 02 14 02
+            15 01 00 00 00 00 02 15 5D
+            15 01 00 00 00 00 02 16 02
+            15 01 00 00 00 00 02 17 92
+            15 01 00 00 00 00 02 18 02
+            15 01 00 00 00 00 02 19 B2
+            15 01 00 00 00 00 02 1A 02
+            15 01 00 00 00 00 02 1B DC
+            15 01 00 00 00 00 02 1C 02
+            15 01 00 00 00 00 02 1D FF
+            15 01 00 00 00 00 02 1E 03
+            15 01 00 00 00 00 02 1F 27
+            15 01 00 00 00 00 02 20 03
+            15 01 00 00 00 00 02 21 3B
+            15 01 00 00 00 00 02 22 03
+            15 01 00 00 00 00 02 23 45
+            15 01 00 00 00 00 02 24 03
+            15 01 00 00 00 00 02 25 63
+            15 01 00 00 00 00 02 26 03
+            15 01 00 00 00 00 02 27 77
+            15 01 00 00 00 00 02 28 03
+            15 01 00 00 00 00 02 29 95
+            15 01 00 00 00 00 02 2A 03
+            15 01 00 00 00 00 02 2B 9E
+            05 01 00 00 00 00 01 2C
+            15 01 00 00 00 00 02 2D 03
+            05 01 00 00 00 00 01 2E
+            15 01 00 00 00 00 02 2F A4
+            15 01 00 00 00 00 02 30 03
+            15 01 00 00 00 00 02 31 BC
+            //Gamma G- 
+            15 01 00 00 00 00 02 32 00
+            15 01 00 00 00 00 02 33 B2
+            15 01 00 00 00 00 02 34 00
+            15 01 00 00 00 00 02 35 F1
+            15 01 00 00 00 00 02 36 00
+            15 01 00 00 00 00 02 37 FC
+            15 01 00 00 00 00 02 38 01
+            15 01 00 00 00 00 02 39 13
+            15 01 00 00 00 00 02 3A 01
+            15 01 00 00 00 00 02 3B 21
+            05 01 00 00 00 00 01 3C
+            15 01 00 00 00 00 02 3D 01
+            05 01 00 00 00 00 01 3E
+            15 01 00 00 00 00 02 3F 37
+            15 01 00 00 00 00 02 40 01
+            15 01 00 00 00 00 02 41 44
+            15 01 00 00 00 00 02 42 01
+            15 01 00 00 00 00 02 43 51
+            15 01 00 00 00 00 02 44 01
+            15 01 00 00 00 00 02 45 65
+            15 01 00 00 00 00 02 46 01
+            15 01 00 00 00 00 02 47 8A
+            15 01 00 00 00 00 02 48 01
+            15 01 00 00 00 00 02 49 A8
+            15 01 00 00 00 00 02 4A 01
+            15 01 00 00 00 00 02 4B E2
+            15 01 00 00 00 00 02 4C 02
+            15 01 00 00 00 00 02 4D 0B
+            15 01 00 00 00 00 02 4E 02
+            15 01 00 00 00 00 02 4F 48
+            15 01 00 00 00 00 02 50 02
+            15 01 00 00 00 00 02 51 7E
+            15 01 00 00 00 00 02 52 02
+            15 01 00 00 00 00 02 53 7E
+            15 01 00 00 00 00 02 54 02
+            15 01 00 00 00 00 02 55 AD
+            15 01 00 00 00 00 02 56 02
+            05 01 00 00 00 00 01 57
+            15 01 00 00 00 00 02 58 E4
+            15 01 00 00 00 00 02 59 03
+            15 01 00 00 00 00 02 5A 06
+            15 01 00 00 00 00 02 5B 03
+            15 01 00 00 00 00 02 5C 35
+            15 01 00 00 00 00 02 5D 03
+            15 01 00 00 00 00 02 5E 59
+            15 01 00 00 00 00 02 5F 03
+            15 01 00 00 00 00 02 60 80
+            15 01 00 00 00 00 02 61 03
+            15 01 00 00 00 00 02 62 93
+            15 01 00 00 00 00 02 63 03
+            15 01 00 00 00 00 02 64 A1
+            15 01 00 00 00 00 02 65 03
+            15 01 00 00 00 00 02 66 C0
+            15 01 00 00 00 00 02 67 03
+            15 01 00 00 00 00 02 68 D4
+            15 01 00 00 00 00 02 69 03
+            15 01 00 00 00 00 02 6A DD
+            15 01 00 00 00 00 02 6B 03
+            15 01 00 00 00 00 02 6C E3
+            15 01 00 00 00 00 02 6D 03
+            15 01 00 00 00 00 02 6E E7
+            15 01 00 00 00 00 02 6F 03
+            15 01 00 00 00 00 02 70 EA
+            //Gamma B+ 
+            15 01 00 00 00 00 02 71 00
+            15 01 00 00 00 00 02 72 5F
+            15 01 00 00 00 00 02 73 00
+            15 01 00 00 00 00 02 74 97
+            15 01 00 00 00 00 02 75 00
+            15 01 00 00 00 00 02 76 A1
+            15 01 00 00 00 00 02 77 00
+            15 01 00 00 00 00 02 78 B6
+            15 01 00 00 00 00 02 79 00
+            15 01 00 00 00 00 02 7A C6
+            15 01 00 00 00 00 02 7B 00
+            15 01 00 00 00 00 02 7C D9
+            15 01 00 00 00 00 02 7D 00
+            15 01 00 00 00 00 02 7E E2
+            15 01 00 00 00 00 02 7F 00
+            15 01 00 00 00 00 02 80 F1
+            15 01 00 00 00 00 02 81 00
+            15 01 00 00 00 00 02 82 FD
+            15 01 00 00 00 00 02 83 01
+            15 01 00 00 00 00 02 84 26
+            15 01 00 00 00 00 02 85 01
+            15 01 00 00 00 00 02 86 45
+            15 01 00 00 00 00 02 87 01
+            15 01 00 00 00 00 02 88 83
+            15 01 00 00 00 00 02 89 01
+            15 01 00 00 00 00 02 8A AF
+            15 01 00 00 00 00 02 8B 01
+            15 01 00 00 00 00 02 8C F7
+            15 01 00 00 00 00 02 8D 02
+            15 01 00 00 00 00 02 8E 21
+            15 01 00 00 00 00 02 8F 02
+            15 01 00 00 00 00 02 90 21
+            15 01 00 00 00 00 02 91 02
+            15 01 00 00 00 00 02 92 5A
+            15 01 00 00 00 00 02 93 02
+            15 01 00 00 00 00 02 94 90
+            15 01 00 00 00 00 02 95 02
+            15 01 00 00 00 00 02 96 B1
+            15 01 00 00 00 00 02 97 02
+            15 01 00 00 00 00 02 98 DB
+            15 01 00 00 00 00 02 99 02
+            15 01 00 00 00 00 02 9A F7
+            15 01 00 00 00 00 02 9B 03
+            15 01 00 00 00 00 02 9C 1E
+            15 01 00 00 00 00 02 9D 03
+            15 01 00 00 00 00 02 9E 29
+            15 01 00 00 00 00 02 9F 03
+            15 01 00 00 00 00 02 A0 37
+            05 01 00 00 00 00 01 A1
+            15 01 00 00 00 00 02 A2 03
+            15 01 00 00 00 00 02 A3 56
+            15 01 00 00 00 00 02 A4 03
+            15 01 00 00 00 00 02 A5 79
+            15 01 00 00 00 00 02 A6 03
+            15 01 00 00 00 00 02 A7 99
+            05 01 00 00 00 00 01 A8
+            15 01 00 00 00 00 02 A9 03
+            15 01 00 00 00 00 02 AA A7
+            15 01 00 00 00 00 02 AB 03
+            15 01 00 00 00 00 02 AC B9
+            15 01 00 00 00 00 02 AD 03
+            15 01 00 00 00 00 02 AE BD
+            //Gamma B- 
+            15 01 00 00 00 00 02 AF 00
+            15 01 00 00 00 00 02 B0 D9
+            15 01 00 00 00 00 02 B1 01
+            15 01 00 00 00 00 02 B2 0C
+            15 01 00 00 00 00 02 B3 01
+            15 01 00 00 00 00 02 B4 13
+            15 01 00 00 00 00 02 B5 01
+            15 01 00 00 00 00 02 B6 26
+            15 01 00 00 00 00 02 B7 01
+            15 01 00 00 00 00 02 B8 33
+            15 01 00 00 00 00 02 B9 01
+            15 01 00 00 00 00 02 BA 45
+            15 01 00 00 00 00 02 BB 01
+            15 01 00 00 00 00 02 BC 50
+            15 01 00 00 00 00 02 BD 01
+            15 01 00 00 00 00 02 BE 5D
+            15 01 00 00 00 00 02 BF 01
+            15 01 00 00 00 00 02 C0 69
+            15 01 00 00 00 00 02 C1 01
+            15 01 00 00 00 00 02 C2 8E
+            15 01 00 00 00 00 02 C3 01
+            15 01 00 00 00 00 02 C4 A8
+            15 01 00 00 00 00 02 C5 01
+            15 01 00 00 00 00 02 C6 DC
+            15 01 00 00 00 00 02 C7 02
+            15 01 00 00 00 00 02 C8 04
+            15 01 00 00 00 00 02 C9 02
+            15 01 00 00 00 00 02 CA 43
+            15 01 00 00 00 00 02 CB 02
+            15 01 00 00 00 00 02 CC 87
+            15 01 00 00 00 00 02 CD 02
+            15 01 00 00 00 00 02 CE 87
+            15 01 00 00 00 00 02 CF 02
+            15 01 00 00 00 00 02 D0 AA
+            15 01 00 00 00 00 02 D1 02
+            15 01 00 00 00 00 02 D2 E4
+            15 01 00 00 00 00 02 D3 03
+            15 01 00 00 00 00 02 D4 05
+            15 01 00 00 00 00 02 D5 03
+            15 01 00 00 00 00 02 D6 2E
+            15 01 00 00 00 00 02 D7 03
+            15 01 00 00 00 00 02 D8 51
+            15 01 00 00 00 00 02 D9 03
+            15 01 00 00 00 00 02 DA 76
+            15 01 00 00 00 00 02 DB 03
+            15 01 00 00 00 00 02 DC 83
+            15 01 00 00 00 00 02 DD 03
+            15 01 00 00 00 00 02 DE 8F
+            15 01 00 00 00 00 02 DF 03
+            15 01 00 00 00 00 02 E0 B2
+            15 01 00 00 00 00 02 E1 03
+            15 01 00 00 00 00 02 E2 DA
+            15 01 00 00 00 00 02 E3 03
+            15 01 00 00 00 00 02 E4 E4
+            15 01 00 00 00 00 02 E5 03
+            15 01 00 00 00 00 02 E6 E6
+            15 01 00 00 00 00 02 E7 03
+            15 01 00 00 00 00 02 E8 E8
+            15 01 00 00 00 00 02 E9 03
+            15 01 00 00 00 00 02 EA EA
+            //Page select (CMD1) 
+            15 01 00 00 00 00 02 FF 00
+            15 01 00 00 00 00 02 FB 01
+            //gamma end
+			15 01 00 00 00 00 02 ff 04
+			15 01 00 00 00 00 02 fb 01
+			15 01 00 00 00 00 02 ff 00
+			15 01 00 00 00 00 02 fb 01
+            //CMD2 Page 4 -Display Register
+            15 01 00 00 00 00 02 FF 05
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 01 00
+            15 01 00 00 00 00 02 02 7F
+            15 01 00 00 00 00 02 03 7F
+            15 01 00 00 00 00 02 04 7F
+            15 01 00 00 00 00 02 05 00
+            15 01 00 00 00 00 02 06 00
+            15 01 00 00 00 00 02 07 00
+            15 01 00 00 00 00 02 08 00
+            15 01 00 00 00 00 02 09 02
+            15 01 00 00 00 00 02 0A 01
+            15 01 00 00 00 00 02 0B 75
+            15 01 00 00 00 00 02 0D 0E
+            15 01 00 00 00 00 02 0E 1A
+            15 01 00 00 00 00 02 0F 09
+            15 01 00 00 00 00 02 10 80
+            15 01 00 00 00 00 02 14 04
+            15 01 00 00 00 00 02 16 08
+            15 01 00 00 00 00 02 17 00
+            15 01 00 00 00 00 02 19 1F
+            15 01 00 00 00 00 02 1A 00
+            15 01 00 00 00 00 02 1B FC
+            15 01 00 00 00 00 02 1C 00
+            15 01 00 00 00 00 02 1D 00
+            15 01 00 00 00 00 02 1E 00
+            15 01 00 00 00 00 02 1F 80
+            15 01 00 00 00 00 02 21 00
+            15 01 00 00 00 00 02 24 45
+            15 01 00 00 00 00 02 27 05
+            15 01 00 00 00 00 02 28 00
+            15 01 00 00 00 00 02 29 52
+            15 01 00 00 00 00 02 2A A9
+            15 01 00 00 00 00 02 2D 02
+            15 01 00 00 00 00 02 2F 00
+            15 01 00 00 00 00 02 30 30
+            15 01 00 00 00 00 02 35 16
+            15 01 00 00 00 00 02 36 01
+            15 01 00 00 00 00 02 37 00
+            15 01 00 00 00 00 02 38 02
+            15 01 00 00 00 00 02 39 01
+            15 01 00 00 00 00 02 3F 00
+            15 01 00 00 00 00 02 40 00
+            15 01 00 00 00 00 02 41 00
+            15 01 00 00 00 00 02 42 00
+            15 01 00 00 00 00 02 4A 01
+            15 01 00 00 00 00 02 6F 25
+            15 01 00 00 00 00 02 7E E9
+            15 01 00 00 00 00 02 82 18
+            15 01 00 00 00 00 02 89 C1
+            15 01 00 00 00 00 02 A4 05
+            15 01 00 00 00 00 02 BB 06
+            15 01 00 00 00 00 02 BC 02
+            15 01 00 00 00 00 02 FF 00
+            15 01 00 00 00 00 02 FB 01
+            //CMD2 Page 3 Fre(PWM)=57.292KHz
+            15 01 00 00 00 00 02 FF 04
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 07 40
+            15 01 00 00 00 00 02 08 03
+            //CMD1
+            15 01 00 00 00 00 02 FF 00 
+            15 01 00 00 00 00 02 fb 01			
+            15 01 00 00 00 00 02 BA 03
+            15 01 00 00 00 00 02 55 00
+            39 01 00 00 00 00 02 53 24
+            39 01 00 00 00 00 02 35 20
+            39 01 00 00 96 00 02 11 00
+            39 01 00 00 00 00 02 29 00
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 32 00 02 28 00
+					39 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [32 16 0e 00 38 3a 12 18 10 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x4>;
+		qcom,mdss-dsi-t-clk-pre = <0x11>;
+		qcom,mdss-brightness-max-level = <255>;
+		qcom,mdss-dsi-bl-min-level = <10>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a1 = <87>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a2 = <99>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b1 = <476>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b2 = <270>;
+		qcom,mdss-dsi-bright-to-bl-lvl-turn-point = <186>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 1500>, <0 30>, <1 23000>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/dsi-lianchuang-panel-nt35592-720p-video.dtsi b/arch/arm/boot/dts/zte/ne501j/dsi-lianchuang-panel-nt35592-720p-video.dtsi
new file mode 100644
index 0000000..773cbec
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/dsi-lianchuang-panel-nt35592-720p-video.dtsi
@@ -0,0 +1,567 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_lianchuang_nt35592_720_vid: qcom,mdss_dsi_lianchuang_nt35592_720p_video {
+		qcom,mdss-dsi-panel-name = "lianchuang nt35592 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <12>;
+		qcom,mdss-dsi-h-back-porch = <12>;
+		qcom,mdss-dsi-h-pulse-width = <4>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <2>;
+		qcom,mdss-dsi-v-front-porch = <6>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+            //CMD2 Page0 -Power 
+            15 01 00 00 00 00 02 FF 01
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 00 4A
+            15 01 00 00 00 00 02 01 33
+            15 01 00 00 00 00 02 02 53
+            15 01 00 00 00 00 02 03 55
+            15 01 00 00 00 00 02 04 55
+            15 01 00 00 00 00 02 05 33
+            15 01 00 00 00 00 02 06 22
+            15 01 00 00 00 00 02 08 56
+            15 01 00 00 00 00 02 09 8f
+            15 01 00 00 00 00 02 0B CF
+            15 01 00 00 00 00 02 0C CF
+            15 01 00 00 00 00 02 0D 2F
+            15 01 00 00 00 00 02 0E 29
+            15 01 00 00 00 00 02 36 73
+            15 01 00 00 00 00 02 0f 0a
+            //power mode 
+            15 01 00 00 00 00 02 ff ee
+            15 01 00 00 00 00 02 fb 01
+            15 01 00 00 00 00 02 2b 10
+            //gamma2.2
+            //page selection cmd start
+            15 01 00 00 00 00 02 FF 01
+            15 01 00 00 00 00 02 FB 01
+            //page selection cmd end
+            //R(+) MCR cmd
+            15 01 00 00 00 00 02 75 00
+            15 01 00 00 00 00 02 76 21
+            15 01 00 00 00 00 02 77 00
+            15 01 00 00 00 00 02 78 6B
+            15 01 00 00 00 00 02 79 00
+            15 01 00 00 00 00 02 7A A1
+            15 01 00 00 00 00 02 7B 00
+            15 01 00 00 00 00 02 7C C2
+            15 01 00 00 00 00 02 7D 00
+            15 01 00 00 00 00 02 7E DC
+            15 01 00 00 00 00 02 7F 00
+            15 01 00 00 00 00 02 80 F1
+            15 01 00 00 00 00 02 81 01
+            15 01 00 00 00 00 02 82 04
+            15 01 00 00 00 00 02 83 01
+            15 01 00 00 00 00 02 84 14
+            15 01 00 00 00 00 02 85 01
+            15 01 00 00 00 00 02 86 23
+            15 01 00 00 00 00 02 87 01
+            15 01 00 00 00 00 02 88 53
+            15 01 00 00 00 00 02 89 01
+            15 01 00 00 00 00 02 8A 78
+            15 01 00 00 00 00 02 8B 01
+            15 01 00 00 00 00 02 8C B1
+            15 01 00 00 00 00 02 8D 01
+            15 01 00 00 00 00 02 8E DC
+            15 01 00 00 00 00 02 8F 02
+            15 01 00 00 00 00 02 90 1E
+            15 01 00 00 00 00 02 91 02
+            15 01 00 00 00 00 02 92 52
+            15 01 00 00 00 00 02 93 02
+            15 01 00 00 00 00 02 94 54
+            15 01 00 00 00 00 02 95 02
+            15 01 00 00 00 00 02 96 81
+            15 01 00 00 00 00 02 97 02
+            15 01 00 00 00 00 02 98 B2
+            15 01 00 00 00 00 02 99 02
+            15 01 00 00 00 00 02 9A D1
+            15 01 00 00 00 00 02 9B 02
+            15 01 00 00 00 00 02 9C FB
+            15 01 00 00 00 00 02 9D 03
+            15 01 00 00 00 00 02 9E 19
+            15 01 00 00 00 00 02 9F 03
+            15 01 00 00 00 00 02 A0 40
+            15 01 00 00 00 00 02 A2 03
+            15 01 00 00 00 00 02 A3 4D
+            15 01 00 00 00 00 02 A4 03
+            15 01 00 00 00 00 02 A5 5B
+            15 01 00 00 00 00 02 A6 03
+            15 01 00 00 00 00 02 A7 6A
+            15 01 00 00 00 00 02 A9 03
+            15 01 00 00 00 00 02 AA 7C
+            15 01 00 00 00 00 02 AB 03
+            15 01 00 00 00 00 02 AC 90
+            15 01 00 00 00 00 02 AD 03
+            15 01 00 00 00 00 02 AE AA
+            15 01 00 00 00 00 02 AF 03
+            15 01 00 00 00 00 02 B0 D2
+            15 01 00 00 00 00 02 B1 03
+            15 01 00 00 00 00 02 B2 FF
+            //R(-) MCR cmd
+            15 01 00 00 00 00 02 B3 00
+            15 01 00 00 00 00 02 B4 21
+            15 01 00 00 00 00 02 B5 00
+            15 01 00 00 00 00 02 B6 6B
+            15 01 00 00 00 00 02 B7 00
+            15 01 00 00 00 00 02 B8 A1
+            15 01 00 00 00 00 02 B9 00
+            15 01 00 00 00 00 02 BA C2
+            15 01 00 00 00 00 02 BB 00
+            15 01 00 00 00 00 02 BC DC
+            15 01 00 00 00 00 02 BD 00
+            15 01 00 00 00 00 02 BE F1
+            15 01 00 00 00 00 02 BF 01
+            15 01 00 00 00 00 02 C0 04
+            15 01 00 00 00 00 02 C1 01
+            15 01 00 00 00 00 02 C2 14
+            15 01 00 00 00 00 02 C3 01
+            15 01 00 00 00 00 02 C4 23
+            15 01 00 00 00 00 02 C5 01
+            15 01 00 00 00 00 02 C6 53
+            15 01 00 00 00 00 02 C7 01
+            15 01 00 00 00 00 02 C8 78
+            15 01 00 00 00 00 02 C9 01
+            15 01 00 00 00 00 02 CA B1
+            15 01 00 00 00 00 02 CB 01
+            15 01 00 00 00 00 02 CC DC
+            15 01 00 00 00 00 02 CD 02
+            15 01 00 00 00 00 02 CE 1E
+            15 01 00 00 00 00 02 CF 02
+            15 01 00 00 00 00 02 D0 52
+            15 01 00 00 00 00 02 D1 02
+            15 01 00 00 00 00 02 D2 54
+            15 01 00 00 00 00 02 D3 02
+            15 01 00 00 00 00 02 D4 81
+            15 01 00 00 00 00 02 D5 02
+            15 01 00 00 00 00 02 D6 B2
+            15 01 00 00 00 00 02 D7 02
+            15 01 00 00 00 00 02 D8 D1
+            15 01 00 00 00 00 02 D9 02
+            15 01 00 00 00 00 02 DA FB
+            15 01 00 00 00 00 02 DB 03
+            15 01 00 00 00 00 02 DC 19
+            15 01 00 00 00 00 02 DD 03
+            15 01 00 00 00 00 02 DE 40
+            15 01 00 00 00 00 02 DF 03
+            15 01 00 00 00 00 02 E0 4D
+            15 01 00 00 00 00 02 E1 03
+            15 01 00 00 00 00 02 E2 5B
+            15 01 00 00 00 00 02 E3 03
+            15 01 00 00 00 00 02 E4 6A
+            15 01 00 00 00 00 02 E5 03
+            15 01 00 00 00 00 02 E6 7C
+            15 01 00 00 00 00 02 E7 03
+            15 01 00 00 00 00 02 E8 90
+            15 01 00 00 00 00 02 E9 03
+            15 01 00 00 00 00 02 EA AA
+            15 01 00 00 00 00 02 EB 03
+            15 01 00 00 00 00 02 EC D2
+            15 01 00 00 00 00 02 ED 03
+            15 01 00 00 00 00 02 EE FF
+            //G(+) MCR cmd
+            15 01 00 00 00 00 02 EF 00
+            15 01 00 00 00 00 02 F0 21
+            15 01 00 00 00 00 02 F1 00
+            15 01 00 00 00 00 02 F2 6B
+            15 01 00 00 00 00 02 F3 00
+            15 01 00 00 00 00 02 F4 A1
+            15 01 00 00 00 00 02 F5 00
+            15 01 00 00 00 00 02 F6 C2
+            15 01 00 00 00 00 02 F7 00
+            15 01 00 00 00 00 02 F8 DC
+            15 01 00 00 00 00 02 F9 00
+            15 01 00 00 00 00 02 FA F1
+            //page selection cmd start
+            15 01 00 00 00 00 02 FF 02
+            15 01 00 00 00 00 02 FB 01
+            //page selection cmd end
+            15 01 00 00 00 00 02 00 01
+            15 01 00 00 00 00 02 01 04
+            15 01 00 00 00 00 02 02 01
+            15 01 00 00 00 00 02 03 14
+            15 01 00 00 00 00 02 04 01
+            15 01 00 00 00 00 02 05 23
+            15 01 00 00 00 00 02 06 01
+            15 01 00 00 00 00 02 07 53
+            15 01 00 00 00 00 02 08 01
+            15 01 00 00 00 00 02 09 78
+            15 01 00 00 00 00 02 0A 01
+            15 01 00 00 00 00 02 0B B1
+            15 01 00 00 00 00 02 0C 01
+            15 01 00 00 00 00 02 0D DC
+            15 01 00 00 00 00 02 0E 02
+            15 01 00 00 00 00 02 0F 1E
+            15 01 00 00 00 00 02 10 02
+            15 01 00 00 00 00 02 11 52
+            15 01 00 00 00 00 02 12 02
+            15 01 00 00 00 00 02 13 54
+            15 01 00 00 00 00 02 14 02
+            15 01 00 00 00 00 02 15 81
+            15 01 00 00 00 00 02 16 02
+            15 01 00 00 00 00 02 17 B2
+            15 01 00 00 00 00 02 18 02
+            15 01 00 00 00 00 02 19 D1
+            15 01 00 00 00 00 02 1A 02
+            15 01 00 00 00 00 02 1B FB
+            15 01 00 00 00 00 02 1C 03
+            15 01 00 00 00 00 02 1D 19
+            15 01 00 00 00 00 02 1E 03
+            15 01 00 00 00 00 02 1F 40
+            15 01 00 00 00 00 02 20 03
+            15 01 00 00 00 00 02 21 4D
+            15 01 00 00 00 00 02 22 03
+            15 01 00 00 00 00 02 23 5B
+            15 01 00 00 00 00 02 24 03
+            15 01 00 00 00 00 02 25 6A
+            15 01 00 00 00 00 02 26 03
+            15 01 00 00 00 00 02 27 7C
+            15 01 00 00 00 00 02 28 03
+            15 01 00 00 00 00 02 29 90
+            15 01 00 00 00 00 02 2A 03
+            15 01 00 00 00 00 02 2B AA
+            15 01 00 00 00 00 02 2D 03
+            15 01 00 00 00 00 02 2F D2
+            15 01 00 00 00 00 02 30 03
+            15 01 00 00 00 00 02 31 FF
+            //G(-) MCR cmd
+            15 01 00 00 00 00 02 32 00
+            15 01 00 00 00 00 02 33 21
+            15 01 00 00 00 00 02 34 00
+            15 01 00 00 00 00 02 35 6B
+            15 01 00 00 00 00 02 36 00
+            15 01 00 00 00 00 02 37 A1
+            15 01 00 00 00 00 02 38 00
+            15 01 00 00 00 00 02 39 C2
+            15 01 00 00 00 00 02 3A 00
+            15 01 00 00 00 00 02 3B DC
+            15 01 00 00 00 00 02 3D 00
+            15 01 00 00 00 00 02 3F F1
+            15 01 00 00 00 00 02 40 01
+            15 01 00 00 00 00 02 41 04
+            15 01 00 00 00 00 02 42 01
+            15 01 00 00 00 00 02 43 14
+            15 01 00 00 00 00 02 44 01
+            15 01 00 00 00 00 02 45 23
+            15 01 00 00 00 00 02 46 01
+            15 01 00 00 00 00 02 47 53
+            15 01 00 00 00 00 02 48 01
+            15 01 00 00 00 00 02 49 78
+            15 01 00 00 00 00 02 4A 01
+            15 01 00 00 00 00 02 4B B1
+            15 01 00 00 00 00 02 4C 01
+            15 01 00 00 00 00 02 4D DC
+            15 01 00 00 00 00 02 4E 02
+            15 01 00 00 00 00 02 4F 1E
+            15 01 00 00 00 00 02 50 02
+            15 01 00 00 00 00 02 51 52
+            15 01 00 00 00 00 02 52 02
+            15 01 00 00 00 00 02 53 54
+            15 01 00 00 00 00 02 54 02
+            15 01 00 00 00 00 02 55 81
+            15 01 00 00 00 00 02 56 02
+            15 01 00 00 00 00 02 58 B2
+            15 01 00 00 00 00 02 59 02
+            15 01 00 00 00 00 02 5A D1
+            15 01 00 00 00 00 02 5B 02
+            15 01 00 00 00 00 02 5C FB
+            15 01 00 00 00 00 02 5D 03
+            15 01 00 00 00 00 02 5E 19
+            15 01 00 00 00 00 02 5F 03
+            15 01 00 00 00 00 02 60 40
+            15 01 00 00 00 00 02 61 03
+            15 01 00 00 00 00 02 62 4D
+            15 01 00 00 00 00 02 63 03
+            15 01 00 00 00 00 02 64 5B
+            15 01 00 00 00 00 02 65 03
+            15 01 00 00 00 00 02 66 6A
+            15 01 00 00 00 00 02 67 03
+            15 01 00 00 00 00 02 68 7C
+            15 01 00 00 00 00 02 69 03
+            15 01 00 00 00 00 02 6A 90
+            15 01 00 00 00 00 02 6B 03
+            15 01 00 00 00 00 02 6C AA
+            15 01 00 00 00 00 02 6D 03
+            15 01 00 00 00 00 02 6E D2
+            15 01 00 00 00 00 02 6F 03
+            15 01 00 00 00 00 02 70 FF
+            //B(+) MCR cmd
+            15 01 00 00 00 00 02 71 00
+            15 01 00 00 00 00 02 72 21
+            15 01 00 00 00 00 02 73 00
+            15 01 00 00 00 00 02 74 6B
+            15 01 00 00 00 00 02 75 00
+            15 01 00 00 00 00 02 76 A1
+            15 01 00 00 00 00 02 77 00
+            15 01 00 00 00 00 02 78 C2
+            15 01 00 00 00 00 02 79 00
+            15 01 00 00 00 00 02 7A DC
+            15 01 00 00 00 00 02 7B 00
+            15 01 00 00 00 00 02 7C F1
+            15 01 00 00 00 00 02 7D 01
+            15 01 00 00 00 00 02 7E 04
+            15 01 00 00 00 00 02 7F 01
+            15 01 00 00 00 00 02 80 14
+            15 01 00 00 00 00 02 81 01
+            15 01 00 00 00 00 02 82 23
+            15 01 00 00 00 00 02 83 01
+            15 01 00 00 00 00 02 84 53
+            15 01 00 00 00 00 02 85 01
+            15 01 00 00 00 00 02 86 78
+            15 01 00 00 00 00 02 87 01
+            15 01 00 00 00 00 02 88 B1
+            15 01 00 00 00 00 02 89 01
+            15 01 00 00 00 00 02 8A DC
+            15 01 00 00 00 00 02 8B 02
+            15 01 00 00 00 00 02 8C 1E
+            15 01 00 00 00 00 02 8D 02
+            15 01 00 00 00 00 02 8E 52
+            15 01 00 00 00 00 02 8F 02
+            15 01 00 00 00 00 02 90 54
+            15 01 00 00 00 00 02 91 02
+            15 01 00 00 00 00 02 92 81
+            15 01 00 00 00 00 02 93 02
+            15 01 00 00 00 00 02 94 B2
+            15 01 00 00 00 00 02 95 02
+            15 01 00 00 00 00 02 96 D1
+            15 01 00 00 00 00 02 97 02
+            15 01 00 00 00 00 02 98 FB
+            15 01 00 00 00 00 02 99 03
+            15 01 00 00 00 00 02 9A 19
+            15 01 00 00 00 00 02 9B 03
+            15 01 00 00 00 00 02 9C 40
+            15 01 00 00 00 00 02 9D 03
+            15 01 00 00 00 00 02 9E 4D
+            15 01 00 00 00 00 02 9F 03
+            15 01 00 00 00 00 02 A0 5B
+            15 01 00 00 00 00 02 A2 03
+            15 01 00 00 00 00 02 A3 6A
+            15 01 00 00 00 00 02 A4 03
+            15 01 00 00 00 00 02 A5 7C
+            15 01 00 00 00 00 02 A6 03
+            15 01 00 00 00 00 02 A7 90
+            15 01 00 00 00 00 02 A9 03
+            15 01 00 00 00 00 02 AA AA
+            15 01 00 00 00 00 02 AB 03
+            15 01 00 00 00 00 02 AC D2
+            15 01 00 00 00 00 02 AD 03
+            15 01 00 00 00 00 02 AE FF
+            //B(-) MCR cmd
+            15 01 00 00 00 00 02 AF 00
+            15 01 00 00 00 00 02 B0 21
+            15 01 00 00 00 00 02 B1 00
+            15 01 00 00 00 00 02 B2 6B
+            15 01 00 00 00 00 02 B3 00
+            15 01 00 00 00 00 02 B4 A1
+            15 01 00 00 00 00 02 B5 00
+            15 01 00 00 00 00 02 B6 C2
+            15 01 00 00 00 00 02 B7 00
+            15 01 00 00 00 00 02 B8 DC
+            15 01 00 00 00 00 02 B9 00
+            15 01 00 00 00 00 02 BA F1
+            15 01 00 00 00 00 02 BB 01
+            15 01 00 00 00 00 02 BC 04
+            15 01 00 00 00 00 02 BD 01
+            15 01 00 00 00 00 02 BE 14
+            15 01 00 00 00 00 02 BF 01
+            15 01 00 00 00 00 02 C0 23
+            15 01 00 00 00 00 02 C1 01
+            15 01 00 00 00 00 02 C2 53
+            15 01 00 00 00 00 02 C3 01
+            15 01 00 00 00 00 02 C4 78
+            15 01 00 00 00 00 02 C5 01
+            15 01 00 00 00 00 02 C6 B1
+            15 01 00 00 00 00 02 C7 01
+            15 01 00 00 00 00 02 C8 DC
+            15 01 00 00 00 00 02 C9 02
+            15 01 00 00 00 00 02 CA 1E
+            15 01 00 00 00 00 02 CB 02
+            15 01 00 00 00 00 02 CC 52
+            15 01 00 00 00 00 02 CD 02
+            15 01 00 00 00 00 02 CE 54
+            15 01 00 00 00 00 02 CF 02
+            15 01 00 00 00 00 02 D0 81
+            15 01 00 00 00 00 02 D1 02
+            15 01 00 00 00 00 02 D2 B2
+            15 01 00 00 00 00 02 D3 02
+            15 01 00 00 00 00 02 D4 D1
+            15 01 00 00 00 00 02 D5 02
+            15 01 00 00 00 00 02 D6 FB
+            15 01 00 00 00 00 02 D7 03
+            15 01 00 00 00 00 02 D8 19
+            15 01 00 00 00 00 02 D9 03
+            15 01 00 00 00 00 02 DA 40
+            15 01 00 00 00 00 02 DB 03
+            15 01 00 00 00 00 02 DC 4D
+            15 01 00 00 00 00 02 DD 03
+            15 01 00 00 00 00 02 DE 5B
+            15 01 00 00 00 00 02 DF 03
+            15 01 00 00 00 00 02 E0 6A
+            15 01 00 00 00 00 02 E1 03
+            15 01 00 00 00 00 02 E2 7C
+            15 01 00 00 00 00 02 E3 03
+            15 01 00 00 00 00 02 E4 90
+            15 01 00 00 00 00 02 E5 03
+            15 01 00 00 00 00 02 E6 AA
+            15 01 00 00 00 00 02 E7 03
+            15 01 00 00 00 00 02 E8 D2
+            15 01 00 00 00 00 02 E9 03
+            15 01 00 00 00 00 02 EA FF
+            //gamma 2.2 end
+            //CMD2 Page 4 -Display Register
+            15 01 00 00 00 00 02 FF 05
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 01 00
+            15 01 00 00 00 00 02 02 82
+            15 01 00 00 00 00 02 03 82
+            15 01 00 00 00 00 02 04 82
+            15 01 00 00 00 00 02 06 33
+            15 01 00 00 00 00 02 07 01
+            15 01 00 00 00 00 02 08 00
+            15 01 00 00 00 00 02 09 46
+            15 01 00 00 00 00 02 0A 46
+            15 01 00 00 00 00 02 0D 0B
+            15 01 00 00 00 00 02 0E 1D
+            15 01 00 00 00 00 02 0F 08
+            15 01 00 00 00 00 02 10 53
+            15 01 00 00 00 00 02 11 00
+            15 01 00 00 00 00 02 12 00
+            15 01 00 00 00 00 02 14 01
+            15 01 00 00 00 00 02 15 00
+            15 01 00 00 00 00 02 16 05
+            15 01 00 00 00 00 02 17 00
+            15 01 00 00 00 00 02 19 7F
+            15 01 00 00 00 00 02 1A FF
+            15 01 00 00 00 00 02 1B 0F
+            15 01 00 00 00 00 02 1C 00
+            15 01 00 00 00 00 02 1D 00
+            15 01 00 00 00 00 02 1E 00
+            15 01 00 00 00 00 02 1F 07
+            15 01 00 00 00 00 02 20 00
+            15 01 00 00 00 00 02 21 00
+            15 01 00 00 00 00 02 22 55
+            15 01 00 00 00 00 02 23 4d
+            15 01 00 00 00 00 02 2D 02
+            15 01 00 00 00 00 02 83 01
+            15 01 00 00 00 00 02 9e 58
+            15 01 00 00 00 00 02 9f 68
+            15 01 00 00 00 00 02 a0 01
+            15 01 00 00 00 00 02 a2 10
+            15 01 00 00 00 00 02 bb 0a
+            15 01 00 00 00 00 02 bc 0a
+            15 01 00 00 00 00 02 28 01
+            15 01 00 00 00 00 02 2f 02
+            15 01 00 00 00 00 02 32 08
+            15 01 00 00 00 00 02 33 b8
+            15 01 00 00 00 00 02 36 01
+            15 01 00 00 00 00 02 37 00
+            15 01 00 00 00 00 02 43 00
+            15 01 00 00 00 00 02 4b 21
+            15 01 00 00 00 00 02 4c 03
+            15 01 00 00 00 00 02 50 21
+            15 01 00 00 00 00 02 51 03
+            15 01 00 00 00 00 02 58 21
+            15 01 00 00 00 00 02 59 03
+            15 01 00 00 00 00 02 5d 21
+            15 01 00 00 00 00 02 5e 03
+            15 01 00 00 00 00 02 6c 00
+            15 01 00 00 00 00 02 6d 00
+            //non-reload MTP
+            //CMD1
+            15 01 00 00 00 00 02 FF 00 
+            15 01 00 00 00 00 02 fb 01
+            //CMD2, Page0
+            15 01 00 00 00 00 02 FF 01 
+            15 01 00 00 00 00 02 fb 01
+            //CMD2, Page1
+            15 01 00 00 00 00 02 FF 02 
+            15 01 00 00 00 00 02 fb 01
+            //CMD2, Page2
+            15 01 00 00 00 00 02 FF 03
+            15 01 00 00 00 00 02 fb 01
+            //CMD2, Page3
+            15 01 00 00 00 00 02 FF 04
+            15 01 00 00 00 00 02 FB 01
+            //CMD2, Page4
+            15 01 00 00 00 00 02 FF 05
+            15 01 00 00 00 00 02 fb 01
+            //CMD2, Page3 Fre(PWM)=57.292KHz
+            15 01 00 00 00 00 02 FF 04
+            15 01 00 00 00 00 02 FB 01
+            15 01 00 00 00 00 02 07 40
+            15 01 00 00 00 00 02 08 03
+            //CMD1
+            15 01 00 00 00 00 02 FF 00 
+            15 01 00 00 00 00 02 fb 01			
+            15 01 00 00 00 00 02 BA 03
+            39 01 00 00 00 00 02 35 00
+            39 01 00 00 78 00 02 11 00
+            15 01 00 00 00 00 02 55 00
+            39 01 00 00 00 00 02 53 24
+            39 01 00 00 00 00 02 29 00      
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 32 00 02 28 00
+					39 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		// dsi panel timings from lianchuang(mass production)
+        qcom,mdss-dsi-panel-timings = [93 1F 17 00 2f 50 1c 21 26 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x4>;
+		qcom,mdss-dsi-t-clk-pre = <0x12>;
+		qcom,mdss-brightness-max-level = <255>;
+		qcom,mdss-dsi-bl-min-level = <7>;
+		qcom,mdss-dsi-bl-max-level = <230>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a1 = <85>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a2 = <96>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b1 = <104>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b2 = <4294965905>;
+		qcom,mdss-dsi-bright-to-bl-lvl-turn-point = <186>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 1500>, <0 1000>, <1 50000>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/dsi-success-panel-hx8392b-720p-video.dtsi b/arch/arm/boot/dts/zte/ne501j/dsi-success-panel-hx8392b-720p-video.dtsi
new file mode 100644
index 0000000..48054a6
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/dsi-success-panel-hx8392b-720p-video.dtsi
@@ -0,0 +1,105 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_success_hx8392b_720_vid: qcom,mdss_dsi_success_hx8392b_720p_video {
+		qcom,mdss-dsi-panel-name = "success hx8392b 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <76>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <76>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <8>;
+		qcom,mdss-dsi-v-front-porch = <17>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+            39 01 00 00 00 00 04 B9 FF 83 92
+            //39 01 00 00 00 00 02 35 00
+            39 01 00 00 00 00 18 B1 4D 45 45 14 3B 31 55 12 ED B3 B1 50 0F 43 F0 C0 C0 C0 C0 00 02 16 19
+            39 01 00 00 00 00 13 B2 00 00 C8 08 0F 72 1B 08 0F 1B 1B 02 02 30 04 00 00 48
+            39 01 00 00 00 00 29 B4 00 FF 20 24 00 3F 00 3F 05 00 02 03 03 0C 02 03 04 01 00 07 36 20 24 00 3F 00 3F 05 00 02 03 00 0C 02 03 04 01 00 07 36
+            39 01 00 00 00 00 03 B6 74 74
+            39 01 00 00 00 00 2b E0 00 17 1B 2B 2F 3F 2B 41 0A 0E 0E 12 15 13 13 12 13 00 17 1B 2B 2F 3F 2B 41 0A 0E 0F 12 15 13 14 10 14 0B 17 09 12 0C 18 08 11
+            39 01 00 00 00 00 02 BA 03
+            39 01 00 00 00 00 02 CC 08
+            39 01 00 00 00 00 29 D3 00 00 01 00 01 10 28 08 32 30 05 00 05 32 13 C0 00 00 32 10 08 00 00 11 05 05 01 04 00 27 00 00 00 0A 00 11 00 00 00 00
+            39 01 00 00 00 00 37 D5 21 21 1F 1F 1E 1E 1C 1C 1D 1D 19 19 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 2F 2F 30 30 31 31
+            39 01 00 00 00 00 37 D6 21 21 1F 1F 1E 1E 1D 1D 1C 1C 19 19 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 2F 2F 30 30 31 31
+            39 01 00 00 00 00 02 BD 00
+            39 01 00 00 00 00 1d D8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8
+            39 01 00 00 00 00 02 BD 01
+            39 01 00 00 00 00 2b D8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+            39 01 00 00 00 00 02 BD 02
+            39 01 00 00 00 00 0f D8 82 E0 00 00 00 00 FC 82 E0 00 00 00 00 FC
+            39 01 00 00 00 00 02 BD 00
+            39 01 00 00 00 00 04 D9 00 01 02
+            39 01 00 00 96 00 02 11 00
+            39 01 00 00 00 00 03 C9 0F 10
+            39 01 00 00 00 00 02 55 00
+            39 01 00 00 00 00 02 53 24
+            39 01 00 00 78 00 02 29 00
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 32 00 02 28 00
+					39 01 00 00 78 00 02 10 00];
+        qcom,mdss-dsi-esd-command = [39 01 00 00 05 00 02 11 00
+                39 01 00 00 05 00 02 29 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [37 1c 12 00 40 44 16 1e 17 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x4>;
+		qcom,mdss-dsi-t-clk-pre = <0x18>;
+		qcom,mdss-brightness-max-level = <255>;
+		qcom,mdss-dsi-bl-min-level = <7>;
+		qcom,mdss-dsi-bl-max-level = <222>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a1 = <81>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-a2 = <93>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b1 = <81>;
+		qcom,mdss-dsi-bright-to-bl-lvl-para-b2 = <4294965844>;
+		qcom,mdss-dsi-bright-to-bl-lvl-turn-point = <186>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 1500>, <0 30>, <1 23000>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/msm8226-720p-mtp.dtsi b/arch/arm/boot/dts/zte/ne501j/msm8226-720p-mtp.dtsi
new file mode 100755
index 0000000..1809806
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/msm8226-720p-mtp.dtsi
@@ -0,0 +1,636 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "msm8226-camera-sensor-mtp.dtsi"
+
+&soc {
+	serial@f991f000 {
+		status = "ok";
+	};
+	i2c@f9923000 { /* BLSP1 QUP3 */
+		ams-sensor_i2c_adapter@39 {
+			status = "okay";
+			reg = <0x39>;
+			compatible = "ams,ams-sensor";
+			interrupt-parent = <&msmgpio>;
+			ams,irq-gpio = <&msmgpio 49 0x00>;
+		};
+	};
+
+	i2c@f9927000 { /* BLSP1 QUP5 */
+		/*ZTEMT Added by luochangyang, 2014/01/07*/
+		goodix_gt915@5d {
+			compatible = "goodix,gt915_i2c";
+			reg = <0x5d>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2008>;
+			vdd_ana-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			goodix,reset-gpio = <&msmgpio 16 0x00>;
+			goodix,irq-gpio = <&msmgpio 17 0x00>;
+		};
+		/*ZTEMT END*/
+/*
+		synaptics@20 {
+			compatible = "synaptics,rmi4";
+			reg = <0x20>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2008>;
+			vdd-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 16 0x00>;
+			synaptics,irq-gpio = <&msmgpio 17 0x2008>;
+			synaptics,button-map = <139 102 158>;
+			synaptics,fw-image-name = "PR1468813.img";
+			synaptics,i2c-pull-up;
+			synaptics,power-down;
+			synaptics,disable-gpios;
+		};
+*/
+		focaltech@38 {
+			compatible = "focaltech,5x06";
+			reg = <0x38>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2>;
+			vdd-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			focaltech,name = "ft5x06";
+			focaltech,family-id = <0x14>;
+			focaltech,fw-vkey-support;
+			focaltech,ignore-id-check;
+			focaltech,reset-gpio = <&msmgpio 16 0x00>;
+			focaltech,irq-gpio = <&msmgpio 17 0x00>;
+			focaltech,display-coords = <0 0 720 1280>;
+			focaltech,panel-coords = <0 0 1080 2000>;
+			focaltech,button-map= <139 102 158>;
+			focaltech,no-force-update;
+			focaltech,i2c-pull-up;
+			focaltech,group-id = <1>;
+			focaltech,hard-reset-delay-ms = <20>;
+			focaltech,soft-reset-delay-ms = <150>;
+			focaltech,num-max-touches = <5>;
+			focaltech,fw-name = "ft_8226_qrd_1080p_fw.bin";
+			focaltech,fw-delay-aa-ms = <50>;
+			focaltech,fw-delay-55-ms = <30>;
+			focaltech,fw-upgrade-id1 = <0x79>;
+			focaltech,fw-upgrade-id2 = <0x03>;
+			focaltech,fw-delay-readid-ms = <10>;
+			focaltech,fw-delay-era-flsh-ms = <2000>;
+		};
+	};
+
+	i2c@f9925000 { /* BLSP1 QUP3 */
+		nfc-nci@0e {
+			compatible = "qcom,nfc-nci";
+			reg = <0x0e>;
+			qcom,irq-gpio = <&msmgpio 21 0x00>;
+			qcom,dis-gpio = <&msmgpio 20 0x00>;
+			qcom,clk-src = "BBCLK2";
+			qcom,clk-en-gpio = <&msmgpio 0 0x00>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <21 0>;
+			qcom,clk-gpio = <&pm8226_gpios 3 0>;
+		};
+	};
+	gpio_keys {
+		compatible = "gpio-keys";
+		input-name = "gpio-keys";
+
+		camera_focus {
+			label = "camera_focus";
+			gpios = <&msmgpio 108 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x210>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		camera_snapshot {
+			label = "camera_snapshot";
+			gpios = <&msmgpio 107 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x2fe>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		vol_up {
+			label = "volume_up";
+			gpios = <&msmgpio 106 0x1>;
+			linux,input-type = <1>;
+			linux,code = <115>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+		vol_dn {
+			label = "volume_dn";
+			gpios = <&msmgpio 109 0x1>;
+			linux,input-type = <1>;
+			linux,code = <114>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+	};
+
+	spi@f9923000 {
+		ethernet-switch@3 {
+			compatible = "micrel,ks8851";
+			reg = <3>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <115 0x8>;
+			spi-max-frequency = <4800000>;
+			rst-gpio = <&msmgpio 114 0>;
+			vdd-io-supply = <&pm8226_lvs1>;
+			vdd-phy-supply = <&pm8226_lvs1>;
+		};
+	};
+
+	sound {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC4", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCRight Headset Mic",
+			"AMIC5", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCLeft Headset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+
+	sound-9302 {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC3", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Handset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+};
+
+&usb_otg {
+	#address-cells = <0>;
+	interrupt-parent = <&usb_otg>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 134 0
+			1 &intc 0 140 0
+			2 &spmi_bus 0x0 0x0 0x9 0x0>;
+	interrupt-names = "core_irq", "async_irq", "pmic_id_irq";
+
+	qcom,hsusb-otg-mode = <3>;
+	vbus_otg-supply = <&pm8226_chg_otg>;
+};
+
+&sdcc1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "disabled";
+};
+
+&sdhc_1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "ok";
+};
+
+&sdcc2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,xpc;
+	qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50", "SDR104";
+	qcom,current-limit = <600>; #address-cells = <0>; interrupt-parent = <&sdcc2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 220 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "core_irq", "bam_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "disabled";
+};
+
+&sdhc_2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+
+	#address-cells = <0>;
+	interrupt-parent = <&sdhc_2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 221 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "hc_irq", "pwr_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "ok";
+};
+
+&spmi_bus {
+	qcom,pm8226@0 {
+/*
+		qcom,leds@a100 {
+			status = "okay";
+			qcom,led_mpp_2 {
+				label = "mpp";
+				linux,name = "button-backlight";
+				linux,default-trigger = "none";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "manual";
+				qcom,source-sel = <1>;
+				qcom,mode-ctrl = <0x60>;
+			};
+		};
+*/
+/*ZTEMT modify by ttwang for breath led 2014/04/30*/
+		qcom,leds@a100 {
+		    compatible = "qcom,ztemt-leds-qpnp";
+			reg = <0xa100 0x100>;
+			label = "mpp";
+			status = "okay";
+			qcom,led_mpp_2 {
+				label = "mpp";
+				linux,name = "red";
+				linux,default-trigger = "none";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,source-sel = <14>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,pwm-channel = <3>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts= [00 02 04 06 08 0a 0c 
+				                 0e 10 12 14 16 18 1a 
+				                 1c 1e 20 22 24 26 28 
+				                 2a 2c 2e 30 32 34 36 
+				                 38 3a 3c 3e 40 42 44 
+				                 46 48 4a 4c 4e 50 52 
+				                 54 56 58 5a 5c 5e 60 
+				                 62 64];
+				qcom,use-blink = <1>;
+			};
+		};
+
+		qcom,leds@a300 {
+		    compatible = "qcom,ztemt-leds-qpnp";
+			reg = <0xa300 0x100>;
+			label = "mpp";
+			status = "okay";
+			qcom,led_mpp_4 {
+				label = "mpp";
+				linux,name = "green";
+				linux,default-trigger = "battery-full";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,source-sel = <8>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,pwm-channel = <0>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+
+		qcom,leds@a500 {
+		    compatible = "qcom,ztemt-leds-qpnp";
+			reg = <0xa500 0x100>;
+			label = "mpp";
+			status = "okay";
+			qcom,led_mpp_6 {
+				label = "mpp";
+				//linux,name = "red";
+				linux,name = "msm_red";
+				linux,default-trigger = "battery-charging";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,source-sel = <10>;
+				qcom,pwm-channel = <5>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+	};
+
+	qcom,pm8226@1 {
+                qcom,leds@d300 {
+                        status = "okay";
+                };
+
+		qcom,leds@d800 {
+			status = "okay";
+			qcom,wled_0 {
+				/*mayu close
+				label = "wled";
+				linux,name = "wled:backlight";
+				linux,default-trigger = "bkl-trigger";
+				qcom,cs-out-en;
+				qcom,op-fdbck = <1>;
+				qcom,default-state = "on";
+				qcom,max-current = <20>;
+				qcom,ctrl-delay-us = <0>;
+				qcom,boost-curr-lim = <3>;
+				qcom,cp-sel = <0>;
+				qcom,switch-freq = <11>;
+				qcom,ovp-val = <0>;
+				qcom,num-strings = <1>;
+				qcom,id = <0>;*/
+			};
+		};
+
+		qcom,vibrator@c000 {
+			status = "okay";
+			qcom,vib-timeout-ms = <15000>;
+			qcom,vib-vtg-level-mV = <3100>;
+		};
+	};
+};
+
+&pm8226_gpios {
+	gpio@c000 { /* GPIO 1 */
+		/* XO_PMIC_CDC_MCLK enable for tapan codec */
+		qcom,mode = <1>;		/* Digital output */
+		qcom,output-type = <0>;	/* CMOS logic */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO*/
+		qcom,vin-sel = <3>;		/* QPNP_PIN_VIN3 */
+		qcom,out-strength = <3>;/* QPNP_PIN_OUT_STRENGTH_HIGH */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;	/* Enable GPIO */
+	};
+
+	gpio@c100 { /* GPIO 2 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <3>;
+		qcom,out-strength = <3>;
+		qcom,src-sel = <2>;
+		qcom,master-en = <1>;
+	};
+
+	gpio@c200 { /* GPIO 3 */
+		qcom,mode = <0>;		/* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO */
+		qcom,vin-sel = <2>;		/* QPNP_PIN_VIN2 */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c300 { /* GPIO 4 */
+	};
+
+	gpio@c400 { /* GPIO 5 */
+	};
+
+	gpio@c500 { /* GPIO 6 */
+	};
+
+	gpio@c600 { /* GPIO 7 */
+	};
+
+	gpio@c700 { /* GPIO 8 */
+	};
+};
+
+&pm8226_mpps {
+	mpp@a000 { /* MPP 1 */
+	};
+
+	mpp@a100 { /* MPP 2 */
+	};
+
+	mpp@a200 { /* MPP 3 */
+	};
+
+	mpp@a300 { /* MPP 4 */
+	};
+
+	mpp@a400 { /* MPP 5 */
+		/* PA_THERM0 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <0>; /* AMUX 5 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+
+	mpp@a500 { /* MPP 6 */
+	};
+
+	mpp@a600 { /* MPP 7 */
+	};
+
+	mpp@a700 { /* MPP 8 */
+		/* PA_THERM1 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <3>; /* AMUX 8 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+};
+
+&pm8226_vadc {
+	chan@14 {
+		label = "pa_therm0";
+		reg = <0x14>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+
+	chan@17 {
+		label = "pa_therm1";
+		reg = <0x17>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+};
+
+/* Charger
+*
+* CONFIG_ZTEMT_CHARGE
+*/
+/ {
+	mtp_batterydata: qcom,battery-data {
+		qcom,rpull-up-kohm = <100>;
+		qcom,vref-batt-therm = <1800000>;
+
+		/include/ "batterydata-zte-2400mah.dtsi"
+/*
+		/include/ "batterydata-palladium.dtsi"
+		/include/ "batterydata-mtp-3000mah.dtsi"
+*/
+	};
+};
+
+&pm8226_bms {
+	status = "ok";
+	qcom,enable-fcc-learning;
+	qcom,min-fcc-learning-soc = <20>;
+	qcom,min-fcc-ocv-pc = <30>;
+	qcom,min-fcc-learning-samples = <5>;
+	qcom,fcc-resolution = <10>;
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+&pm8226_chg {
+	/*qcom,charging-disabled;*/
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+&slim_msm {
+	tapan_codec {
+		qcom,cdc-micbias1-ext-cap;
+	};
+};
+
+&mdss_mdp {
+	qcom,mdss-pref-prim-intf = "dsi";
+	batfet-supply = <&pm8226_chg_batif>;
+};
+
+&mdss_dsi0 {
+	qcom,dsi-pref-prim-pan = <&dsi_cs_nt35592_720_vid>;
//qcom,dsi-pref-prim-pan = <&dsi_nt35590_720_vid>;
+};
+
+&dsi_nt35590_720_vid {
+	qcom,cont-splash-enabled;
+};
+&dsi_cs_nt35592_720_vid {
+    status = "disabled";
+	qcom,cont-splash-enabled;
+};
+
+&dsi_success_hx8392b_720_vid {
+    status = "disabled";
+	qcom,cont-splash-enabled;
+};
+&dsi_lianchuang_nt35592_720_vid {
+    status = "disabled";
+	qcom,cont-splash-enabled;
+};
diff --git a/arch/arm/boot/dts/zte/ne501j/msm8226-camera-sensor-mtp.dtsi b/arch/arm/boot/dts/zte/ne501j/msm8226-camera-sensor-mtp.dtsi
new file mode 100755
index 0000000..95cbdf4
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne501j/msm8226-camera-sensor-mtp.dtsi
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+
+	led_flash0: qcom,camera-led-flash {
+		cell-index = <0>;
+		compatible = "qcom,camera-led-flash";
+		qcom,flash-type = <1>;
+		qcom,flash-source = <&pm8226_flash0 &pm8226_flash1>;
+		qcom,torch-source = <&pm8226_torch>;
+	};
+};
+
+&cci {
+
+	actuator0: qcom,actuator@6e {
+		cell-index = <3>;
+		reg = <0x6c>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	actuator1: qcom,actuator@18 {
+		cell-index = <1>;
+		reg = <0x18>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@20 {
+		compatible = "qcom,imx135";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator1>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135";
+		cam_vdig-supply = <&pm8226_l5>;
+		/*cam_vana-supply = <&pm8226_l19>;*/
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l19>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", /*"cam_vana",*/
+							 "cam_vaf";
+		qcom,cam-vreg-type = <0 1  0>;
+		qcom,cam-vreg-min-voltage = <1050000 0  2850000>;
+		qcom,cam-vreg-max-voltage = <1050000 0  2850000>;
+		qcom,cam-vreg-op-mode = <200000 0  100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,gpio-avdd-enable = <&msmgpio 14 0>;		/*tanyijun add for back camera avdd enable */	
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1f>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6c {
+		compatible = "qcom,ov5648";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300a 0x5648>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov5648";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1500000 0 2800000>;
+		qcom,cam-vreg-max-voltage = <1500000 0 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+				<&msmgpio 28 0>,
+				<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET",
+				"CAM_STANDBY";
+		qcom,gpio-avdd-enable = <&msmgpio 12 0>;		/*tanyijun add for back camera avdd enable */				
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6f {
+		compatible = "qcom,ov8825";
+		reg = <0x6f>;
+		qcom,slave-id = <0x6c 0x300a 0x8825>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov8825";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+							 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1f>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@6d {
+		compatible = "qcom,ov9724";
+		reg = <0x6d>;
+		qcom,slave-id = <0x20 0x0 0x9724>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov9724";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+				<&msmgpio 28 0>,
+				<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET",
+				"CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+	qcom,camera@0 {
+		cell-index = <0>;
+		compatible = "qcom,camera";
+		reg = <0x0>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+			 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@1 {
+		cell-index = <1>;
+		compatible = "qcom,camera";
+		reg = <0x1>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 28 0>,
+			<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne504h/batterydata-zte-2400mah.dtsi b/arch/arm/boot/dts/zte/ne504h/batterydata-zte-2400mah.dtsi
new file mode 100755
index 0000000..ce74257
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne504h/batterydata-zte-2400mah.dtsi
@@ -0,0 +1,112 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+qcom,zte-2400mah {
+	qcom,fcc-mah = <2400>;
+	qcom,default-rbatt-mohm = <129>;
+	qcom,max-voltage-uv = <4350000>;
+	qcom,rbatt-capacitive-mohm = <50>;
+	qcom,v-cutoff-uv = <3400000>;
+	qcom,chg-term-ua = <100000>;
+	qcom,batt-id-kohm = <300>;
+
+	qcom,fcc-temp-lut {
+		qcom,lut-col-legend = <(-20)  0 25 40 60>;
+		qcom,lut-data = <2469  2472  2469  2456  2450>;
+	};
+
+	qcom,pc-temp-ocv-lut {
+		qcom,lut-col-legend = <(-20)  0 25 40 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>,
+				<0>;
+		qcom,lut-data = <4333 4332 4327 4323 4315>,
+							<4247 4259 4261 4260 4255>,
+							<4177 4200 4206 4205 4200>,
+							<4114 4144 4152 4151 4147>,
+							<4056 4091 4100 4100 4096>,
+							<3989 4039 4053 4053 4048>,
+							<3942 3980 4005 4006 4003>,
+							<3902 3934 3963 3966 3963>,
+							<3865 3895 3920 3924 3922>,
+							<3835 3860 3869 3873 3871>,
+							<3810 3830 3840 3842 3841>,
+							<3789 3806 3817 3819 3818>,
+							<3770 3788 3797 3799 3798>,
+							<3753 3773 3782 3781 3780>,
+							<3737 3759 3769 3765 3759>,
+							<3720 3742 3753 3746 3733>,
+							<3702 3723 3729 3722 3707>,
+							<3683 3707 3697 3691 3677>,
+							<3665 3695 3683 3677 3665>,
+							<3650 3686 3681 3674 3663>,
+							<3641 3681 3679 3673 3661>,
+							<3629 3676 3677 3671 3659>,
+							<3615 3669 3673 3668 3655>,
+							<3598 3658 3666 3661 3644>,
+							<3577 3639 3643 3642 3614>,
+							<3548 3606 3603 3604 3573>,
+							<3507 3556 3549 3555 3523>,
+							<3449 3488 3483 3497 3463>,
+							<3363 3392 3403 3425 3382>,
+							<3233 3263 3284 3316 3256>,
+							<3000 3000 3000 3000 3000>;
+			};
+
+	qcom,rbatt-sf-lut {
+		qcom,lut-col-legend = <(-20) 0 25 40 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>,
+				<0>;
+		qcom,lut-data = <1438 321 100 77 69>,
+												<1437 321 100 78 69>,
+												<1407 332 106 82 72>,
+												<1380 343 111 86 74>,
+												<1373 351 117 89 77>,
+												<1363 365 125 95 81>,
+												<1389 355 133 99 84>,
+												<1417 353 141 105 87>,
+												<1445 359 136 107 89>,
+												<1482 368 108 86 74>,
+												<1535 382 109 82 74>,
+												<1600 406 114 87 78>,
+												<1675 437 122 93 82>,
+												<1762 475 130 96 85>,
+												<1926 518 137 96 82>,
+												<2218 559 140 93 78>,
+												<2544 603 140 93 76>,
+												<2794 648 137 91 74>,
+												<2714 664 138 91 75>,
+												<2811 684 149 97 79>,
+												<2997 705 155 100 80>,
+												<3219 725 162 103 81>,
+												<3494 753 168 105 82>,
+												<3824 775 173 106 79>,
+												<4250 796 169 103 79>,
+												<4806 821 169 102 82>,
+												<5523 853 177 106 89>,
+												<6575 903 193 120 103>,
+												<8443 981 233 142 111>,
+												<14044 1566 277 162 137>,
+												<39526 12585 2471 2394 668>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne504h/dsi-cs-panel-nt35592-720p-video.dtsi b/arch/arm/boot/dts/zte/ne504h/dsi-cs-panel-nt35592-720p-video.dtsi
new file mode 100755
index 0000000..de42a14
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne504h/dsi-cs-panel-nt35592-720p-video.dtsi
@@ -0,0 +1,568 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_cs_nt35592_720_vid: qcom,mdss_dsi_cs_nt35592_720p_video {
+		qcom,mdss-dsi-panel-name = "cs nt35592 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <12>;
+		qcom,mdss-dsi-h-back-porch = <12>;
+		qcom,mdss-dsi-h-pulse-width = <4>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <2>;
+		qcom,mdss-dsi-v-front-porch = <6>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+            //CMD2 Page0 -Power 
+            29 01 00 00 00 00 02 FF 01
+            29 01 00 00 00 00 02 FB 01
+            29 01 00 00 00 00 02 00 2A
+            29 01 00 00 00 00 02 01 33
+            29 01 00 00 00 00 02 02 53
+            29 01 00 00 00 00 02 03 55
+            29 01 00 00 00 00 02 04 55
+            29 01 00 00 00 00 02 05 00
+            29 01 00 00 00 00 02 06 44
+            29 01 00 00 00 00 02 08 26
+            29 01 00 00 00 00 02 09 09
+            //// GVDDP  GVDDN 
+            29 01 00 00 00 00 02 0B CA
+            29 01 00 00 00 00 02 0C CA
+            29 01 00 00 00 00 02 0D 24
+            29 01 00 00 00 00 02 0E 2B
+            //VGLO = -6.2V  
+            29 01 00 00 00 00 02 0F 96
+            29 01 00 00 00 00 02 10 0F
+            //VCOMDC 
+            29 01 00 00 00 00 02 11 72
+            29 01 00 00 00 00 02 12 03
+            //power mode 
+            29 01 00 00 00 00 02 14 01
+            //Gate EQ 
+            29 01 00 00 00 00 02 36 73
+            //VGLO pull GND
+            29 01 00 00 00 00 02 37 02
+			29 01 00 00 00 00 02 4c 01
+			29 01 00 00 00 00 02 6f 00
+            29 01 00 00 00 00 02 71 2C
+			29 01 00 00 00 00 02 ff 00
+			29 01 00 00 00 00 02 fb 01
+			//gamma begin
+			//Page Select CMD2,Page0 
+            29 01 00 00 00 00 02 FF 01
+            //Don't reload MTP 
+            29 01 00 00 00 00 02 FB 01
+            //Gamma R+ 
+            29 01 00 00 00 00 02 75 00
+            29 01 00 00 00 00 02 76 5F
+            29 01 00 00 00 00 02 77 00
+            29 01 00 00 00 00 02 78 97
+            29 01 00 00 00 00 02 79 00
+            29 01 00 00 00 00 02 7A A1
+            29 01 00 00 00 00 02 7B 00
+            29 01 00 00 00 00 02 7C B8
+            29 01 00 00 00 00 02 7D 00
+            29 01 00 00 00 00 02 7E CC
+            29 01 00 00 00 00 02 7F 00
+            29 01 00 00 00 00 02 80 E2
+            29 01 00 00 00 00 02 81 00
+            29 01 00 00 00 00 02 82 EC
+            29 01 00 00 00 00 02 83 00
+            29 01 00 00 00 00 02 84 F9
+            29 01 00 00 00 00 02 85 01
+            29 01 00 00 00 00 02 86 08
+            29 01 00 00 00 00 02 87 01
+            29 01 00 00 00 00 02 88 2F
+            29 01 00 00 00 00 02 89 01
+            29 01 00 00 00 00 02 8A 50
+            29 01 00 00 00 00 02 8B 01
+            29 01 00 00 00 00 02 8C 8E
+            29 01 00 00 00 00 02 8D 01
+            29 01 00 00 00 00 02 8E B6
+            29 01 00 00 00 00 02 8F 01
+            29 01 00 00 00 00 02 90 FD
+            29 01 00 00 00 00 02 91 02
+            29 01 00 00 00 00 02 92 2E
+            29 01 00 00 00 00 02 93 02
+            29 01 00 00 00 00 02 94 2E
+            29 01 00 00 00 00 02 95 02
+            29 01 00 00 00 00 02 96 5E
+            29 01 00 00 00 00 02 97 02
+            29 01 00 00 00 00 02 98 94
+            29 01 00 00 00 00 02 99 02
+            29 01 00 00 00 00 02 9A B4
+            29 01 00 00 00 00 02 9B 02
+            29 01 00 00 00 00 02 9C DB
+            29 01 00 00 00 00 02 9D 02
+            29 01 00 00 00 00 02 9E FD
+            29 01 00 00 00 00 02 9F 03
+            29 01 00 00 00 00 02 A0 24
+            29 01 00 00 00 00 01 A1
+            29 01 00 00 00 00 02 A2 03
+            29 01 00 00 00 00 02 A3 30
+            29 01 00 00 00 00 02 A4 03
+            29 01 00 00 00 00 02 A5 3C
+            29 01 00 00 00 00 02 A6 03
+            29 01 00 00 00 00 02 A7 5B
+            29 01 00 00 00 00 01 A8
+            29 01 00 00 00 00 02 A9 03
+            29 01 00 00 00 00 02 AA 80
+            29 01 00 00 00 00 02 AB 03
+            29 01 00 00 00 00 02 AC A3
+            29 01 00 00 00 00 02 AD 03
+            29 01 00 00 00 00 02 AE B1
+            29 01 00 00 00 00 02 AF 03
+            29 01 00 00 00 00 02 B0 BE
+            29 01 00 00 00 00 02 B1 03
+            29 01 00 00 00 00 02 B2 BD
+            //Gamma R- 
+            29 01 00 00 00 00 02 B3 00
+            29 01 00 00 00 00 02 B4 D9
+            29 01 00 00 00 00 02 B5 01
+            29 01 00 00 00 00 02 B6 0D
+            29 01 00 00 00 00 02 B7 01
+            29 01 00 00 00 00 02 B8 13
+            29 01 00 00 00 00 02 B9 01
+            29 01 00 00 00 00 02 BA 26
+            29 01 00 00 00 00 02 BB 01
+            29 01 00 00 00 00 02 BC 3A
+            29 01 00 00 00 00 02 BD 01
+            29 01 00 00 00 00 02 BE 4F
+            29 01 00 00 00 00 02 BF 01
+            29 01 00 00 00 00 02 C0 5A
+            29 01 00 00 00 00 02 C1 01
+            29 01 00 00 00 00 02 C2 66
+            29 01 00 00 00 00 02 C3 01
+            29 01 00 00 00 00 02 C4 6B
+            29 01 00 00 00 00 02 C5 01
+            29 01 00 00 00 00 02 C6 97
+            29 01 00 00 00 00 02 C7 01
+            29 01 00 00 00 00 02 C8 B1
+            29 01 00 00 00 00 02 C9 01
+            29 01 00 00 00 00 02 CA E8
+            29 01 00 00 00 00 02 CB 02
+            29 01 00 00 00 00 02 CC 0C
+            29 01 00 00 00 00 02 CD 02
+            29 01 00 00 00 00 02 CE 48
+            29 01 00 00 00 00 02 CF 02
+            29 01 00 00 00 00 02 D0 7E
+            29 01 00 00 00 00 02 D1 02
+            29 01 00 00 00 00 02 D2 7E
+            29 01 00 00 00 00 02 D3 02
+            29 01 00 00 00 00 02 D4 AE
+            29 01 00 00 00 00 02 D5 02
+            29 01 00 00 00 00 02 D6 E4
+            29 01 00 00 00 00 02 D7 03
+            29 01 00 00 00 00 02 D8 03
+            29 01 00 00 00 00 02 D9 03
+            29 01 00 00 00 00 02 DA 33
+            29 01 00 00 00 00 02 DB 03
+            29 01 00 00 00 00 02 DC 57
+            29 01 00 00 00 00 02 DD 03
+            29 01 00 00 00 00 02 DE 83
+            29 01 00 00 00 00 02 DF 03
+            29 01 00 00 00 00 02 E0 8D
+            29 01 00 00 00 00 02 E1 03
+            29 01 00 00 00 00 02 E2 99
+            29 01 00 00 00 00 02 E3 03
+            29 01 00 00 00 00 02 E4 B7
+            29 01 00 00 00 00 02 E5 03
+            29 01 00 00 00 00 02 E6 CF
+            29 01 00 00 00 00 02 E7 03
+            29 01 00 00 00 00 02 E8 D8
+            29 01 00 00 00 00 02 E9 03
+            29 01 00 00 00 00 02 EA E6
+            29 01 00 00 00 00 02 EB 03
+            29 01 00 00 00 00 02 EC E8
+            29 01 00 00 00 00 02 ED 03
+            29 01 00 00 00 00 02 EE EA
+            //Gamma G+ 
+            29 01 00 00 00 00 02 EF 00
+            29 01 00 00 00 00 02 F0 2D
+            29 01 00 00 00 00 02 F1 00
+            29 01 00 00 00 00 02 F2 71
+            29 01 00 00 00 00 02 F3 00
+            29 01 00 00 00 00 02 F4 87
+            29 01 00 00 00 00 02 F5 00
+            29 01 00 00 00 00 02 F6 A1
+            29 01 00 00 00 00 02 F7 00
+            29 01 00 00 00 00 02 F8 B2
+            29 01 00 00 00 00 02 F9 00
+            29 01 00 00 00 00 02 FA CB
+            29 01 00 00 00 00 02 FB 01
+            //Page Select CMD1 
+            29 01 00 00 00 00 02 FF 00
+            //Don't reload MTP 
+            29 01 00 00 00 00 02 FB 01
+            //Page Select CMD2,Page1 
+            29 01 00 00 00 00 02 FF 02
+            //Don't reload MTP 
+            29 01 00 00 00 00 02 FB 01
+            29 01 00 00 00 00 02 00 00
+            29 01 00 00 00 00 02 01 D7
+            29 01 00 00 00 00 02 02 00
+            29 01 00 00 00 00 02 03 E6
+            29 01 00 00 00 00 02 04 00
+            29 01 00 00 00 00 02 05 F9
+            29 01 00 00 00 00 02 06 01
+            29 01 00 00 00 00 02 07 2C
+            29 01 00 00 00 00 02 08 01
+            29 01 00 00 00 00 02 09 4F
+            29 01 00 00 00 00 02 0A 01
+            29 01 00 00 00 00 02 0B 86
+            29 01 00 00 00 00 02 0C 01
+            29 01 00 00 00 00 02 0D B3
+            29 01 00 00 00 00 02 0E 01
+            29 01 00 00 00 00 02 0F FC
+            29 01 00 00 00 00 02 10 02
+            29 01 00 00 00 00 02 11 2E
+            29 01 00 00 00 00 02 12 02
+            29 01 00 00 00 00 02 13 2E
+            29 01 00 00 00 00 02 14 02
+            29 01 00 00 00 00 02 15 5D
+            29 01 00 00 00 00 02 16 02
+            29 01 00 00 00 00 02 17 92
+            29 01 00 00 00 00 02 18 02
+            29 01 00 00 00 00 02 19 B2
+            29 01 00 00 00 00 02 1A 02
+            29 01 00 00 00 00 02 1B DC
+            29 01 00 00 00 00 02 1C 02
+            29 01 00 00 00 00 02 1D FF
+            29 01 00 00 00 00 02 1E 03
+            29 01 00 00 00 00 02 1F 27
+            29 01 00 00 00 00 02 20 03
+            29 01 00 00 00 00 02 21 3B
+            29 01 00 00 00 00 02 22 03
+            29 01 00 00 00 00 02 23 45
+            29 01 00 00 00 00 02 24 03
+            29 01 00 00 00 00 02 25 63
+            29 01 00 00 00 00 02 26 03
+            29 01 00 00 00 00 02 27 77
+            29 01 00 00 00 00 02 28 03
+            29 01 00 00 00 00 02 29 95
+            29 01 00 00 00 00 02 2A 03
+            29 01 00 00 00 00 02 2B 9E
+            29 01 00 00 00 00 01 2C
+            29 01 00 00 00 00 02 2D 03
+            29 01 00 00 00 00 01 2E
+            29 01 00 00 00 00 02 2F A4
+            29 01 00 00 00 00 02 30 03
+            29 01 00 00 00 00 02 31 BC
+            //Gamma G- 
+            29 01 00 00 00 00 02 32 00
+            29 01 00 00 00 00 02 33 B2
+            29 01 00 00 00 00 02 34 00
+            29 01 00 00 00 00 02 35 F1
+            29 01 00 00 00 00 02 36 00
+            29 01 00 00 00 00 02 37 FC
+            29 01 00 00 00 00 02 38 01
+            29 01 00 00 00 00 02 39 13
+            29 01 00 00 00 00 02 3A 01
+            29 01 00 00 00 00 02 3B 21
+            29 01 00 00 00 00 01 3C
+            29 01 00 00 00 00 02 3D 01
+            29 01 00 00 00 00 01 3E
+            29 01 00 00 00 00 02 3F 37
+            29 01 00 00 00 00 02 40 01
+            29 01 00 00 00 00 02 41 44
+            29 01 00 00 00 00 02 42 01
+            29 01 00 00 00 00 02 43 51
+            29 01 00 00 00 00 02 44 01
+            29 01 00 00 00 00 02 45 65
+            29 01 00 00 00 00 02 46 01
+            29 01 00 00 00 00 02 47 8A
+            29 01 00 00 00 00 02 48 01
+            29 01 00 00 00 00 02 49 A8
+            29 01 00 00 00 00 02 4A 01
+            29 01 00 00 00 00 02 4B E2
+            29 01 00 00 00 00 02 4C 02
+            29 01 00 00 00 00 02 4D 0B
+            29 01 00 00 00 00 02 4E 02
+            29 01 00 00 00 00 02 4F 48
+            29 01 00 00 00 00 02 50 02
+            29 01 00 00 00 00 02 51 7E
+            29 01 00 00 00 00 02 52 02
+            29 01 00 00 00 00 02 53 7E
+            29 01 00 00 00 00 02 54 02
+            29 01 00 00 00 00 02 55 AD
+            29 01 00 00 00 00 02 56 02
+            29 01 00 00 00 00 01 57
+            29 01 00 00 00 00 02 58 E4
+            29 01 00 00 00 00 02 59 03
+            29 01 00 00 00 00 02 5A 06
+            29 01 00 00 00 00 02 5B 03
+            29 01 00 00 00 00 02 5C 35
+            29 01 00 00 00 00 02 5D 03
+            29 01 00 00 00 00 02 5E 59
+            29 01 00 00 00 00 02 5F 03
+            29 01 00 00 00 00 02 60 80
+            29 01 00 00 00 00 02 61 03
+            29 01 00 00 00 00 02 62 93
+            29 01 00 00 00 00 02 63 03
+            29 01 00 00 00 00 02 64 A1
+            29 01 00 00 00 00 02 65 03
+            29 01 00 00 00 00 02 66 C0
+            29 01 00 00 00 00 02 67 03
+            29 01 00 00 00 00 02 68 D4
+            29 01 00 00 00 00 02 69 03
+            29 01 00 00 00 00 02 6A DD
+            29 01 00 00 00 00 02 6B 03
+            29 01 00 00 00 00 02 6C E3
+            29 01 00 00 00 00 02 6D 03
+            29 01 00 00 00 00 02 6E E7
+            29 01 00 00 00 00 02 6F 03
+            29 01 00 00 00 00 02 70 EA
+            //Gamma B+ 
+            29 01 00 00 00 00 02 71 00
+            29 01 00 00 00 00 02 72 5F
+            29 01 00 00 00 00 02 73 00
+            29 01 00 00 00 00 02 74 97
+            29 01 00 00 00 00 02 75 00
+            29 01 00 00 00 00 02 76 A1
+            29 01 00 00 00 00 02 77 00
+            29 01 00 00 00 00 02 78 B6
+            29 01 00 00 00 00 02 79 00
+            29 01 00 00 00 00 02 7A C6
+            29 01 00 00 00 00 02 7B 00
+            29 01 00 00 00 00 02 7C D9
+            29 01 00 00 00 00 02 7D 00
+            29 01 00 00 00 00 02 7E E2
+            29 01 00 00 00 00 02 7F 00
+            29 01 00 00 00 00 02 80 F1
+            29 01 00 00 00 00 02 81 00
+            29 01 00 00 00 00 02 82 FD
+            29 01 00 00 00 00 02 83 01
+            29 01 00 00 00 00 02 84 26
+            29 01 00 00 00 00 02 85 01
+            29 01 00 00 00 00 02 86 45
+            29 01 00 00 00 00 02 87 01
+            29 01 00 00 00 00 02 88 83
+            29 01 00 00 00 00 02 89 01
+            29 01 00 00 00 00 02 8A AF
+            29 01 00 00 00 00 02 8B 01
+            29 01 00 00 00 00 02 8C F7
+            29 01 00 00 00 00 02 8D 02
+            29 01 00 00 00 00 02 8E 21
+            29 01 00 00 00 00 02 8F 02
+            29 01 00 00 00 00 02 90 21
+            29 01 00 00 00 00 02 91 02
+            29 01 00 00 00 00 02 92 5A
+            29 01 00 00 00 00 02 93 02
+            29 01 00 00 00 00 02 94 90
+            29 01 00 00 00 00 02 95 02
+            29 01 00 00 00 00 02 96 B1
+            29 01 00 00 00 00 02 97 02
+            29 01 00 00 00 00 02 98 DB
+            29 01 00 00 00 00 02 99 02
+            29 01 00 00 00 00 02 9A F7
+            29 01 00 00 00 00 02 9B 03
+            29 01 00 00 00 00 02 9C 1E
+            29 01 00 00 00 00 02 9D 03
+            29 01 00 00 00 00 02 9E 29
+            29 01 00 00 00 00 02 9F 03
+            29 01 00 00 00 00 02 A0 37
+            29 01 00 00 00 00 01 A1
+            29 01 00 00 00 00 02 A2 03
+            29 01 00 00 00 00 02 A3 56
+            29 01 00 00 00 00 02 A4 03
+            29 01 00 00 00 00 02 A5 79
+            29 01 00 00 00 00 02 A6 03
+            29 01 00 00 00 00 02 A7 99
+            29 01 00 00 00 00 01 A8
+            29 01 00 00 00 00 02 A9 03
+            29 01 00 00 00 00 02 AA A7
+            29 01 00 00 00 00 02 AB 03
+            29 01 00 00 00 00 02 AC B9
+            29 01 00 00 00 00 02 AD 03
+            29 01 00 00 00 00 02 AE BD
+            //Gamma B- 
+            29 01 00 00 00 00 02 AF 00
+            29 01 00 00 00 00 02 B0 D9
+            29 01 00 00 00 00 02 B1 01
+            29 01 00 00 00 00 02 B2 0C
+            29 01 00 00 00 00 02 B3 01
+            29 01 00 00 00 00 02 B4 13
+            29 01 00 00 00 00 02 B5 01
+            29 01 00 00 00 00 02 B6 26
+            29 01 00 00 00 00 02 B7 01
+            29 01 00 00 00 00 02 B8 33
+            29 01 00 00 00 00 02 B9 01
+            29 01 00 00 00 00 02 BA 45
+            29 01 00 00 00 00 02 BB 01
+            29 01 00 00 00 00 02 BC 50
+            29 01 00 00 00 00 02 BD 01
+            29 01 00 00 00 00 02 BE 5D
+            29 01 00 00 00 00 02 BF 01
+            29 01 00 00 00 00 02 C0 69
+            29 01 00 00 00 00 02 C1 01
+            29 01 00 00 00 00 02 C2 8E
+            29 01 00 00 00 00 02 C3 01
+            29 01 00 00 00 00 02 C4 A8
+            29 01 00 00 00 00 02 C5 01
+            29 01 00 00 00 00 02 C6 DC
+            29 01 00 00 00 00 02 C7 02
+            29 01 00 00 00 00 02 C8 04
+            29 01 00 00 00 00 02 C9 02
+            29 01 00 00 00 00 02 CA 43
+            29 01 00 00 00 00 02 CB 02
+            29 01 00 00 00 00 02 CC 87
+            29 01 00 00 00 00 02 CD 02
+            29 01 00 00 00 00 02 CE 87
+            29 01 00 00 00 00 02 CF 02
+            29 01 00 00 00 00 02 D0 AA
+            29 01 00 00 00 00 02 D1 02
+            29 01 00 00 00 00 02 D2 E4
+            29 01 00 00 00 00 02 D3 03
+            29 01 00 00 00 00 02 D4 05
+            29 01 00 00 00 00 02 D5 03
+            29 01 00 00 00 00 02 D6 2E
+            29 01 00 00 00 00 02 D7 03
+            29 01 00 00 00 00 02 D8 51
+            29 01 00 00 00 00 02 D9 03
+            29 01 00 00 00 00 02 DA 76
+            29 01 00 00 00 00 02 DB 03
+            29 01 00 00 00 00 02 DC 83
+            29 01 00 00 00 00 02 DD 03
+            29 01 00 00 00 00 02 DE 8F
+            29 01 00 00 00 00 02 DF 03
+            29 01 00 00 00 00 02 E0 B2
+            29 01 00 00 00 00 02 E1 03
+            29 01 00 00 00 00 02 E2 DA
+            29 01 00 00 00 00 02 E3 03
+            29 01 00 00 00 00 02 E4 E4
+            29 01 00 00 00 00 02 E5 03
+            29 01 00 00 00 00 02 E6 E6
+            29 01 00 00 00 00 02 E7 03
+            29 01 00 00 00 00 02 E8 E8
+            29 01 00 00 00 00 02 E9 03
+            29 01 00 00 00 00 02 EA EA
+            //Page select (CMD1) 
+            29 01 00 00 00 00 02 FF 00
+            29 01 00 00 00 00 02 FB 01
+            //gamma end
+			29 01 00 00 00 00 02 ff 04
+			29 01 00 00 00 00 02 fb 01
+			29 01 00 00 00 00 02 ff 00
+			29 01 00 00 00 00 02 fb 01
+            //CMD2 Page 4 -Display Register
+            29 01 00 00 00 00 02 FF 05
+            29 01 00 00 00 00 02 FB 01
+            29 01 00 00 00 00 02 01 00
+            29 01 00 00 00 00 02 02 7F
+            29 01 00 00 00 00 02 03 7F
+            29 01 00 00 00 00 02 04 7F
+            29 01 00 00 00 00 02 05 00
+            29 01 00 00 00 00 02 06 00
+            29 01 00 00 00 00 02 07 00
+            29 01 00 00 00 00 02 08 00
+            29 01 00 00 00 00 02 09 02
+            29 01 00 00 00 00 02 0A 01
+            29 01 00 00 00 00 02 0B 75
+            29 01 00 00 00 00 02 0D 0E
+            29 01 00 00 00 00 02 0E 1A
+            29 01 00 00 00 00 02 0F 09
+            29 01 00 00 00 00 02 10 80
+            29 01 00 00 00 00 02 14 04
+            29 01 00 00 00 00 02 16 08
+            29 01 00 00 00 00 02 17 00
+            29 01 00 00 00 00 02 19 1F
+            29 01 00 00 00 00 02 1A 00
+            29 01 00 00 00 00 02 1B FC
+            29 01 00 00 00 00 02 1C 00
+            29 01 00 00 00 00 02 1D 00
+            29 01 00 00 00 00 02 1E 00
+            29 01 00 00 00 00 02 1F 80
+            29 01 00 00 00 00 02 21 00
+            29 01 00 00 00 00 02 24 45
+            29 01 00 00 00 00 02 27 05
+            29 01 00 00 00 00 02 28 00
+            29 01 00 00 00 00 02 29 52
+            29 01 00 00 00 00 02 2A A9
+            29 01 00 00 00 00 02 2D 02
+            29 01 00 00 00 00 02 2F 00
+            29 01 00 00 00 00 02 30 30
+            29 01 00 00 00 00 02 35 16
+            29 01 00 00 00 00 02 36 01
+            29 01 00 00 00 00 02 37 00
+            29 01 00 00 00 00 02 38 02
+            29 01 00 00 00 00 02 39 01
+            29 01 00 00 00 00 02 3F 00
+            29 01 00 00 00 00 02 40 00
+            29 01 00 00 00 00 02 41 00
+            29 01 00 00 00 00 02 42 00
+            29 01 00 00 00 00 02 4A 01
+            29 01 00 00 00 00 02 6F 25
+            29 01 00 00 00 00 02 7E E9
+            29 01 00 00 00 00 02 82 18
+            29 01 00 00 00 00 02 89 C1
+            29 01 00 00 00 00 02 A4 05
+            29 01 00 00 00 00 02 BB 06
+            29 01 00 00 00 00 02 BC 02
+            29 01 00 00 00 00 02 FF 00
+            29 01 00 00 00 00 02 FB 01
+            //CMD1
+            29 01 00 00 00 00 02 FF 00 
+            29 01 00 00 00 00 02 fb 01			
+            29 01 00 00 00 00 02 BA 03
+            15 01 00 00 00 00 02 55 00
+            39 01 00 00 00 00 02 53 24
+            39 01 00 00 00 00 02 35 20
+            39 01 00 00 96 00 02 11 00
+            39 01 00 00 00 00 02 29 00
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 32 00 02 28 00
+					39 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [32 16 0e 00 38 3a 12 18 10 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x4>;
+		qcom,mdss-dsi-t-clk-pre = <0x17>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 1500>, <0 30>, <1 23000>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne504h/dsi-success-panel-hx8392b-720p-video.dtsi b/arch/arm/boot/dts/zte/ne504h/dsi-success-panel-hx8392b-720p-video.dtsi
new file mode 100755
index 0000000..a7e42de
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne504h/dsi-success-panel-hx8392b-720p-video.dtsi
@@ -0,0 +1,98 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_success_hx8392b_720_vid: qcom,mdss_dsi_success_hx8392b_720p_video {
+		qcom,mdss-dsi-panel-name = "success hx8392b 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <76>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <76>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <8>;
+		qcom,mdss-dsi-v-front-porch = <17>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [
+            39 01 00 00 00 00 04 B9 FF 83 92
+            39 01 00 00 00 00 02 35 00
+            39 01 00 00 00 00 18 B1 4D 45 45 14 3B 31 55 12 ED B3 B1 50 0F 43 F0 C0 C0 C0 C0 00 02 16 19
+            39 01 00 00 00 00 13 B2 00 00 C8 08 0F 72 1B 08 0F 1B 1B 02 02 30 04 00 00 48
+            39 01 00 00 00 00 29 B4 00 FF 20 24 00 3F 00 3F 05 00 02 03 03 0C 02 03 04 01 00 07 36 20 24 00 3F 00 3F 05 00 02 03 00 0C 02 03 04 01 00 07 36
+            39 01 00 00 00 00 03 B6 74 74
+            39 01 00 00 00 00 2b E0 00 16 1A 2B 2F 3F 26 3B 08 0D 0E 12 15 13 13 12 13 00 15 1A 2A 2F 3F 25 3C 08 0D 0F 12 15 13 14 10 14 0B 17 09 12 0C 18 08 11
+            39 01 00 00 00 00 02 BA 03
+            39 01 00 00 00 00 02 CC 08
+            39 01 00 00 00 00 29 D3 00 00 01 00 01 10 28 08 32 30 05 00 05 32 13 C0 00 00 32 10 08 00 00 11 05 05 01 04 00 27 00 00 00 0A 00 11 00 00 00 00
+            39 01 00 00 00 00 37 D5 21 21 1F 1F 1E 1E 1C 1C 1D 1D 19 19 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 2F 2F 30 30 31 31
+            39 01 00 00 00 00 37 D6 21 21 1F 1F 1E 1E 1D 1D 1C 1C 19 19 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 2F 2F 30 30 31 31
+            39 01 00 00 00 00 02 BD 00
+            39 01 00 00 00 00 1d D8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8
+            39 01 00 00 00 00 02 BD 01
+            39 01 00 00 00 00 2b D8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 82 C0 00 00 00 00 A8 82 C0 00 00 00 00 A8 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+            39 01 00 00 00 00 02 BD 02
+            39 01 00 00 00 00 0f D8 82 E0 00 00 00 00 FC 82 E0 00 00 00 00 FC
+            39 01 00 00 00 00 02 BD 00
+            39 01 00 00 00 00 04 D9 00 01 02
+            39 01 00 00 96 00 02 11 00
+            //39 01 00 00 00 00 03 CB 0C 6E
+            39 01 00 00 78 00 02 29 00
+            29 01 00 00 00 00 02 51 61
+            39 01 00 00 00 00 02 55 01
+            39 01 00 00 00 00 02 53 24
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 32 00 02 28 00
+					39 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [37 1c 12 00 40 44 16 1e 17 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x4>;
+		qcom,mdss-dsi-t-clk-pre = <0x18>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_dcs";
+		qcom,mdss-dsi-reset-sequence = <1 4>, <0 1>, <1 150>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/ne504h/msm8226-720p-mtp.dtsi b/arch/arm/boot/dts/zte/ne504h/msm8226-720p-mtp.dtsi
new file mode 100755
index 0000000..50a9c32
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne504h/msm8226-720p-mtp.dtsi
@@ -0,0 +1,590 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "msm8226-camera-sensor-mtp.dtsi"
+
+&soc {
+	serial@f991f000 {
+		status = "ok";
+	};
+	i2c@f9923000 { /* BLSP1 QUP3 */
+		ams-sensor_i2c_adapter@39 {
+			status = "okay";
+			reg = <0x39>;
+			compatible = "ams,ams-sensor";
+			interrupt-parent = <&msmgpio>;
+			ams,irq-gpio = <&msmgpio 49 0x00>;
+		};
+	};
+
+	i2c@f9927000 { /* BLSP1 QUP5 */
+		/*ZTEMT Added by luochangyang, 2014/01/07*/
+		goodix_gt915@5d {
+			compatible = "goodix,gt915_i2c";
+			reg = <0x5d>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2008>;
+			vdd_ana-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			goodix,reset-gpio = <&msmgpio 16 0x00>;
+			goodix,irq-gpio = <&msmgpio 17 0x00>;
+		};
+		/*ZTEMT END*/
+/*
+		synaptics@20 {
+			compatible = "synaptics,rmi4";
+			reg = <0x20>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2008>;
+			vdd-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 16 0x00>;
+			synaptics,irq-gpio = <&msmgpio 17 0x2008>;
+			synaptics,button-map = <139 102 158>;
+			synaptics,fw-image-name = "PR1468813.img";
+			synaptics,i2c-pull-up;
+			synaptics,power-down;
+			synaptics,disable-gpios;
+		};
+*/
+		focaltech@38 {
+			compatible = "focaltech,5x06";
+			reg = <0x38>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2>;
+			vdd-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			focaltech,name = "ft5x06";
+			focaltech,family-id = <0x14>;
+			focaltech,fw-vkey-support;
+			focaltech,ignore-id-check;
+			focaltech,reset-gpio = <&msmgpio 16 0x00>;
+			focaltech,irq-gpio = <&msmgpio 17 0x00>;
+			focaltech,display-coords = <0 0 720 1280>;
+			focaltech,panel-coords = <0 0 1080 2000>;
+			focaltech,button-map= <139 102 158>;
+			focaltech,no-force-update;
+			focaltech,i2c-pull-up;
+			focaltech,group-id = <1>;
+			focaltech,hard-reset-delay-ms = <20>;
+			focaltech,soft-reset-delay-ms = <150>;
+			focaltech,num-max-touches = <5>;
+			focaltech,fw-name = "ft_8226_qrd_1080p_fw.bin";
+			focaltech,fw-delay-aa-ms = <50>;
+			focaltech,fw-delay-55-ms = <30>;
+			focaltech,fw-upgrade-id1 = <0x79>;
+			focaltech,fw-upgrade-id2 = <0x03>;
+			focaltech,fw-delay-readid-ms = <10>;
+			focaltech,fw-delay-era-flsh-ms = <2000>;
+		};
+	};
+
+	i2c@f9925000 { /* BLSP1 QUP3 */
+		nfc-nci@0e {
+			compatible = "qcom,nfc-nci";
+			reg = <0x0e>;
+			qcom,irq-gpio = <&msmgpio 21 0x00>;
+			qcom,dis-gpio = <&msmgpio 20 0x00>;
+			qcom,clk-src = "BBCLK2";
+			qcom,clk-en-gpio = <&msmgpio 0 0x00>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <21 0>;
+			qcom,clk-gpio = <&pm8226_gpios 3 0>;
+		};
+	};
+	gpio_keys {
+		compatible = "gpio-keys";
+		input-name = "gpio-keys";
+
+		camera_focus {
+			label = "camera_focus";
+			gpios = <&msmgpio 108 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x210>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		camera_snapshot {
+			label = "camera_snapshot";
+			gpios = <&msmgpio 107 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x2fe>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		vol_up {
+			label = "volume_up";
+			gpios = <&msmgpio 106 0x1>;
+			linux,input-type = <1>;
+			linux,code = <115>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+		vol_dn {
+			label = "volume_dn";
+			gpios = <&msmgpio 109 0x1>;
+			linux,input-type = <1>;
+			linux,code = <114>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+	};
+
+	spi@f9923000 {
+		ethernet-switch@3 {
+			compatible = "micrel,ks8851";
+			reg = <3>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <115 0x8>;
+			spi-max-frequency = <4800000>;
+			rst-gpio = <&msmgpio 114 0>;
+			vdd-io-supply = <&pm8226_lvs1>;
+			vdd-phy-supply = <&pm8226_lvs1>;
+		};
+	};
+
+	sound {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC4", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCRight Headset Mic",
+			"AMIC5", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCLeft Headset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+
+	sound-9302 {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC3", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Handset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+};
+
+&usb_otg {
+	#address-cells = <0>;
+	interrupt-parent = <&usb_otg>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 134 0
+			1 &intc 0 140 0
+			2 &spmi_bus 0x0 0x0 0x9 0x0>;
+	interrupt-names = "core_irq", "async_irq", "pmic_id_irq";
+
+	qcom,hsusb-otg-mode = <3>;
+	vbus_otg-supply = <&pm8226_chg_otg>;
+};
+
+&sdcc1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "disabled";
+};
+
+&sdhc_1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "ok";
+};
+
+&sdcc2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,xpc;
+	qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50", "SDR104";
+	qcom,current-limit = <600>; #address-cells = <0>; interrupt-parent = <&sdcc2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 220 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "core_irq", "bam_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "disabled";
+};
+
+&sdhc_2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+
+	#address-cells = <0>;
+	interrupt-parent = <&sdhc_2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 221 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "hc_irq", "pwr_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "ok";
+};
+
+&spmi_bus {
+	qcom,pm8226@0 {
+		qcom,leds@a100 {
+			status = "okay";
+			qcom,led_mpp_2 {
+				label = "mpp";
+				linux,name = "button-backlight";
+				linux,default-trigger = "none";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "manual";
+				qcom,source-sel = <1>;
+				qcom,mode-ctrl = <0x60>;
+			};
+		};
+
+		qcom,leds@a300 {
+			status = "okay";
+			qcom,led_mpp_4 {
+				label = "mpp";
+				linux,name = "green";
+				linux,default-trigger = "battery-full";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,source-sel = <8>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,pwm-channel = <0>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+
+		qcom,leds@a500 {
+			status = "okay";
+			qcom,led_mpp_6 {
+				label = "mpp";
+				linux,name = "red";
+				linux,default-trigger = "battery-charging";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,source-sel = <10>;
+				qcom,pwm-channel = <5>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+	};
+
+	qcom,pm8226@1 {
+                qcom,leds@d300 {
+                        status = "okay";
+                };
+
+		qcom,leds@d800 {
+			status = "okay";
+			qcom,wled_0 {
+				/*mayu close
+				label = "wled";
+				linux,name = "wled:backlight";
+				linux,default-trigger = "bkl-trigger";
+				qcom,cs-out-en;
+				qcom,op-fdbck = <1>;
+				qcom,default-state = "on";
+				qcom,max-current = <20>;
+				qcom,ctrl-delay-us = <0>;
+				qcom,boost-curr-lim = <3>;
+				qcom,cp-sel = <0>;
+				qcom,switch-freq = <11>;
+				qcom,ovp-val = <0>;
+				qcom,num-strings = <1>;
+				qcom,id = <0>;*/
+			};
+		};
+
+		qcom,vibrator@c000 {
+			status = "okay";
+			qcom,vib-timeout-ms = <15000>;
+			qcom,vib-vtg-level-mV = <3100>;
+		};
+	};
+};
+
+&pm8226_gpios {
+	gpio@c000 { /* GPIO 1 */
+		/* XO_PMIC_CDC_MCLK enable for tapan codec */
+		qcom,mode = <1>;		/* Digital output */
+		qcom,output-type = <0>;	/* CMOS logic */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO*/
+		qcom,vin-sel = <3>;		/* QPNP_PIN_VIN3 */
+		qcom,out-strength = <3>;/* QPNP_PIN_OUT_STRENGTH_HIGH */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;	/* Enable GPIO */
+	};
+
+	gpio@c100 { /* GPIO 2 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <3>;
+		qcom,out-strength = <3>;
+		qcom,src-sel = <2>;
+		qcom,master-en = <1>;
+	};
+
+	gpio@c200 { /* GPIO 3 */
+		qcom,mode = <0>;		/* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO */
+		qcom,vin-sel = <2>;		/* QPNP_PIN_VIN2 */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c300 { /* GPIO 4 */
+	};
+
+	gpio@c400 { /* GPIO 5 */
+	};
+
+	gpio@c500 { /* GPIO 6 */
+	};
+
+	gpio@c600 { /* GPIO 7 */
+	};
+
+	gpio@c700 { /* GPIO 8 */
+	};
+};
+
+&pm8226_mpps {
+	mpp@a000 { /* MPP 1 */
+	};
+
+	mpp@a100 { /* MPP 2 */
+	};
+
+	mpp@a200 { /* MPP 3 */
+	};
+
+	mpp@a300 { /* MPP 4 */
+	};
+
+	mpp@a400 { /* MPP 5 */
+		/* PA_THERM0 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <0>; /* AMUX 5 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+
+	mpp@a500 { /* MPP 6 */
+	};
+
+	mpp@a600 { /* MPP 7 */
+	};
+
+	mpp@a700 { /* MPP 8 */
+		/* PA_THERM1 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <3>; /* AMUX 8 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+};
+
+&pm8226_vadc {
+	chan@14 {
+		label = "pa_therm0";
+		reg = <0x14>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+
+	chan@17 {
+		label = "pa_therm1";
+		reg = <0x17>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+};
+/* Charger
+*
+* CONFIG_ZTEMT_CHARGE
+*/
+/ {
+	mtp_batterydata: qcom,battery-data {
+		qcom,rpull-up-kohm = <100>;
+		qcom,vref-batt-therm = <1800000>;
+
+		/include/ "batterydata-zte-2400mah.dtsi"
+/*
+		/include/ "batterydata-palladium.dtsi"
+		/include/ "batterydata-mtp-3000mah.dtsi"
+*/
+	};
+};
+
+&pm8226_bms {
+	status = "ok";
+	qcom,enable-fcc-learning;
+	qcom,min-fcc-learning-soc = <20>;
+	qcom,min-fcc-ocv-pc = <30>;
+	qcom,min-fcc-learning-samples = <5>;
+	qcom,fcc-resolution = <10>;
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+&pm8226_chg {
+	/*qcom,charging-disabled;*/
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+&slim_msm {
+	tapan_codec {
+		qcom,cdc-micbias1-ext-cap;
+	};
+};
+
+&mdss_mdp {
+	qcom,mdss-pref-prim-intf = "dsi";
+	batfet-supply = <&pm8226_chg_batif>;
+};
+
+&mdss_dsi0 {
+	qcom,dsi-pref-prim-pan = <&dsi_cs_nt35592_720_vid>;
//qcom,dsi-pref-prim-pan = <&dsi_nt35590_720_vid>;
+};
+
+&dsi_nt35590_720_vid {
+	qcom,cont-splash-enabled;
+};
+&dsi_cs_nt35592_720_vid {
+    status = "disabled";
+	qcom,cont-splash-enabled;
+};
+
+&dsi_success_hx8392b_720_vid {
+    status = "disabled";
+	qcom,cont-splash-enabled;
+};
diff --git a/arch/arm/boot/dts/zte/ne504h/msm8226-camera-sensor-mtp.dtsi b/arch/arm/boot/dts/zte/ne504h/msm8226-camera-sensor-mtp.dtsi
new file mode 100755
index 0000000..696a88d
--- /dev/null
+++ b/arch/arm/boot/dts/zte/ne504h/msm8226-camera-sensor-mtp.dtsi
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+
+	led_flash0: qcom,camera-led-flash {
+		cell-index = <0>;
+		compatible = "qcom,camera-led-flash";
+		qcom,flash-type = <1>;
+		qcom,flash-source = <&pm8226_flash0 &pm8226_flash1>;
+		qcom,torch-source = <&pm8226_torch>;
+	};
+};
+
+&cci {
+
+	actuator0: qcom,actuator@6e {
+		cell-index = <3>;
+		reg = <0x6c>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	actuator1: qcom,actuator@18 {
+		cell-index = <1>;
+		reg = <0x18>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@20 {
+		compatible = "qcom,imx135";
+		reg = <0x20>;
+		qcom,slave-id = <0x20 0x0016 0x0135>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator1>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "imx135";
+		cam_vdig-supply = <&pm8226_l5>;
+		/*cam_vana-supply = <&pm8226_l19>;*/
+		cam_vio-supply = <&pm8226_l28>;
+		cam_vaf-supply = <&pm8226_l19>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", /*"cam_vana",*/
+							 "cam_vaf";
+		qcom,cam-vreg-type = <0 1  0>;
+		qcom,cam-vreg-min-voltage = <1050000 1800000  2850000>;
+		qcom,cam-vreg-max-voltage = <1050000 1800000  2850000>;
+		qcom,cam-vreg-op-mode = <200000 0  100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,gpio-avdd-enable = <&msmgpio 14 0>;		/*tanyijun add for back camera avdd enable */	
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1f>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6c {
+		compatible = "qcom,ov5648";
+		reg = <0x6c>;
+		qcom,slave-id = <0x6c 0x300a 0x5648>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <90>;
+		qcom,sensor-name = "ov5648";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1500000 0 2800000>;
+		qcom,cam-vreg-max-voltage = <1500000 0 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+				<&msmgpio 28 0>,
+				<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET",
+				"CAM_STANDBY";
+		qcom,gpio-avdd-enable = <&msmgpio 12 0>;		/*tanyijun add for back camera avdd enable */				
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@6f {
+		compatible = "qcom,ov8825";
+		reg = <0x6f>;
+		qcom,slave-id = <0x6c 0x300a 0x8825>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov8825";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+							 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1f>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@6d {
+		compatible = "qcom,ov9724";
+		reg = <0x6d>;
+		qcom,slave-id = <0x20 0x0 0x9724>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov9724";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+				<&msmgpio 28 0>,
+				<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET",
+				"CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+	qcom,camera@0 {
+		cell-index = <0>;
+		compatible = "qcom,camera";
+		reg = <0x0>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+			 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@1 {
+		cell-index = <1>;
+		compatible = "qcom,camera";
+		reg = <0x1>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 28 0>,
+			<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/batterydata-zte-2000mah.dtsi b/arch/arm/boot/dts/zte/nx404h/batterydata-zte-2000mah.dtsi
new file mode 100644
index 0000000..b796672
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/batterydata-zte-2000mah.dtsi
@@ -0,0 +1,110 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+qcom,zte-2000mah {
+	qcom,fcc-mah = <2000>;
+	qcom,default-rbatt-mohm = <180>;
+	qcom,max-voltage-uv = <4350000>;
+	qcom,rbatt-capacitive-mohm = <50>;
+	qcom,v-cutoff-uv = <3400000>;
+	qcom,chg-term-ua = <100000>;
+	qcom,batt-id-kohm = <300>;
+
+	qcom,fcc-temp-lut {
+		qcom,lut-col-legend = <(-20) (-10) 0 25 40 45 50 60>;
+		qcom,lut-data = <2036 2042 2041 2046 2047 2040 2038 2039>;
+	};
+
+	qcom,pc-temp-ocv-lut {
+		qcom,lut-col-legend = <(-20) (-10) 0 25 40 45 50 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>,
+				<0>;
+		qcom,lut-data = <4334  4333  4332  4326  4320  4318  4316  4312>, 
+							<4220  4240  4248  4252  4249  4248  4247  4244>, 
+							<4147  4177  4188  4194  4192  4191  4191  4188>, 
+							<4082  4117  4132  4141  4138  4138  4138  4135>, 
+							<4022  4061  4078  4090  4088  4087  4087  4084>, 
+							<3968  4006  4024  4041  4040  4040  4040  4037>, 
+							<3920  3957  3973  3995  3996  3996  3996  3994>, 
+							<3876  3914  3928  3950  3953  3954  3955  3953>, 
+							<3839  3877  3891  3905  3909  3911  3912  3910>, 
+							<3809  3844  3858  3869  3870  3871  3872  3870>, 
+							<3783  3815  3830  3841  3842  3842  3843  3841>, 
+							<3762  3791  3806  3818  3819  3820  3820  3818>, 
+							<3742  3772  3786  3799  3801  3801  3801  3800>, 
+							<3724  3755  3770  3782  3784  3785  3785  3782>, 
+							<3706  3739  3758  3766  3764  3765  3764  3760>, 
+							<3687  3721  3743  3747  3741  3740  3737  3730>, 
+							<3666  3699  3723  3726  3720  3718  3716  3709>, 
+							<3646  3680  3700  3706  3700  3699  3696  3689>, 
+							<3626  3665  3679  3685  3680  3680  3677  3670>, 
+							<3610  3653  3665  3674  3671  3670  3668  3662>, 
+							<3599  3645  3659  3671  3669  3667  3665  3659>, 
+							<3587  3635  3651  3667  3665  3664  3662  3655>, 
+							<3571  3622  3642  3660  3659  3659  3656  3649>, 
+							<3552  3606  3629  3649  3648  3649  3647  3637>, 
+							<3527  3584  3610  3626  3622  3627  3624  3610>, 
+							<3497  3551  3578  3586  3580  3589  3585  3568>, 
+							<3457  3504  3527  3532  3527  3539  3535  3516>, 
+							<3400  3436  3459  3464  3458  3475  3471  3449>, 
+							<3323  3341  3366  3371  3365  3390  3386  3360>, 
+							<3201  3206  3230  3229  3222  3262  3259  3228>, 
+							<3000  3000  3000  3000  3000  3000  3000  3000>;
+			};
+
+	qcom,rbatt-sf-lut {
+		qcom,lut-col-legend = <(-20) (-10) 0 25 40 45 50 60>;
+		qcom,lut-row-legend = <100 95 90 85 80>,
+				<75 70 65 60 55>,
+				<50 45 40 35 30>,
+				<25 20 16 13 11>,
+				<10 9 8 7 6>,
+				<5 4 3 2 1>;
+		qcom,lut-data = <1095  453  237  100  85  83  82  82>, 
+							<1095  453  237  100  85  83  82  82>, 
+							<1097  458  242  102  87  85  83  82>, 
+							<1081  458  246  106  90  87  85  84>, 
+							<1067  457  247  111  92  89  86  85>, 
+							<1054  452  243  116  95  92  89  87>, 
+							<1048  447  238  120  99  95  92  90>, 
+							<1046  447  235  117  102  98  95  92>, 
+							<1054  448  235  107  96  95  93  91>, 
+							<1071  453  236  102  88  87  85  84>, 
+							<1093  457  238  103  88  85  83  83>, 
+							<1124  465  243  104  88  87  85  84>, 
+							<1158  478  248  107  91  88  86  85>, 
+							<1205  493  255  110  93  90  88  86>, 
+							<1262  513  265  110  92  90  88  86>, 
+							<1360  538  276  106  88  86  85  83>, 
+							<1532  574  283  105  88  86  85  84>, 
+							<1652  608  286  106  89  87  85  84>, 
+							<1608  615  283  105  88  86  85  84>, 
+							<1290  560  267  103  88  86  84  84>, 
+							<1425  583  275  106  89  86  85  84>, 
+							<1594  611  285  108  90  87  85  85>, 
+							<1843  647  300  110  91  88  86  86>, 
+							<2189  698  318  111  92  89  87  86>, 
+							<2701  773  342  111  90  88  86  85>, 
+							<3525  891  372  111  90  88  86  85>, 
+							<4989  1150  421  113  92  88  87  86>, 
+							<8087  2096  519  119  94  91  89  88>, 
+							<16690  5066  815  130  101  95  93  93>, 
+							<46764  18528  3096  174  141  116  116  136>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi
new file mode 100755
index 0000000..261f405
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-1080p-video.dtsi
@@ -0,0 +1,82 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_r63311_1080_vid: qcom,mdss_dsi_r63311_1080p_video {
+		qcom,mdss-dsi-panel-name = "r63311 1080p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <1080>;
+		qcom,mdss-dsi-panel-height = <1920>;
+		qcom,mdss-dsi-h-front-porch = <100>;
+		qcom,mdss-dsi-h-back-porch = <60>;
+		qcom,mdss-dsi-h-pulse-width = <12>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <4>;
+		qcom,mdss-dsi-v-front-porch = <4>;
+		qcom,mdss-dsi-v-pulse-width = <2>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [23 01 00 00 00 00 02 b0 04
+					05 01 00 00 00 00 02 00 00
+					05 01 00 00 00 00 02 00 00
+					23 01 00 00 00 00 02 d6 01
+					29 01 00 00 00 00 08
+						ce 00 01 88 c1 00
+						1e 04
+					29 01 00 00 00 00 21 ca
+						00 80 80 80 80 80 80 80 08 20
+						80 80 0a 4a 37 a0 55 f8 0c 0c
+						20 10 3f 3f 00 00 10 10 3f 3f
+						3f 3f
+					05 01 00 00 00 00 02 29 00
+					05 01 00 00 78 00 02 11 00];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 02 28 00
+					05 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [2f 36 24 00 66 6a 2a 3a 2d 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x03>;
+		qcom,mdss-dsi-t-clk-pre = <0x22>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-dsi-reset-sequence = <0 55>, <1 12>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi
new file mode 100755
index 0000000..f42a5c4
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-cmd.dtsi
@@ -0,0 +1,83 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_r69431_720_cmd: qcom,mdss_dsi_sharp_r69431_720p_cmd {
+		qcom,mdss-dsi-panel-name = "r69431 720p command mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_cmd_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <120>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <20>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <11>;
+		qcom,mdss-dsi-v-front-porch = <10>;
+		qcom,mdss-dsi-v-pulse-width = <5>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [29 01 00 00 00 00 02 b0 04
+					29 01 00 00 00 00 02 d6 01
+					39 01 00 00 78 00 02 11 00
+					29 01 00 00 00 00 02 b3 0c
+					39 01 00 00 00 00 05 2a 00 00 02 cf
+					39 01 00 00 00 00 05 2b 00 00 04 ff
+					39 01 00 00 00 00 02 35 00
+					39 01 00 00 28 00 02 29 00];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 02 28 00
+					05 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-te-pin-select = <1>;
+		qcom,mdss-dsi-wr-mem-start = <0x2c>;
+		qcom,mdss-dsi-wr-mem-continue = <0x3c>;
+		qcom,mdss-dsi-te-dcs-command = <1>;
+		qcom,mdss-dsi-te-check-enable;
+		qcom,mdss-dsi-te-using-te-pin;
+		qcom,mdss-dsi-panel-timings = [66 26 18 00 1a 8f 1e 8c 1a 03 04 a0];
+		qcom,mdss-dsi-t-clk-post = <0x09>;
+		qcom,mdss-dsi-t-clk-pre = <0x1D>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-dsi-reset-sequence = <0 6>, <1 10>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-video.dtsi b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-video.dtsi
new file mode 100755
index 0000000..432e5ea
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/dsi-sharp-panel-r69431-720p-video.dtsi
@@ -0,0 +1,75 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_r69431_720_vid: qcom,mdss_dsi_sharp_r69431_720p_video {
+		qcom,mdss-dsi-panel-name = "r69431 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <120>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <20>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <13>;
+		qcom,mdss-dsi-v-front-porch = <8>;
+		qcom,mdss-dsi-v-pulse-width = <4>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [29 01 00 00 00 00 02 b0 04
+					29 01 00 00 00 00 02 d6 01
+					39 01 00 00 78 00 02 11 00
+					29 01 00 00 00 00 02 b3 1c
+					39 01 00 00 00 00 02 29 00];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 02 28 00
+					05 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [8b 47 14 00 56 56 19 4b 1f 03 04 a0];
+		qcom,mdss-dsi-t-clk-post = <0x08>;
+		qcom,mdss-dsi-t-clk-pre = <0x21>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-dsi-reset-sequence = <0 6>, <1 10>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi b/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi
new file mode 100755
index 0000000..424323d
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-cmd.dtsi
@@ -0,0 +1,195 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_otm1282a_720_cmd: qcom,mdss_dsi_tianma_otm1282a_720p_cmd {
+		qcom,mdss-dsi-panel-name = "otm1282a 720p command mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_cmd_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <120>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <20>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <11>;
+		qcom,mdss-dsi-v-front-porch = <10>;
+		qcom,mdss-dsi-v-pulse-width = <5>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [29 01 00 00 01 00 04 FF 12 82 01
+		23 01 00 00 01 00 02 00 80
+		29 01 00 00 05 00 03 FF 12 82
+		23 01 00 00 05 00 02 00 00
+		23 01 00 00 00 00 02 00 A1
+		23 01 00 00 00 00 02 C1 EE
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 05 C4 04 0C 00 22
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 04 C5 20 09 00
+		23 01 00 00 00 00 02 00 90
+		29 01 00 00 00 00 0b C5 12 D6 D0 D0 8F 95 44 33 30 88
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 0b C5 12 D6 D0 D0 8F 95 44 33 30 88
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 03 D8 2E 2E
+		23 01 00 00 00 00 02 00 00
+		23 01 00 00 00 00 02 D9 86
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 04 A5 0C 02 01
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 0f C0 00 85 00 06 06 00 85 06 06 00 85 00 06 06
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 0d C0 00 00 00 1D 06 15 03 00 00 00 00 00
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 09 C2 84 02 79 14 84 00 4D A2
+		23 01 00 00 00 00 02 00 90
+		29 01 00 00 00 00 10 C2 83 04 01 0B 00 82 04 01 0B 00 81 04 01 0B 00
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 10 C2 84 04 01 0B 00 83 04 01 0B 00 82 04 81 0B 00
+		23 01 00 00 00 00 02 00 B0
+		29 01 00 00 00 00 0b C2 81 04 01 0B 00 84 04 01 0B 00
+		23 01 00 00 00 00 02 00 F8
+		23 01 00 00 00 00 02 C2 02
+		23 01 00 00 00 00 02 00 FA
+		29 01 00 00 00 00 04 C2 00 0C 01
+		23 01 00 00 00 00 02 00 C9
+		23 01 00 00 00 00 02 CB 01
+		23 01 00 00 00 00 02 00 90
+		29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+		23 01 00 00 00 00 02 00 B0
+		29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+		29 01 00 00 00 00 03 44 01 ff
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 03 F5 21 18
+		23 01 00 00 00 00 02 00 D2
+		23 01 00 00 00 00 02 F5 28
+		23 01 00 00 00 00 02 00 91
+		23 01 00 00 00 00 02 B0 9E
+		23 01 00 00 00 00 02 00 90
+		23 01 00 00 00 00 02 A5 00
+		23 01 00 00 00 00 02 00 B3
+		23 01 00 00 00 00 02 C0 33
+		23 01 00 00 00 00 02 00 B4
+		23 01 00 00 00 00 02 C0 40
+		23 01 00 00 00 00 02 00 C0
+		29 01 00 00 00 00 10 CB 04 04 04 04 04 04 04 04 04 04 04 04 04 28 28
+		23 01 00 00 00 00 02 00 D0
+		29 01 00 00 00 00 10 CB 28 28 14 04 18 3C 04 F7 04 14 14 14 14 04 04
+		23 01 00 00 00 00 02 00 E0
+		29 01 00 00 00 00 10 CB 04 04 04 04 04 04 04 04 15 15 07 14 14 00 00
+		23 01 00 00 00 00 02 00 F0
+		29 01 00 00 00 00 0d CB FF FF F3 03 30 30 00 00 00 00 00 00
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 0b CC 01 03 04 05 06 07 08 09 0A 02
+		23 01 00 00 00 00 02 00 B0
+		29 01 00 00 00 00 0b CC 01 0A 09 08 07 06 05 04 03 02
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 10 CD 02 2D 04 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
+		23 01 00 00 00 00 02 00 B0
+		29 01 00 00 00 00 10 CD 2D 2D 2D 14 01 0A 2D 2D 2D 2D 2D 2D 2D 2D 2D
+		23 01 00 00 00 00 02 00 C0
+		29 01 00 00 00 00 0b CD 2D 2D 2D 27 28 29 2A 2B 1D 2D
+		23 01 00 00 00 00 02 00 D0
+		29 01 00 00 00 00 10 CD 2D 03 2D 05 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
+		23 01 00 00 00 00 02 00 E0
+		29 01 00 00 00 00 10 CD 2D 2D 2D 14 01 0A 0C 0B 13 2D 2D 2D 2D 2D 2D
+		23 01 00 00 00 00 02 00 F0
+		29 01 00 00 00 00 0b CD 2D 2D 2D 27 28 29 2A 2B 1D 2D
+		23 01 00 00 00 00 02 00 D0
+		29 01 00 00 00 00 0d C0 00 00 00 1D 06 15 03 00 00 00 00 00
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 09 C3 84 02 79 14 84 00 4D A2
+		23 01 00 00 00 00 02 00 90
+		29 01 00 00 00 00 10 C3 83 04 01 0B 00 82 04 01 0B 00 81 04 01 0B 00
+		23 01 00 00 00 00 02 00 A0
+		29 01 00 00 00 00 10 C3 84 04 01 0B 00 83 04 01 0B 00 82 04 81 0B 00
+		23 01 00 00 00 00 02 00 B0
+		29 01 00 00 00 00 0b C3 81 04 01 0B 00 84 04 01 0B 00
+		23 01 00 00 00 00 02 00 EA
+		29 01 00 00 00 00 04 C3 00 01 11
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E1 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E2 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E3 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E4 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E5 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 19 E6 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+		29 01 00 00 00 00 02 51 00
+		23 01 00 00 00 00 02 53 24
+		23 01 00 00 00 00 02 00 81
+		23 01 00 00 00 00 02 C1 55
+		23 01 00 00 00 00 02 00 80
+		29 01 00 00 00 00 04 FF 00 00 00
+		23 01 00 00 00 00 02 00 00
+		29 01 00 00 00 00 04 FF 00 00 00
+		39 01 00 00 78 00 02 11 00
+		05 01 00 00 00 00 02 13 00
+		39 01 00 00 0a 00 02 29 00
+		];
+		qcom,mdss-dsi-off-command = [39 01 00 00 00 00 02 51 00
+					39 01 00 00 00 00 02 53 00
+					39 01 00 00 32 00 02 22 00
+					39 01 00 00 02 00 02 28 00
+					39 01 00 00 7c 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-te-pin-select = <1>;
+		qcom,mdss-dsi-te-v-sync-rd-ptr-irq-line = <0x2c>;
+		qcom,mdss-dsi-te-v-sync-continue-lines = <0x3c>;
+		qcom,mdss-dsi-te-dcs-command = <1>;
+		qcom,mdss-dsi-te-check-enable;
+		qcom,mdss-dsi-te-using-te-pin;
+		qcom,mdss-dsi-panel-timings = [66 26 18 00 1a 8f 1e 8c 1a 03 04 a0];
+		qcom,mdss-dsi-t-clk-post = <0x09>;
+		qcom,mdss-dsi-t-clk-pre = <0x1D>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-dsi-reset-sequence = <1 20>, <0 1>, <1 20>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-video.dtsi b/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-video.dtsi
new file mode 100755
index 0000000..428b5d8
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/dsi-tianma-panel-otm1282a-720p-video.dtsi
@@ -0,0 +1,191 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_otm1282a_720_vid: qcom,mdss_dsi_tianma_otm1282a_720p_video {
+		qcom,mdss-dsi-panel-name = "tianma 720p video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <720>;
+		qcom,mdss-dsi-panel-height = <1280>;
+		qcom,mdss-dsi-h-front-porch = <120>;
+		qcom,mdss-dsi-h-back-porch = <80>;
+		qcom,mdss-dsi-h-pulse-width = <20>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <13>;
+		qcom,mdss-dsi-v-front-porch = <8>;
+		qcom,mdss-dsi-v-pulse-width = <4>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = <0>;
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-on-command = [29 01 00 00 01 00 04 FF 12 82 01
+					23 01 00 00 01 00 02 00 80
+					29 01 00 00 05 00 03 FF 12 82
+					23 01 00 00 05 00 02 00 00
+					23 01 00 00 00 00 02 1C 30
+					23 01 00 00 00 00 02 00 A1
+					23 01 00 00 00 00 02 C1 EE
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 01 00 05 C4 04 0C 00 22
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 04 C5 20 09 00
+					23 01 00 00 00 00 02 00 90
+					29 01 00 00 00 00 0b C5 12 D6 D0 D0 8F 95 44 33 30 88
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 0b C5 12 D6 D0 D0 8F 95 44 33 30 88
+					23 01 00 00 00 00 02 00 C1
+					29 01 00 00 00 00 02 C5 BA
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 03 D8 2E 2E
+					23 01 00 00 00 00 02 00 00
+					23 01 00 00 00 00 02 D9 90
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 04 A5 0C 02 01
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 0f C0 00 85 00 06 06 00 85 06 06 00 85 00 06 06
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 0d C0 00 00 00 1D 06 15 03 00 00 00 00 00
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 09 C2 84 02 79 14 84 00 4D A2
+					23 01 00 00 00 00 02 00 90
+					29 01 00 00 00 00 10 C2 83 04 01 0B 00 82 04 01 0B 00 81 04 01 0B 00
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 10 C2 84 04 01 0B 00 83 04 01 0B 00 82 04 81 0B 00
+					23 01 00 00 00 00 02 00 B0
+					29 01 00 00 00 00 0b C2 81 04 01 0B 00 84 04 01 0B 00
+					23 01 00 00 00 00 02 00 F8
+					23 01 00 00 00 00 02 C2 02
+					23 01 00 00 00 00 02 00 FA
+					29 01 00 00 00 00 04 C2 00 0C 01
+					23 01 00 00 00 00 02 00 C9
+					23 01 00 00 00 00 02 CB 01
+					23 01 00 00 00 00 02 00 90
+					29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+					23 01 00 00 00 00 02 00 B0
+					29 01 00 00 00 00 10 CB 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 03 F5 21 18
+					23 01 00 00 00 00 02 00 D2
+					23 01 00 00 00 00 02 F5 28
+					23 01 00 00 00 00 02 00 91
+					23 01 00 00 00 00 02 B0 9E
+					23 01 00 00 00 00 02 00 90
+					23 01 00 00 00 00 02 A5 00
+					23 01 00 00 00 00 02 00 B3
+					23 01 00 00 00 00 02 C0 33
+					23 01 00 00 00 00 02 00 B4
+					23 01 00 00 00 00 02 C0 40
+					23 01 00 00 00 00 02 00 C0
+					29 01 00 00 00 00 10 CB 04 04 04 04 04 04 04 04 04 04 04 04 04 28 28
+					23 01 00 00 00 00 02 00 D0
+					29 01 00 00 00 00 10 CB 28 28 14 04 18 3C 04 F7 04 14 14 14 14 04 04
+					23 01 00 00 00 00 02 00 E0
+					29 01 00 00 00 00 10 CB 04 04 04 04 04 04 04 04 15 15 07 14 14 00 00
+					23 01 00 00 00 00 02 00 F0
+					29 01 00 00 00 00 0d CB FF FF F3 03 30 30 00 00 00 00 00 00
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 0b CC 01 03 04 05 06 07 08 09 0A 02
+					23 01 00 00 00 00 02 00 B0
+					29 01 00 00 00 00 0b CC 01 0A 09 08 07 06 05 04 03 02
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 10 CD 02 2D 04 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
+					23 01 00 00 00 00 02 00 B0
+					29 01 00 00 00 00 10 CD 2D 2D 2D 14 01 0A 2D 2D 2D 2D 2D 2D 2D 2D 2D
+					23 01 00 00 00 00 02 00 C0
+					29 01 00 00 00 00 0b CD 2D 2D 2D 27 28 29 2A 2B 1D 2D
+					23 01 00 00 00 00 02 00 D0
+					29 01 00 00 00 00 10 CD 2D 03 2D 05 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D
+					23 01 00 00 00 00 02 00 E0
+					29 01 00 00 00 00 10 CD 2D 2D 2D 14 01 0A 0C 0B 13 2D 2D 2D 2D 2D 2D
+					23 01 00 00 00 00 02 00 F0
+					29 01 00 00 00 00 0b CD 2D 2D 2D 27 28 29 2A 2B 1D 2D
+					23 01 00 00 00 00 02 00 D0
+					29 01 00 00 00 00 0d C0 00 00 00 1D 06 15 03 00 00 00 00 00
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 09 C3 84 02 79 14 84 00 4D A2
+					23 01 00 00 00 00 02 00 90
+					29 01 00 00 00 00 10 C3 83 04 01 0B 00 82 04 01 0B 00 81 04 01 0B 00
+					23 01 00 00 00 00 02 00 A0
+					29 01 00 00 00 00 10 C3 84 04 01 0B 00 83 04 01 0B 00 82 04 81 0B 00
+					23 01 00 00 00 00 02 00 B0
+					29 01 00 00 00 00 0b C3 81 04 01 0B 00 84 04 01 0B 00
+					23 01 00 00 00 00 02 00 EA
+					29 01 00 00 00 00 04 C3 00 01 11
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E1 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E2 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E3 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E4 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E5 2a 2d 3b 47 4f 56 61 70 7a 88 92 99 61 5c 56 4b 39 2a 22 1c 17 12 10 0e
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 19 E6 2a 2d 3b 46 4f 56 60 70 7a 89 93 9a 60 5d 57 4a 39 2a 23 1c 17 12 10 0e
+					39 01 00 00 00 00 02 51 00
+					39 01 00 00 00 00 02 53 24
+					23 01 00 00 00 00 02 00 81
+					23 01 00 00 00 00 02 C1 66
+					23 01 00 00 00 00 02 00 80
+					29 01 00 00 00 00 04 FF 00 00 00
+					23 01 00 00 00 00 02 00 00
+					29 01 00 00 00 00 04 FF 00 00 00
+					39 01 00 00 78 00 02 11 00
+					05 01 00 00 00 00 02 13 00
+					39 01 00 00 0a 00 02 29 00];
+		qcom,mdss-dsi-off-command = [39 01 00 00 00 00 02 51 00
+					39 01 00 00 00 00 02 53 00
+					39 01 00 00 32 00 02 22 00
+					39 01 00 00 02 00 02 28 00
+					39 01 00 00 7c 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = <2>;
+		qcom,mdss-dsi-lane-map = <0>;
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [8b 47 14 00 56 56 19 4b 1f 03 04 a0];
+		qcom,mdss-dsi-t-clk-post = <0x08>;
+		qcom,mdss-dsi-t-clk-pre = <0x21>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <4095>;
+		qcom,mdss-dsi-dma-trigger = <4>;
+		qcom,mdss-dsi-mdp-trigger = <0>;
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
+		qcom,mdss-dsi-reset-sequence = <1 20>, <0 1>, <1 20>;
+		qcom,mdss-pan-physical-width-dimension = <59>;
+		qcom,mdss-pan-physical-height-dimension = <104>;
+
+	};
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/msm8226-720p-mtp.dtsi b/arch/arm/boot/dts/zte/nx404h/msm8226-720p-mtp.dtsi
new file mode 100755
index 0000000..d11d0f6
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/msm8226-720p-mtp.dtsi
@@ -0,0 +1,597 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/include/ "msm8226-camera-sensor-mtp.dtsi"
+
+&soc {
+	serial@f991f000 {
+		status = "ok";
+	};
+
+//+++ add by duguowei,2013.12.18,for breath led	
+	i2c@f9923000 { /* BLSP1 QUP3 */
+		aw9106b_i2c_adapter@5b {
+			compatible = "aw,9106b";
+			reg = <0x5b>;
+			interrupt-parent = <&msmgpio>;
+		};
+		
+		ams-sensor_i2c_adapter@39 {
+			status = "okay";
+			reg = <0x39>;
+			compatible = "ams,ams-sensor";
+			interrupt-parent = <&msmgpio>;
+			ams,irq-gpio = <&msmgpio 49 0x00>;
+		};
+	};
+//--- add by duguowei,2013.12.18,for breath led
+	i2c@f9927000 { /* BLSP1 QUP5 */
+/* ZTEMT Added by LiuYongfeng, 2013/12/17 */
+/*		synaptics@20 {
+			compatible = "synaptics,rmi4";
+			reg = <0x20>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2008>;
+			vdd-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 16 0x00>;
+			synaptics,irq-gpio = <&msmgpio 17 0x2008>;
+			synaptics,button-map = <139 102 158>;
+			synaptics,i2c-pull-up;
+			synaptics,power-down;
+			synaptics,disable-gpios;
+		};*/
+
+		cyttsp4_i2c_adapter@24 {
+			compatible = "cypress,cyttsp4_i2c_adapter";
+			reg = <0x24>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2>;
+			vdd_ana-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			cypress,reset-gpio = <&msmgpio 16 0x00>;
+			cypress,irq-gpio = <&msmgpio 17 0x00>;
+		};
+
+		synaptics_dsx_i2c@22 {
+			compatible = "synaptics_dsx_i2c,rmi4";
+			reg = <0x22>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <17 0x2>;
+			vdd_ana-supply = <&pm8226_l19>;
+			vcc_i2c-supply = <&pm8226_lvs1>;
+			synaptics,reset-gpio = <&msmgpio 16 0x00>;
+			synaptics,irq-gpio = <&msmgpio 17 0x00>;
+			synaptics,regulator_en;
+		};
+/* ZTEMT END */
+	};
+
+	i2c@f9925000 { /* BLSP1 QUP3 */
+		nfc-nci@0e {
+			compatible = "qcom,nfc-nci";
+			reg = <0x0e>;
+			qcom,irq-gpio = <&msmgpio 21 0x00>;
+			qcom,dis-gpio = <&msmgpio 20 0x00>;
+			qcom,clk-src = "BBCLK2";
+			qcom,clk-en-gpio = <&msmgpio 0 0x00>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <21 0>;
+			qcom,clk-gpio = <&pm8226_gpios 3 0>;
+		};
+	};
+	gpio_keys {
+		compatible = "gpio-keys";
+		input-name = "gpio-keys";
+
+		camera_focus {
+			label = "camera_focus";
+			gpios = <&msmgpio 108 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x210>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		camera_snapshot {
+			label = "camera_snapshot";
+			gpios = <&msmgpio 107 0x1>;
+			linux,input-type = <1>;
+			linux,code = <0x2fe>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		vol_up {
+			label = "volume_up";
+			gpios = <&msmgpio 106 0x1>;
+			linux,input-type = <1>;
+			linux,code = <115>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+		vol_dn {
+			label = "volume_dn";
+			gpios = <&msmgpio 109 0x1>;
+			linux,input-type = <1>;
+			linux,code = <114>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+	};
+
+	spi@f9923000 {
+		ethernet-switch@3 {
+			compatible = "micrel,ks8851";
+			reg = <3>;
+			interrupt-parent = <&msmgpio>;
+			interrupts = <115 0x8>;
+			spi-max-frequency = <4800000>;
+			rst-gpio = <&msmgpio 114 0>;
+			vdd-io-supply = <&pm8226_lvs1>;
+			vdd-phy-supply = <&pm8226_lvs1>;
+		};
+	};
+
+	sound {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC4", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCRight Headset Mic",
+			"AMIC5", "MIC BIAS2 External",
+			"MIC BIAS2 External", "ANCLeft Headset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+
+	sound-9302 {
+		qcom,audio-routing =
+			"RX_BIAS", "MCLK",
+			"LDO_H", "MCLK",
+			"SPK_OUT", "MCLK",
+			"SPK_OUT", "EXT_VDD_SPKR",
+			"AMIC1", "MIC BIAS1 Internal1",
+			"MIC BIAS1 Internal1", "Handset Mic",
+			"AMIC2", "MIC BIAS2 External",
+			"MIC BIAS2 External", "Headset Mic",
+			"AMIC3", "MIC BIAS1 External",
+			"MIC BIAS1 External", "Handset Mic";
+
+		qcom,cdc-mclk-gpios = <&pm8226_gpios 1 0>;
+		qcom,cdc-vdd-spkr-gpios = <&pm8226_gpios 2 0>;
+	};
+};
+
+&usb_otg {
+	#address-cells = <0>;
+	interrupt-parent = <&usb_otg>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 134 0
+			1 &intc 0 140 0
+			2 &spmi_bus 0x0 0x0 0x9 0x0>;
+	interrupt-names = "core_irq", "async_irq", "pmic_id_irq";
+
+	qcom,hsusb-otg-mode = <3>;
+	vbus_otg-supply = <&pm8226_chg_otg>;
+};
+
+&sdcc1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "disabled";
+};
+
+&sdhc_1 {
+	vdd-supply = <&pm8226_l17>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <800 500000>;
+
+	vdd-io-supply = <&pm8226_l6>;
+	qcom,vdd-io-always-on;
+	qcom,vdd-io-voltage-level = <1800000 1800000>;
+	qcom,vdd-io-current-level = <250 154000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,bus-speed-mode = "HS200_1p8v", "DDR_1p8v";
+	qcom,nonremovable;
+
+	status = "ok";
+};
+
+&sdcc2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+	qcom,sup-voltages = <2950 2950>;
+
+	qcom,xpc;
+	qcom,bus-speed-mode = "SDR12", "SDR25", "SDR50", "DDR50", "SDR104";
+	qcom,current-limit = <600>; #address-cells = <0>; interrupt-parent = <&sdcc2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 220 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "core_irq", "bam_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "disabled";
+};
+
+&sdhc_2 {
+	vdd-supply = <&pm8226_l18>;
+	qcom,vdd-voltage-level = <2950000 2950000>;
+	qcom,vdd-current-level = <9000 800000>;
+
+	vdd-io-supply = <&pm8226_l21>;
+	qcom,vdd-io-voltage-level = <1800000 2950000>;
+	qcom,vdd-io-current-level = <6 22000>;
+
+	qcom,pad-pull-on = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-pull-off = <0x0 0x3 0x3>; /* no-pull, pull-up, pull-up */
+	qcom,pad-drv-on = <0x4 0x4 0x4>; /* 10mA, 10mA, 10mA */
+	qcom,pad-drv-off = <0x0 0x0 0x0>; /* 2mA, 2mA, 2mA */
+
+	qcom,clk-rates = <400000 25000000 50000000 100000000 200000000>;
+
+	#address-cells = <0>;
+	interrupt-parent = <&sdhc_2>;
+	interrupts = <0 1 2>;
+	#interrupt-cells = <1>;
+	interrupt-map-mask = <0xffffffff>;
+	interrupt-map = <0 &intc 0 125 0
+			1 &intc 0 221 0
+			2 &msmgpio 38 0x3>;
+	interrupt-names = "hc_irq", "pwr_irq", "status_irq";
+	cd-gpios = <&msmgpio 38 0x1>;
+
+	status = "ok";
+};
+
+&spmi_bus {
+	qcom,pm8226@0 {
+		qcom,leds@a100 {
+			status = "okay";
+			qcom,led_mpp_2 {
+				label = "mpp";
+				linux,name = "button-backlight";
+				linux,default-trigger = "none";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "manual";
+				qcom,source-sel = <1>;
+				qcom,mode-ctrl = <0x60>;
+			};
+		};
+
+		qcom,leds@a300 {
+			status = "okay";
+			qcom,led_mpp_4 {
+				label = "mpp";
+				linux,name = "green";
+				linux,default-trigger = "battery-full";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,source-sel = <8>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,pwm-channel = <0>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+
+		qcom,leds@a500 {
+			status = "okay";
+			qcom,led_mpp_6 {
+				label = "mpp";
+				//linux,name = "red";
+				linux,name = "msm_red";
+				linux,default-trigger = "battery-charging";
+				qcom,default-state = "off";
+				qcom,max-current = <40>;
+				qcom,current-setting = <5>;
+				qcom,id = <6>;
+				qcom,mode = "pwm";
+				qcom,pwm-us = <1000>;
+				qcom,mode-ctrl = <0x60>;
+				qcom,source-sel = <10>;
+				qcom,pwm-channel = <5>;
+				qcom,start-idx = <1>;
+				qcom,ramp-step-ms = <120>;
+				qcom,duty-pcts = [00 00 00 00 00
+						  00 00 00 00 00
+						  50 00 00 00 00
+						  00 00 00 00 00
+						  00];
+				qcom,use-blink;
+			};
+		};
+	};
+
+	qcom,pm8226@1 {
+                qcom,leds@d300 {
+                        status = "okay";
+                };
+
+		qcom,leds@d800 {
+			status = "okay";
+			qcom,wled_0 {
+				label = "wled";
+				linux,name = "wled:backlight";
+				linux,default-trigger = "bkl-trigger";
+				qcom,cs-out-en;
+				qcom,op-fdbck = <1>;
+				qcom,default-state = "on";
+				qcom,max-current = <20>;
+				qcom,ctrl-delay-us = <0>;
+				qcom,boost-curr-lim = <3>;
+				qcom,cp-sel = <0>;
+				qcom,switch-freq = <11>;
+				qcom,ovp-val = <0>;
+				qcom,num-strings = <1>;
+				qcom,id = <0>;
+			};
+		};
+
+		qcom,vibrator@c000 {
+			status = "okay";
+			qcom,vib-timeout-ms = <15000>;
+			qcom,vib-vtg-level-mV = <3100>;
+		};
+	};
+};
+
+&pm8226_gpios {
+	gpio@c000 { /* GPIO 1 */
+		/* XO_PMIC_CDC_MCLK enable for tapan codec */
+		qcom,mode = <1>;		/* Digital output */
+		qcom,output-type = <0>;	/* CMOS logic */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO*/
+		qcom,vin-sel = <3>;		/* QPNP_PIN_VIN3 */
+		qcom,out-strength = <3>;/* QPNP_PIN_OUT_STRENGTH_HIGH */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;	/* Enable GPIO */
+	};
+
+	gpio@c100 { /* GPIO 2 */
+		qcom,mode = <1>;
+		qcom,output-type = <0>;
+		qcom,pull = <5>;
+		qcom,vin-sel = <3>;
+		qcom,out-strength = <3>;
+		qcom,src-sel = <2>;
+		qcom,master-en = <1>;
+	};
+
+	gpio@c200 { /* GPIO 3 */
+		qcom,mode = <0>;		/* QPNP_PIN_MODE_DIG_IN */
+		qcom,pull = <5>;		/* QPNP_PIN_PULL_NO */
+		qcom,vin-sel = <2>;		/* QPNP_PIN_VIN2 */
+		qcom,src-sel = <2>;		/* QPNP_PIN_SEL_FUNC_1 */
+		qcom,master-en = <1>;
+	};
+
+	gpio@c300 { /* GPIO 4 */
+	};
+
+	gpio@c400 { /* GPIO 5 */
+	};
+
+	gpio@c500 { /* GPIO 6 */
+	};
+
+	gpio@c600 { /* GPIO 7 */
+	};
+
+	gpio@c700 { /* GPIO 8 */
+	};
+};
+
+&pm8226_mpps {
+	mpp@a000 { /* MPP 1 */
+	};
+
+	mpp@a100 { /* MPP 2 */
+	};
+
+	mpp@a200 { /* MPP 3 */
+	};
+
+	mpp@a300 { /* MPP 4 */
+	};
+
+	mpp@a400 { /* MPP 5 */
+		/* PA_THERM0 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <0>; /* AMUX 5 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+
+	mpp@a500 { /* MPP 6 */
+	};
+
+	mpp@a600 { /* MPP 7 */
+	};
+
+	mpp@a700 { /* MPP 8 */
+		/* PA_THERM1 config */
+		qcom,mode = <4>; /* AIN input */
+		qcom,invert = <1>; /* Enable MPP */
+		qcom,ain-route = <3>; /* AMUX 8 */
+		qcom,master-en = <1>;
+		qcom,src-sel = <0>; /* Function constant */
+	};
+};
+
+&pm8226_vadc {
+	chan@14 {
+		label = "pa_therm0";
+		reg = <0x14>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+
+	chan@17 {
+		label = "pa_therm1";
+		reg = <0x17>;
+		qcom,decimation = <0>;
+		qcom,pre-div-channel-scaling = <0>;
+		qcom,calibration-type = "ratiometric";
+		qcom,scale-function = <2>;
+		qcom,hw-settle-time = <2>;
+		qcom,fast-avg-setup = <0>;
+	};
+};
+
+/* Charger
+*
+* CONFIG_ZTEMT_CHARGE
+*/
+/ {
+	mtp_batterydata: qcom,battery-data {
+		qcom,rpull-up-kohm = <100>;
+		qcom,vref-batt-therm = <1800000>;
+
+		/include/ "batterydata-zte-2000mah.dtsi"
+/*
+		/include/ "batterydata-palladium.dtsi"
+		/include/ "batterydata-mtp-3000mah.dtsi"
+*/
+	};
+};
+
+&pm8226_bms {
+	status = "ok";
+	qcom,enable-fcc-learning;
+	qcom,min-fcc-learning-soc = <20>;
+	qcom,min-fcc-ocv-pc = <30>;
+	qcom,min-fcc-learning-samples = <5>;
+	qcom,fcc-resolution = <10>;
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+&pm8226_chg {
+	qcom,charging-disabled;
+	qcom,battery-data = <&mtp_batterydata>;
+};
+
+&slim_msm {
+	tapan_codec {
+		qcom,cdc-micbias1-ext-cap;
+	};
+};
+
+&mdss_mdp {
+	qcom,mdss-pref-prim-intf = "dsi";
+	batfet-supply = <&pm8226_chg_batif>;
+};
+
+&mdss_dsi0 {
+	//qcom,dsi-pref-prim-pan = <&dsi_nt35590_720_vid>;
+};
+
+&mdss_dsi0 {
+	qcom,platform-enable-gpio = <&msmgpio 33 0>;
+	qcom,platform-avddn-enable-gpio = <&msmgpio 34 0>;
+};
+
+&dsi_r69431_720_vid {
+     status = "disabled";
+     qcom,cont-splash-enabled;
+};
+
+&dsi_r69431_720_cmd {
+     status = "disabled";
+     qcom,cont-splash-enabled;
+};
+
+&dsi_otm1282a_720_vid {
+     status = "disabled";
+     qcom,cont-splash-enabled;
+};
+
+
+&dsi_otm1282a_720_cmd {
+     status = "disabled";
+     qcom,cont-splash-enabled;
+};
+
+&dsi_r63311_1080_vid {
+	status = "disabled";
+	qcom,cont-splash-enabled;
+};
+&dsi_nt35590_720_vid {
+	qcom,cont-splash-enabled;
+};
diff --git a/arch/arm/boot/dts/zte/nx404h/msm8226-camera-sensor-mtp.dtsi b/arch/arm/boot/dts/zte/nx404h/msm8226-camera-sensor-mtp.dtsi
new file mode 100644
index 0000000..97e7dff
--- /dev/null
+++ b/arch/arm/boot/dts/zte/nx404h/msm8226-camera-sensor-mtp.dtsi
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&soc {
+
+	led_flash0: qcom,camera-led-flash {
+		cell-index = <0>;
+		compatible = "qcom,camera-led-flash";
+		qcom,flash-type = <1>;
+		qcom,flash-source = <&pm8226_flash0>;
+		qcom,torch-source = <&pm8226_torch>;
+	};
+};
+
+&cci {
+
+	actuator0: qcom,actuator@6e {
+		cell-index = <3>;
+		reg = <0x6c>;
+		compatible = "qcom,actuator";
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@6f {
+		compatible = "qcom,ov8825";
+		reg = <0x6f>;
+		qcom,slave-id = <0x6c 0x300a 0x8825>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov8825";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+							 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x1f>;
+		qcom,sensor-position = <0>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+	};
+
+	qcom,camera@6d {
+		compatible = "qcom,ov9724";
+		reg = <0x6d>;
+		qcom,slave-id = <0x20 0x0 0x9724>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		qcom,sensor-name = "ov9724";
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+				<&msmgpio 28 0>,
+				<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+				"CAM_RESET",
+				"CAM_STANDBY";
+		qcom,gpio-set-tbl-num = <1 1>;
+		qcom,gpio-set-tbl-flags = <0 2>;
+		qcom,gpio-set-tbl-delay = <1000 4000>;
+		qcom,csi-lane-assign = <0x4320>;
+		qcom,csi-lane-mask = <0x3>;
+		qcom,sensor-position = <1>;
+		qcom,sensor-mode = <1>;
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+	qcom,camera@0 {
+		cell-index = <0>;
+		compatible = "qcom,camera";
+		reg = <0x0>;
+		qcom,csiphy-sd-index = <0>;
+		qcom,csid-sd-index = <0>;
+		qcom,mount-angle = <0>;
+		qcom,actuator-src = <&actuator0>;
+		qcom,led-flash-src = <&led_flash0>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		cam_vaf-supply = <&pm8226_l15>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana",
+			 "cam_vaf";
+		qcom,cam-vreg-type = <0 1 0 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000 2800000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000 100000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 37 0>,
+			<&msmgpio 35 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET1",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+
+	qcom,camera@1 {
+		cell-index = <1>;
+		compatible = "qcom,camera";
+		reg = <0x1>;
+		qcom,csiphy-sd-index = <1>;
+		qcom,csid-sd-index = <1>;
+		qcom,mount-angle = <270>;
+		cam_vdig-supply = <&pm8226_l5>;
+		cam_vana-supply = <&pm8226_l19>;
+		cam_vio-supply = <&pm8226_lvs1>;
+		qcom,cam-vreg-name = "cam_vdig", "cam_vio", "cam_vana";
+		qcom,cam-vreg-type = <0 1 0>;
+		qcom,cam-vreg-min-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-max-voltage = <1200000 0 2850000>;
+		qcom,cam-vreg-op-mode = <200000 0 80000>;
+		qcom,gpio-no-mux = <0>;
+		gpios = <&msmgpio 26 0>,
+			<&msmgpio 28 0>,
+			<&msmgpio 36 0>;
+		qcom,gpio-reset = <1>;
+		qcom,gpio-standby = <2>;
+		qcom,gpio-req-tbl-num = <0 1 2>;
+		qcom,gpio-req-tbl-flags = <1 0 0>;
+		qcom,gpio-req-tbl-label = "CAMIF_MCLK",
+			"CAM_RESET",
+			"CAM_STANDBY";
+		qcom,cci-master = <0>;
+		status = "ok";
+	};
+};
diff --git a/arch/arm/configs/msm8926-ne501j_defconfig b/arch/arm/configs/msm8926-ne501j_defconfig
new file mode 100644
index 0000000..f1cfd3b
--- /dev/null
+++ b/arch/arm/configs/msm8926-ne501j_defconfig
@@ -0,0 +1,525 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_AUDIT=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_ARCH_MSM=y
+CONFIG_ARCH_MSM8226=y
+# CONFIG_MSM_STACKED_MEMORY is not set
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_SMP2P=y
+CONFIG_MSM_SMP2P_TEST=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_QMI_INTERFACE=y
+CONFIG_MSM_SMCMOD=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL_LPASS_QDSP6V5=y
+CONFIG_MSM_PIL_MSS_QDSP6V5=y
+CONFIG_MSM_PIL_VENUS=y
+CONFIG_MSM_PIL_PRONTO=y
+CONFIG_MSM_BUSPM_DEV=m
+CONFIG_MSM_TZ_LOG=y
+CONFIG_MSM_RPM_RBCPR_STATS_V2_LOG=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_MSM_WATCHDOG_V2=y
+CONFIG_MSM_MEMORY_DUMP=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_OCMEM=y
+CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
+CONFIG_MSM_OCMEM_DEBUG=y
+CONFIG_MSM_OCMEM_POWER_DISABLE=y
+CONFIG_SENSORS_ADSP=y
+CONFIG_MSM_RTB=y
+CONFIG_MSM_RTB_SEPARATE_CPUS=y
+CONFIG_MSM_ENABLE_WDOG_DEBUG_CONTROL=y
+CONFIG_MSM_BOOT_STATS=y
+CONFIG_MSM_XPU_ERR_FATAL=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_ENABLE_VMALLOC_SAVING=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_CP_ACCESS=y
+CONFIG_USE_OF=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_CLS_FW=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCISMD=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_CMA=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_QSEECOM=y
+CONFIG_USB_HSIC_SMSC_HUB=y
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_TUN=y
+# CONFIG_MSM_RMNET is not set
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_USBNET=y
+CONFIG_WCNSS_CORE=y
+CONFIG_WCNSS_CORE_PRONTO=y
+CONFIG_WCNSS_MEM_PRE_ALLOC=y
+CONFIG_WCNSS_REGISTER_DUMP_ON_BITE=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_ZTEMT_TOUCHSCREEN_GT9XX=y
+CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_DRIVER=y
+CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_UPDATE=y
+CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_DEBUG=y
+CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_TEST=y
+CONFIG_ZTEMT_TOUCHSCREEN_FT5336=y
+CONFIG_FT5336_TOUCHSCREEN_DRIVER=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=m
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_DIAG_CHAR=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_MSM_RDBG=m
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_QUP=y
+CONFIG_SPI=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_MSM_QPNP_INT=y
+CONFIG_SLIMBUS_MSM_NGD=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_QPNP_PIN=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_QPNP_CHARGER=y
+CONFIG_BATTERY_BCL=y
+CONFIG_ZTEMT_2400AMH_BATTERY=y
+CONFIG_QPNP_BMS=y
+CONFIG_ZTEMT_HW_VERSION=y
+CONFIG_ZTEMT_HW_VERSION_GPIO=y
+CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
+CONFIG_SENSORS_QPNP_ADC_CURRENT=y
+CONFIG_ZTEMT_SENSORS=y
+CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON=y
+CONFIG_ZTEMT_SENSORS_COMMON=y
+CONFIG_ZTEMT_SENSORS_ALS_PS=y
+CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_TSENS8974=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_THERMAL_QPNP=y
+CONFIG_THERMAL_QPNP_ADC_TM=y
+CONFIG_WCD9306_CODEC=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_ONSEMI_NCP6335D=y
+CONFIG_REGULATOR_STUB=y
+CONFIG_REGULATOR_QPNP=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_MSM_CAMERA is not set
+CONFIG_MSMB_CAMERA=y
+CONFIG_MSM_CAMERA_SENSOR=y
+CONFIG_MSM_CPP=y
+CONFIG_MSM_CCI=y
+CONFIG_MSM_CSI30_HEADER=y
+CONFIG_MSM_CSIPHY=y
+CONFIG_MSM_CSID=y
+CONFIG_MSM_EEPROM=y
+CONFIG_MSM_ISPIF=y
+CONFIG_ZTEMT_CAMERA=y
+CONFIG_IMX135=y
+CONFIG_OV5648=y
+CONFIG_MSMB_JPEG=y
+CONFIG_MSM_VIDC_V4L2=y
+CONFIG_MSM_WFD=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_IRIS_TRANSPORT=m
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_MSM_KGSL=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_FB=y
+CONFIG_FB_MSM=y
+# CONFIG_FB_MSM_BACKLIGHT is not set
+CONFIG_FB_MSM_MDSS=y
+CONFIG_FB_MSM_MDSS_WRITEBACK=y
+CONFIG_FB_MSM_MDSS_DSI_CTRL_STATUS=y
+CONFIG_ZTEMT_LCD_MIPI_COMMON=y
+CONFIG_ZTEMT_NE501_LCD=y
+CONFIG_ZTEMT_LCD_DISP_ENHANCE=y
+CONFIG_ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P=y
+CONFIG_ZTEMT_LCD_ESD_TE_CHECK=y
+CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_SOUND=y
+CONFIG_ZTEMT_AUDIO=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_MSM8226=y
+CONFIG_UHID=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_MON=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_CCID_BRIDGE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=m
+CONFIG_MMC_BLOCK_TEST=m
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_MSM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_QPNP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_ZTEMT_RGB_BREATH_LEDS=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_DRV_MSM is not set
+CONFIG_RTC_DRV_QPNP=y
+CONFIG_ZTE_POWEROFF_ALARM=y
+CONFIG_UIO=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_SPS=y
+CONFIG_USB_BAM=y
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_QPNP_PWM=y
+CONFIG_QPNP_POWER_ON=y
+CONFIG_QPNP_VIBRATOR=y
+CONFIG_QPNP_REVID=y
+CONFIG_MSM_IOMMU_V1=y
+CONFIG_MOBICORE_SUPPORT=m
+CONFIG_MOBICORE_API=m
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_FUSE=y
+CONFIG_CORESIGHT_TMC=y
+CONFIG_CORESIGHT_TPIU=y
+CONFIG_CORESIGHT_FUNNEL=y
+CONFIG_CORESIGHT_REPLICATOR=y
+CONFIG_CORESIGHT_STM=y
+CONFIG_CORESIGHT_HWEVENT=y
+CONFIG_CORESIGHT_ETM=y
+CONFIG_CORESIGHT_AUDIO_ETM=y
+CONFIG_CORESIGHT_MODEM_ETM=y
+CONFIG_CORESIGHT_WCN_ETM=y
+CONFIG_CORESIGHT_RPM_ETM=y
+CONFIG_CORESIGHT_EVENT=m
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SYSRQ_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_KMEMLEAK=y
+CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_STACK_USAGE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+CONFIG_FAULT_INJECTION=y
+CONFIG_FAIL_PAGE_ALLOC=y
+CONFIG_FAULT_INJECTION_DEBUG_FS=y
+CONFIG_FAULT_INJECTION_STACKTRACE_FILTER=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_PANIC_ON_DATA_CORRUPTION=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_DEV_QCRYPTO=m
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCEDEV=m
+CONFIG_NET_KEY=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
diff --git a/arch/arm/configs/msm8926-nx404h_defconfig b/arch/arm/configs/msm8926-nx404h_defconfig
new file mode 100755
index 0000000..e2f10cc
--- /dev/null
+++ b/arch/arm/configs/msm8926-nx404h_defconfig
@@ -0,0 +1,525 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_AUDIT=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_ARCH_MSM=y
+CONFIG_ARCH_MSM8226=y
+# CONFIG_MSM_STACKED_MEMORY is not set
+CONFIG_CPU_HAS_L2_PMU=y
+# CONFIG_MSM_FIQ_SUPPORT is not set
+# CONFIG_MSM_PROC_COMM is not set
+CONFIG_MSM_SMD=y
+CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_BAM_DMUX=y
+CONFIG_MSM_SMP2P=y
+CONFIG_MSM_SMP2P_TEST=y
+CONFIG_MSM_IPC_LOGGING=y
+CONFIG_MSM_IPC_ROUTER=y
+CONFIG_MSM_IPC_ROUTER_SMD_XPRT=y
+CONFIG_MSM_QMI_INTERFACE=y
+CONFIG_MSM_SMCMOD=y
+CONFIG_MSM_SUBSYSTEM_RESTART=y
+CONFIG_MSM_SYSMON_COMM=y
+CONFIG_MSM_PIL_LPASS_QDSP6V5=y
+CONFIG_MSM_PIL_MSS_QDSP6V5=y
+CONFIG_MSM_PIL_VENUS=y
+CONFIG_MSM_PIL_PRONTO=y
+CONFIG_MSM_BUSPM_DEV=m
+CONFIG_MSM_TZ_LOG=y
+CONFIG_MSM_RPM_RBCPR_STATS_V2_LOG=y
+CONFIG_MSM_DIRECT_SCLK_ACCESS=y
+CONFIG_MSM_WATCHDOG_V2=y
+CONFIG_MSM_MEMORY_DUMP=y
+CONFIG_MSM_DLOAD_MODE=y
+CONFIG_MSM_ADSP_LOADER=y
+CONFIG_MSM_OCMEM=y
+CONFIG_MSM_OCMEM_LOCAL_POWER_CTRL=y
+CONFIG_MSM_OCMEM_DEBUG=y
+CONFIG_MSM_OCMEM_POWER_DISABLE=y
+CONFIG_SENSORS_ADSP=y
+CONFIG_MSM_RTB=y
+CONFIG_MSM_RTB_SEPARATE_CPUS=y
+CONFIG_MSM_ENABLE_WDOG_DEBUG_CONTROL=y
+CONFIG_MSM_BOOT_STATS=y
+CONFIG_MSM_XPU_ERR_FATAL=y
+CONFIG_STRICT_MEMORY_RWX=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_ENABLE_VMALLOC_SAVING=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_CP_ACCESS=y
+CONFIG_USE_OF=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_CLS_FW=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCISMD=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_CMA=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_QSEECOM=y
+CONFIG_USB_HSIC_SMSC_HUB=y
+CONFIG_SCSI=y
+CONFIG_SCSI_TGT=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_TUN=y
+# CONFIG_MSM_RMNET is not set
+CONFIG_MSM_RMNET_BAM=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_USBNET=y
+CONFIG_WCNSS_CORE=y
+CONFIG_WCNSS_CORE_PRONTO=y
+CONFIG_WCNSS_MEM_PRE_ALLOC=y
+CONFIG_WCNSS_REGISTER_DUMP_ON_BITE=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_CYPRSS_TOUCHSCREEN_TMA463=y
+CONFIG_CYTTSP4_4P7_INCH_OTG_GW=y
+CONFIG_CYPRESS_CYTTSP4_BUS=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_I2C=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER=y
+CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_4P7_INCH_TP_2=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_I2C=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING=y
+CONFIG_ZTEMT_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=m
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIAL_MSM_HSL=y
+CONFIG_SERIAL_MSM_HSL_CONSOLE=y
+CONFIG_DIAG_CHAR=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_MSM=y
+CONFIG_MSM_ADSPRPC=y
+CONFIG_MSM_RDBG=m
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_QUP=y
+CONFIG_SPI=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_MSM_QPNP_INT=y
+CONFIG_SLIMBUS_MSM_NGD=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_QPNP_PIN=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_QPNP_CHARGER=y
+CONFIG_BATTERY_BCL=y
+CONFIG_ZTEMT_2000AMH_BATTERY=y
+CONFIG_QPNP_BMS=y
+CONFIG_SENSORS_QPNP_ADC_VOLTAGE=y
+CONFIG_SENSORS_QPNP_ADC_CURRENT=y
+CONFIG_ZTEMT_SENSORS=y
+CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON=y
+CONFIG_ZTEMT_SENSORS_COMMON=y
+CONFIG_ZTEMT_SENSORS_ALS_PS=y
+CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772_NX404H=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_TSENS8974=y
+CONFIG_THERMAL_MONITOR=y
+CONFIG_THERMAL_QPNP=y
+CONFIG_THERMAL_QPNP_ADC_TM=y
+CONFIG_WCD9306_CODEC=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_ONSEMI_NCP6335D=y
+CONFIG_REGULATOR_STUB=y
+CONFIG_REGULATOR_QPNP=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_MSM_CAMERA is not set
+CONFIG_MSMB_CAMERA=y
+CONFIG_MSM_CAMERA_SENSOR=y
+CONFIG_MSM_CPP=y
+CONFIG_MSM_CCI=y
+CONFIG_MSM_CSI30_HEADER=y
+CONFIG_MSM_CSIPHY=y
+CONFIG_MSM_CSID=y
+CONFIG_MSM_EEPROM=y
+CONFIG_MSM_ISPIF=y
+CONFIG_MSMB_JPEG=y
+CONFIG_MSM_VIDC_V4L2=y
+CONFIG_MSM_WFD=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEOBUF2_MSM_MEM=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_RADIO_IRIS=y
+CONFIG_RADIO_IRIS_TRANSPORT=m
+CONFIG_ION=y
+CONFIG_ION_MSM=y
+CONFIG_MSM_KGSL=y
+CONFIG_KGSL_PER_PROCESS_PAGE_TABLE=y
+CONFIG_FB=y
+CONFIG_FB_MSM=y
+# CONFIG_FB_MSM_BACKLIGHT is not set
+CONFIG_FB_MSM_MDSS=y
+CONFIG_FB_MSM_MDSS_WRITEBACK=y
+CONFIG_ZTEMT_LCD_MIPI_COMMON=y
+CONFIG_ZTEMT_LCD_POWER_CONTRL=y
+CONFIG_ZTEMT_MIPI_720P_R69431_SHARP_IPS_4P7=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_SOUND=y
+CONFIG_ZTEMT_AUDIO=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_MSM8226=y
+CONFIG_UHID=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_MON=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_MSM=y
+CONFIG_USB_EHCI_MSM_HSIC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_CCID_BRIDGE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_CI13XXX_MSM=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=m
+CONFIG_MMC_BLOCK_TEST=m
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_MSM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_MMC_MSM_SPS_SUPPORT=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_QPNP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_DRV_MSM is not set
+CONFIG_RTC_DRV_QPNP=y
+CONFIG_ZTE_POWEROFF_ALARM=y
+CONFIG_UIO=y
+CONFIG_UIO_MSM_SHAREDMEM=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_SPS=y
+CONFIG_USB_BAM=y
+CONFIG_SPS_SUPPORT_NDP_BAM=y
+CONFIG_QPNP_PWM=y
+CONFIG_QPNP_POWER_ON=y
+CONFIG_QPNP_VIBRATOR=y
+CONFIG_QPNP_REVID=y
+CONFIG_MSM_IOMMU_V1=y
+CONFIG_MOBICORE_SUPPORT=m
+CONFIG_MOBICORE_API=m
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_FUSE=y
+CONFIG_CORESIGHT_TMC=y
+CONFIG_CORESIGHT_TPIU=y
+CONFIG_CORESIGHT_FUNNEL=y
+CONFIG_CORESIGHT_REPLICATOR=y
+CONFIG_CORESIGHT_STM=y
+CONFIG_CORESIGHT_HWEVENT=y
+CONFIG_CORESIGHT_ETM=y
+CONFIG_CORESIGHT_AUDIO_ETM=y
+CONFIG_CORESIGHT_MODEM_ETM=y
+CONFIG_CORESIGHT_WCN_ETM=y
+CONFIG_CORESIGHT_RPM_ETM=y
+CONFIG_CORESIGHT_EVENT=m
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SYSRQ_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_KMEMLEAK=y
+CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_STACK_USAGE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+CONFIG_FAULT_INJECTION=y
+CONFIG_FAIL_PAGE_ALLOC=y
+CONFIG_FAULT_INJECTION_DEBUG_FS=y
+CONFIG_FAULT_INJECTION_STACKTRACE_FILTER=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_PANIC_ON_DATA_CORRUPTION=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_LSM_MMAP_MIN_ADDR=4096
+CONFIG_SECURITY_SELINUX=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_DEV_QCRYPTO=m
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCEDEV=m
+CONFIG_ZTEMT_LIQUID_LED=y
+CONFIG_NET_KEY=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
old mode 100644
new mode 100755
index 5f7f0d9..f3c383f
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -264,6 +264,10 @@ obj-$(CONFIG_MACH_MSM8930_FLUID) += board-8930-all.o board-8930-regulator-pm8038
 obj-$(CONFIG_PM8921_BMS) += bms-batterydata.o bms-batterydata-desay.o batterydata-lib.o
 obj-$(CONFIG_QPNP_BMS) += bms-batterydata.o bms-batterydata-desay.o batterydata-lib.o
 obj-$(CONFIG_QPNP_BMS) += bms-batterydata-oem.o bms-batterydata-qrd-4v35-2000mah.o bms-batterydata-qrd-4v2-1300mah.o
+#ZTEMT Added For Charger Bms
+obj-$(CONFIG_ZTEMT_2000AMH_BATTERY) += bms_ztemt_batterydata_2000mAh.o
+obj-$(CONFIG_ZTEMT_2400AMH_BATTERY) += bms_ztemt_batterydata_2400mAh.o
+#ZTEMT END
 obj-$(CONFIG_MACH_APQ8064_CDP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_MTP) += board-8064-all.o board-8064-regulator.o
 obj-$(CONFIG_MACH_APQ8064_LIQUID) += board-8064-all.o board-8064-regulator.o
diff --git a/arch/arm/mach-msm/bms_ztemt_batterydata_2000mAh.c b/arch/arm/mach-msm/bms_ztemt_batterydata_2000mAh.c
new file mode 100755
index 0000000..91a1d3f
--- /dev/null
+++ b/arch/arm/mach-msm/bms_ztemt_batterydata_2000mAh.c
@@ -0,0 +1,103 @@
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
+
+static struct single_row_lut fcc_temp = {
+	.x		= {-20, -10, 0, 25, 40, 45, 50, 60},
+	.y		= {2036, 2042, 2041, 2046, 2047, 2040, 2038, 2039},
+	.cols	= 8
+};
+
+static struct single_row_lut fcc_sf = {
+	.x		= {0},
+	.y		= {100},
+	.cols	= 1
+};
+
+static struct sf_lut rbatt_sf = {
+	.rows		= 30,
+	.cols		= 8,
+	.row_entries		= {-20, -10, 0, 25, 40, 45, 50, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},
+	.sf		= {
+				{1095, 453, 237, 100, 85, 83, 82, 82},
+				{1095, 453, 237, 100, 85, 83, 82, 82},
+				{1097, 458, 242, 102, 87, 85, 83, 82},
+				{1081, 458, 246, 106, 90, 87, 85, 84},
+				{1067, 457, 247, 111, 92, 89, 86, 85},
+				{1054, 452, 243, 116, 95, 92, 89, 87},
+				{1048, 447, 238, 120, 99, 95, 92, 90},
+				{1046, 447, 235, 117, 102, 98, 95, 92},
+				{1054, 448, 235, 107, 96, 95, 93, 91},
+				{1071, 453, 236, 102, 88, 87, 85, 84},
+				{1093, 457, 238, 103, 88, 85, 83, 83},
+				{1124, 465, 243, 104, 88, 87, 85, 84},
+				{1158, 478, 248, 107, 91, 88, 86, 85},
+				{1205, 493, 255, 110, 93, 90, 88, 86},
+				{1262, 513, 265, 110, 92, 90, 88, 86},
+				{1360, 538, 276, 106, 88, 86, 85, 83},
+				{1532, 574, 283, 105, 88, 86, 85, 84},
+				{1652, 608, 286, 106, 89, 87, 85, 84},
+				{1608, 615, 283, 105, 88, 86, 85, 84},
+				{1290, 560, 267, 103, 88, 86, 84, 84},
+				{1425, 583, 275, 106, 89, 86, 85, 84},
+				{1594, 611, 285, 108, 90, 87, 85, 85},
+				{1843, 647, 300, 110, 91, 88, 86, 86},
+				{2189, 698, 318, 111, 92, 89, 87, 86},
+				{2701, 773, 342, 111, 90, 88, 86, 85},
+				{3525, 891, 372, 111, 90, 88, 86, 85},
+				{4989, 1150, 421, 113, 92, 88, 87, 86},
+				{8087, 2096, 519, 119, 94, 91, 89, 88},
+				{16690, 5066, 815, 130, 101, 95, 93, 93},
+				{46764, 18528, 3096, 174, 141, 116, 116, 136},
+					}
+};
+
+
+static struct pc_temp_ocv_lut pc_temp_ocv = {
+	.rows		= 31,
+	.cols		= 8,
+	.temp		= {-20, -10, 0, 25, 40, 45, 50, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+	.ocv		= {
+				{4334, 4333, 4332, 4326, 4320, 4318, 4316, 4312},
+				{4220, 4240, 4248, 4252, 4249, 4248, 4247, 4244},
+				{4147, 4177, 4188, 4194, 4192, 4191, 4191, 4188},
+				{4082, 4117, 4132, 4141, 4138, 4138, 4138, 4135},
+				{4022, 4061, 4078, 4090, 4088, 4087, 4087, 4084},
+				{3968, 4006, 4024, 4041, 4040, 4040, 4040, 4037},
+				{3920, 3957, 3973, 3995, 3996, 3996, 3996, 3994},
+				{3876, 3914, 3928, 3950, 3953, 3954, 3955, 3953},
+				{3839, 3877, 3891, 3905, 3909, 3911, 3912, 3910},
+				{3809, 3844, 3858, 3869, 3870, 3871, 3872, 3870},
+				{3783, 3815, 3830, 3841, 3842, 3842, 3843, 3841},
+				{3762, 3791, 3806, 3818, 3819, 3820, 3820, 3818},
+				{3742, 3772, 3786, 3799, 3801, 3801, 3801, 3800},
+				{3724, 3755, 3770, 3782, 3784, 3785, 3785, 3782},
+				{3706, 3739, 3758, 3766, 3764, 3765, 3764, 3760},
+				{3687, 3721, 3743, 3747, 3741, 3740, 3737, 3730},
+				{3666, 3699, 3723, 3726, 3720, 3718, 3716, 3709},
+				{3646, 3680, 3700, 3706, 3700, 3699, 3696, 3689},
+				{3626, 3665, 3679, 3685, 3680, 3680, 3677, 3670},
+				{3610, 3653, 3665, 3674, 3671, 3670, 3668, 3662},
+				{3599, 3645, 3659, 3671, 3669, 3667, 3665, 3659},
+				{3587, 3635, 3651, 3667, 3665, 3664, 3662, 3655},
+				{3571, 3622, 3642, 3660, 3659, 3659, 3656, 3649},
+				{3552, 3606, 3629, 3649, 3648, 3649, 3647, 3637},
+				{3527, 3584, 3610, 3626, 3622, 3627, 3624, 3610},
+				{3497, 3551, 3578, 3586, 3580, 3589, 3585, 3568},
+				{3457, 3504, 3527, 3532, 3527, 3539, 3535, 3516},
+				{3400, 3436, 3459, 3464, 3458, 3475, 3471, 3449},
+				{3323, 3341, 3366, 3371, 3365, 3390, 3386, 3360},
+				{3201, 3206, 3230, 3229, 3222, 3262, 3259, 3228},
+				{3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000}
+	}
+};
+
+struct bms_battery_data ztemt_2000mAh_data = {
+	.fcc				= 2000,
+	.fcc_temp_lut			= &fcc_temp,
+	.fcc_sf_lut				= &fcc_sf,
+	.pc_temp_ocv_lut		= &pc_temp_ocv,
+	.rbatt_sf_lut			= &rbatt_sf,
+	.default_rbatt_mohm	= 180
+};
+
diff --git a/arch/arm/mach-msm/bms_ztemt_batterydata_2400mAh.c b/arch/arm/mach-msm/bms_ztemt_batterydata_2400mAh.c
new file mode 100755
index 0000000..6e16985
--- /dev/null
+++ b/arch/arm/mach-msm/bms_ztemt_batterydata_2400mAh.c
@@ -0,0 +1,202 @@
+#include <linux/mfd/pm8xxx/pm8921-bms.h>
+//#include <linux/mfd/pm8xxx/pm8921-lib.h>
+/*
+* CONFIG_ZTEMT_CHARGE
+*/
+static struct single_row_lut fcc_temp = {
+	.x		= {-20, 0, 25, 40, 60},
+	.y		= {2469, 2472, 2469, 2456, 2450},
+	.cols	= 5
+};
+
+static struct single_row_lut fcc_sf = {
+	.x		= {0},
+	.y		= {100},
+	.cols	= 1
+};
+
+static struct sf_lut rbatt_sf = {
+	.rows		= 31,
+	.cols		= 5,
+	.row_entries		= {-20, 0, 25, 40, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+	.sf		= {
+				{1438, 321, 100, 77, 69},
+				{1437, 321, 100, 78, 69},
+				{1407, 332, 106, 82, 72},
+				{1380, 343, 111, 86, 74},
+				{1373, 351, 117, 89, 77},
+				{1363, 365, 125, 95, 81},
+				{1389, 355, 133, 99, 84},
+				{1417, 353, 141, 105, 87},
+				{1445, 359, 136, 107, 89},
+				{1482, 368, 108, 86, 74},
+				{1535, 382, 109, 82, 74},
+				{1600, 406, 114, 87, 78},
+				{1675, 437, 122, 93, 82},
+				{1762, 475, 130, 96, 85},
+				{1926, 518, 137, 96, 82},
+				{2218, 559, 140, 93, 78},
+				{2544, 603, 140, 93, 76},
+				{2794, 648, 137, 91, 74},
+				{2714, 664, 138, 91, 75},
+				{2811, 684, 149, 97, 79},
+				{2997, 705, 155, 100, 80},
+				{3219, 725, 162, 103, 81},
+				{3494, 753, 168, 105, 82},
+				{3824, 775, 173, 106, 79},
+				{4250, 796, 169, 103, 79},
+				{4806, 821, 169, 102, 82},
+				{5523, 853, 177, 106, 89},
+				{6575, 903, 193, 120, 103},
+				{8443, 981, 233, 142, 111},
+				{14044, 1566, 277, 162, 137},
+				{39526, 12585, 2471, 2394, 668}
+	}
+};
+
+#if 0
+static struct sf_lut r1batt = {
+	.rows		= 31,
+	.cols		= 5,
+	.temp		= {-20, 0, 25, 40, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+	.r1		= {
+				{393, 195, 89, 74, 73},
+				{393, 195, 89, 74, 73},
+				{383, 203, 89, 75, 73},
+				{403, 196, 89, 75, 73},
+				{378, 199, 89, 75, 73},
+				{378, 196, 90, 75, 74},
+				{379, 195, 91, 75, 74},
+				{378, 197, 92, 76, 74},
+				{383, 197, 93, 77, 74},
+				{398, 198, 94, 77, 74},
+				{386, 200, 95, 77, 75},
+				{382, 205, 96, 78, 75},
+				{387, 201, 98, 79, 75},
+				{391, 202, 100, 80, 76},
+				{390, 208, 102, 81, 76},
+				{400, 204, 104, 83, 77},
+				{402, 206, 106, 85, 77},
+				{418, 206, 108, 86, 78},
+				{416, 203, 109, 87, 78},
+				{406, 205, 110, 88, 79},
+				{424, 203, 110, 88, 79},
+				{420, 212, 111, 88, 79},
+				{423, 209, 111, 89, 79},
+				{424, 211, 110, 89, 79},
+				{423, 209, 112, 90, 79},
+				{436, 215, 113, 91, 80},
+				{434, 206, 113, 91, 81},
+				{431, 210, 115, 92, 81},
+				{451, 206, 115, 93, 82},
+				{422, 222, 117, 94, 83},
+				{448, 285, 136, 117, 218}
+	}
+};
+
+static struct sf_lut r2batt = {
+	.rows		= 31,
+	.cols		= 5,
+	.temp		= {-20, 0, 25, 40, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+	.r2		= {
+				{1463, 220, 40, 26, 17},
+				{1462, 220, 40, 27, 17},
+				{1433, 226, 48, 31, 20},
+				{1378, 247, 55, 36, 23},
+				{1394, 255, 63, 41, 27},
+				{1381, 276, 72, 48, 31},
+				{1414, 264, 81, 53, 35},
+				{1451, 259, 90, 60, 39},
+				{1482, 267, 83, 62, 41},
+				{1515, 277, 46, 34, 22},
+				{1595, 294, 46, 30, 21},
+				{1683, 320, 52, 35, 26},
+				{1775, 364, 60, 42, 31},
+				{1882, 412, 68, 44, 34},
+				{2095, 461, 75, 43, 30},
+				{2462, 518, 77, 38, 24},
+				{2880, 572, 75, 35, 22},
+				{3187, 630, 70, 32, 18},
+				{3086, 654, 70, 31, 20},
+				{3221, 678, 83, 38, 24},
+				{3443, 707, 90, 42, 25},
+				{3733, 724, 98, 45, 26},
+				{4085, 763, 107, 47, 27},
+				{4509, 790, 114, 49, 23},
+				{5060, 818, 107, 44, 23},
+				{5765, 845, 106, 41, 27},
+				{6691, 895, 116, 47, 35},
+				{8051, 955, 135, 64, 52},
+				{10441, 1060, 186, 91, 62},
+				{17695, 1799, 241, 116, 94},
+				{50541, 15950, 3052, 2972, 645}
+	}
+};
+#endif
+
+static struct pc_temp_ocv_lut pc_temp_ocv = {
+	.rows		= 31,
+	.cols		= 5,
+	.temp		= {-20, 0, 25, 40, 60},
+	.percent	= {100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 16, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
+	.ocv		= {
+				{4333, 4332, 4327, 4323, 4315},
+				{4247, 4259, 4261, 4260, 4255},
+				{4177, 4200, 4206, 4205, 4200},
+				{4114, 4144, 4152, 4151, 4147},
+				{4056, 4091, 4100, 4100, 4096},
+				{3989, 4039, 4053, 4053, 4048},
+				{3942, 3980, 4005, 4006, 4003},
+				{3902, 3934, 3963, 3966, 3963},
+				{3865, 3895, 3920, 3924, 3922},
+				{3835, 3860, 3869, 3873, 3871},
+				{3810, 3830, 3840, 3842, 3841},
+				{3789, 3806, 3817, 3819, 3818},
+				{3770, 3788, 3797, 3799, 3798},
+				{3753, 3773, 3782, 3781, 3780},
+				{3737, 3759, 3769, 3765, 3759},
+				{3720, 3742, 3753, 3746, 3733},
+				{3702, 3723, 3729, 3722, 3707},
+				{3683, 3707, 3697, 3691, 3677},
+				{3665, 3695, 3683, 3677, 3665},
+				{3650, 3686, 3681, 3674, 3663},
+				{3641, 3681, 3679, 3673, 3661},
+				{3629, 3676, 3677, 3671, 3659},
+				{3615, 3669, 3673, 3668, 3655},
+				{3598, 3658, 3666, 3661, 3644},
+				{3577, 3639, 3643, 3642, 3614},
+				{3548, 3606, 3603, 3604, 3573},
+				{3507, 3556, 3549, 3555, 3523},
+				{3449, 3488, 3483, 3497, 3463},
+				{3363, 3392, 3403, 3425, 3382},
+				{3233, 3263, 3284, 3316, 3256},
+				{3000, 3000, 3000, 3000, 3000}
+	}
+};
+
+#if 0
+static struct pc_sf_lut  pc_sf = {
+	.rows		= 1,
+	.cols		= 1,
+	.cycles		= {0},
+	.percent	= {100},
+	.sf			= {
+				{100}
+	}
+};
+#endif
+
+struct bms_battery_data ztemt_2400mAh_data = {
+	.fcc				= 2400,
+	.fcc_temp_lut			= &fcc_temp,
+	.fcc_sf_lut				= &fcc_sf,
+	.pc_temp_ocv_lut		= &pc_temp_ocv,
+#if 0
+	.pc_sf_lut				= &pc_sf,
+#endif	
+	.rbatt_sf_lut			= &rbatt_sf,
+	.default_rbatt_mohm	= 129
+};
diff --git a/arch/arm/mach-msm/board-8226-gpiomux.c b/arch/arm/mach-msm/board-8226-gpiomux.c
old mode 100644
new mode 100755
index 08566bb..9eaf8b2
--- a/arch/arm/mach-msm/board-8226-gpiomux.c
+++ b/arch/arm/mach-msm/board-8226-gpiomux.c
@@ -154,22 +154,32 @@ static struct gpiomux_setting gpio_spi_act_config = {
 	.pull = GPIOMUX_PULL_NONE,
 };
 
+#if 0
 static struct gpiomux_setting gpio_spi_cs_act_config = {
 	.func = GPIOMUX_FUNC_1,
 	.drv = GPIOMUX_DRV_6MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
+#endif
 static struct gpiomux_setting gpio_spi_susp_config = {
 	.func = GPIOMUX_FUNC_GPIO,
 	.drv = GPIOMUX_DRV_2MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
+#ifdef CONFIG_ZTEMT_NE501_LCD
+static struct gpiomux_setting gpio_lcd_id0_config = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+#else
 static struct gpiomux_setting gpio_spi_cs_eth_config = {
 	.func = GPIOMUX_FUNC_4,
 	.drv = GPIOMUX_DRV_6MA,
 	.pull = GPIOMUX_PULL_DOWN,
 };
+#endif
 
 static struct gpiomux_setting wcnss_5wire_suspend_cfg = {
 	.func = GPIOMUX_FUNC_GPIO,
@@ -238,6 +248,34 @@ static struct gpiomux_setting lcd_rst_sus_cfg = {
 	.pull = GPIOMUX_PULL_DOWN,
 };
 
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+static struct gpiomux_setting lcd_en_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting lcd_en_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+static struct gpiomux_setting lcd_avdd_neg_en_act_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_8MA,
+	.pull = GPIOMUX_PULL_NONE,
+	.dir = GPIOMUX_OUT_HIGH,
+};
+
+static struct gpiomux_setting lcd_avdd_neg_en_sus_cfg = {
+	.func = GPIOMUX_FUNC_GPIO,
+	.drv = GPIOMUX_DRV_2MA,
+	.pull = GPIOMUX_PULL_DOWN,
+};
+#endif
+
 static struct msm_gpiomux_config msm_lcd_configs[] __initdata = {
 	{
 		.gpio = 25,		/* LCD Reset */
@@ -246,6 +284,24 @@ static struct msm_gpiomux_config msm_lcd_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &lcd_rst_sus_cfg,
 		},
 	},
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd  ctl board2 add ,mayu 6.25*/
+	{
+		.gpio = 33,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &lcd_en_act_cfg,
+			[GPIOMUX_SUSPENDED] = &lcd_en_sus_cfg,
+		},
+	},
+	{
+		.gpio = 34,
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &lcd_avdd_neg_en_act_cfg ,
+			[GPIOMUX_SUSPENDED] = &lcd_avdd_neg_en_sus_cfg ,
+		},
+	},
+#else
+/*qcom ori*/
 	{
 		.gpio = 109,		/* LCD Enable */
 		.settings = {
@@ -253,6 +309,7 @@ static struct msm_gpiomux_config msm_lcd_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &lcd_rst_sus_cfg,
 		},
 	}
+#endif
 };
 
 static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
@@ -270,6 +327,29 @@ static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
 		},
 	},
+	#if 1
+	{
+		.gpio      = 2,		/* BLSP1 QUP1 I2C_SDA */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	{
+		.gpio      = 3,		/* BLSP1 QUP1 I2C_SCL */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_i2c_config,
+			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
+		},
+	},
+	#else
+	{
+		.gpio      = 2,		/* BLSP1 QUP1 SPI_CS1 */
+		.settings = {
+			[GPIOMUX_ACTIVE] = &gpio_spi_cs_act_config,
+			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
+		},
+	},
 	{
 		.gpio      = 3,		/* BLSP1 QUP1 SPI_CLK */
 		.settings = {
@@ -277,6 +357,7 @@ static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gpio_spi_susp_config,
 		},
 	},
+	#endif
 	{
 		.gpio      = 14,	/* BLSP1 QUP4 I2C_SDA */
 		.settings = {
@@ -305,12 +386,21 @@ static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gpio_i2c_config,
 		},
 	},
+#ifdef CONFIG_ZTEMT_NE501_LCD
+	{
+		.gpio      = 22,		/* LCD ID0 */
+		.settings = {
+			[GPIOMUX_SUSPENDED] = &gpio_lcd_id0_config,
+		},
+	},
+#else
 	{
 		.gpio      = 22,		/* BLSP1 QUP1 SPI_CS_ETH */
 		.settings = {
 			[GPIOMUX_SUSPENDED] = &gpio_spi_cs_eth_config,
 		},
 	},
+#endif
 	{					/*  NFC   */
 		.gpio      = 10,		/* BLSP1 QUP3 I2C_DAT */
 		.settings = {
@@ -326,7 +416,7 @@ static struct msm_gpiomux_config msm_blsp_configs[] __initdata = {
 		},
 	},
 };
-
+#if 0
 static struct msm_gpiomux_config msm_blsp_spi_cs_config[] __initdata = {
 	{
 		.gpio      = 2,		/* BLSP1 QUP1 SPI_CS1 */
@@ -336,7 +426,7 @@ static struct msm_gpiomux_config msm_blsp_spi_cs_config[] __initdata = {
 		},
 	},
 };
-
+#endif
 static struct msm_gpiomux_config msm_synaptics_configs[] __initdata = {
 	{
 		.gpio = 16,
@@ -415,12 +505,15 @@ static struct msm_gpiomux_config msm_skuf_blsp_configs[] __initdata = {
 			[GPIOMUX_SUSPENDED] = &gpio_nc_cfg,
 		},
 	},
+#ifdef CONFIG_ZTEMT_CAMERA
+#else	
 	{
 		.gpio      = 14,	/* NC */
 		.settings = {
 			[GPIOMUX_SUSPENDED] = &gpio_nc_cfg,
 		},
 	},
+#endif	
 };
 
 static struct msm_gpiomux_config msm_skuf_goodix_configs[] __initdata = {
@@ -683,6 +776,22 @@ static struct gpiomux_setting cam_settings[] = {
 
 
 static struct msm_gpiomux_config msm_sensor_configs[] __initdata = {
+#ifdef CONFIG_ZTEMT_CAMERA   //tanyijun add   for avdd enable
+	{
+		.gpio = 12, /* AVDD enable for front camera */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &cam_settings[4],
+		},
+	},
+	{
+		.gpio = 14, /* AVDD enable for back camera */
+		.settings = {
+			[GPIOMUX_ACTIVE]    = &cam_settings[3],
+			[GPIOMUX_SUSPENDED] = &cam_settings[4],
+		},
+	},
+#endif
 	{
 		.gpio = 26, /* CAM_MCLK0 */
 		.settings = {
@@ -926,9 +1035,11 @@ void __init msm8226_init_gpiomux(void)
 	else {
 		msm_gpiomux_install(msm_blsp_configs,
 			ARRAY_SIZE(msm_blsp_configs));
+#if 0
 		if (machine_is_msm8226())
 			msm_gpiomux_install(msm_blsp_spi_cs_config,
 				ARRAY_SIZE(msm_blsp_spi_cs_config));
+#endif
 	}
 
 	msm_gpiomux_install(wcnss_5wire_interface,
diff --git a/arch/arm/mach-msm/clock-8226.c b/arch/arm/mach-msm/clock-8226.c
old mode 100644
new mode 100755
index d16d0f1..9c12ebb
--- a/arch/arm/mach-msm/clock-8226.c
+++ b/arch/arm/mach-msm/clock-8226.c
@@ -3278,6 +3278,11 @@ static struct clk_lookup msm_clocks_8226[] = {
 	CLK_LOOKUP("dfab_clk",            pnoc_sps_clk.c, "msm_sps"),
 	CLK_LOOKUP("dma_bam_pclk", gcc_bam_dma_ahb_clk.c, "msm_sps"),
 
+#if 1
+	/* I2C Clocks */
+	CLK_LOOKUP("iface_clk",          gcc_blsp1_ahb_clk.c, "f9923000.i2c"),
+	CLK_LOOKUP("core_clk", gcc_blsp1_qup1_i2c_apps_clk.c, "f9923000.i2c"),
+#endif
 	/* I2C Clocks */
 	CLK_LOOKUP("iface_clk",          gcc_blsp1_ahb_clk.c, "f9926000.i2c"),
 	CLK_LOOKUP("core_clk", gcc_blsp1_qup4_i2c_apps_clk.c, "f9926000.i2c"),
@@ -3408,13 +3413,21 @@ static struct clk_lookup msm_clocks_8226[] = {
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "90.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6d.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6a.qcom,camera"),
+#ifdef CONFIG_ZTEMT_CAMERA
+	CLK_LOOKUP("cam_src_clk", mclk1_clk_src.c, "6c.qcom,camera"),
+#else
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "6c.qcom,camera"),
+#endif
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "20.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6f.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "90.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6d.qcom,camera"),
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6a.qcom,camera"),
+#ifdef CONFIG_ZTEMT_CAMERA
+	CLK_LOOKUP("cam_clk", camss_mclk1_clk.c, "6c.qcom,camera"),
+#else
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "6c.qcom,camera"),
+#endif
 	CLK_LOOKUP("cam_clk", camss_mclk0_clk.c, "20.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "0.qcom,camera"),
 	CLK_LOOKUP("cam_src_clk", mclk0_clk_src.c, "1.qcom,camera"),
diff --git a/arch/arm/mach-msm/include/mach/board.h b/arch/arm/mach-msm/include/mach/board.h
old mode 100644
new mode 100755
index c7f8b74..26d0ad1
--- a/arch/arm/mach-msm/include/mach/board.h
+++ b/arch/arm/mach-msm/include/mach/board.h
@@ -208,6 +208,9 @@ struct msm_camera_gpio_conf {
 	uint32_t *camera_on_table;
 	uint8_t camera_on_table_size;
 	struct msm_camera_gpio_num_info *gpio_num_info;
+#ifdef CONFIG_ZTEMT_CAMERA
+	uint32_t camera_avdd_enable_gpio;  //tanyijun add 
+#endif
 };
 
 enum msm_camera_i2c_mux_mode {
diff --git a/arch/arm/mach-msm/include/mach/restart.h b/arch/arm/mach-msm/include/mach/restart.h
old mode 100644
new mode 100755
index 84bb91d..f502944
--- a/arch/arm/mach-msm/include/mach/restart.h
+++ b/arch/arm/mach-msm/include/mach/restart.h
@@ -26,6 +26,9 @@ void fsm_restart(char mode, const char *cmd);
 #define msm_set_restart_mode(mode)
 #endif
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+extern void *restart_reason;
+#endif
 extern int pmic_reset_irq;
 
 #endif
diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
old mode 100644
new mode 100755
index cbb463b..3309346
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -23,7 +23,9 @@
  * if wakeup events are registered during or immediately before the transition.
  */
 bool events_check_enabled __read_mostly;
-
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+extern bool wakeup_wake_lock_debug;
+#endif
 /*
  * Combined counters of registered wakeup events and wakeup events in progress.
  * They need to be modified together atomically, so it's better to use one
@@ -400,7 +402,12 @@ static void wakeup_source_report_event(struct wakeup_source *ws)
 	/* This is racy, but the counter is approximate anyway. */
 	if (events_check_enabled)
 		ws->wakeup_count++;
-
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	if (wakeup_wake_lock_debug){
+	  wakeup_wake_lock_debug = false;
+	  printk("First wakeup lock:%s\n", ws->name);
+	}
+	#endif
 	if (!ws->active)
 		wakeup_source_activate(ws);
 }
@@ -765,6 +772,31 @@ void pm_wakep_autosleep_enabled(bool set)
 
 static struct dentry *wakeup_sources_stats_dentry;
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+void global_print_active_locks_debug(struct wakeup_source *ws)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ws->lock, flags);
+
+	if (ws->active) {
+		printk("active wake lock %s\n", ws->name);
+	} 
+	spin_unlock_irqrestore(&ws->lock, flags);
+}
+
+void global_print_active_locks(void *unused)
+{
+	struct wakeup_source *ws;
+  
+	rcu_read_lock();
+	list_for_each_entry_rcu(ws, &wakeup_sources, entry)
+		global_print_active_locks_debug(ws);
+	rcu_read_unlock();
+
+}
+
+#endif
 /**
  * print_wakeup_source_stats - Print wakeup source statistics information.
  * @m: seq_file to print the statistics into.
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
old mode 100644
new mode 100755
index 1ed287a..c691705
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1426,6 +1426,124 @@ config SENSORS_MC13783_ADC
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+################################################# SENROS START
+menuconfig ZTEMT_SENSORS
+	tristate "ZTEMT ZTEMT_SENSORS"
+	default n	       
+
+if ZTEMT_SENSORS
+
+	config FEATURE_ZTEMT_SENSORS_LOG_ON
+	tristate "ZTEMT SENSORS LOG ON"
+	depends on ZTEMT_SENSORS
+	default n	
+	help 
+		If you want to enable the sensor log,
+		then choose this config 
+
+################################################# SENSOR_COMMON START
+	config ZTEMT_SENSORS_COMMON
+	tristate "ZTEMT SENSORS COMMON"
+	depends on ZTEMT_SENSORS
+	default n	
+	help 
+		If you want to enable the sensor common,
+		then choose this config 
+################################################# SENSOR_COMMON END
+		
+################################################# ALS_PS START
+menuconfig ZTEMT_SENSORS_ALS_PS
+	tristate "ZTEMT ALS and PS"
+	default n
+
+if ZTEMT_SENSORS_ALS_PS
+
+config ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+	tristate "ALS_PS_SENSOR auto detect"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here,the ALS_PS_SENSOR is auto detect
+
+config ZTEMT_SENSORS_ALS_PS_TMG3993
+	tristate "TMG3993 device driver"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMG3993
+
+config ZTEMT_SENSORS_ALS_PS_TMD2772
+	tristate "TMD2772 device driver"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMD2772
+	  
+config ZTEMT_SENSORS_ALS_PS_TMD2772_NE501J
+	tristate "TMD2772 device driver for NE501J structure "
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMD2772
+
+config ZTEMT_SENSORS_ALS_PS_TMD2772_NX404H
+	tristate "TMD2772 device driver for NX404H structure"
+	depends on ZTEMT_SENSORS_ALS_PS
+	help
+	  If you say yes here you get support for AMS's 
+	  als ps TMD2772
+endif
+################################################# ALS_PS END	
+
+
+################################################# TEMP_HUMI START
+menuconfig ZTEMT_SENSORS_TEMP_HUMI
+	tristate "ZTEMT TEMP and HUMI"
+	default n
+
+if ZTEMT_SENSORS_TEMP_HUMI
+
+config ZTEMT_SENSORS_TEMP_HUMI_SHTC1
+	tristate "SHTC1 device driver"
+	depends on ZTEMT_SENSORS_TEMP_HUMI
+	help
+	  If you say yes here you get support for Sensirion's 
+	  als ps SHTC1
+endif
+################################################# ALS_PS END	
+
+################################################# IR REMOTE START
+menuconfig ZTEMT_SENSORS_IR_REMOTE
+	tristate "ZTEMT IR REMOTE CONTROL"
+	default n
+
+if ZTEMT_SENSORS_IR_REMOTE
+
+config ZTEMT_SENSORS_IR_REMOTE_MAXQ616
+	tristate "MAXQ616 device driver"
+	depends on ZTEMT_SENSORS_IR_REMOTE
+	help
+	  If you say yes here you get support for UEI's 
+	  IR Remote control maxq616
+endif
+################################################# IR REMOTE END	
+
+endif
+################################################# SENROS END
+
+# ZTEMT ADD by hongdanlong
+config ZTEMT_LIQUID_LED
+	bool "ZTEMT liquid led"
+	default n
+	help
+	  ZTEMT liquid led
+#ZTEMT END 
+#+++
+config ZTEMT_BREATH_LED_GPIO_I2C
+	bool "ZTEMT liquid led gpio i2c"
+	default y
+	help
+	  ZTEMT liquid led
+#---
 if ACPI
 
 comment "ACPI drivers"
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
old mode 100644
new mode 100755
index ad5c6bb..27a3bee
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -133,6 +133,31 @@ obj-$(CONFIG_SENSORS_EPM_ADC)	+= epm_adc.o
 obj-$(CONFIG_SENSORS_QPNP_ADC_VOLTAGE)	+= qpnp-adc-voltage.o qpnp-adc-common.o
 obj-$(CONFIG_SENSORS_QPNP_ADC_CURRENT)	+= qpnp-adc-current.o qpnp-adc-common.o
 
+################################################# SENROS START
+		
+################################################# ALS_PS START
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT) += als_prox.o tmg399x.o tmd2772_ne501j.o tmd2772_nx404h.o
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMG3993) += tmg399x.o
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772) += tmd2772.o
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772_NE501J) += tmd2772_ne501j.o
+obj-$(CONFIG_ZTEMT_SENSORS_ALS_PS_TMD2772_NX404H) += tmd2772_nx404h.o
+################################################# ALS_PS END
+
+################################################# TEMP_HUMI START
+obj-$(CONFIG_ZTEMT_SENSORS_TEMP_HUMI)      += shtc1.o
+################################################# TEMP_HUMI END
+
+################################################# TEMP_HUMI START
+obj-$(CONFIG_ZTEMT_SENSORS_COMMON)      += sensor_common.o
+################################################# TEMP_HUMI END
+
+
+################################################# IR_REMOTE START
+obj-$(CONFIG_ZTEMT_SENSORS_IR_REMOTE_MAXQ616)      += maxq616.o
+################################################# IR_REMOTE END
+#ZTEMT ADD by wangshuai
+obj-$(CONFIG_ZTEMT_LIQUID_LED)      += aw_9106b.o
+#ZTEMT END
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
 ccflags-$(CONFIG_HWMON_DEBUG_CHIP) := -DDEBUG
diff --git a/drivers/hwmon/aw_9106b.c b/drivers/hwmon/aw_9106b.c
new file mode 100755
index 0000000..9fd1b58
--- /dev/null
+++ b/drivers/hwmon/aw_9106b.c
@@ -0,0 +1,1246 @@
+/***********************************************************************************/
+/* File Name: aw_9106b.c */
+/* File Description: this file is used to make aw9106b driver to be added in kernel or module. */
+
+/*  Copyright (c) 2002-2012, ZTEMT, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: ZTEMT, Inc.,            */
+/***********************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <linux/kobject.h>
+#include <linux/io.h>
+#include <linux/kthread.h>
+
+#include <linux/bug.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/spinlock_types.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/earlysuspend.h>
+
+#include <linux/i2c.h>
+#include "aw_9106b.h"
+#include  <../../include/linux/printk.h>
+
+static bool AW9106B_SUSPEND_FLAG=false; 
+//#define GPIO_PWDN 28
+#define GPIO_PWDN 15
+#define DELAY_256MS_UNIT 1
+#define AW_DRIVER_NAME "aw9106bdrv"
+#define DRV_NAME "class/leds/red/outn"
+//#define AW_GPIO_CONFIG
+
+#define AW_LED_DELAY_MS 650
+#define TIME_MS_UNIT  1000000ULL
+#define CONST_MIN_GRADE  10
+#define CONST_MAX_GRADE  200
+#define START_OUTN 3
+#define END_OUTN 5
+#define FADE_PARAM_LEN 20
+#define GRADE_PARAM_LEN 20
+#if 0
+enum aw_fade_time {
+	FADE_0_MS = 0x00,
+	FADE_256_MS = 0x09,
+	FADE_512_MS = 0x12,
+	FADE_1024_MS = 0x1b,
+	FADE_2048_MS = 0x24,
+	FADE_4096_MS = 0x2d,
+};
+enum aw_fullon_time {
+	FULLON_0_MS,
+	FULLON_256_MS,
+	FULLON_512_MS,
+	FULLON_1024_MS,
+	FULLON_2048_MS,
+	FULLON_4096_MS,
+	FULLON_8192_MS,
+	FULLON_16384_MS,
+};
+
+enum aw_fulloff_time {
+	FULLOFF_0_MS = 0x00,
+	FULLOFF_256_MS = 0x08,
+	FULLOFF_512_MS = 0x10,
+	FULLOFF_1024_MS = 0x18,
+	FULLOFF_2048_MS = 0x20,
+	FULLOFF_4096_MS = 0x28,
+	FULLOFF_8192_MS = 0x30,
+	FULLOFF_16384_MS = 0x38,
+};
+#endif
+enum aw_fade_time {
+	FADE_0_MS,
+	FADE_256_MS,
+	FADE_512_MS,
+	FADE_1024_MS,
+	FADE_2048_MS,
+	FADE_4096_MS,
+};
+enum aw_fullon_time {
+	FULLON_0_MS,
+	FULLON_256_MS,
+	FULLON_512_MS,
+	FULLON_1024_MS,
+	FULLON_2048_MS,
+	FULLON_4096_MS,
+	FULLON_8192_MS,
+	FULLON_16384_MS,
+};
+
+enum aw_fulloff_time {
+	FULLOFF_0_MS,
+	FULLOFF_256_MS,
+	FULLOFF_512_MS,
+	FULLOFF_1024_MS,
+	FULLOFF_2048_MS,
+	FULLOFF_4096_MS,
+	FULLOFF_8192_MS,
+	FULLOFF_16384_MS,
+};
+enum aw_max_current {
+	MAX_37_MA,
+	MAX_27_8__MA,
+	MAX_18_5__MA,
+	MAX_9_25__MA,
+};
+
+enum aw_ctl {
+	AW_CTL_DISABLE,
+	AW_CTL_ENABLE,
+};
+
+enum aw_reg_ctl {
+	REG_BIT_CLEAR,
+	REG_BIT_SET,
+};
+
+enum aw_gpio_led {
+	AW_LED_MODE,
+	AW_GPIO_MODE,
+};
+
+enum aw_smart_blink{
+	AW_SMART_MODE,
+	AW_BLINK_MODE,
+};
+
+enum aw_smart_fade{
+	AW_FADE_OFF,
+	AW_FADE_ON,
+};
+
+enum aw_led_close_mode{
+	AW_CLOSE_NOW,
+	AW_CLOSE_DELAY,
+};
+
+enum aw_power_state{
+	AW_POWER_DOWN,
+	AW_POWER_ON,
+};
+
+enum aw_out_val{
+	AW_OUT_LOW,
+	AW_OUT_HIGH,
+};
+
+enum aw_outn_mode{
+	AW_POWER_OFF,// 0
+	AW_CONST_ON,  // 1
+	AW_CONST_OFF, // 2
+	AW_FADE_AUTO, // 3 
+	AW_FADE_ON_STEP,  // 4
+	AW_FADE_OFF_STEP, // 5
+	AW_FADE_CYCLE, // 6
+	AW_RESERVED, //7
+};
+#if 0
+typedef struct {
+	enum aw_fade_time fade_t;
+	enum aw_fullon_time fullon_t;
+	enum aw_fulloff_time fulloff_t;
+	enum aw_max_current max_ma;
+} breath_config;
+
+typedef struct {
+	enum aw_fade_time fade_t;
+	enum aw_max_current max_ma;
+} smart_config;
+
+typedef struct  {
+	breath_config breath_t[3];
+	smart_config  smart_t[2];
+} aw9106b_config_param;
+#endif
+typedef struct {
+	u16 in_mode;
+	u16 dim_grade;
+	u16 grade_updown;
+} fade_data;
+
+static int debug_mask = 0;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define AW_DBG(x...) do {if (debug_mask) pr_info("aw9106b  " x); } while (0)
+
+static int max_current = MAX_9_25__MA;
+module_param(max_current, int, 0644);
+
+static int min_grade = CONST_MIN_GRADE;
+static int max_grade = CONST_MAX_GRADE;
+static int start_grade = CONST_MIN_GRADE;
+static char grade_parameter[GRADE_PARAM_LEN];
+
+static int fade_time= FADE_2048_MS;
+static int fullon_time= FULLON_0_MS;
+static int fulloff_time= FULLOFF_4096_MS;
+static char fade_parameter[FADE_PARAM_LEN];
+
+static int outn = 0;
+static u16 aw_running = 0;
+static int timer_running = 0;
+static int fade_outn = 0;
+fade_data fade[6];
+struct aw9106b_plat_data aw9106b_data;
+static struct aw9106b_regs_data aw9106b_regs = 
+{
+	.en_bre = 0x14 ,
+	.smart_blink = 0x05,
+	.in_out = 0x05,
+	.out_val = 0x03,
+	.smart_fade = 0x03,
+	.led_gpio = 0x13,
+	.fade_tmr = 0x15,
+	.full_tmr = 0x16,
+	.delay_bre0 = 0x17,
+	.dim0 = 0x20,
+	.aw_reset = 0x7f,
+	.ctl = 0x11,
+};
+#if 0
+aw9106b_config_param aw_config = {
+	.breath_t = {
+		{FADE_2048_MS,FULLON_0_MS,FULLOFF_4096_MS,MAX_9_25__MA},
+		{FADE_2048_MS,FULLON_0_MS,FULLOFF_4096_MS,MAX_9_25__MA},
+		{FADE_1024_MS,FULLON_0_MS,FULLOFF_2048_MS,MAX_9_25__MA}
+	},
+	.smart_t ={
+		{FADE_2048_MS,MAX_9_25__MA},
+		{FADE_2048_MS,MAX_9_25__MA}
+	},
+};
+#endif
+#ifdef CONFIG_OF
+static struct of_device_id aw_9106b_match_table[] = {
+	{ .compatible = "aw,9106b", },
+	{}
+};
+#endif
+
+/******************************************************** 
+ *					 I2C I/O function 				              *
+ *********************************************************/
+
+//read aw9106b i2c function
+static int aw9106b_i2c_rx_byte_data(
+		struct i2c_client *i2c,
+		unsigned char  reg,
+		unsigned char* buf)
+{
+
+	struct i2c_msg msgs[2];
+
+	//write message: this is the sub address that we are reading from
+	msgs[0].addr = i2c->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg;
+
+	//read message: now we read into the buffer
+	msgs[1].addr = i2c->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = buf;
+
+	if (i2c_transfer(i2c->adapter, msgs, 2) < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.\n", __func__);
+		return -4;
+	}
+	pr_debug("return  buf[0]=0x%x!\n",buf[0]);
+
+	return 0;
+}
+
+//write aw9106b i2c function
+static int aw9106b_i2c_tx_byte_data(
+		struct i2c_client *i2c,
+		unsigned char reg, 
+		unsigned char buf)
+{
+	struct i2c_msg msgs;
+	char bufwr[2];
+
+	bufwr[0] = reg;
+	bufwr[1] = buf;
+
+	//write message: this is the sub address that we are reading from
+	msgs.addr = i2c->addr;
+	msgs.flags = 0;
+	msgs.len = 2;
+	msgs.buf = bufwr;
+
+	if (i2c_transfer(i2c->adapter, &msgs, 1) < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.\n", __func__);
+		return -4;
+	}
+
+	return 0;
+}
+
+//modigy aw9106b i2c function
+static int aw9106b_modify_regs(int reg,char bitn,enum aw_reg_ctl set)
+{
+	char buf = 0;
+	int ret;
+
+	ret = aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,reg,&buf);
+	if(ret < 0)
+		pr_err("%s: read reg[0x%x] fail!\n",__func__,reg);
+
+	if(set == REG_BIT_SET)
+		buf |= (0x01 << bitn);
+	else
+		buf &= ~(0x01 << bitn);
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+
+	return ret;
+
+}
+
+static void aw9106b_power_set(enum aw_power_state power_set)
+{
+	gpio_set_value(GPIO_PWDN, power_set);
+	AW_DBG("aw9106b_power_set = %d,GPIO_PWDN = %d\n", power_set,GPIO_PWDN);
+}
+
+static int set_fade_time(int fade_t)
+{
+	char buf;
+	int ret;
+
+	buf = fade_t;
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.fade_tmr,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.fade_tmr);
+
+	return ret;
+}
+
+static int set_full_onoff_time(int full_on, int full_off)
+{
+	char buf;
+	int ret;
+
+	buf = full_on | full_off;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.full_tmr,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.full_tmr);
+	return ret;
+}
+/******************************************************** 
+ *                                Config AW Outn mode                                 *
+ *********************************************************/
+
+static int set_out_led_gpio(int out,enum aw_gpio_led gpmd_mode)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.led_gpio;
+		shift = out;
+	}
+	else{
+		reg = 0x12;
+		shift = out - AW_OUT_4;
+	}
+
+	if(gpmd_mode == AW_LED_MODE)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_breath(int out,enum aw_ctl enable)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.en_bre;
+	if( enable == AW_CTL_DISABLE )
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,out,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_smart_blink(int out,enum aw_smart_blink blink_cfg)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.smart_blink;
+		shift = out;
+	}
+	else{
+		reg = 0x04;
+		shift = out - AW_OUT_4;
+	}
+
+	if(blink_cfg == AW_SMART_MODE)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_smart_fade(int out,enum aw_smart_fade fade_onoff)
+{
+	enum aw_reg_ctl set;
+	int ret;
+	int reg;
+	int shift;
+
+	if( out <= AW_OUT_3 ){
+		reg = aw9106b_regs.smart_fade;
+		shift = out;
+	}
+	else{
+		reg = 0x02;
+		shift = out - AW_OUT_4;
+	}
+
+	if(fade_onoff == AW_FADE_OFF)
+		set = REG_BIT_CLEAR;
+	else
+		set = REG_BIT_SET;
+
+	ret = aw9106b_modify_regs(reg,shift,set);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_delay_time(int out,int delay_unit)
+{
+	char buf;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.delay_bre0 + out;
+
+	buf = delay_unit;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_out_dim_grade(int out,char grade)
+{
+	char buf;
+	int ret;
+	int reg;
+
+	reg = aw9106b_regs.dim0 + out;
+
+	buf = grade;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,reg,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,reg);
+	return ret;
+}
+
+static int set_const_current(enum aw_max_current max_i)
+{
+	char buf;
+	int ret;
+
+	buf = max_i;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+static int start_blink_led(enum aw_max_current max_i)
+{
+	char buf;
+	int ret;
+
+	buf = max_i | 0x80;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+static int close_out_blink_led(enum aw_led_close_mode close_mode)
+{
+	char buf;
+	int ret;
+
+	buf = 0;
+
+	if(close_mode == AW_CLOSE_NOW)
+		ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.en_bre,buf);
+	else
+		ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.smart_blink,buf);
+
+
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.ctl);
+	return ret;
+}
+
+int aw_full_fade_time_confg(int fade_t,	int full_on, int full_off)
+{
+	int ret;
+	fade_t = (fade_t<<3) + fade_t;
+	full_off = full_off<<3;
+	AW_DBG("fade_t= %d, full_on=%d full_off=%d\n",fade_t,full_on,full_off);
+	ret = set_fade_time(fade_t);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	ret = set_full_onoff_time(full_on,full_off);
+	if(ret < 0)
+		pr_err("%s: config full time fail!\n",__func__);
+
+	return ret;
+}
+
+static void aw9106b_control_init(void)
+{
+	outn = 0;
+	aw_running = 0;
+}
+
+static void aw9106b_fade_data_init(void)
+{
+	int i;
+
+	for(i=0; i<6;i++){
+		fade[i].in_mode = 0;
+		fade[i].dim_grade = 0;
+		fade[i].grade_updown = 1;
+	}
+	timer_running = 0;
+	fade_outn = 0;
+}
+
+static int aw9106b_solft_reset(void)
+{
+	char buf;
+	int ret;
+	buf = 0x00;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.aw_reset,buf);
+	if(ret < 0)
+		pr_err("%s: write reg[0x%x] fail!\n",__func__,aw9106b_regs.aw_reset);
+	return ret;
+}
+
+#ifdef AW_GPIO_CONFIG
+static int set_out0_gpio_value(enum aw_out_val out_val)
+{
+	char buf;
+	int ret;
+
+	buf = out_val;
+
+	ret = aw9106b_i2c_tx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.out_val,buf);
+	if(ret < 0)
+		pr_err("%s: write out_val[0x%x] fail!\n",__func__,aw9106b_regs.out_val);
+	return ret;
+}
+int enable_out0_gpio(enum aw_out_val out_val)
+{
+
+	int ret;
+	//power on aw9106b
+	aw9106b_power_set(AW_POWER_ON);
+
+	ret = set_out_led_gpio(aw9106b_data.outn ,AW_GPIO_MODE);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	ret = set_out0_gpio_value(out_val);
+	if(ret < 0)
+		pr_err("%s: config fade time  fail!\n",__func__);
+
+	return ret;
+}
+
+#endif 
+
+void enable_outn_fade_onoff(int val, int max_ma, enum aw_smart_fade fade_onoff)
+{
+	int rc = 0;
+	int n = 0;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n))&&(fade[n].in_mode != val)){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			if(fade_onoff == AW_FADE_ON){
+				rc = set_out_breath(n,AW_CTL_DISABLE);
+				if(rc < 0)
+					pr_err("%s: diable out[%d] breath mode fail!\n",__func__,n);
+			}
+
+			//set fade,fullon,fulloff time
+			rc = aw_full_fade_time_confg(fade_time,FULLON_0_MS,FULLOFF_0_MS);
+			if(rc < 0)
+				pr_err("%s: config fade full on/off time fail!\n",__func__);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//enable outn breath func
+			rc = set_out_breath(n,AW_CTL_ENABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn blink
+			rc = set_out_smart_blink(n,AW_SMART_MODE);
+			if(rc < 0)
+				pr_err("%s: set out smart-fade mode fail!\n",__func__);
+
+			//set Imax
+			rc = set_const_current(max_ma);
+			if(rc < 0)
+				pr_err("%s: set imax fail!\n",__func__);
+
+			//set outn delay time
+			rc = set_out_delay_time(n,0*DELAY_256MS_UNIT);
+			if(rc < 0)
+				pr_err("%s: set out delay time fail!\n",__func__);
+
+			//set outn smart fade
+			rc = set_out_smart_fade(n,fade_onoff);
+			if(rc < 0)
+				pr_err("%s: start samrt-fade mode fail!\n",__func__);
+		}
+		outn &= ~(1<<n);
+		AW_DBG("fade_onoff outn= 0x%x\n",outn);
+	}
+}
+
+
+void enable_outn_const_led(int val,int max_ma, char grade)
+
+{
+
+	int rc = 0;
+	int n = 0;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n)&&(fade[n].in_mode != val))){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			//disable breathing mode
+			rc = set_out_breath(n,AW_CTL_DISABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//set Imax
+			rc = set_const_current(max_ma);
+			if(rc < 0)
+				pr_err("%s: set imax fail!\n",__func__);
+
+			//set const current = (grade/256)*imax
+			rc = set_out_dim_grade(n,grade);
+			if(rc < 0)
+				pr_err("%s: set out[%d] dim grade fail!\n",__func__,n);
+		}
+
+		//clean the corresponding bit of outn
+		outn &= ~(1<<n);
+		AW_DBG("const_led outn= 0x%x\n",outn);
+	}
+}
+
+
+void enable_outn_blink_led(int val, int max_ma)
+
+{
+	int rc = 0;
+	int n = 0;
+
+	aw9106b_fade_data_init();
+	rc = aw9106b_solft_reset();
+	if(rc < 0)
+		pr_err("%s: solft reset fail!\n",__func__);
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if((outn & (1<<n))&&(fade[n].in_mode != val)){
+			//store the corrent mode
+			fade[n].in_mode = val;
+
+			//set fade,fullon,fulloff time
+			rc = aw_full_fade_time_confg(fade_time,fullon_time,fulloff_time);
+			if(rc < 0)
+				pr_err("%s: config fade full on/off time fail!\n",__func__);
+
+			//set outn led mode
+			rc = set_out_led_gpio(n,AW_LED_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] LED mode fail!\n",__func__,n);
+
+			//enable outn breath func
+			rc = set_out_breath(n,AW_CTL_ENABLE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] breath mode fail!\n",__func__,n);
+
+			//set outn blink
+			rc = set_out_smart_blink(n,AW_BLINK_MODE);
+			if(rc < 0)
+				pr_err("%s: set out[%d] blink mode fail!\n",__func__,n);
+
+			//set outn delay time
+			rc = set_out_delay_time(n,0*DELAY_256MS_UNIT);
+			if(rc < 0)
+				pr_err("%s: set out[%d] delay time fail!\n",__func__,n);
+		}
+
+		//clean the corresponding bit of outn
+		outn &= ~(1<<n);
+		AW_DBG("blink_led outn= 0x%x\n",outn);
+	}
+
+	//start outn blink led
+	rc |= start_blink_led(max_ma);
+	if(rc < 0)
+		pr_err("%s: start blink fail!\n",__func__);
+}
+
+
+
+static void aw9106b_work_func(struct work_struct *work)
+
+{
+
+	int rc;
+	int n;
+
+	for(n = START_OUTN; n <= END_OUTN; n++){
+		if(fade_outn & (1<<n)){
+			if(fade[n].in_mode != AW_FADE_CYCLE){
+				//first time to set fade mode for this channel,disable breathing mode
+				rc = set_out_breath(n,AW_CTL_DISABLE);
+
+				//set outn led mode
+				rc |= set_out_led_gpio(n,AW_LED_MODE);
+
+				//set Imax
+				rc |= set_const_current(max_current);
+				if(rc < 0)
+					pr_err("%s: set imax fail!\n",__func__);
+
+				fade[n].in_mode = AW_FADE_CYCLE;
+				fade[n].dim_grade = min_grade;
+				fade[n].grade_updown = 1;
+				timer_running |= (1<<n);
+				AW_DBG("work_func:timer_running = 0x%x\n", timer_running);
+			}
+
+			if(fade[n].dim_grade == 0)
+				fade[n].dim_grade = start_grade;
+
+			if(fade[n].grade_updown == 1 && fade[n].dim_grade < max_grade)
+				fade[n].dim_grade++;
+			else if(fade[n].grade_updown == 2 && fade[n].dim_grade>min_grade)
+				fade[n].dim_grade--;
+
+			rc = set_out_dim_grade(n,fade[n].dim_grade);
+			if(rc < 0){
+				fade[n].in_mode = AW_CONST_ON;
+				fade[n].dim_grade = 0;
+				fade[n].grade_updown = 1;
+				timer_running &=~(1<<n);
+				fade_outn &=~(1<<n);
+				pr_err("%s: set out dim grade fail!\n",__func__);
+				return;
+			}
+
+			if(fade[n].grade_updown == 1 && fade[n].dim_grade>=max_grade)
+				fade[n].grade_updown = 2;
+
+			else if(fade[n].grade_updown == 2 && fade[n].dim_grade <= min_grade){
+				//fade cycle finish
+				fade[n].dim_grade = 0;
+				fade[n].in_mode = AW_CONST_ON;
+				fade[n].grade_updown = 1;
+				timer_running &=~(1<<n);
+				fade_outn &=~(1<<n);
+				AW_DBG("work_func:timer_running = 0x%x, fade_outn = 0x%x\n",timer_running, fade_outn);
+				AW_DBG("%s: end breath!\n",__func__);
+			}
+
+			if((timer_running & 0x3f) !=0)
+				hrtimer_start(&aw9106b_data.timer,ktime_set(0,1*TIME_MS_UNIT),HRTIMER_MODE_REL);
+		}
+	}
+}
+
+
+static enum hrtimer_restart aw9106b_timer(struct hrtimer *timer)
+
+{
+	schedule_work(&aw9106b_data.work);
+	return HRTIMER_NORESTART;
+}
+
+/*********************       aw9106b_breath_mode_set    *********************/
+
+void aw9106b_breath_mode_set(struct led_classdev *led_cdev,
+
+		enum led_brightness brightness)
+
+{
+	int val = brightness;
+	int rc = 0;
+    
+	if(AW9106B_SUSPEND_FLAG==true)return;
+
+	gpio_tlmm_config(GPIO_CFG(GPIO_PWDN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+	AW_DBG("val=%d fade_outn= 0x%x, outn= 0x%x \n",val,fade_outn, outn);
+
+	if (aw_running == 0 && val != AW_POWER_OFF) { 
+		aw9106b_power_set(AW_POWER_ON);
+		rc = aw9106b_solft_reset();
+		if(rc < 0)
+			pr_err("%s: solft reset fail!\n",__func__);
+		aw_running = 1;
+	}
+
+	switch (val) {
+		case AW_POWER_OFF:
+			aw9106b_fade_data_init();
+			aw9106b_control_init();
+			aw9106b_power_set(AW_POWER_DOWN);
+			break;
+
+		case AW_CONST_ON: 
+			enable_outn_const_led(val, max_current, min_grade);
+			break;
+
+		case AW_CONST_OFF:
+			enable_outn_const_led(val, max_current, 0);
+			break;
+
+			//blink breath mode
+		case AW_FADE_AUTO:
+			enable_outn_blink_led(val, max_current);
+			break;
+
+			//smart breath mode
+		case AW_FADE_ON_STEP:
+			enable_outn_fade_onoff(val, max_current,AW_FADE_ON);
+			break;
+
+		case AW_FADE_OFF_STEP:
+			enable_outn_fade_onoff(val,max_current,AW_FADE_OFF);
+			break;
+
+			//fade 1 cycle for press home key
+		case AW_FADE_CYCLE:
+			fade_outn |= outn;
+			if((timer_running & 0x3f) == 0){
+				AW_DBG("timer_running = 0x%x, start fade mode.\n",timer_running);
+				hrtimer_start(&aw9106b_data.timer,ktime_set(0,0),HRTIMER_MODE_REL);
+			}
+			break;
+
+		case AW_RESERVED:
+			break;
+
+		default:
+			break;
+
+	}
+}
+
+EXPORT_SYMBOL_GPL(aw9106b_breath_mode_set);
+
+
+static void aw9106b_show_regs(void)
+
+{
+	char buf[1];
+
+	//read EN_BRE
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.en_bre,buf);
+	printk("read  en_bre[0x%x]= 0x%x\n",aw9106b_regs.en_bre,buf[0]);
+
+	//set led_gpio 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.led_gpio,buf);
+	printk("read  led_gpio[0x%x] = 0x%x\n",aw9106b_regs.led_gpio,buf[0]);
+
+	//set BLINK 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.smart_blink,buf);
+	printk("read  smart_blink[0x%x] = 0x%x\n",aw9106b_regs.smart_blink,buf[0]);
+
+	//set delay time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.delay_bre0,buf);
+	printk("read  delay_bre0[0x%x] = 0x%x\n",aw9106b_regs.delay_bre0,buf[0]);
+
+	//set flade time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.fade_tmr,buf);
+	printk("read  fade_tmr[0x%x] = 0x%x\n",aw9106b_regs.fade_tmr,buf[0]);
+
+	//set full on and off  time 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.full_tmr,buf);
+	printk("read  full_tmr[0x%x] = 0x%x\n",aw9106b_regs.full_tmr,buf[0]);
+
+	//set gpio in and out 
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.in_out,buf);
+	printk("read  in_out[0x%x] = 0x%x\n",aw9106b_regs.in_out,buf[0]);
+
+	//start
+	buf[0] = 0x0;
+	aw9106b_i2c_rx_byte_data(aw9106b_data.i2c_client,aw9106b_regs.ctl,buf);
+	printk("read  ctl[0x%x] = 0x%x\n",aw9106b_regs.ctl,buf[0]);
+}
+
+//fade_parameter
+static ssize_t show_fade_parameter(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	snprintf(fade_parameter, FADE_PARAM_LEN,	"%4d %4d %4d\n",
+			fade_time, fullon_time, fulloff_time);
+
+	return sprintf(buf, "%s\n", fade_parameter);
+}
+
+static ssize_t set_fade_parameter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	strncpy(fade_parameter, buf, FADE_PARAM_LEN);
+	sscanf(fade_parameter, "%d %d %d", &fade_time, &fullon_time, &fulloff_time);
+	AW_DBG("fade_time= %d, fullon_time=%d fulloff_time=%d\n",fade_time,fullon_time,fulloff_time);
+
+	return count;
+}
+
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(fade_parameter, S_IRUGO | S_IWUSR,
+		show_fade_parameter, set_fade_parameter);
+
+//grade_parameter
+static ssize_t show_grade_parameter(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	snprintf(grade_parameter, GRADE_PARAM_LEN,	"%4d %4d\n",
+			min_grade, max_grade);
+
+	return sprintf(buf, "%s\n", grade_parameter);
+}
+
+static ssize_t set_grade_parameter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	strncpy(grade_parameter, buf, GRADE_PARAM_LEN);
+	sscanf(grade_parameter, "%d %d", &min_grade, &max_grade);
+	AW_DBG("min_grade= %d, max_grade=%d \n",min_grade,max_grade);
+
+	return count;
+}
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(grade_parameter, S_IRUGO | S_IWUSR,
+		show_grade_parameter, set_grade_parameter);
+
+
+//out_n
+static ssize_t show_outn(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n", outn);
+}
+
+static ssize_t set_outn(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	sscanf(buf, "%d", &outn);
+	AW_DBG("outn= %d \n",outn);
+
+	return count;
+}
+//path: sys/class/leds/red/
+const static DEVICE_ATTR(outn, S_IRUGO | S_IWUSR,
+		show_outn, set_outn);
+
+#if 0
+static int store_outn(const char *val, struct kernel_param *kp)
+
+{
+	int ret = 0;
+	ret = param_set_int(val, kp);
+	if (ret) {
+		pr_err("error setting value %d\n", ret);
+		return ret;
+	}
+	return ret;
+}
+module_param_call(outn, store_outn, param_get_uint,
+		&outn, 0644);
+#endif
+static int led_config;
+static int set_led_mode(const char *val, struct kernel_param *kp)
+
+{
+	int ret;
+	int rc = 0;
+
+	ret = param_set_int(val, kp);
+	if (ret) {
+		pr_err("error setting value %d\n", ret);
+		return ret;
+	}
+
+	printk("__%s: led_config=%d!\n",__func__,led_config);
+
+	switch(led_config){
+		case 0:
+			aw9106b_power_set(AW_POWER_DOWN);
+			break;
+
+		case 1:
+			outn = AW_OUT_0;
+			break;
+
+		case 2:
+			outn = AW_OUT_1;
+			break;
+
+		case 3:
+			aw9106b_show_regs();
+			break;
+
+		case 4:
+			enable_outn_const_led(AW_CONST_ON, MAX_18_5__MA,min_grade);
+			break;
+
+		case 5:
+			enable_outn_blink_led(AW_FADE_AUTO,max_current);
+			rc |= start_blink_led(max_current);
+			if(rc < 0)
+				pr_err("%s: start blink fail!\n",__func__);
+			break;
+
+		case 6:
+			close_out_blink_led(AW_CLOSE_NOW);
+			break;
+
+		case 7:
+			close_out_blink_led(AW_CLOSE_DELAY);
+			break;
+
+		default:
+			break;
+	};
+	return 0;
+}
+
+module_param_call(led_config, set_led_mode, param_get_uint,
+		&led_config, 0644);
+
+
+static struct led_classdev breath_led = {
+	.name		= "red",
+	.brightness_set	= aw9106b_breath_mode_set,
+};
+
+
+static int  aw9106b_probe(struct i2c_client *client,
+
+		const struct i2c_device_id *dev_id)
+
+{
+	int ret = 0;
+
+	printk("%s: start probe:\n",__func__);
+
+	aw9106b_data.i2c_client = client;
+	ret = led_classdev_register(NULL, &breath_led);
+	if (ret) {
+		pr_err("unable to register breath_led ret=%d\n",ret);
+		goto init_fail;
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_fade_parameter);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create fade_parameter.\n");
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_grade_parameter);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create grade_parameter.\n");
+	}
+
+	ret = device_create_file(breath_led.dev, &dev_attr_outn);
+	if (unlikely(ret < 0)) {
+		dev_err(breath_led.dev, "failed: cannot create outn.\n");
+	}
+
+	INIT_WORK(&aw9106b_data.work, aw9106b_work_func);
+
+	hrtimer_init(&aw9106b_data.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw9106b_data.timer.function = aw9106b_timer;
+
+	aw9106b_fade_data_init();
+	aw9106b_control_init();
+
+	ret = gpio_request(GPIO_PWDN, "aw9106b_shdn");
+	if (ret) {
+		pr_err("%s: fail gpio_request(%d)=%d\n", __func__,GPIO_PWDN, ret);
+	}
+	gpio_tlmm_config(GPIO_CFG(GPIO_PWDN, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA),GPIO_CFG_ENABLE);
+
+	printk("%s: finish probe:\n",__func__);
+	return 0;
+
+init_fail:
+	return ret;
+
+}
+
+static int aw9106b_remove(struct i2c_client *client)
+{	
+	led_classdev_unregister(&breath_led);
+	gpio_free(GPIO_PWDN);
+	return 0;
+}
+
+static int aw9106b_suspend(struct i2c_client *cl, pm_message_t mesg)
+{
+    AW9106B_SUSPEND_FLAG=true;
+	return 0;
+};
+
+static int aw9106b_resume(struct i2c_client *cl)
+{   
+    AW9106B_SUSPEND_FLAG=false;
+	return 0;
+};
+
+
+static const struct i2c_device_id aw9106b_id[] = {
+	{ "aw_9106b", 1 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, BQ27520_id);
+
+static struct i2c_driver aw9106b_driver = {
+	.driver = {
+		.name = "aw_9106b",
+#ifdef CONFIG_OF
+		.of_match_table = aw_9106b_match_table,
+#endif
+	},
+	.id_table 	= aw9106b_id,
+	.probe 		= aw9106b_probe,
+	.remove 	= aw9106b_remove,
+	.suspend	= aw9106b_suspend,
+	.resume 	= aw9106b_resume,
+};
+
+
+static int __init aw9106b_init(void)
+{
+	printk( "%s:enter...\n", __func__);
+	return i2c_add_driver(&aw9106b_driver);
+}
+
+static void __exit aw9106b_exit(void)
+{
+	printk( "%s:%d:aw9106b is exiting\n", __func__,__LINE__);
+	i2c_del_driver(&aw9106b_driver);
+}
+
+
+late_initcall(aw9106b_init);
+module_exit(aw9106b_exit);
+
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("wangshuai <wang.shuai12@zte.com.cn>");
+MODULE_DESCRIPTION("aw9106b Linux driver");
+MODULE_ALIAS("platform:aw9106b");
+
diff --git a/drivers/hwmon/aw_9106b.h b/drivers/hwmon/aw_9106b.h
new file mode 100755
index 0000000..f581521
--- /dev/null
+++ b/drivers/hwmon/aw_9106b.h
@@ -0,0 +1,57 @@
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __AW_9106B_H__
+#define __AW_9106B_H__
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <mach/board.h>
+#include <linux/mfd/pm8xxx/pm8921-charger.h>
+
+#define AW_DEVICE_NAME "aw_9106b"
+
+enum aw_outn{
+	AW_OUT_0,
+	AW_OUT_1,
+	AW_OUT_2,
+	AW_OUT_3,
+	AW_OUT_4,
+	AW_OUT_5,
+};
+
+struct aw9106b_plat_data {
+	struct i2c_client *i2c_client;
+	struct i2c_driver *i2c_driver;
+	struct work_struct work;
+	struct hrtimer timer;
+};
+
+struct aw9106b_regs_data {
+	int en_bre;    //enable or disable breath func
+	int smart_blink;  //blink or smart-fade modle
+	int in_out;  //gpio in and out 
+	int out_val;
+	int smart_fade;
+	int led_gpio;  //led or gpio
+	int fade_tmr; //fade time
+	int full_tmr; //full light and black
+	int delay_bre0; //delay breath time
+	int dim0;
+	int aw_reset;
+	int ctl;  //set start blink
+};
+
+#endif /* __AW_9106B_H__ */
+
+
diff --git a/drivers/hwmon/maxq616.c b/drivers/hwmon/maxq616.c
new file mode 100644
index 0000000..af7bdd3
--- /dev/null
+++ b/drivers/hwmon/maxq616.c
@@ -0,0 +1,218 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+*
+* File Name          : maxq616.c
+* Authors            : Zhu Bing
+* Version            : V.1.0.0
+* Date               : 07/024/2013
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+ 
+Revision 1-0-0 07/024/2013
+ first revision
+
+*******************************************************************************/
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+
+
+
+#define LOG_TAG "IR_REMOTE"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+static int maxq616_power_on(struct device *dev)
+{
+	int rc;
+    static struct regulator *vdd_chip;
+    //static struct regulator *vdd_led;
+
+    SENSOR_LOG_INFO("start\n");
+
+	vdd_chip = regulator_get(dev, "vdd-chip");
+	if (IS_ERR(vdd_chip))
+    {
+		rc = PTR_ERR(vdd_chip);
+		SENSOR_LOG_ERROR("Regulator get failed vdd_chip rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(vdd_chip) > 0)
+    {
+		rc = regulator_set_voltage(vdd_chip, 1800000, 1800000);
+		if (rc)
+        {
+			SENSOR_LOG_ERROR("Regulator set vdd_chip failed rc=%d\n", rc);
+			goto error_set_vtg_vdd_chip;
+		}
+	}
+    
+    rc = regulator_set_optimum_mode(vdd_chip, 600000);
+    if (rc < 0)
+    {
+        SENSOR_LOG_ERROR("Regulator vdd_chip set_opt failed rc=%d\n", rc);
+        goto error_set_optimum_vdd_chip;
+
+    }
+    
+    rc = regulator_enable(vdd_chip);
+    if (rc)
+    {
+        SENSOR_LOG_ERROR("Regulator vdd_chip enable failed rc=%d\n", rc);
+        goto error_reg_en_vdd_chip;
+    }
+    
+    SENSOR_LOG_INFO("success\n");
+    return 0;
+
+#if 0
+error_reg_en_vcc_i2c:
+    reg_set_optimum_mode_check(vcc_i2c, 0);
+//error_set_vtg_i2c:
+//    regulator_put(vcc_i2c);
+error_reg_opt_vcc_dig:
+    regulator_disable(vcc_ana);
+#endif
+error_set_optimum_vdd_chip:
+    regulator_set_voltage(vdd_chip, 0, 1800000);
+    regulator_put(vdd_chip);
+error_reg_en_vdd_chip:
+    regulator_set_optimum_mode(vdd_chip, 0);
+error_set_vtg_vdd_chip:
+	regulator_put(vdd_chip);
+	return rc;
+}
+
+ 
+ 
+static int __devinit maxq616_probe(struct i2c_client *client,
+                  const struct i2c_device_id *id)
+{
+
+    SENSOR_LOG_INFO("prob start\n");
+
+    maxq616_power_on(&client->dev);
+
+    SENSOR_LOG_INFO("prob success\n");
+
+    return 0;
+}
+
+ 
+ /**
+  * maxq616_remove() - remove device
+  * @client: I2C client device
+  */
+ static int __devexit maxq616_remove(struct i2c_client *client)
+ {
+     struct shtc1_data *chip_data = i2c_get_clientdata(client);
+ 
+     SENSOR_LOG_INFO("maxq616_remove\n");
+    
+     kfree(chip_data);
+     return 0;
+ }
+
+
+static const struct i2c_device_id maxq616_idtable_id[] = {
+     { "uie,maxq616", 0 },
+     { },
+ };
+ 
+static struct of_device_id of_maxq616_idtable[] = {
+     { .compatible = "uei,maxq616",},
+     {}
+};
+ 
+ MODULE_DEVICE_TABLE(i2c, maxq616_idtable);
+ 
+ static struct i2c_driver maxq616_driver = {
+     .driver = {
+         .name = "maxq616",
+         .of_match_table = of_maxq616_idtable,
+         .pm = NULL,
+     },
+     .id_table = maxq616_idtable_id,
+     .probe = maxq616_probe,
+     .remove = __devexit_p(maxq616_remove),
+ };
+
+
+
+static int __init maxq616_init(void)
+{
+        SENSOR_LOG_INFO("driver: init\n");
+        return i2c_add_driver(&maxq616_driver);
+}
+ 
+static void __exit maxq616_exit(void)
+{
+        SENSOR_LOG_INFO("driver: exit\n");
+        i2c_del_driver(&maxq616_driver);
+}
+
+module_init(maxq616_init);
+module_exit(maxq616_exit);
+ 
+MODULE_DESCRIPTION("UEI maxq616 driver");
+MODULE_AUTHOR("ZhuBing, ZTEMT");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/qpnp-adc-common.c b/drivers/hwmon/qpnp-adc-common.c
old mode 100644
new mode 100755
index 37a11d2..648b232
--- a/drivers/hwmon/qpnp-adc-common.c
+++ b/drivers/hwmon/qpnp-adc-common.c
@@ -44,6 +44,33 @@
    and provided to the battery driver in the units desired for
    their framework which is 0.1DegC. True resolution of 0.1DegC
    will result in the below table size to increase by 10 times */
+#ifdef CONFIG_ZTEMT_CHARGE
+static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
+	{-300, 1626},
+	{-250, 1573},
+	{-200, 1510},
+	{-150, 1438},
+	{-100, 1358},
+	{-50, 1274},
+	{0,   1188},
+	{50,  1103},
+	{100, 1022},
+	{150,  946},
+	{200,  877},
+	{250,  816},
+	{300,  763},
+	{350,  718},
+	{400,  679},
+	{450,  647},
+	{500,  619},
+	{550,  596},
+	{600,  577},
+	{650,  561},
+	{700,  548},
+	{750,  537},
+	{800,  528}
+};
+#else
 static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
 	{-300,	1642},
 	{-200,	1544},
@@ -129,6 +156,7 @@ static const struct qpnp_vadc_map_pt adcmap_btm_threshold[] = {
 	{780,	208},
 	{790,	203}
 };
+#endif
 
 static const struct qpnp_vadc_map_pt adcmap_qrd_btm_threshold[] = {
 	{-200,	1540},
diff --git a/drivers/hwmon/sensor_common.c b/drivers/hwmon/sensor_common.c
new file mode 100644
index 0000000..c127c47
--- /dev/null
+++ b/drivers/hwmon/sensor_common.c
@@ -0,0 +1,265 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+*
+* File Name          : hts221.c
+* Authors            : Motion MEMS
+*                      Morris Chen (morris.chen@st.com)
+* Version            : V.1.0.0
+* Date               : 06/03/2013
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+ 
+Revision 1-0-0 06/03/2013
+ first revision
+
+*******************************************************************************/
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/i2c/sensor_common.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+
+
+
+#define LOG_TAG "SENSOR_COMMON"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+static const struct i2c_device_id sensor_common_idtable_id[] = {
+    { "zte,sensor_common", 0 },
+    { },
+};
+ 
+static struct of_device_id of_sensor_common_idtable[] = {
+    { .compatible = "zte,sensor_common",},
+    {}
+};
+ 
+ MODULE_DEVICE_TABLE(i2c, sensor_common_idtable);
+ 
+static struct i2c_driver sensor_common_driver = {
+    .driver = {
+        .name = "sensor_common",
+        .of_match_table = of_sensor_common_idtable,
+        .pm = NULL,
+    },
+    .id_table = sensor_common_idtable_id,
+    .probe = sensor_common_probe,
+    .remove = __devexit_p(sensor_common_remove),
+};
+
+
+struct class  *sensor_common_class;
+
+static dev_t const sensor_compass_dev = MKDEV(MISC_MAJOR, 248);
+
+static ssize_t compass_int_pin_get(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "gpio is %d\n",gpio_get_value(COMPASS_INT_PIN));
+}
+ 
+
+static ssize_t compass_int_pin_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    bool value;
+    if (strtobool(buf, &value))
+        return -EINVAL;
+
+    if (value)
+    { 
+        SENSOR_LOG_INFO("set to be 1\n");
+        gpio_set_value(COMPASS_INT_PIN, 1);
+    }
+    else
+    {
+        SENSOR_LOG_INFO("set to be 0\n");
+        gpio_set_value(COMPASS_INT_PIN, 0);
+    }
+
+    return size;
+}
+
+
+
+static struct device_attribute attrs_sensor_compass[] = {
+	__ATTR(int_pin,                  0640,   compass_int_pin_get,          compass_int_pin_set),
+};
+
+
+
+static int sensor_compass_create_sysfs_interfaces(struct device *dev)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(attrs_sensor_compass); i++)
+     if (device_create_file(dev, attrs_sensor_compass + i))
+         goto error;
+    return 0;
+
+error:
+    for ( ; i >= 0; i--)
+    device_remove_file(dev, attrs_sensor_compass + i);
+    SENSOR_LOG_ERROR("Unable to create interface\n");
+    return -1;
+}
+
+
+static int sensor_compass_int_pin_init(int pin_num)
+{
+    int ret = 0;
+
+    ret = gpio_request(pin_num, "compass_int");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",COMPASS_INT_PIN);
+        
+        gpio_free(pin_num);
+        ret = gpio_request(pin_num, "compass_int");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",COMPASS_INT_PIN);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("gpio %d get success\n",COMPASS_INT_PIN);
+    }
+
+    ret = gpio_tlmm_config(GPIO_CFG(pin_num, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("gpio_tlmm_config failed ret = %d",ret);
+    }
+    
+    return ret;
+}
+
+static int __devinit sensor_common_probe(struct i2c_client *client,
+                  const struct i2c_device_id *id)
+{
+
+    struct sensor_common_data *chip_data;
+//	struct device *dev = &client->dev;
+
+    int ret;
+
+	chip_data = kzalloc(sizeof(struct sensor_common_data), GFP_KERNEL);
+
+    SENSOR_LOG_INFO("prob start\n");
+
+    i2c_set_clientdata(client, chip_data);
+
+    sensor_common_class = class_create(THIS_MODULE, "sensor");
+
+    chip_data->sensor_compass_dev = device_create(sensor_common_class, NULL, sensor_compass_dev, &sensor_common_driver ,"compass");
+    if (IS_ERR(chip_data->sensor_compass_dev)) 
+    {
+        ret = PTR_ERR(chip_data->sensor_compass_dev);
+        goto create_sensor_compass__failed;
+    }
+
+    dev_set_drvdata(chip_data->sensor_compass_dev, chip_data);
+
+    sensor_compass_create_sysfs_interfaces(chip_data->sensor_compass_dev);
+
+    sensor_compass_int_pin_init(COMPASS_INT_PIN);
+
+
+    SENSOR_LOG_INFO("prob success\n");
+
+    return 0;
+
+create_sensor_compass__failed:
+    chip_data->sensor_compass_dev = NULL;
+    class_destroy(sensor_common_class); 
+
+    return ret;
+}
+
+ 
+ /**
+  * sensor_common_remove() - remove device
+  * @client: I2C client device
+  */
+ static int __devexit sensor_common_remove(struct i2c_client *client)
+ {
+     struct sensor_common_data *chip_data = i2c_get_clientdata(client);
+ 
+      SENSOR_LOG_INFO("sensor_common_remove\n");
+     //hwmon_device_unregister(chip_data->hwmon_dev);
+     //sysfs_remove_group(&client->dev.kobj, &sensor_common_attr_group);
+    
+     kfree(chip_data);
+     return 0;
+ }
+
+static int __init sensor_common_init(void)
+{
+        SENSOR_LOG_INFO("driver: init\n");
+        return i2c_add_driver(&sensor_common_driver);
+}
+ 
+static void __exit sensor_common_exit(void)
+{
+        SENSOR_LOG_INFO("driver: exit\n");
+        i2c_del_driver(&sensor_common_driver);
+}
+
+module_init(sensor_common_init);
+module_exit(sensor_common_exit);
+ 
+MODULE_DESCRIPTION("sensor commom driver");
+MODULE_AUTHOR("ZhuBing, ZTEMT");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/shtc1.c b/drivers/hwmon/shtc1.c
new file mode 100644
index 0000000..422c70d
--- /dev/null
+++ b/drivers/hwmon/shtc1.c
@@ -0,0 +1,807 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+*
+* File Name          : hts221.c
+* Authors            : Motion MEMS
+*                      Morris Chen (morris.chen@st.com)
+* Version            : V.1.0.0
+* Date               : 06/03/2013
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+Version History.
+ 
+Revision 1-0-0 06/03/2013
+ first revision
+
+*******************************************************************************/
+ 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/device.h>
+#include <linux/i2c/shtc1.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/miscdevice.h>
+
+
+
+#define LOG_TAG "TEMP_HUMI"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+ static const struct i2c_device_id shtc1_idtable_id[] = {
+     { "sencirion,shtc1", 0 },
+     { },
+ };
+ 
+ static struct of_device_id of_shtc1_idtable[] = {
+     { .compatible = "sencirion,shtc1",},
+     {}
+ };
+ 
+ MODULE_DEVICE_TABLE(i2c, shtc1_idtable);
+ 
+ static struct i2c_driver shtc1_driver = {
+     .driver = {
+         .name = "shtc1",
+         .of_match_table = of_shtc1_idtable,
+         .pm = NULL,
+     },
+     .id_table = shtc1_idtable_id,
+     .probe = shtc1_probe,
+     .remove = __devexit_p(shtc1_remove),
+ };
+
+
+ struct class  *temperature_class;
+ struct class  *humidity_class;
+
+ 
+ static dev_t const shtc1_temperature_dev_t = MKDEV(MISC_MAJOR, 248);
+ static dev_t const shtc1_humidity_dev_t    = MKDEV(MISC_MAJOR, 249);
+
+ /* commands (high precision mode) */
+ static const unsigned char shtc1_cmd_measure_blocking_hpm[]    = { 0x7C, 0xA2 };
+ static const unsigned char shtc1_cmd_measure_nonblocking_hpm[] = { 0x78, 0x66 };
+ 
+ /* commands (low precision mode) */
+ static const unsigned char shtc1_cmd_measure_blocking_lpm[]    = { 0x64, 0x58 };
+ static const unsigned char shtc1_cmd_measure_nonblocking_lpm[] = { 0x60, 0x9c };
+ 
+ /* delays for non-blocking i2c commands */
+ /* TODO: use max timings */
+#define SHTC1_NONBLOCKING_WAIT_TIME_HPM  10
+#define SHTC1_NONBLOCKING_WAIT_TIME_LPM   1
+ 
+#define SHTC1_CMD_LENGTH      2
+#define SHTC1_RESPONSE_LENGTH 6
+ 
+
+static void shtc1_data_init(struct shtc1_data *chip_data)
+{
+    chip_data->input_dev_t_name = "temperature";
+    chip_data->input_dev_h_name = "humidity";
+
+    chip_data->temperature_poll_time = 1000;
+    chip_data->humidity_poll_time    = 1000;
+    chip_data->poll_time             = 1000;
+    chip_data->poll_time_minimum     = 20;
+
+    chip_data->temperature_debug     = false;
+    chip_data->humidity_debug        = false;
+}
+
+static void shtc1_select_command(struct shtc1_data *chip_data)
+{
+    if (chip_data->pdata.high_precision) 
+    {
+        chip_data->command = chip_data->pdata.blocking_io ?
+             shtc1_cmd_measure_blocking_hpm :
+             shtc1_cmd_measure_nonblocking_hpm;
+        chip_data->nonblocking_wait_time = SHTC1_NONBLOCKING_WAIT_TIME_HPM;
+
+    } 
+    else 
+    {
+        chip_data->command = chip_data->pdata.blocking_io ?
+             shtc1_cmd_measure_blocking_lpm :
+             shtc1_cmd_measure_nonblocking_lpm;
+        chip_data->nonblocking_wait_time = SHTC1_NONBLOCKING_WAIT_TIME_LPM;
+    }
+}
+ 
+ static int shtc1_update_values(struct i2c_client *client, struct shtc1_data *chip_data, char *buf, int bufsize)
+ {
+     int ret = i2c_master_send(client, chip_data->command, SHTC1_CMD_LENGTH);
+     if (ret < 0) {
+         dev_err(&client->dev, "failed to send command");
+         return ret;
+     }
+ 
+     /*
+      * in blocking mode (clock stretching mode) the I2C bus
+      * is blocked for other traffic, thus the call to i2c_master_recv()
+      * will wait until the data is ready. for non blocking mode, we
+      * have to wait ourselves, thus the msleep()
+      *
+      * TODO: consider usleep_range
+      */
+     if (!chip_data->pdata.blocking_io)
+         msleep(chip_data->nonblocking_wait_time);
+ 
+     ret = i2c_master_recv(client, buf, bufsize);
+     if (ret != bufsize) {
+         dev_err(&client->dev, "failed to read values: %d", ret);
+         return ret;
+     }
+ 
+     return 0;
+ }
+ 
+/* sysfs attributes */
+static struct shtc1_data *shtc1_update_client(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct shtc1_data *chip_data = i2c_get_clientdata(client);
+
+    unsigned char buf[SHTC1_RESPONSE_LENGTH];
+    int val;
+    int ret;
+
+    //mutex_lock(&chip_data->lock);
+
+    /*
+    * initialize 'ret' in case we had a valid result before, but
+    * read too quickly in which case we return the last values
+    */
+    ret = !chip_data->valid;
+
+    if (time_after(jiffies, chip_data->last_updated + HZ / 10) || !chip_data->valid) 
+    {
+        ret = shtc1_update_values(client, chip_data, buf, sizeof(buf));
+
+        if (ret)
+        goto out;
+
+        /*
+        * From datasheet:
+        *   T = -45 + 175 * ST / 2^16
+        *   RH = -10 + 120 * SRH / 2^16
+        *
+        * Adapted for integer fixed point (3 digit) arithmetic
+        */
+        val = be16_to_cpup((__be16 *)buf);
+        chip_data->temperature_data = ((21875 * val) >> 13) - 45000;
+        val = be16_to_cpup((__be16 *)(buf+3));
+        chip_data->humidity_data = ((15000 * val) >> 13) - 10000;
+
+        chip_data->last_updated = jiffies;
+        chip_data->valid = 1;
+    }
+
+    out:
+    //mutex_unlock(&chip_data->lock);
+
+    return ret == 0 ? chip_data : ERR_PTR(ret);
+}
+ 
+
+static void shtc1_updata_poll_time(struct shtc1_data *chip_data)
+{
+    unsigned mini_time = 0;
+    
+    if (!chip_data->humidity_state && chip_data->temperature_state)
+    {
+        mini_time = chip_data->temperature_poll_time;
+    }
+    else
+    {
+        if (chip_data->humidity_state && !chip_data->temperature_state)
+        {
+            mini_time = chip_data->humidity_poll_time;
+        }
+        else
+        {
+            mini_time = chip_data->humidity_poll_time < chip_data->temperature_poll_time ? 
+                        chip_data->humidity_poll_time : chip_data->temperature_poll_time;
+        }
+    }
+
+    chip_data->poll_time = mini_time > chip_data->poll_time_minimum ?
+                           mini_time : chip_data->poll_time_minimum;
+}
+
+
+static ssize_t shtc1_poll_time_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("poll_time = %d\n",chip_data->poll_time);
+    return sprintf(buf, "%d\n", chip_data->poll_time);
+}
+
+static ssize_t shtc1_poll_time_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+
+    chip_data->poll_time = time;
+
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+
+
+
+static void shtc1_temperature_enable(struct shtc1_data *chip_data, bool on)
+{
+    SENSOR_LOG_INFO("temperature %s\n",on? "enable" : "disable");
+    chip_data->temperature_state = on;
+    if (on)
+    {
+       if (false==chip_data->humidity_state)
+       {            
+           schedule_delayed_work(&chip_data->poll_work, msecs_to_jiffies(100));
+       }
+    }
+    else
+    {
+       msleep(50);
+       shtc1_input_temperature(chip_data);
+
+       chip_data->temperature_poll_time = 1000;
+       shtc1_updata_poll_time(chip_data);
+    }
+}
+
+
+static ssize_t shtc1_temperature_poll_time_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("temperature_poll_time = %d\n",chip_data->temperature_poll_time);
+    return sprintf(buf, "%d\n", chip_data->temperature_poll_time);
+}
+
+static ssize_t shtc1_temperature_poll_time_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+    chip_data->temperature_poll_time = time;
+    shtc1_updata_poll_time(chip_data);
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+/*
+static int shtc1_temperature_data_convert(int original_data)
+{
+    int temperature_data = 175 * original_data;
+    temperature_data = temperature_data / 65536;
+    temperature_data -= 45;
+    SENSOR_LOG_INFO("temperature = %d\n",temperature_data);
+    return temperature_data;
+}
+*/
+
+static ssize_t shtc1_temperature_data_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    shtc1_update_client(&chip_data->client->dev);
+    shtc1_input_temperature(chip_data);
+    SENSOR_LOG_INFO("temperature original = %d\n",chip_data->temperature_data % 1000000);
+    return sprintf(buf, "%d\n", chip_data->temperature_data % 1000000);
+}
+ 
+
+static ssize_t shtc1_temperature_enable_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+
+    SENSOR_LOG_INFO("temperature_state = %d\n",chip_data->temperature_state);
+    return sprintf(buf, "%d\n", chip_data->temperature_state);
+}
+ 
+
+static ssize_t shtc1_temperature_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+        return -EINVAL;
+    mutex_lock(&chip_data->lock);
+
+    if (value)
+    {
+        shtc1_temperature_enable(chip_data, 1);
+    }
+    else
+    {
+        shtc1_temperature_enable(chip_data, 0);
+    }
+
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+static ssize_t shtc1_temperature_debug_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+        return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+    if (value)
+    {
+        chip_data->temperature_debug = true;
+    }
+    else
+    {
+        chip_data->temperature_debug = false;
+    }
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+static ssize_t shtc1_temperature_debug_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("temperature_debug = %s\n",chip_data->temperature_debug? "true":"false");
+    return sprintf(buf, "%s\n", chip_data->temperature_debug? "true":"false");
+}
+
+
+static void shtc1_humidity_enable(struct shtc1_data *chip_data, bool on)
+{
+    SENSOR_LOG_INFO("humidity %s\n",on? "enable" : "disable");
+    chip_data->humidity_state = on;
+    if (on)
+    {
+        if (false==chip_data->temperature_state)
+        {            
+            schedule_delayed_work(&chip_data->poll_work, msecs_to_jiffies(100));
+        }
+    }
+    else
+    {
+        msleep(50);
+        shtc1_input_humidity(chip_data);
+
+        chip_data->humidity_poll_time = 1000;
+        shtc1_updata_poll_time(chip_data);
+    }
+}
+
+static ssize_t shtc1_humidity_poll_time_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("humidity_poll_time = %d\n",chip_data->humidity_poll_time);
+    return sprintf(buf, "%d\n", chip_data->humidity_poll_time);
+}
+
+static ssize_t shtc1_humidity_poll_time_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+
+    chip_data->humidity_poll_time = time;
+    shtc1_updata_poll_time(chip_data);
+
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+
+static ssize_t shtc1_humidity_data_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    shtc1_update_client(&chip_data->client->dev);
+    shtc1_input_humidity(chip_data);
+    SENSOR_LOG_INFO("humidity original data = %d\n",chip_data->humidity_data % 1000000);
+    return sprintf(buf, "%d\n", chip_data->humidity_data % 1000000);
+}
+
+
+static ssize_t shtc1_humidity_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+        return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+    if (value)
+    {
+        shtc1_humidity_enable(chip_data, 1);
+    }
+    else
+    {
+        shtc1_humidity_enable(chip_data, 0);
+    }
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+
+static ssize_t shtc1_humidity_enable_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("humidity_state = %d\n",chip_data->humidity_state);
+    return sprintf(buf, "%d\n", chip_data->humidity_state);
+}
+
+
+static ssize_t shtc1_humidity_debug_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+        return -EINVAL;
+
+    mutex_lock(&chip_data->lock);
+    if (value)
+    {
+        chip_data->humidity_debug = true;
+    }
+    else
+    {
+        chip_data->humidity_debug = false;
+    }
+    mutex_unlock(&chip_data->lock);
+
+    return size;
+}
+
+static ssize_t shtc1_humidity_debug_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	struct shtc1_data *chip_data = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("humidity_debug = %s\n",chip_data->humidity_debug? "true":"false");
+    return sprintf(buf, "%s\n", chip_data->humidity_debug? "true":"false");
+}
+
+
+static struct device_attribute attrs_temperature[] = {
+	__ATTR(enable,                  0640,   shtc1_temperature_enable_show,          shtc1_temperature_enable_store),
+	__ATTR(temperature_data,        0640,   shtc1_temperature_data_show,            NULL),
+    __ATTR(temperature_poll_time,   0640,   shtc1_temperature_poll_time_show,       shtc1_temperature_poll_time_store),
+    __ATTR(poll_time,               0640,   shtc1_poll_time_show,                   shtc1_poll_time_store),
+    __ATTR(temperature_debug,       0640,   shtc1_temperature_debug_show,           shtc1_temperature_debug_store),
+};
+
+
+static struct device_attribute attrs_humidity[] = {
+	__ATTR(enable,                  0640,   shtc1_humidity_enable_show,             shtc1_humidity_enable_store),
+	__ATTR(humidity_data,           0640,   shtc1_humidity_data_show,               NULL),
+    __ATTR(humidity_poll_time,      0640,   shtc1_humidity_poll_time_show,          shtc1_humidity_poll_time_store),
+    __ATTR(poll_time,               0640,   shtc1_poll_time_show,                   shtc1_poll_time_store),
+    __ATTR(humidity_debug,          0640,   shtc1_humidity_debug_show,              shtc1_humidity_debug_store),
+
+};
+
+
+static int shtc1_create_sysfs_interfaces_temperature(struct device *dev)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(attrs_temperature); i++)
+     if (device_create_file(dev, attrs_temperature + i))
+         goto error;
+    return 0;
+
+error:
+    for ( ; i >= 0; i--)
+    device_remove_file(dev, attrs_temperature + i);
+    SENSOR_LOG_ERROR("Unable to create interface\n");
+    return -1;
+}
+
+static int shtc1_create_sysfs_interfaces_humidity(struct device *dev)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(attrs_humidity); i++)
+    if (device_create_file(dev, attrs_humidity + i))
+        goto error;
+    return 0;
+
+    error:
+    for ( ; i >= 0; i--)
+        device_remove_file(dev, attrs_humidity + i);
+    SENSOR_LOG_ERROR("Unable to create interface\n");
+    return -1;
+}
+
+static void shtc1_input_temperature(struct shtc1_data *chip_data)
+{
+    if (chip_data->temperature_debug)
+    {
+        SENSOR_LOG_INFO("temperature = %d\n",chip_data->temperature_data);
+    }
+
+    input_report_rel(chip_data->t_idev, REL_X, chip_data->temperature_data);
+    input_sync(chip_data->t_idev);
+}
+
+
+static void shtc1_input_humidity(struct shtc1_data *chip_data)
+{
+    if (chip_data->humidity_debug)
+    {
+        SENSOR_LOG_INFO("humidity = %d\n",chip_data->humidity_data);
+    }
+
+    input_report_rel(chip_data->h_idev, REL_X, chip_data->humidity_data);
+    input_sync(chip_data->h_idev);
+}
+
+static void shtc1_poll_work_func(struct work_struct *work)
+{
+    struct shtc1_data *chip_data = container_of((struct delayed_work *)work, struct shtc1_data, poll_work);
+    
+    mutex_lock(&chip_data->lock);
+
+    shtc1_update_client(&chip_data->client->dev);
+
+    if (chip_data->temperature_state)
+    {
+        shtc1_input_temperature(chip_data);
+    }
+
+    if (chip_data->humidity_state)
+    {
+        shtc1_input_humidity(chip_data);
+    }
+
+    if (chip_data->humidity_state || chip_data->temperature_state)
+    {
+        schedule_delayed_work(&chip_data->poll_work, msecs_to_jiffies(chip_data->poll_time));
+    }
+
+    mutex_unlock(&chip_data->lock);
+
+}
+
+
+static int __devinit shtc1_probe(struct i2c_client *client,
+                  const struct i2c_device_id *id)
+{
+
+    struct shtc1_data *chip_data;
+	struct device *dev = &client->dev;
+
+    int ret;
+
+	chip_data = kzalloc(sizeof(struct shtc1_data), GFP_KERNEL);
+
+    if (!chip_data)
+    {
+        return -ENOMEM;
+    }
+    else
+    {
+        shtc1_data_init(chip_data);
+    }
+
+    SENSOR_LOG_INFO("prob start\n");
+
+    dev->platform_data = &chip_data->pdata;
+
+
+    /* defaults: blocking, high precision mode */
+    chip_data->pdata.blocking_io    = 1;
+    chip_data->pdata.high_precision = 1;
+
+
+    shtc1_select_command(chip_data);
+
+    chip_data->client = client;
+    i2c_set_clientdata(client, chip_data);
+
+    mutex_init(&chip_data->lock);
+
+    temperature_class = class_create(THIS_MODULE, "temperature");
+    humidity_class    = class_create(THIS_MODULE, "humidity");
+
+
+    chip_data->temperature_dev = device_create(temperature_class, NULL, shtc1_temperature_dev_t, &shtc1_driver ,"temperature");
+    if (IS_ERR(chip_data->temperature_dev)) 
+    {
+        ret = PTR_ERR(chip_data->temperature_dev);
+        goto create_temperature_dev_failed;
+    }
+
+    chip_data->humidity_dev = device_create(humidity_class, NULL, shtc1_humidity_dev_t, &shtc1_driver ,"humidity");
+    if (IS_ERR(chip_data->humidity_dev)) 
+    {
+        ret = PTR_ERR(chip_data->humidity_dev);
+        goto create_humidity_dev_failed;
+    }
+
+    dev_set_drvdata(chip_data->temperature_dev, chip_data);
+    dev_set_drvdata(chip_data->humidity_dev,   chip_data);
+
+    shtc1_create_sysfs_interfaces_temperature(chip_data->temperature_dev);
+    shtc1_create_sysfs_interfaces_humidity(chip_data->humidity_dev);
+
+    chip_data->t_idev = input_allocate_device();
+    if (!chip_data->t_idev) 
+    {
+        SENSOR_LOG_ERROR("input_allocate_device temperature failed\n");
+        ret = -ENODEV;
+        goto input_t_alloc_failed;
+    }
+
+    chip_data->t_idev->name = chip_data->input_dev_t_name;
+    chip_data->t_idev->id.bustype = BUS_I2C; 
+    set_bit(EV_REL, chip_data->t_idev->evbit);
+    set_bit(REL_X,  chip_data->t_idev->relbit);
+    dev_set_drvdata(&chip_data->t_idev->dev, chip_data);
+
+
+
+    ret = input_register_device(chip_data->t_idev);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("cant register input '%s'\n",chip_data->input_dev_t_name);
+        goto input_t_register_failed;
+    }
+
+
+
+    chip_data->h_idev = input_allocate_device();
+    if (!chip_data->h_idev) 
+    {
+        SENSOR_LOG_ERROR("input_allocate_device humidity failed\n");
+        ret = -ENODEV;
+        goto input_h_alloc_failed;
+    }
+
+    chip_data->h_idev->name = chip_data->input_dev_h_name;
+    chip_data->h_idev->id.bustype = BUS_I2C;
+    set_bit(EV_REL, chip_data->h_idev->evbit);
+    set_bit(REL_X,  chip_data->h_idev->relbit);
+    dev_set_drvdata(&chip_data->h_idev->dev, chip_data);
+    ret = input_register_device(chip_data->h_idev);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("cant register input '%s'\n",chip_data->input_dev_h_name);
+        goto input_h_register_failed;
+    }
+
+    INIT_DELAYED_WORK(&chip_data->poll_work, shtc1_poll_work_func);
+
+    SENSOR_LOG_INFO("prob success\n");
+
+    return 0;
+
+input_h_register_failed:
+    input_free_device(chip_data->h_idev);
+input_h_alloc_failed:
+
+input_t_register_failed:
+    input_free_device(chip_data->t_idev);
+input_t_alloc_failed:
+
+create_humidity_dev_failed:
+    chip_data->humidity_dev = NULL;
+    class_destroy(humidity_class); 
+
+create_temperature_dev_failed:
+    chip_data->temperature_dev = NULL;
+    class_destroy(temperature_class); 
+
+    return ret;
+}
+
+ 
+ /**
+  * shtc1_remove() - remove device
+  * @client: I2C client device
+  */
+ static int __devexit shtc1_remove(struct i2c_client *client)
+ {
+     struct shtc1_data *chip_data = i2c_get_clientdata(client);
+ 
+      SENSOR_LOG_INFO("shtc1_remove\n");
+     //hwmon_device_unregister(chip_data->hwmon_dev);
+     //sysfs_remove_group(&client->dev.kobj, &shtc1_attr_group);
+    
+     kfree(chip_data);
+     return 0;
+ }
+
+static int __init shtc1_init(void)
+{
+        SENSOR_LOG_INFO("driver: init\n");
+        return i2c_add_driver(&shtc1_driver);
+}
+ 
+static void __exit shtc1_exit(void)
+{
+        SENSOR_LOG_INFO("driver: exit\n");
+        i2c_del_driver(&shtc1_driver);
+}
+
+module_init(shtc1_init);
+module_exit(shtc1_exit);
+ 
+MODULE_DESCRIPTION("shtc1 humidity driver");
+MODULE_AUTHOR("ZhuBing, ZTEMT");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/tmd2772.c b/drivers/hwmon/tmd2772.c
new file mode 100755
index 0000000..0a8eba0
--- /dev/null
+++ b/drivers/hwmon/tmd2772.c
@@ -0,0 +1,3540 @@
+/*******************************************************************************
+*                                                                              *
+*   File Name:    taos.c                                                      *
+*   Description:   Linux device driver for Taos ambient light and         *
+*   proximity sensors.                                     *
+*   Author:         John Koshi                                             *
+*   History:   09/16/2009 - Initial creation                          *
+*           10/09/2009 - Triton version         *
+*           12/21/2009 - Probe/remove mode                *
+*           02/07/2010 - Add proximity          *
+*                                                                                       *
+********************************************************************************
+*    Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// includes
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/delay.h>
+#include <linux/i2c/taos_common.h>
+#include <linux/delay.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h> 
+#include <linux/slab.h>
+#include <asm/gpio.h> 
+#include <linux/poll.h> 
+#include <linux/wakelock.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+#include <linux/of_gpio.h>
+
+
+#ifdef CONFIG_ZTE_DEVICE_INFO_SHOW
+#include <linux/zte_device_info.h>
+#endif
+
+#define LOG_TAG "SENSOR_ALS_PROX"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+// device name/id/address/counts
+#define TAOS_DEVICE_NAME                "taos"
+#define TAOS_DEVICE_ID                  "tritonFN"
+#define TAOS_ID_NAME_SIZE               10
+#define TAOS_TRITON_CHIPIDVAL           0x00
+#define TAOS_TRITON_MAXREGS             32
+#define TAOS_DEVICE_ADDR1               0x29
+#define TAOS_DEVICE_ADDR2               0x39
+#define TAOS_DEVICE_ADDR3               0x49
+#define TAOS_MAX_NUM_DEVICES            3
+#define TAOS_MAX_DEVICE_REGS            32
+#define I2C_MAX_ADAPTERS                12
+
+// TRITON register offsets
+#define TAOS_TRITON_CNTRL               0x00
+#define TAOS_TRITON_ALS_TIME            0X01
+#define TAOS_TRITON_PRX_TIME            0x02
+#define TAOS_TRITON_WAIT_TIME           0x03
+#define TAOS_TRITON_ALS_MINTHRESHLO     0X04
+#define TAOS_TRITON_ALS_MINTHRESHHI     0X05
+#define TAOS_TRITON_ALS_MAXTHRESHLO     0X06
+#define TAOS_TRITON_ALS_MAXTHRESHHI     0X07
+#define TAOS_TRITON_PRX_MINTHRESHLO     0X08
+#define TAOS_TRITON_PRX_MINTHRESHHI     0X09
+#define TAOS_TRITON_PRX_MAXTHRESHLO     0X0A
+#define TAOS_TRITON_PRX_MAXTHRESHHI     0X0B
+#define TAOS_TRITON_INTERRUPT           0x0C
+#define TAOS_TRITON_PRX_CFG             0x0D
+#define TAOS_TRITON_PRX_COUNT           0x0E
+#define TAOS_TRITON_GAIN                0x0F
+#define TAOS_TRITON_REVID               0x11
+#define TAOS_TRITON_CHIPID              0x12
+#define TAOS_TRITON_STATUS              0x13
+#define TAOS_TRITON_ALS_CHAN0LO         0x14
+#define TAOS_TRITON_ALS_CHAN0HI         0x15
+#define TAOS_TRITON_ALS_CHAN1LO         0x16
+#define TAOS_TRITON_ALS_CHAN1HI         0x17
+#define TAOS_TRITON_PRX_LO              0x18
+#define TAOS_TRITON_PRX_HI              0x19
+#define TAOS_TRITON_TEST_STATUS         0x1F
+
+// Triton cmd reg masks
+//0x by clli2
+#define TAOS_TRITON_CMD_REG             0X80
+#define TAOS_TRITON_CMD_AUTO            0x20 
+#define TAOS_TRITON_CMD_BYTE_RW         0x00 
+#define TAOS_TRITON_CMD_WORD_BLK_RW     0x20 
+#define TAOS_TRITON_CMD_SPL_FN          0x60 
+#define TAOS_TRITON_CMD_PROX_INTCLR     0X05 
+#define TAOS_TRITON_CMD_ALS_INTCLR      0X06 
+#define TAOS_TRITON_CMD_PROXALS_INTCLR  0X07 
+#define TAOS_TRITON_CMD_TST_REG         0X08 
+#define TAOS_TRITON_CMD_USER_REG        0X09
+
+// Triton cntrl reg masks
+#define TAOS_TRITON_CNTL_PROX_INT_ENBL  0X20
+#define TAOS_TRITON_CNTL_ALS_INT_ENBL   0X10
+#define TAOS_TRITON_CNTL_WAIT_TMR_ENBL  0X08
+#define TAOS_TRITON_CNTL_PROX_DET_ENBL  0X04
+#define TAOS_TRITON_CNTL_ADC_ENBL       0x02
+#define TAOS_TRITON_CNTL_PWRON          0x01
+
+// Triton status reg masks
+#define TAOS_TRITON_STATUS_ADCVALID     0x01
+#define TAOS_TRITON_STATUS_PRXVALID     0x02
+#define TAOS_TRITON_STATUS_ADCINTR      0x10
+#define TAOS_TRITON_STATUS_PRXINTR      0x20
+
+// lux constants
+#define TAOS_MAX_LUX                    10000
+#define TAOS_SCALE_MILLILUX             3
+#define TAOS_FILTER_DEPTH               3
+#define CHIP_ID                         0x3d
+
+#define TAOS_INPUT_NAME                 "lightsensor"
+#define	POLL_DELAY	                    msecs_to_jiffies(5)
+#define	TAOS_ALS_ADC_TIME_WHEN_PROX_ON	0xF0//0XF5//0XEB
+#define TAOS_ALS_GAIN_DIVIDE            1000
+#define TAOS_ALS_GAIN_1X                0
+#define TAOS_ALS_GAIN_8X                1
+#define TAOS_ALS_GAIN_16X               2
+#define TAOS_ALS_GAIN_120X              3
+
+#define CAL_THRESHOLD                      "/persist/proxdata/threshold"
+#define PATH_PROX_OFFSET                   "/persist/sensors/proximity/offset/proximity_offset"
+#define PATH_PROX_UNCOVER_DATA             "/persist/sensors/proximity/uncover_data"
+
+#define PROX_LED_PULSE_CNT                  12
+#define PROX_THRESHOLD_DISTANCE             100
+#define PROX_DATA_TARGET                    150
+#define PROX_DATA_MAX                       1023
+#define PROX_OFFSET_CAL_BUFFER_SIZE         30
+#define PROX_OFFSET_CAL_THRESHOLD           800
+#define PROX_OFFSET_CAL_ABILITY_MAX         72 // -9*72
+#define PROX_DATA_SAFE_RANGE_MIN            (PROX_DATA_TARGET - 50)
+#define PROX_DATA_SAFE_RANGE_MAX            (PROX_DATA_TARGET + 350)
+#define PROX_OFFSET_CAL_GETDATA_DELAY       10
+#define PROX_OFFSET_CAL_PER_BIT             10/85
+#define PROX_DEFAULT_THRESHOLD_HIGH         800
+#define PROX_DEFAULT_THRESHOLD_LOW          700
+#define PROX_THRESHOLD_HIGH_MAX             800
+#define PROX_THRESHOLD_HIGH_MIN             250
+#define PROX_DEFAULT_OFFSET_CNT              0
+#define PROX_THRESHOLD_SAFE_DISTANCE        PROX_THRESHOLD_DISTANCE / 2
+
+
+
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501
+// added the work mode marco
+//#define WORK_UES_POLL_MODE
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501 END
+
+//#define IRQ_TRIGER_LEVEL_LOW
+
+// forward declarations
+static int tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp);
+static int tmd2772_remove(struct i2c_client *client);
+static int taos_get_lux(void);
+static int taos_lux_filter(int raw_lux);
+static int taos_device_name(unsigned char *bufp, char **device_name);
+static int taos_prox_poll(struct taos_prox_info *prxp);
+static void taos_prox_poll_timer_func(unsigned long param);
+static void taos_prox_poll_timer_start(void);
+//iVIZM
+static int taos_prox_threshold_set(void);
+static int taos_als_get_data(void);
+static int taos_interrupts_clear(void);
+static int taos_resume(struct i2c_client *client);
+static int taos_suspend(struct i2c_client *client,pm_message_t mesg);
+//CLLI@
+
+
+static int taos_sensors_als_poll_on(void);
+static int taos_sensors_als_poll_off(void);
+static void taos_als_poll_work_func(struct work_struct *work);
+static int taos_als_gain_set(unsigned als_gain);
+static void taos_update_sat_als(void);
+static int taos_prox_on(void);
+static int taos_prox_off(void);
+static int taos_prox_calibrate(void);
+static void taos_prox_calibrate_work_func(struct work_struct *work);
+static void taos_prox_offset_cal_work_func(struct work_struct *work);
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable);
+static int taos_write_cal_file(char *file_path,unsigned int value);
+static int taos_read_cal_value(char *file_path);
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer);
+
+
+static dev_t const tmd2772_proximity_dev_t = MKDEV(MISC_MAJOR, 101);
+static dev_t const tmd2772_light_dev_t     = MKDEV(MISC_MAJOR, 102);
+
+
+DECLARE_WAIT_QUEUE_HEAD(waitqueue_read);//iVIZM
+
+struct ReadData { //iVIZM
+    unsigned int data;
+    unsigned int interrupt;
+};
+struct ReadData readdata[2];//iVIZM
+
+// workqueue struct
+//static struct workqueue_struct *taos_wq; //iVIZM
+
+// class structure for this device
+struct class *taos_class;
+
+// board and address info   iVIZM
+struct i2c_board_info taos_board_info[] = {
+    {I2C_BOARD_INFO(TAOS_DEVICE_ID, TAOS_DEVICE_ADDR2),},
+};
+
+unsigned short const taos_addr_list[2] = {TAOS_DEVICE_ADDR2, I2C_CLIENT_END};//iVIZM
+
+// client and device
+struct i2c_client *my_clientp;
+struct i2c_client *bad_clientp[TAOS_MAX_NUM_DEVICES];
+static int device_found = 0;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+
+
+//iVIZM
+static char pro_buf[4]; //iVIZM
+static int mcount = 0; //iVIZM
+static bool pro_ft = false; //by clli2
+static bool flag_prox_debug = false;
+static bool flag_als_debug  = false;
+static bool flag_just_open_light = false;
+static unsigned int als_poll_delay = 1000;
+static unsigned int prox_debug_delay_time = 0;
+u16 status = 0;
+static int als_poll_time_mul  = 1;
+static unsigned char reg_addr = 0;
+static bool wakeup_from_sleep = false;
+
+// ZTEMT ADD by zhubing
+// modify for input filter the same data
+static int last_proximity_data = -1;
+//static int last_als_data       = -1;
+// ZTEMT ADD by zhubing END
+
+
+static const struct i2c_device_id tmd2772_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmd2772_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmd2772_idtable);
+
+struct i2c_driver tmd2772_driver = {
+	.driver = {
+		.name = "ams-sensor-tmd2772",
+        .of_match_table = of_tmd2772_idtable,
+		//.pm = NULL,
+	},
+	.id_table = tmd2772_idtable_id,
+	.probe = tmd2772_probe,
+	.remove = __devexit_p(tmd2772_remove),
+#ifdef CONFIG_PM_SLEEP //by clli2
+    .resume = taos_resume,
+    .suspend = taos_suspend,
+#endif
+
+};
+
+
+
+
+
+
+// per-device data
+struct taos_data {
+	struct i2c_client *client;
+	struct cdev cdev;
+	unsigned int addr;
+	//struct input_dev *input_dev;//iVIZM
+	//struct work_struct work;//iVIZM
+	struct delayed_work work;//iVIZM
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+	struct taos_wake_lock proximity_wakelock;//iVIZM
+	struct mutex lock;
+	struct device *class_dev;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_calibrate_work;
+	struct delayed_work prox_offset_cal_work;
+	struct hrtimer  prox_unwakelock_timer;
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+
+	struct device *proximity_dev;
+	struct device *light_dev;
+	struct device *gesture_dev;
+
+	char taos_id;
+	char taos_name[TAOS_ID_NAME_SIZE];
+
+	char *prox_name;
+	char *als_name;
+	bool prox_calibrate_flag;
+	bool prox_calibrate_result;
+	bool prox_offset_cal_result;
+
+	bool phone_is_sleep;
+
+	int  prox_calibrate_times;
+	int  prox_thres_hi_max;
+	int  prox_thres_hi_min;
+	int  prox_data_max;
+	int  prox_manual_calibrate_threshold;
+	int  irq_pin_num;
+
+    u8   prox_uncover_data;
+
+	char *chip_name;
+
+
+	bool prox_on;
+	bool als_on;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool init;
+	int als_poll_time_mul;
+
+	struct semaphore update_lock;
+	char valid;
+} *taos_datap;
+
+// device configuration by clli2
+struct taos_cfg *taos_cfgp;
+static u32 calibrate_target_param = 300000;
+static u16 als_time_param = 41;
+static u16 scale_factor_param_prox = 6;    
+static u16 scale_factor_param_als = 13;
+static u16 gain_trim_param = 512;          //NULL
+static u8 filter_history_param = 3;        //NULL
+static u8 filter_count_param = 1;          //NULL
+/* gain_param  00--1X, 01--8X, 10--16X, 11--120X
+ */
+static u8 gain_param = 0;                  //same as prox-gain_param 1:0 8X
+static u16 prox_calibrate_hi_param = 500;
+static u16 prox_calibrate_lo_param = 330;
+static u16 prox_threshold_hi_param = PROX_DEFAULT_THRESHOLD_HIGH;
+static u16 prox_threshold_lo_param = PROX_DEFAULT_THRESHOLD_LOW;
+static u16 als_threshold_hi_param  = 3000; 
+static u16 als_threshold_lo_param  = 10;   
+static u8  prox_int_time_param     = 0xF0;//0xCD; // time of the ALS ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_adc_time_param     = 0xFF; // time of the PRO ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_wait_time_param    = 0xFF; // time of the    Wait TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+/*7~4->pls,3~0->als*/
+static u8  prox_intr_filter_param  = 0x33; // Int filter, Bit7--Bit4:PROX  Bit3--Bit0:ALS
+static u8  prox_config_param       = 0x00; // wait long time disable
+/*pulse/62.5Khz  less  32 recommand*/
+static u8  prox_pulse_cnt_param    = PROX_LED_PULSE_CNT; //PROX LED pluse count to send for each measure 0x00--0xff:0--255
+/* 7:6 11->100ma        00->12.5ma
+   5:4 01->ch0          10->ch1    11->both
+   1:0(als gain ctrol)  1X 8X 16X 128X        */
+static u8  prox_gain_param = 0x20;   //50ma     8X
+static u8  prox_config_offset_param  = 0x0;
+// prox info
+struct taos_prox_info prox_cal_info[20];
+struct taos_prox_info prox_cur_info;
+struct taos_prox_info *prox_cur_infop = &prox_cur_info;
+static struct timer_list prox_poll_timer;
+static int device_released = 0;
+static u16 sat_als = 0;
+static u16 sat_prox = 0;
+
+
+
+// device reg init values
+u8 taos_triton_reg_init[16] = {0x00,0xFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00};
+
+// lux time scale
+struct time_scale_factor  {
+    u16 numerator;
+    u16 denominator;
+    u16 saturation;
+};
+struct time_scale_factor TritonTime = {1, 0, 0};
+struct time_scale_factor *lux_timep = &TritonTime;
+
+// gain table
+u8 taos_triton_gain_table[] = {1, 8, 16, 120};
+
+// lux data
+struct lux_data {
+    u16 ratio;
+    u16 clear;
+    u16 ir;
+};
+struct lux_data TritonFN_lux_data[] = {
+    { 9830,  8320,  15360 },
+    { 12452, 10554, 22797 },
+    { 14746, 6234,  11430 },
+    { 17695, 3968,  6400  },
+    { 0,     0,     0     }
+};
+struct lux_data *lux_tablep = TritonFN_lux_data;
+static int lux_history[TAOS_FILTER_DEPTH] = {-ENODATA, -ENODATA, -ENODATA};//iVIZM
+
+static int taos_get_data(void);
+
+
+static void taos_irq_ops(bool enable, bool flag_sync)
+{
+    if (enable == taos_datap->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(taos_datap->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(taos_datap->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(taos_datap->client->irq);
+        }
+    }
+
+    taos_datap->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static ssize_t attr_set_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_pulse_cnt_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_pulse_cnt reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_pluse_cnt is %d\n", taos_cfgp->prox_pulse_cnt);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_int_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_int_time = prox_int_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the als_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_int_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_adc_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_adc_time = prox_adc_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_adc_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_wait_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_wait_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_wait_time = prox_wait_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) 
+        {   
+            SENSOR_LOG_ERROR("failed to write the wait_time reg\n");
+        }
+
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_wait_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "wait_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_wait_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = 4 - val;
+        prox_gain_param = (prox_gain_param & 0x3F) | (val<<6);
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    char *p_led_strength[4] = {"100", "50", "25", "12.5"};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_strength is %s mA\n", p_led_strength[(taos_cfgp->prox_gain) >> 6]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_als_gain(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = val-1;
+        prox_gain_param = (prox_gain_param & 0xFC) | val;
+        gain_param      = prox_gain_param & 0x03;
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->gain      = gain_param;
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_gain(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    u8 als_gain[4] = {1, 8, 16, 120};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als gain is x%d\n", als_gain[taos_cfgp->prox_gain & 0x03]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_debug_delay_time =  val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_debug_delay_time is %d\n", prox_debug_delay_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_debug_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_prox_debug = true;
+    }
+    else
+    {       
+        flag_prox_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_prox_debug_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_calibrate_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_offset_cal_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_offset_cal_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "prox calibrate is %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t attr_prox_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        taos_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {       
+    	 //cancel_delayed_work_sync(&chip->prox_unwakelock_work);
+	hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+	taos_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+//als
+static ssize_t attr_set_als_debug(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_als_debug = true;
+    }
+    else
+    {       
+        flag_als_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_debug(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_als_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_irq(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        taos_irq_ops(true, true);
+    }
+    else
+    {       
+        taos_irq_ops(false, true);
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_irq(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "flag_irq is %s\n", taos_datap->irq_enabled? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_prox_calibrate(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    int val,ret;
+
+	ret=kstrtouint(buf, 10, &val);
+    SENSOR_LOG_ERROR("enter\n");
+    if (ret<0)
+    {
+        return -EINVAL;
+    }
+
+    if (val>1)
+    {
+     taos_datap->prox_calibrate_times= val;
+    taos_prox_calibrate();
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("your input error, please input a number that bigger than 1\n");
+    }
+   
+	return size;
+}
+
+static ssize_t attr_prox_thres_high_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_hi_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_hi_param is %d\n",prox_calibrate_hi_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_low_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_lo_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n",prox_calibrate_lo_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n prox_calibrate_hi_param is %d\n",taos_cfgp->prox_threshold_lo,taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	mutex_lock(&taos_datap->lock);
+
+	if (value==1)
+    {
+   		if( (rc=taos_read_cal_value(CAL_THRESHOLD))<0)
+        {
+            mutex_unlock(&taos_datap->lock);
+            return -EINVAL;
+        }
+		else
+		{
+			if(rc > (taos_datap->prox_thres_hi_min))
+            		{
+			taos_datap->prox_calibrate_flag = false;
+			taos_datap->prox_manual_calibrate_threshold =rc;
+			taos_cfgp->prox_threshold_hi= rc;
+			taos_cfgp->prox_threshold_lo  = rc - PROX_THRESHOLD_DISTANCE;
+			input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+			input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+			input_sync(taos_datap->p_idev);
+			SENSOR_LOG_ERROR("prox_th_high  = %d\n",taos_cfgp->prox_threshold_hi);
+			SENSOR_LOG_ERROR("prox_th_low   = %d\n",taos_cfgp->prox_threshold_lo);
+           		 }
+
+		}
+	}
+	else
+    {	
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+static ssize_t attr_set_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_prox = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_prox is %d\n",taos_cfgp->scale_factor_prox);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_als = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_als = scale_factor_param_als;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_als is %d\n",taos_cfgp->scale_factor_als);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_get_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_hi = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+
+static ssize_t attr_get_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_lo);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_lo = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_set_prox_offset(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_config_offset_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_offset(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_config_offset_param is %d\n", taos_cfgp->prox_config_offset);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_calibrate_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_offset_cal_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_offset_cal_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_hi_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "prox_thres_hi_max is %d\n",taos_datap->prox_thres_hi_max);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_thres_hi_min(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        SENSOR_LOG_ERROR("prox_thres_hi_min is %d\n",taos_datap->prox_thres_hi_min);
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_min);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_data_safa_range_max_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "PROX_DATA_SAFE_RANGE_MAX is %d\n",PROX_DATA_SAFE_RANGE_MAX);
+
+        return sprintf(buf, "%d", PROX_DATA_SAFE_RANGE_MAX);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_safa_range_min_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+                SENSOR_LOG_ERROR("PROX_DATA_SAFE_RANGE_MIN is %d\n",PROX_DATA_SAFE_RANGE_MIN);
+
+        return sprintf(buf, "%d", PROX_DATA_SAFE_RANGE_MIN);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_chip_name_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%s", taos_datap->chip_name);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_data_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_manual_calibrate_threshold(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_manual_calibrate_threshold);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t attr_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|reg_addr), val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    unsigned char i;
+    if (100 == reg_addr)
+    {
+        for (i=0x00; i<=0x0F; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));
+        }
+        for (i=0x11; i<=0x19; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));            
+        }
+
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | 0x1F));
+        SENSOR_LOG_ERROR("reg[0x1F] = 0x%02X",i2c_smbus_read_byte(taos_datap->client));  
+    }   
+    else
+    {
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | reg_addr));
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(taos_datap->client)); 
+    }
+
+	return strlen(buf);
+}
+
+static ssize_t attr_get_prox_value(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+
+	 return sprintf(buf, "%d\n", last_proximity_data%100000);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+/*
+static struct device_attribute attributes[] = {
+#ifdef CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+	__ATTR(taos_prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+	__ATTR(taos_als_adc_time,                   0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+	__ATTR(taos_prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+	__ATTR(taos_wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+	__ATTR(taos_prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+	__ATTR(taos_als_gain,                       0644,   attr_get_als_gain,                          attr_set_als_gain),
+	__ATTR(taos_prox_debug,                     0644,   attr_get_prox_debug,                        attr_set_prox_debug),
+	__ATTR(taos_als_debug,                      0644,   attr_get_als_debug,                         attr_set_als_debug),
+	__ATTR(taos_prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+	__ATTR(taos_irq,                            0644,   attr_get_irq,                               attr_set_irq),       
+	__ATTR(taos_prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+	__ATTR(taos_prox_calibrate_hi_param,        0644,   attr_get_prox_calibrate_hi_param,           attr_set_prox_calibrate_hi_param),
+	__ATTR(taos_prox_calibrate_lo_param,        0644,   attr_get_prox_calibrate_lo_param,           attr_set_prox_calibrate_lo_param),
+	__ATTR(taos_als_scale_factor_param_als,     0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+	__ATTR(taos_als_scale_factor_param_prox,    0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+	__ATTR(taos_prox_threshold_high,            0644,   attr_get_prox_threshold_high,               NULL),
+	__ATTR(taos_prox_threshold_low,             0644,   attr_get_prox_threshold_low,                NULL),
+	__ATTR(taos_prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+#endif
+    __ATTR(taos_reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(taos_reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+	__ATTR(th_hi,                               0644,   attr_get_threshold_hi,                      attr_set_threshold_hi),
+	__ATTR(th_low,                              0644,   attr_get_threshold_lo,                      attr_set_threshold_lo),
+	__ATTR(prox_value,                          0644,   attr_get_prox_value,                        NULL),
+};
+*/
+
+
+///***************************************************************************************///
+//light
+static ssize_t attr_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_on);
+}
+
+static ssize_t attr_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        taos_sensors_als_poll_on();
+    }
+    else
+    {
+        taos_sensors_als_poll_off();
+    }
+
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "als_poll_time = %d\n", als_poll_delay);
+}
+
+static ssize_t attr_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+	als_poll_delay = time;
+	return size;
+}
+
+
+
+//prox
+static ssize_t attr_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_on);
+}
+
+static ssize_t attr_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value)
+    {
+        taos_prox_on();
+    }
+	else
+    {
+        taos_prox_off();
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_init_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "chip->init%d\n", chip->init);
+	
+}
+
+static ssize_t attr_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0,err=1;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+    {
+    	if((ret=taos_read_cal_value(PATH_PROX_OFFSET))>0)
+        {
+		    taos_cfgp->prox_config_offset = ret;
+        }
+
+    	if((ret=taos_read_cal_value(CAL_THRESHOLD))<0)
+		{
+		    SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+		    err=taos_write_cal_file(CAL_THRESHOLD,0);
+			if(err<0)
+			{
+				SENSOR_LOG_ERROR("ERROR=%s\n",CAL_THRESHOLD);
+				mutex_unlock(&taos_datap->lock);
+				return -EINVAL;
+			}
+           	taos_datap->prox_calibrate_flag = true;
+		}
+		else 
+        {
+            if (ret==0)
+            {
+                taos_datap->prox_calibrate_flag = true;
+                SENSOR_LOG_ERROR("taos_prox_calibrate==1\n");
+    		}
+    		else 
+            {
+                taos_datap->prox_calibrate_flag = false;
+                taos_datap->prox_manual_calibrate_threshold =ret;
+                taos_cfgp->prox_threshold_hi = ret;
+                taos_cfgp->prox_threshold_lo  = ret - PROX_THRESHOLD_DISTANCE;
+                input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+                input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+                input_sync(taos_datap->p_idev);
+                SENSOR_LOG_ERROR("taos_prox_init> 0\n");
+    		}
+        }
+
+        if((ret=taos_read_cal_value(PATH_PROX_UNCOVER_DATA))>0)
+        {
+		    taos_datap->prox_uncover_data = ret;
+            taos_datap->prox_thres_hi_min = taos_datap->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+        }
+	}
+	else
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_offset_cal_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+	{
+		return -EINVAL;
+	}
+		mutex_lock(&taos_datap->lock);
+		SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+      {
+             schedule_delayed_work(&taos_datap->prox_offset_cal_work, msecs_to_jiffies(0));
+             mutex_unlock(&taos_datap->lock);
+	}
+	else
+      {
+             SENSOR_LOG_ERROR("input error\n");
+       	mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+      }
+		SENSOR_LOG_INFO("exit\n");
+		return size;
+}
+
+
+static struct device_attribute attrs_light[] = {
+	__ATTR(enable,                         0640,   attr_als_enable_show,                       attr_als_enable_store),
+    __ATTR(light_gain,                     0644,   attr_get_als_gain,                          attr_set_als_gain),
+    __ATTR(light_debug,                    0644,   attr_get_als_debug,                         attr_set_als_debug),
+    __ATTR(light_adc_time,                 0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+    __ATTR(light_scale_factor_param,       0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+    __ATTR(prox_scale_factor_param,        0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+    __ATTR(delay,                          0640,   attr_als_poll_time_show,                    attr_als_poll_time_store),
+};
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                      0640,   attr_chip_name_show,                        NULL),
+	__ATTR(enable,                         0640,   attr_prox_enable_show,                      attr_prox_enable_store),    
+	__ATTR(prox_init,                      0640,   attr_prox_init_show,                        attr_prox_init_store),  
+	__ATTR(prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+    __ATTR(prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+    __ATTR(prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+    __ATTR(prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+    __ATTR(prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+    __ATTR(prox_threshold_high,            0644,   attr_get_prox_threshold_high,               attr_set_prox_threshold_high),
+    __ATTR(prox_threshold_low,             0644,   attr_get_prox_threshold_low,                attr_set_prox_threshold_low),
+    __ATTR(prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+    __ATTR(prox_value,                     0644,   attr_get_prox_value,                        NULL),
+    __ATTR(prox_calibrate_result,          0640,   attr_prox_calibrate_result_show,            NULL), 
+    __ATTR(prox_thres_param_high,          0640,   attr_prox_thres_high_show,                  attr_prox_thres_high_store),
+    __ATTR(prox_thres_param_low,           0640,   attr_prox_thres_low_show,                   attr_prox_thres_low_store),
+    __ATTR(prox_thres,                     0640,   attr_prox_thres_show,                       attr_prox_thres_store),
+    __ATTR(prox_debug,                     0640,   attr_prox_debug_show,                       attr_prox_debug_store),
+    __ATTR(prox_calibrate_start,           0640,   attr_prox_calibrate_start_show,             attr_prox_debug_store),
+    __ATTR(prox_thres_max,                 0644,   attr_prox_thres_hi_max,                     NULL), 
+    __ATTR(prox_thres_min,                 0644,   attr_prox_thres_hi_min,                     NULL), 
+    __ATTR(prox_data_max,                  0640,   attr_prox_data_max,                         NULL), 
+    __ATTR(prox_manual_calibrate_threshold,0644,   attr_prox_manual_calibrate_threshold,       NULL), 
+    __ATTR(prox_phone_is_sleep,            0640,   attr_prox_phone_is_sleep_show,              attr_prox_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                  0640,   attr_prox_prox_wakelock_show,               attr_prox_prox_wakelock_store),
+    __ATTR(reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+    __ATTR(irq_status,                     0644,   attr_get_irq,                               attr_set_irq),       
+    __ATTR(wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+    __ATTR(prox_offset_cal_start,           0640,   attr_prox_offset_cal_start_show,     attr_prox_debug_store),
+    __ATTR(prox_offset_cal,                 0640,   attr_get_prox_offset,           attr_prox_offset_cal_store),
+    __ATTR(prox_offset_cal_result,          0640,   attr_prox_offset_cal_result_show,            NULL), 
+    __ATTR(prox_data_safe_range_max,        0644,   attr_prox_data_safa_range_max_show,  NULL), 
+    __ATTR(prox_data_safe_range_min,        0644,   attr_prox_data_safa_range_min_show,  NULL), 
+
+};
+
+
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable)
+{
+    if (enable == wakelock->locked)
+    {
+        SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+static int taos_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+      
+    }
+       memset(write_buf, 0, sizeof(write_buf));
+      sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+
+static int taos_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+static void taos_irq_work_func(struct work_struct * work) //iVIZM
+{
+    int retry_times = 0;
+    int ret;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    if (wakeup_from_sleep)
+    {  
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        mdelay(50);
+        wakeup_from_sleep = false;
+    }
+
+    for (retry_times=0; retry_times<=50; retry_times++)
+    {
+        ret = taos_get_data();
+        if (ret >= 0)
+        {
+            break;
+        }
+        mdelay(20);
+    }
+    taos_interrupts_clear();
+
+    hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+    taos_datap->irq_work_status = false;
+   // SENSOR_LOG_INFO("########  taos_irq_work_func enter   hrtimer_start #########\n");
+    hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+   //  schedule_delayed_work(&taos_datap->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    taos_irq_ops(true, true);
+    SENSOR_LOG_INFO(" retry_times = %d\n",retry_times);
+    mutex_unlock(&taos_datap->lock);
+}
+
+static irqreturn_t taos_irq_handler(int irq, void *dev_id) //iVIZM
+{
+    SENSOR_LOG_INFO("enter\n");
+    taos_datap->irq_work_status = true;
+    taos_irq_ops(false, false);
+    taos_wakelock_ops(&(taos_datap->proximity_wakelock), true);
+    if (0==queue_work(taos_datap->irq_work_queue, &taos_datap->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+    SENSOR_LOG_INFO("exit\n");
+    return IRQ_HANDLED;
+}
+
+static int taos_get_data(void)//iVIZM
+{
+    int ret = 0;
+
+    ret = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS));
+    
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("read TAOS_TRITON_STATUS failed\n");
+        return ret;
+    }
+    else
+    { 
+        ret = taos_prox_threshold_set();
+    }
+    return ret;
+}
+
+
+static int taos_interrupts_clear(void)//iVIZM
+{
+    int ret = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_CMD_SPL_FN|0x07)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte(2) failed in taos_work_func()\n");
+        return (ret);
+    }
+    return ret;
+}
+
+static int taos_als_get_data(void)//iVIZM
+{
+    int ret = 0;
+    u8 reg_val;
+    int lux_val = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) != (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+        return -ENODATA;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) != TAOS_TRITON_STATUS_ADCVALID)
+        return -ENODATA;
+
+    if ((lux_val = taos_get_lux()) < 0)
+    {
+        printk(KERN_ERR "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n", lux_val);
+    }
+
+    if (lux_val<TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_8X)
+    {
+        taos_als_gain_set(TAOS_ALS_GAIN_8X);
+    }
+    else
+    {
+        if (lux_val>TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_1X)
+        {
+            taos_als_gain_set(TAOS_ALS_GAIN_1X);
+        }
+    }
+    
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "reg_val = %d lux_val = %d\n",reg_val,lux_val);
+    }
+
+    if (reg_val != prox_int_time_param)
+    {
+        lux_val = (lux_val * (101 - (0XFF - reg_val)))/20;
+    }
+
+    lux_val = taos_lux_filter(lux_val);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "lux_val = %d",lux_val);
+    }
+
+    input_report_rel(taos_datap->a_idev, REL_X, lux_val+1);
+    input_sync(taos_datap->a_idev);
+
+    return ret;
+}
+
+static int taos_prox_threshold_set(void)//iVIZM
+{
+    int i,ret = 0;
+    u8 chdata[6];
+    u16 proxdata = 0;
+    u16 cleardata = 0;
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_WORD_BLK_RW| (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    cleardata = chdata[0] + chdata[1]*256;
+    proxdata = chdata[4] + chdata[5]*256;
+
+	if (pro_ft || flag_prox_debug)
+    {
+        pro_buf[0] = 0xff;
+        pro_buf[1] = 0xff;
+        pro_buf[2] = 0xff;
+        pro_buf[3] = 0xff;
+        
+        for( mcount=0; mcount<4; mcount++ )
+        {
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+            {
+                 printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+                 return (ret);
+            }
+        }      
+
+        if (pro_ft)
+        {
+            SENSOR_LOG_INFO( "init the prox threshold");
+        }
+
+        if (flag_prox_debug)
+        {
+            mdelay(prox_debug_delay_time);
+            SENSOR_LOG_INFO( "proxdata = %d",proxdata);
+	        input_report_rel(taos_datap->p_idev, REL_MISC, proxdata);
+
+        }
+		pro_ft = false;
+	} 
+    else 
+    {
+        if (proxdata < taos_cfgp->prox_threshold_lo) 
+        {   //FAR
+            pro_buf[0] = 0x0;
+            pro_buf[1] = 0x0;
+            pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+            pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+    		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+            input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+        } 
+        else 
+        {
+                if (proxdata > taos_cfgp->prox_threshold_hi)
+                {   //NEAR
+                    if (cleardata > ((sat_als*80)/100))
+                    {
+                    	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                    	msleep(100);
+                        return -ENODATA;
+                    }
+                    pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                    pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                    pro_buf[2] = 0xff;
+                    pro_buf[3] = 0xff;
+                    SENSOR_LOG_INFO("Near!!! proxdata = %d\n",proxdata);
+                    input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                }
+                else
+                {
+                    if( (taos_cfgp->prox_threshold_hi-proxdata) > (proxdata-taos_cfgp->prox_threshold_lo))
+                    {
+                        //FAR
+                        pro_buf[0] = 0x0;
+                        pro_buf[1] = 0x0;
+                        pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+                        pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+                		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, taos_cfgp->prox_threshold_lo-50);
+                    }
+                    else
+                    {
+                        //NEAR
+                        if (cleardata > ((sat_als*80)/100))
+                        {
+                        	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                        	msleep(100);
+                            return -ENODATA;
+                        }
+                        pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                        pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                        pro_buf[2] = 0xff;
+                        pro_buf[3] = 0xff;
+                        SENSOR_LOG_INFO( "Near!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, taos_cfgp->prox_threshold_hi+50);
+                    }
+                }
+            }
+    }
+
+    input_sync(taos_datap->p_idev);
+
+    for( mcount=0; mcount<4; mcount++) 
+    { 
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+        {
+             printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+             return (ret);
+        }
+    }
+
+    return ret;
+}
+
+// driver init
+static int __init taos_init(void) 
+{
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmd2772_driver);
+#endif
+}
+
+// driver exit
+static void __exit taos_exit(void) 
+{
+	i2c_del_driver(&tmd2772_driver);
+}
+
+static int tmd2772_parse_dt(struct taos_data *chip)
+{
+	struct device_node *np = chip->client->dev.of_node;
+	chip->irq_pin_num = of_get_named_gpio(np, "ams,irq-gpio", 0);
+    SENSOR_LOG_INFO("irq_pin_num is %d\n",chip->irq_pin_num);
+    return 0;
+}
+
+static void tmd2772_data_init(void)
+{
+    taos_datap->als_on  = false;
+    taos_datap->prox_on = false;
+    taos_datap->init = false;
+    taos_datap->als_poll_time_mul = 1;
+    taos_datap->prox_name = "proximity";
+    taos_datap->als_name  = "light";
+    taos_datap->chip_name = "tmd2772";
+    taos_datap->prox_calibrate_result = false;
+    taos_datap->prox_offset_cal_result = false;
+    taos_datap->prox_thres_hi_max = PROX_THRESHOLD_HIGH_MAX;
+    taos_datap->prox_thres_hi_min = PROX_DATA_SAFE_RANGE_MAX + PROX_THRESHOLD_DISTANCE;
+    taos_datap->prox_data_max     = PROX_DATA_MAX;
+    taos_datap->prox_uncover_data = 0;
+    taos_datap->prox_calibrate_times = 10;
+    taos_datap->prox_calibrate_flag = true;//true :auto_calibrate,false :manual_calibrate
+    taos_datap->prox_manual_calibrate_threshold = 0;
+    taos_datap->proximity_wakelock.name = "proximity-wakelock";
+    taos_datap->proximity_wakelock.locked = false;
+    taos_datap->phone_is_sleep = false;
+    taos_datap->irq_work_status = false;
+    taos_datap->irq_enabled = true;
+}
+
+
+
+// client probe
+static int __devinit tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp) 
+{
+    int ret = 0;
+    int i = 0;
+    int chip_id = -1;
+    unsigned char buf[TAOS_MAX_DEVICE_REGS];
+    char *device_name;
+    SENSOR_LOG_INFO("Prob Start\n");
+    chip_id = i2c_smbus_read_byte_data(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12))); //iVIZM
+    /*TSL27711=0x00 TSL27713=0x09 TMD27711=0x20 TMD27713=0x29 	2011.09.07*/
+	SENSOR_LOG_ERROR(" TAOS chip_id = %x TMD27713=30,TMD27723=39\n",chip_id);	
+	//printk(" TAOS ID reg = %d\n",(TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12)));	
+    if(chip_id != 0x39) 
+    {
+    	printk(" chip id that was read does not match TMD27723\n");	
+        return -ENODEV;
+    }
+    if (device_found)
+        return -ENODEV;
+    if (!i2c_check_functionality(clientp->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) 
+    {
+        printk(KERN_ERR "TAOS: taos_probe() - i2c smbus byte data functions unsupported\n");
+        return -EOPNOTSUPP;
+    }
+
+    taos_datap = kmalloc(sizeof(struct taos_data), GFP_KERNEL);
+    if (!taos_datap) 
+    {
+         SENSOR_LOG_ERROR("kmalloc for struct taos_data failed\n");
+         return -ENOMEM;
+    }
+
+    taos_datap->client = clientp;
+
+    i2c_set_clientdata(clientp, taos_datap);
+
+    
+
+    INIT_WORK(&(taos_datap->irq_work),taos_irq_work_func);  
+
+	sema_init(&taos_datap->update_lock,1);
+	mutex_init(&(taos_datap->lock));
+    wake_lock_init(&taos_datap->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, "proximity-wakelock");
+
+    tmd2772_data_init();
+
+    tmd2772_parse_dt(taos_datap);
+
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+        if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + i))))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+            return(ret);
+        }
+        buf[i] = i2c_smbus_read_byte(clientp);
+    }
+
+    if ((ret = taos_device_name(buf, &device_name)) == 0) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read found mismatched by taos_device_name(), in taos_probe()\n");
+        return -ENODEV;
+    }
+    if (strcmp(device_name, TAOS_DEVICE_ID)) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read does not match expected id in taos_probe()\n");
+        return -ENODEV;
+    }
+    else 
+    {
+        SENSOR_LOG_ERROR( "TAOS: chip id of %s that was read matches expected id in taos_probe()\n", device_name);
+        device_found = 1;
+    }
+    if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+        return(ret);
+    }
+    strlcpy(clientp->name, TAOS_DEVICE_ID, I2C_NAME_SIZE);
+    strlcpy(taos_datap->taos_name, TAOS_DEVICE_ID, TAOS_ID_NAME_SIZE);
+    taos_datap->valid = 0;
+    if (!(taos_cfgp = kmalloc(sizeof(struct taos_cfg), GFP_KERNEL))) {
+        printk(KERN_ERR "TAOS: kmalloc for struct taos_cfg failed in taos_probe()\n");
+        return -ENOMEM;
+    }
+    taos_cfgp->calibrate_target = calibrate_target_param;
+    taos_cfgp->als_time = als_time_param;
+    taos_cfgp->scale_factor_als = scale_factor_param_als;
+	taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+    taos_cfgp->gain_trim = gain_trim_param;
+    taos_cfgp->filter_history = filter_history_param;
+    taos_cfgp->filter_count = filter_count_param;
+    taos_cfgp->gain = gain_param;
+    taos_cfgp->als_threshold_hi = als_threshold_hi_param;//iVIZM
+    taos_cfgp->als_threshold_lo = als_threshold_lo_param;//iVIZM
+    taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+    taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+    taos_cfgp->prox_int_time = prox_int_time_param;
+    taos_cfgp->prox_adc_time = prox_adc_time_param;
+    taos_cfgp->prox_wait_time = prox_wait_time_param;
+    taos_cfgp->prox_intr_filter = prox_intr_filter_param;
+    taos_cfgp->prox_config = prox_config_param;
+    taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+    taos_cfgp->prox_gain = prox_gain_param;
+    taos_cfgp->prox_config_offset=prox_config_offset_param;
+    sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+    sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+
+    /*dmobile ::power down for init ,Rambo liu*/
+    SENSOR_LOG_ERROR("TAOS:Rambo::light sensor will pwr down \n");
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x00), 0x00))) < 0) {
+        printk(KERN_ERR "TAOS:Rambo, i2c_smbus_write_byte_data failed in power down\n");
+        return (ret);
+    }
+
+
+    taos_datap->irq_work_queue = create_singlethread_workqueue("taos_work_queue");
+    if (!taos_datap->irq_work_queue)
+    {
+        ret = -ENOMEM;
+        SENSOR_LOG_INFO( "---------%s: %d: cannot create work taos_work_queue, err = %d",__func__,__LINE__,ret);
+        return ret;
+    }
+
+    ret = gpio_request(taos_datap->irq_pin_num, "ALS_PS_INT");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",taos_datap->irq_pin_num);
+        
+        gpio_free(taos_datap->irq_pin_num);
+        ret = gpio_request(taos_datap->irq_pin_num, "ALS_PS_INT");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",taos_datap->irq_pin_num);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("get gpio %d success\n",taos_datap->irq_pin_num);
+    }
+
+
+    ret = gpio_tlmm_config(GPIO_CFG(taos_datap->irq_pin_num, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    taos_datap->client->irq = gpio_to_irq(taos_datap->irq_pin_num);
+
+	ret = request_threaded_irq(taos_datap->client->irq, NULL, &taos_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "taos_irq", taos_datap);
+    if (ret != 0) 
+    {
+        gpio_free(taos_datap->irq_pin_num);
+        return(ret);
+    }
+
+    taos_irq_ops(false, true);
+    INIT_DELAYED_WORK(&taos_datap->als_poll_work, taos_als_poll_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_calibrate_work, taos_prox_calibrate_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_offset_cal_work, taos_prox_offset_cal_work_func);
+
+  //  INIT_DELAYED_WORK(&taos_datap->prox_unwakelock_work, taos_prox_unwakelock_work_func);
+    hrtimer_init(&taos_datap->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    ( taos_datap->prox_unwakelock_timer).function = taos_prox_unwakelock_work_func ;
+   // hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+
+    taos_datap->proximity_dev = device_create(proximity_class, NULL, tmd2772_proximity_dev_t, &tmd2772_driver ,"proximity");
+    if (IS_ERR(taos_datap->proximity_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->proximity_dev);
+      SENSOR_LOG_ERROR("device_create proximity failed\n");
+      goto create_proximity_dev_failed;
+    }
+
+    taos_datap->light_dev= device_create(light_class, NULL, tmd2772_light_dev_t, &tmd2772_driver ,"light");
+    if (IS_ERR(taos_datap->light_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->light_dev);
+      SENSOR_LOG_ERROR("device_create light failed\n");
+      goto create_light_dev_failed;
+    }
+
+    //prox input 
+    taos_datap->p_idev = input_allocate_device();
+    if (!taos_datap->p_idev)
+    {
+        SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->prox_name);
+        ret = -ENODEV;
+        goto input_p_alloc_failed;
+    }
+    taos_datap->p_idev->name = taos_datap->prox_name;
+    taos_datap->p_idev->id.bustype = BUS_I2C;
+    dev_set_drvdata(&taos_datap->p_idev->dev, taos_datap);
+    ret = input_register_device(taos_datap->p_idev);
+    if (ret) 
+    {
+        input_free_device(taos_datap->p_idev);
+        SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+        goto input_p_register_failed;
+    }
+
+    set_bit(EV_REL, taos_datap->p_idev->evbit);
+    set_bit(REL_X,  taos_datap->p_idev->relbit);
+    set_bit(REL_Y,  taos_datap->p_idev->relbit);
+    set_bit(REL_Z,  taos_datap->p_idev->relbit);
+    set_bit(REL_MISC,  taos_datap->p_idev->relbit);
+
+    //light input
+    taos_datap->a_idev = input_allocate_device();
+	if (!taos_datap->a_idev) 
+    {
+		SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	taos_datap->a_idev->name = taos_datap->als_name;
+	taos_datap->a_idev->id.bustype = BUS_I2C;
+    
+    /*
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+    */
+
+    set_bit(EV_REL, taos_datap->a_idev->evbit);
+    set_bit(REL_X,  taos_datap->a_idev->relbit);
+    set_bit(REL_Y,  taos_datap->a_idev->relbit);
+
+
+	//chip->a_idev->open = tmg399x_als_idev_open;
+	//chip->a_idev->close = tmg399x_als_idev_close;
+	dev_set_drvdata(&taos_datap->a_idev->dev, taos_datap);
+	ret = input_register_device(taos_datap->a_idev);
+	if (ret) 
+    {
+		input_free_device(taos_datap->a_idev);
+		SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+		goto input_a_register_failed;
+	}
+
+	dev_set_drvdata(taos_datap->proximity_dev, taos_datap);
+	dev_set_drvdata(taos_datap->light_dev, taos_datap);
+
+
+    create_sysfs_interfaces_prox(taos_datap->proximity_dev);
+    create_sysfs_interfaces_light(taos_datap->light_dev);
+
+    SENSOR_LOG_INFO("Prob OK\n");
+
+	return 0;
+
+
+input_a_register_failed:
+    input_free_device(taos_datap->a_idev);
+input_a_alloc_failed:
+
+input_p_register_failed:
+    input_free_device(taos_datap->p_idev);
+input_p_alloc_failed:
+
+create_light_dev_failed:
+    taos_datap->light_dev = NULL;
+    class_destroy(light_class);
+
+create_proximity_dev_failed:
+    taos_datap->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+    SENSOR_LOG_INFO("Prob Failed\n");
+
+    return (ret);
+}
+
+#ifdef CONFIG_PM_SLEEP
+//don't move these pm blew to ioctl
+//resume  
+static int taos_resume(struct i2c_client *client) {
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: disable irq wakeup\n",__func__,__LINE__);
+		ret = disable_irq_wake(taos_datap->client->irq);
+	}
+    if(ret < 0)
+		printk(KERN_ERR "TAOS: disable_irq_wake failed\n");
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+//suspend  
+static int taos_suspend(struct i2c_client *client, pm_message_t mesg) 
+{
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: enable irq wakeup\n",__func__,__LINE__);
+       	ret = enable_irq_wake(taos_datap->client->irq);
+    }
+	if(ret < 0)
+    {
+		printk(KERN_ERR "TAOS: enable_irq_wake failed\n");
+    }
+
+    wakeup_from_sleep = true;
+
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+#endif
+// client remove
+static int __devexit tmd2772_remove(struct i2c_client *client) {
+    int ret = 0;
+
+    return (ret);
+}
+
+
+// read/calculate lux value
+static int taos_get_lux(void) 
+{
+    int raw_clear = 0, raw_ir = 0, raw_lux = 0;
+    u32 lux = 0;
+    u32 ratio = 0;
+    u8 dev_gain = 0;
+    u16 Tint = 0;
+    struct lux_data *p;
+    int ret = 0;
+    u8 chdata[4];
+    int tmp = 0, i = 0,tmp_gain=1;
+    for (i = 0; i < 4; i++) {
+        if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_ALS_CHAN0LO + i))))) < 0) {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to chan0/1/lo/hi reg failed in taos_get_lux()\n");
+            return (ret);
+        }
+        chdata[i] = i2c_smbus_read_byte(taos_datap->client);
+    }
+
+    tmp = (taos_cfgp->als_time + 25)/50;            //if atime =100  tmp = (atime+25)/50=2.5   time = 2.7*(256-atime)=  412.5
+    TritonTime.numerator = 1;
+    TritonTime.denominator = tmp;
+
+    tmp = 300 * taos_cfgp->als_time;               //tmp = 300*atime  400
+    if(tmp > 65535)
+        tmp = 65535;
+    TritonTime.saturation = tmp;
+    raw_clear = chdata[1];
+    raw_clear <<= 8;
+    raw_clear |= chdata[0];
+    raw_ir    = chdata[3];
+    raw_ir    <<= 8;
+    raw_ir    |= chdata[2];
+
+    raw_clear *= ((taos_cfgp->scale_factor_als )*tmp_gain);
+    raw_ir *= (taos_cfgp->scale_factor_prox );
+
+    if(raw_ir > raw_clear) {
+        raw_lux = raw_ir;
+        raw_ir = raw_clear;
+        raw_clear = raw_lux;
+    }
+    dev_gain = taos_triton_gain_table[taos_cfgp->gain & 0x3];
+    if(raw_clear >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_ir >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_clear == 0)
+        return(0);
+    if(dev_gain == 0 || dev_gain > 127) {
+        printk(KERN_ERR "TAOS: dev_gain = 0 or > 127 in taos_get_lux()\n");
+        return -1;
+    }
+    if(lux_timep->denominator == 0) {
+        printk(KERN_ERR "TAOS: lux_timep->denominator = 0 in taos_get_lux()\n");
+        return -1;
+    }
+    ratio = (raw_ir<<15)/raw_clear;
+    for (p = lux_tablep; p->ratio && p->ratio < ratio; p++);
+	#ifdef WORK_UES_POLL_MODE
+    if(!p->ratio) {//iVIZM
+        if(lux_history[0] < 0)
+            return 0;
+        else
+            return lux_history[0];
+    }
+	#endif
+    Tint = taos_cfgp->als_time;
+    raw_clear = ((raw_clear*400 + (dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    raw_ir = ((raw_ir*400 +(dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    lux = ((raw_clear*(p->clear)) - (raw_ir*(p->ir)));
+    lux = (lux + 32000)/64000;
+    if(lux > TAOS_MAX_LUX) {
+        lux = TAOS_MAX_LUX;
+    }
+    return(lux);
+}
+
+static int taos_lux_filter(int lux)
+{
+    static u8 middle[] = {1,0,2,0,0,2,0,1};
+    int index;
+
+    lux_history[2] = lux_history[1];
+    lux_history[1] = lux_history[0];
+    lux_history[0] = lux;
+
+    if(lux_history[2] < 0) { //iVIZM
+        if(lux_history[1] > 0)
+            return lux_history[1];       
+        else 
+            return lux_history[0];
+    }
+    index = 0;
+    if( lux_history[0] > lux_history[1] ) 
+        index += 4;
+    if( lux_history[1] > lux_history[2] ) 
+        index += 2;
+    if( lux_history[0] > lux_history[2] )
+        index++;
+    return(lux_history[middle[index]]);
+}
+
+// verify device
+static int taos_device_name(unsigned char *bufp, char **device_name)
+{
+    /*
+    int i=0 ,j;
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+	  	j=bufp[i];
+	  	printk("(bufp[i=%x]=%x,\n",i,j);
+    }
+    */
+    *device_name="tritonFN";
+    return(1);
+}
+
+// proximity poll
+static int taos_prox_poll(struct taos_prox_info *prxp)
+{
+    int i = 0, ret = 0; //wait_count = 0;
+    u8 chdata[6];
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_AUTO | (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    prxp->prox_clear = chdata[1];
+    prxp->prox_clear <<= 8;
+    prxp->prox_clear |= chdata[0];
+    if (prxp->prox_clear > ((sat_als*80)/100))
+    {
+		printk(KERN_ERR "TAOS: %u <= %u*0.8 poll data\n",prxp->prox_clear,sat_als);
+        return -ENODATA;
+    }
+    prxp->prox_data = chdata[5];
+    prxp->prox_data <<= 8;
+    prxp->prox_data |= chdata[4];
+
+    return (ret);
+}
+
+// prox poll timer function
+static void taos_prox_poll_timer_func(unsigned long param) {
+    int ret = 0;
+
+    if (!device_released) {
+        if ((ret = taos_prox_poll(prox_cur_infop)) < 0) {
+            printk(KERN_ERR "TAOS: call to prox_poll failed in taos_prox_poll_timer_func()\n");
+            return;
+        }
+        taos_prox_poll_timer_start();
+    }
+    return;
+}
+
+// start prox poll timer
+static void taos_prox_poll_timer_start(void) {
+    init_timer(&prox_poll_timer);
+    prox_poll_timer.expires = jiffies + (HZ/10);
+    prox_poll_timer.function = taos_prox_poll_timer_func;
+    add_timer(&prox_poll_timer);
+    return;
+}
+
+static void taos_update_sat_als(void)
+{
+    u8 reg_val = 0;
+    int ret = 0;
+
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_calibrate\n");
+        return;
+    }
+    
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    sat_als = (256 - reg_val) << 10;
+}
+
+static int taos_als_gain_set(unsigned als_gain)
+{
+    int ret;
+    prox_gain_param = (prox_gain_param & 0xFC) | als_gain;
+    gain_param      = prox_gain_param & 0x03;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->gain      = gain_param;
+        taos_cfgp->prox_gain = prox_gain_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");        
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static void taos_als_poll_work_func(struct work_struct *work)
+{
+    taos_als_get_data();
+    if (true == taos_datap->als_on)
+    {
+        schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(als_poll_time_mul*als_poll_delay));
+    }
+}
+
+static void taos_prox_calibrate_work_func(struct work_struct *work)
+{
+
+		taos_prox_calibrate();
+	
+}
+
+static int taos_prox_offset_cal_prepare(void)
+{
+    int ret =1;
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = 0;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+	     return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+	 return -EINVAL;
+    }
+	 return ret;
+}
+
+static int taos_prox_offset_calculate(int data, int target)
+{
+    int offset;
+
+    if (data > PROX_DATA_TARGET)
+    {
+        offset = (data - PROX_DATA_TARGET) * PROX_OFFSET_CAL_PER_BIT;
+    }
+    else
+    {
+        offset = (PROX_DATA_TARGET - data) * PROX_OFFSET_CAL_PER_BIT + 128;
+    }
+	
+   SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_offset = %d\n",offset );
+
+    return offset;
+}
+
+static int taos_prox_uncover_data_get(void)
+{
+    u8 i = 0, j = 0;
+    int prox_sum = 0, ret = 0;
+    static struct taos_prox_info prox_info_temp;
+
+    mdelay(20);
+    for (i = 0, j = 0; i < PROX_OFFSET_CAL_BUFFER_SIZE / 5; i++)
+    {
+        if ((ret = taos_prox_poll(&prox_info_temp)) < 0)
+        {
+            SENSOR_LOG_ERROR("failed to tmd2772_prox_read_data\n");
+        }
+        else
+        {
+            j++;
+            prox_sum += prox_info_temp.prox_data;
+        }
+        mdelay(20);
+    }
+
+    if(j == 0)
+    {
+        ret = -1;
+        goto error;
+    }
+
+    taos_datap->prox_uncover_data = prox_sum / j;
+    taos_datap->prox_thres_hi_min = taos_datap->prox_uncover_data + PROX_THRESHOLD_SAFE_DISTANCE + PROX_THRESHOLD_DISTANCE;
+
+    SENSOR_LOG_ERROR("prox_uncover_data = %d, prox_thres_hi_min = %d\n", taos_datap->prox_uncover_data, taos_datap->prox_thres_hi_min);
+    taos_write_cal_file(PATH_PROX_UNCOVER_DATA, taos_datap->prox_uncover_data);
+
+    return 0;
+    
+error:
+    return ret;
+}
+
+static int taos_prox_offset_cal_process(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0;
+    int i = 0, j = 0;
+    u8 reg_val = 0;
+    u8 reg_cntrl = 0;
+
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (PROX_OFFSET_CAL_BUFFER_SIZE), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_offset_cal_buffer_error;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_offset_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_offset_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_offset_error;
+        }
+		
+        mdelay(30);
+		
+        for (i = 0; i < (PROX_OFFSET_CAL_BUFFER_SIZE); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+       
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(PROX_OFFSET_CAL_BUFFER_SIZE);
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_mean = %d\n",prox_mean );
+	 if(j != 0)	 	
+            goto prox_calibrate_offset_error;
+
+	  prox_config_offset_param = taos_prox_offset_calculate(prox_mean, PROX_DATA_TARGET);
+	 
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+		
+        if((ret=taos_write_cal_file(PATH_PROX_OFFSET,taos_cfgp->prox_config_offset)) < 0)
+	      goto prox_calibrate_offset_error;
+
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }     
+
+        //read prox data register after update offset register
+        ret = taos_prox_uncover_data_get();
+        if (ret < 0)
+        {
+         SENSOR_LOG_ERROR("failed to tmd2772_prox_uncover_data_get\n");
+         goto prox_calibrate_offset_error;
+        }
+
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_offset_error;
+
+                }
+             }
+         }
+
+
+
+
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_offset_error:
+    SENSOR_LOG_ERROR("ERROR\n");
+	 kfree(prox_cal_info);
+prox_offset_cal_buffer_error:
+
+	return -1;
+    }
+
+static void taos_prox_offset_cal_finish(void)
+{
+
+    if (true == (taos_datap->prox_on))
+    {
+        taos_prox_on();
+    }
+    else
+    {
+        taos_prox_off();
+    }
+}
+static int taos_prox_offset_cal(void)
+{
+    int ret = 0;
+    taos_datap->prox_offset_cal_result = false;
+
+    if ((ret=taos_prox_offset_cal_prepare())<0)
+	goto error;
+
+    mdelay(50);
+
+    if ((ret= taos_prox_offset_cal_process())>=0)
+    {
+        taos_datap->prox_offset_cal_result = true;
+    }
+
+    taos_prox_offset_cal_finish();
+	
+    return ret;
+error:
+    return ret;
+}
+
+
+static void taos_prox_offset_cal_work_func(struct work_struct *work)
+{
+
+		taos_prox_offset_cal();
+	
+}
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer)
+{	 
+	SENSOR_LOG_INFO("######## taos_prox_unwakelock_timer_func #########\n");
+	if(false == taos_datap->irq_work_status )
+	taos_wakelock_ops(&(taos_datap->proximity_wakelock),false);
+	return HRTIMER_NORESTART;
+	
+}
+
+static int taos_sensors_als_poll_on(void) 
+{
+    int  ret = 0, i = 0;
+    u8   reg_val = 0, reg_cntrl = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS ON #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {
+        lux_history[i] = -ENODATA;
+    }
+
+    if (taos_datap->prox_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), taos_cfgp->prox_int_time))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+            return (ret);
+        }
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN));
+
+    //SENSOR_LOG_INFO("reg[0x0F] = 0x%02X\n",reg_val);
+
+    reg_val = reg_val & 0xFC;
+    reg_val = reg_val | (taos_cfgp->gain & 0x03);//*16
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN), reg_val))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+    reg_cntrl = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+    SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_cntrl);
+
+    reg_cntrl |= (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON);
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+	schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(200));
+
+    flag_just_open_light = true;
+
+    taos_datap->als_on = true;
+
+    taos_update_sat_als();
+
+	return ret;
+}	
+
+static int taos_sensors_als_poll_off(void)
+{
+    int  ret = 0, i = 0;
+    u8  reg_val = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS OFF #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {   
+        lux_history[i] = -ENODATA;
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+
+    //SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_val);
+
+    if ((reg_val & TAOS_TRITON_CNTL_PROX_DET_ENBL) == 0x00 && (0 == taos_datap->prox_on)) 
+    {        
+        SENSOR_LOG_INFO("TAOS_TRITON_CNTL_PROX_DET_ENBL = 0\n");
+        reg_val = 0x00;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_val))) < 0) 
+        {
+           printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+           return (ret);
+        }
+
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_ALS_TIME), 0XFF))) < 0) 
+    {
+       printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+       return (ret);
+    }
+
+    taos_datap->als_on = false;
+
+    cancel_delayed_work_sync(&taos_datap->als_poll_work);
+
+    taos_update_sat_als();
+
+    return (ret);
+}
+
+static int taos_prox_on(void)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    int  ret = 0;
+    u8 reg_cntrl = 0, i = 0 ,j = 0;
+
+    taos_datap->prox_on = 1;
+    als_poll_time_mul = 2;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL PROX ON  ######## \n");
+
+    if (true==taos_datap->als_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), 0XFF))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+
+    taos_update_sat_als();
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0C), taos_cfgp->prox_intr_filter))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    reg_cntrl = TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON    | TAOS_TRITON_CNTL_PROX_INT_ENBL | 
+		                                         TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_WAIT_TMR_ENBL  ;
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+	pro_ft = true;
+    if (taos_datap->prox_calibrate_flag)
+    {
+        prox_sum = 0;
+        prox_max = 0;
+
+        mdelay(20);
+        for (i = 0, j = 0; i < 5; i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {
+                j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            mdelay(20);
+        }
+
+        prox_mean = prox_sum/5;
+        if (j==0)
+        {
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+110;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+35;
+
+            printk("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+            printk("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+            if( prox_mean >800 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+            {
+                taos_cfgp->prox_threshold_hi= 800;
+                taos_cfgp->prox_threshold_lo =750;
+            }
+
+            if(taos_cfgp->prox_threshold_hi < 200)
+            {
+            	taos_cfgp->prox_threshold_hi = 200;
+            	taos_cfgp->prox_threshold_lo = 100;	
+            }
+
+            input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+            input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+            input_sync(taos_datap->p_idev);
+    	}
+    }
+    taos_prox_threshold_set();   
+    taos_irq_ops(true, true);
+    return (ret);
+}
+
+
+static int taos_prox_off(void)
+{    
+    int ret = 0;
+    SENSOR_LOG_INFO("########  TAOS IOCTL PROX OFF  ########\n");
+
+    if (true == (taos_datap->proximity_wakelock).locked)
+    {      
+    	  hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+        taos_wakelock_ops(&(taos_datap->proximity_wakelock), false);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), 0x00))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+        return (ret);
+    }
+
+    taos_datap->prox_on = 0;
+    als_poll_time_mul = 1;
+
+	if (true == taos_datap->als_on) 
+    {
+        taos_sensors_als_poll_on();
+	}
+
+   // cancel_work_sync(&taos_datap->irq_work);
+    if (true == taos_datap->irq_enabled)
+    {
+        taos_irq_ops(false, true);
+    }
+
+
+    return (ret);
+}
+
+
+static int taos_prox_calibrate(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0, prox_max = 0,prox_min = 1024;
+    u8 reg_cntrl = 0;
+    u8 reg_val = 0;
+    int i = 0, j = 0;
+    
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_calibrate_error1;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_error;
+        }
+
+        prox_sum = 0;
+        prox_max = 0;
+	 prox_min =1024;
+        mdelay(30);
+        for (i = 0; i < (taos_datap->prox_calibrate_times); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+		if (prox_cal_info[i].prox_data < prox_min)
+                prox_min = prox_cal_info[i].prox_data;
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(taos_datap->prox_calibrate_times);
+	    if(j == 0)
+	 	{
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+120;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+40;
+	 	}
+
+		if( prox_mean >700 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+			{
+			 taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+			taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;	
+			prox_config_offset_param=0x0;
+			taos_cfgp->prox_config_offset = prox_config_offset_param;
+			}
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_mean = %d\n",prox_mean );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_max = %d\n",prox_max );
+	 SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_min = %d\n",prox_min );
+     
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_error;
+
+                }
+             }
+         }
+
+        input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+        input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+        input_sync(taos_datap->p_idev);
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_error:
+    SENSOR_LOG_ERROR("exit\n");
+	 kfree(prox_cal_info);
+prox_calibrate_error1:
+
+	return -1;
+    }
+
+
+MODULE_AUTHOR("John Koshi - Surya Software");
+MODULE_DESCRIPTION("TAOS ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(taos_init);
+module_exit(taos_exit);
+
diff --git a/drivers/hwmon/tmd2772_ne501j.c b/drivers/hwmon/tmd2772_ne501j.c
new file mode 100644
index 0000000..2e1f22b
--- /dev/null
+++ b/drivers/hwmon/tmd2772_ne501j.c
@@ -0,0 +1,3142 @@
+/*******************************************************************************
+*                                                                              *
+*   File Name:    taos.c                                                      *
+*   Description:   Linux device driver for Taos ambient light and         *
+*   proximity sensors.                                     *
+*   Author:         John Koshi                                             *
+*   History:   09/16/2009 - Initial creation                          *
+*           10/09/2009 - Triton version         *
+*           12/21/2009 - Probe/remove mode                *
+*           02/07/2010 - Add proximity          *
+*                                                                                       *
+********************************************************************************
+*    Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// includes
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/delay.h>
+#include <linux/i2c/taos_common.h>
+#include <linux/delay.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h> 
+#include <linux/slab.h>
+#include <asm/gpio.h> 
+#include <linux/poll.h> 
+#include <linux/wakelock.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+
+
+#ifdef CONFIG_ZTE_DEVICE_INFO_SHOW
+#include <linux/zte_device_info.h>
+#endif
+
+#define LOG_TAG "SENSOR_ALS_PROX"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+// device name/id/address/counts
+#define TAOS_DEVICE_NAME                "taos"
+#define TAOS_DEVICE_ID                  "tritonFN"
+#define TAOS_ID_NAME_SIZE               10
+#define TAOS_TRITON_CHIPIDVAL           0x00
+#define TAOS_TRITON_MAXREGS             32
+#define TAOS_DEVICE_ADDR1               0x29
+#define TAOS_DEVICE_ADDR2               0x39
+#define TAOS_DEVICE_ADDR3               0x49
+#define TAOS_MAX_NUM_DEVICES            3
+#define TAOS_MAX_DEVICE_REGS            32
+#define I2C_MAX_ADAPTERS                12
+
+// TRITON register offsets
+#define TAOS_TRITON_CNTRL               0x00
+#define TAOS_TRITON_ALS_TIME            0X01
+#define TAOS_TRITON_PRX_TIME            0x02
+#define TAOS_TRITON_WAIT_TIME           0x03
+#define TAOS_TRITON_ALS_MINTHRESHLO     0X04
+#define TAOS_TRITON_ALS_MINTHRESHHI     0X05
+#define TAOS_TRITON_ALS_MAXTHRESHLO     0X06
+#define TAOS_TRITON_ALS_MAXTHRESHHI     0X07
+#define TAOS_TRITON_PRX_MINTHRESHLO     0X08
+#define TAOS_TRITON_PRX_MINTHRESHHI     0X09
+#define TAOS_TRITON_PRX_MAXTHRESHLO     0X0A
+#define TAOS_TRITON_PRX_MAXTHRESHHI     0X0B
+#define TAOS_TRITON_INTERRUPT           0x0C
+#define TAOS_TRITON_PRX_CFG             0x0D
+#define TAOS_TRITON_PRX_COUNT           0x0E
+#define TAOS_TRITON_GAIN                0x0F
+#define TAOS_TRITON_REVID               0x11
+#define TAOS_TRITON_CHIPID              0x12
+#define TAOS_TRITON_STATUS              0x13
+#define TAOS_TRITON_ALS_CHAN0LO         0x14
+#define TAOS_TRITON_ALS_CHAN0HI         0x15
+#define TAOS_TRITON_ALS_CHAN1LO         0x16
+#define TAOS_TRITON_ALS_CHAN1HI         0x17
+#define TAOS_TRITON_PRX_LO              0x18
+#define TAOS_TRITON_PRX_HI              0x19
+#define TAOS_TRITON_TEST_STATUS         0x1F
+
+// Triton cmd reg masks
+//0x by clli2
+#define TAOS_TRITON_CMD_REG             0X80
+#define TAOS_TRITON_CMD_AUTO            0x20 
+#define TAOS_TRITON_CMD_BYTE_RW         0x00 
+#define TAOS_TRITON_CMD_WORD_BLK_RW     0x20 
+#define TAOS_TRITON_CMD_SPL_FN          0x60 
+#define TAOS_TRITON_CMD_PROX_INTCLR     0X05 
+#define TAOS_TRITON_CMD_ALS_INTCLR      0X06 
+#define TAOS_TRITON_CMD_PROXALS_INTCLR  0X07 
+#define TAOS_TRITON_CMD_TST_REG         0X08 
+#define TAOS_TRITON_CMD_USER_REG        0X09
+
+// Triton cntrl reg masks
+#define TAOS_TRITON_CNTL_PROX_INT_ENBL  0X20
+#define TAOS_TRITON_CNTL_ALS_INT_ENBL   0X10
+#define TAOS_TRITON_CNTL_WAIT_TMR_ENBL  0X08
+#define TAOS_TRITON_CNTL_PROX_DET_ENBL  0X04
+#define TAOS_TRITON_CNTL_ADC_ENBL       0x02
+#define TAOS_TRITON_CNTL_PWRON          0x01
+
+// Triton status reg masks
+#define TAOS_TRITON_STATUS_ADCVALID     0x01
+#define TAOS_TRITON_STATUS_PRXVALID     0x02
+#define TAOS_TRITON_STATUS_ADCINTR      0x10
+#define TAOS_TRITON_STATUS_PRXINTR      0x20
+
+// lux constants
+#define TAOS_MAX_LUX                    10000
+#define TAOS_SCALE_MILLILUX             3
+#define TAOS_FILTER_DEPTH               3
+#define CHIP_ID                         0x3d
+
+#define TAOS_INPUT_NAME                 "lightsensor"
+#define	POLL_DELAY	                    msecs_to_jiffies(5)
+#define	TAOS_ALS_ADC_TIME_WHEN_PROX_ON	0xF0//0XF5//0XEB
+#define TAOS_ALS_GAIN_DIVIDE            1000
+#define TAOS_ALS_GAIN_1X                0
+#define TAOS_ALS_GAIN_8X                1
+#define TAOS_ALS_GAIN_16X               2
+#define TAOS_ALS_GAIN_120X              3
+#define CAL_THRESHOLD   "/persist/proxdata/threshold"
+
+
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501
+// added the work mode marco
+//#define WORK_UES_POLL_MODE
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501 END
+
+//#define IRQ_TRIGER_LEVEL_LOW
+
+// forward declarations
+static int tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp);
+static int tmd2772_remove(struct i2c_client *client);
+static int taos_get_lux(void);
+static int taos_lux_filter(int raw_lux);
+static int taos_device_name(unsigned char *bufp, char **device_name);
+static int taos_prox_poll(struct taos_prox_info *prxp);
+static void taos_prox_poll_timer_func(unsigned long param);
+static void taos_prox_poll_timer_start(void);
+//iVIZM
+static int taos_prox_threshold_set(void);
+static int taos_als_get_data(void);
+static int taos_interrupts_clear(void);
+static int taos_resume(struct i2c_client *client);
+static int taos_suspend(struct i2c_client *client,pm_message_t mesg);
+//CLLI@
+
+
+static int taos_sensors_als_poll_on(void);
+static int taos_sensors_als_poll_off(void);
+static void taos_als_poll_work_func(struct work_struct *work);
+static int taos_als_gain_set(unsigned als_gain);
+static void taos_update_sat_als(void);
+static int taos_prox_on(void);
+static int taos_prox_off(void);
+static int taos_prox_calibrate(void);
+static void taos_prox_calibrate_work_func(struct work_struct *work);
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable);
+static int taos_write_cal_file(char *file_path,unsigned int value);
+static int taos_read_cal_value(char *file_path);
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer);
+
+
+static dev_t const tmd2772_proximity_dev_t = MKDEV(MISC_MAJOR, 101);
+static dev_t const tmd2772_light_dev_t     = MKDEV(MISC_MAJOR, 102);
+
+
+DECLARE_WAIT_QUEUE_HEAD(waitqueue_read);//iVIZM
+
+struct ReadData { //iVIZM
+    unsigned int data;
+    unsigned int interrupt;
+};
+struct ReadData readdata[2];//iVIZM
+
+// workqueue struct
+//static struct workqueue_struct *taos_wq; //iVIZM
+
+// class structure for this device
+struct class *taos_class;
+
+// board and address info   iVIZM
+struct i2c_board_info taos_board_info[] = {
+    {I2C_BOARD_INFO(TAOS_DEVICE_ID, TAOS_DEVICE_ADDR2),},
+};
+
+unsigned short const taos_addr_list[2] = {TAOS_DEVICE_ADDR2, I2C_CLIENT_END};//iVIZM
+
+// client and device
+struct i2c_client *my_clientp;
+struct i2c_client *bad_clientp[TAOS_MAX_NUM_DEVICES];
+static int device_found = 0;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+
+
+//iVIZM
+static char pro_buf[4]; //iVIZM
+static int mcount = 0; //iVIZM
+static bool pro_ft = false; //by clli2
+static bool flag_prox_debug = false;
+static bool flag_als_debug  = false;
+static bool flag_just_open_light = false;
+static unsigned int als_poll_delay = 1000;
+static unsigned int prox_debug_delay_time = 0;
+u16 status = 0;
+static int als_poll_time_mul  = 1;
+static unsigned char reg_addr = 0;
+static bool wakeup_from_sleep = false;
+
+// ZTEMT ADD by zhubing
+// modify for input filter the same data
+static int last_proximity_data = -1;
+//static int last_als_data       = -1;
+// ZTEMT ADD by zhubing END
+
+
+static const struct i2c_device_id tmd2772_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmd2772_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmd2772_idtable);
+
+struct i2c_driver tmd2772_driver = {
+	.driver = {
+		.name = "ams-sensor",
+        .of_match_table = of_tmd2772_idtable,
+		//.pm = NULL,
+	},
+	.id_table = tmd2772_idtable_id,
+	.probe = tmd2772_probe,
+	.remove = __devexit_p(tmd2772_remove),
+#ifdef CONFIG_PM_SLEEP //by clli2
+    .resume = taos_resume,
+    .suspend = taos_suspend,
+#endif
+
+};
+
+
+
+
+
+
+// per-device data
+struct taos_data {
+	struct i2c_client *client;
+	struct cdev cdev;
+	unsigned int addr;
+	//struct input_dev *input_dev;//iVIZM
+	//struct work_struct work;//iVIZM
+	struct delayed_work work;//iVIZM
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+	struct taos_wake_lock proximity_wakelock;//iVIZM
+	struct mutex lock;
+	struct device *class_dev;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_calibrate_work;
+	struct hrtimer  prox_unwakelock_timer;
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+
+	struct device *proximity_dev;
+	struct device *light_dev;
+	struct device *gesture_dev;
+
+	char taos_id;
+	char taos_name[TAOS_ID_NAME_SIZE];
+
+	char *prox_name;
+	char *als_name;
+	bool prox_calibrate_flag;
+	bool prox_calibrate_result;
+	bool phone_is_sleep;
+
+	int  prox_calibrate_times;
+	int  prox_thres_hi_max;
+	int  prox_thres_lo_min;
+	int  prox_data_max;
+	int  prox_manual_calibrate_threshold;
+	char *chip_name;
+
+
+	bool prox_on;
+	bool als_on;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool init;
+	int als_poll_time_mul;
+
+	struct semaphore update_lock;
+	char valid;
+	//int working;
+	unsigned long last_updated;
+} *taos_datap;
+
+// device configuration by clli2
+struct taos_cfg *taos_cfgp;
+static u32 calibrate_target_param = 300000;
+static u16 als_time_param = 41;
+static u16 scale_factor_param_prox = 6;    
+static u16 scale_factor_param_als = 13;
+static u16 gain_trim_param = 512;          //NULL
+static u8 filter_history_param = 3;        //NULL
+static u8 filter_count_param = 1;          //NULL
+/* gain_param  00--1X, 01--8X, 10--16X, 11--120X
+ */
+static u8 gain_param = 0;                  //same as prox-gain_param 1:0 8X
+static u16 prox_calibrate_hi_param = 500;
+static u16 prox_calibrate_lo_param = 330;
+static u16 prox_threshold_hi_param = 800;
+static u16 prox_threshold_lo_param = 750;
+static u16 als_threshold_hi_param  = 3000; 
+static u16 als_threshold_lo_param  = 10;   
+static u8  prox_int_time_param     = 0xF0;//0xCD; // time of the ALS ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_adc_time_param     = 0xFF; // time of the PRO ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_wait_time_param    = 0xFF; // time of the    Wait TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+/*7~4->pls,3~0->als*/
+static u8  prox_intr_filter_param  = 0x33; // Int filter, Bit7--Bit4:PROX  Bit3--Bit0:ALS
+static u8  prox_config_param       = 0x00; // wait long time disable
+/*pulse/62.5Khz  less  32 recommand*/
+static u8  prox_pulse_cnt_param    = 0x0C; //PROX LED pluse count to send for each measure 0x00--0xff:0--255
+/* 7:6 11->100ma        00->12.5ma
+   5:4 01->ch0          10->ch1    11->both
+   1:0(als gain ctrol)  1X 8X 16X 128X        */
+static u8  prox_gain_param = 0x20;   //50ma     8X
+static u8  prox_config_offset_param  = 0x0;
+// prox info
+struct taos_prox_info prox_cal_info[20];
+struct taos_prox_info prox_cur_info;
+struct taos_prox_info *prox_cur_infop = &prox_cur_info;
+static struct timer_list prox_poll_timer;
+static int device_released = 0;
+static u16 sat_als = 0;
+static u16 sat_prox = 0;
+
+
+
+// device reg init values
+u8 taos_triton_reg_init[16] = {0x00,0xFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00};
+
+// lux time scale
+struct time_scale_factor  {
+    u16 numerator;
+    u16 denominator;
+    u16 saturation;
+};
+struct time_scale_factor TritonTime = {1, 0, 0};
+struct time_scale_factor *lux_timep = &TritonTime;
+
+// gain table
+u8 taos_triton_gain_table[] = {1, 8, 16, 120};
+
+// lux data
+struct lux_data {
+    u16 ratio;
+    u16 clear;
+    u16 ir;
+};
+struct lux_data TritonFN_lux_data[] = {
+    { 9830,  8320,  15360 },
+    { 12452, 10554, 22797 },
+    { 14746, 6234,  11430 },
+    { 17695, 3968,  6400  },
+    { 0,     0,     0     }
+};
+struct lux_data *lux_tablep = TritonFN_lux_data;
+static int lux_history[TAOS_FILTER_DEPTH] = {-ENODATA, -ENODATA, -ENODATA};//iVIZM
+
+static int taos_get_data(void);
+
+
+static void taos_irq_ops(bool enable, bool flag_sync)
+{
+    if (enable == taos_datap->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(taos_datap->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(taos_datap->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(taos_datap->client->irq);
+        }
+    }
+
+    taos_datap->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static ssize_t attr_set_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_pulse_cnt_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_pulse_cnt reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_pluse_cnt is %d\n", taos_cfgp->prox_pulse_cnt);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_int_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_int_time = prox_int_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the als_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_int_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_adc_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_adc_time = prox_adc_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_adc_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_wait_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_wait_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_wait_time = prox_wait_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) 
+        {   
+            SENSOR_LOG_ERROR("failed to write the wait_time reg\n");
+        }
+
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_wait_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "wait_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_wait_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = 4 - val;
+        prox_gain_param = (prox_gain_param & 0x3F) | (val<<6);
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    char *p_led_strength[4] = {"100", "50", "25", "12.5"};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_strength is %s mA\n", p_led_strength[(taos_cfgp->prox_gain) >> 6]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_als_gain(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = val-1;
+        prox_gain_param = (prox_gain_param & 0xFC) | val;
+        gain_param      = prox_gain_param & 0x03;
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->gain      = gain_param;
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_gain(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    u8 als_gain[4] = {1, 8, 16, 120};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als gain is x%d\n", als_gain[taos_cfgp->prox_gain & 0x03]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_debug_delay_time =  val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_debug_delay_time is %d\n", prox_debug_delay_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_debug_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_prox_debug = true;
+    }
+    else
+    {       
+        flag_prox_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_prox_debug_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_calibrate_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+
+
+static ssize_t attr_prox_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "prox calibrate is %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t attr_prox_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        taos_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {       
+    	 //cancel_delayed_work_sync(&chip->prox_unwakelock_work);
+	hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+	taos_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+//als
+static ssize_t attr_set_als_debug(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_als_debug = true;
+    }
+    else
+    {       
+        flag_als_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_debug(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_als_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_irq(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        taos_irq_ops(true, true);
+    }
+    else
+    {       
+        taos_irq_ops(false, true);
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_irq(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "flag_irq is %s\n", taos_datap->irq_enabled? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_prox_calibrate(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    int val,ret;
+
+	ret=kstrtouint(buf, 10, &val);
+    SENSOR_LOG_ERROR("enter\n");
+    if (ret<0)
+    {
+        return -EINVAL;
+    }
+
+    if (val>1)
+    {
+     taos_datap->prox_calibrate_times= val;
+    taos_prox_calibrate();
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("your input error, please input a number that bigger than 1\n");
+    }
+   
+	return size;
+}
+
+static ssize_t attr_prox_thres_high_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_hi_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_hi_param is %d\n",prox_calibrate_hi_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_low_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_lo_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n",prox_calibrate_lo_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n prox_calibrate_hi_param is %d\n",taos_cfgp->prox_threshold_lo,taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	mutex_lock(&taos_datap->lock);
+
+	if (value==1)
+    {
+   		if( (rc=taos_read_cal_value(CAL_THRESHOLD))<0)
+        {
+            mutex_unlock(&taos_datap->lock);
+            return -EINVAL;
+        }
+		else
+		{
+			if(rc > (taos_datap->prox_thres_lo_min))
+            		{
+			taos_datap->prox_calibrate_flag = false;
+			taos_datap->prox_manual_calibrate_threshold =rc;
+			taos_cfgp->prox_threshold_hi= rc;
+			taos_cfgp->prox_threshold_lo  = rc - 110;
+			input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+			input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+			input_sync(taos_datap->p_idev);
+			SENSOR_LOG_ERROR("prox_th_high  = %d\n",taos_cfgp->prox_threshold_hi);
+			SENSOR_LOG_ERROR("prox_th_low   = %d\n",taos_cfgp->prox_threshold_lo);
+           		 }
+
+		}
+	}
+	else
+    {	
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+static ssize_t attr_set_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_prox = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_prox is %d\n",taos_cfgp->scale_factor_prox);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_als = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_als = scale_factor_param_als;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_als is %d\n",taos_cfgp->scale_factor_als);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_get_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_hi = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+
+static ssize_t attr_get_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_lo);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_lo = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_set_prox_offset(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_config_offset_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_offset(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_config_offset_param is %d\n", taos_cfgp->prox_config_offset);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_calibrate_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_hi_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "prox_thres_hi_max is %d\n",taos_datap->prox_thres_hi_max);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_thres_lo_min(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+                SENSOR_LOG_ERROR("prox_thres_lo_min is %d\n",taos_datap->prox_thres_lo_min);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_lo_min);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_chip_name_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%s", taos_datap->chip_name);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_data_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_manual_calibrate_threshold(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_manual_calibrate_threshold);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t attr_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|reg_addr), val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    unsigned char i;
+    if (100 == reg_addr)
+    {
+        for (i=0x00; i<=0x0F; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));
+        }
+        for (i=0x11; i<=0x19; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));            
+        }
+
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | 0x1F));
+        SENSOR_LOG_ERROR("reg[0x1F] = 0x%02X",i2c_smbus_read_byte(taos_datap->client));  
+    }   
+    else
+    {
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | reg_addr));
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(taos_datap->client)); 
+    }
+
+	return strlen(buf);
+}
+
+static ssize_t attr_get_prox_value(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+
+	 return sprintf(buf, "%d\n", last_proximity_data%100000);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+/*
+static struct device_attribute attributes[] = {
+#ifdef CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+	__ATTR(taos_prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+	__ATTR(taos_als_adc_time,                   0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+	__ATTR(taos_prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+	__ATTR(taos_wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+	__ATTR(taos_prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+	__ATTR(taos_als_gain,                       0644,   attr_get_als_gain,                          attr_set_als_gain),
+	__ATTR(taos_prox_debug,                     0644,   attr_get_prox_debug,                        attr_set_prox_debug),
+	__ATTR(taos_als_debug,                      0644,   attr_get_als_debug,                         attr_set_als_debug),
+	__ATTR(taos_prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+	__ATTR(taos_irq,                            0644,   attr_get_irq,                               attr_set_irq),       
+	__ATTR(taos_prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+	__ATTR(taos_prox_calibrate_hi_param,        0644,   attr_get_prox_calibrate_hi_param,           attr_set_prox_calibrate_hi_param),
+	__ATTR(taos_prox_calibrate_lo_param,        0644,   attr_get_prox_calibrate_lo_param,           attr_set_prox_calibrate_lo_param),
+	__ATTR(taos_als_scale_factor_param_als,     0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+	__ATTR(taos_als_scale_factor_param_prox,    0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+	__ATTR(taos_prox_threshold_high,            0644,   attr_get_prox_threshold_high,               NULL),
+	__ATTR(taos_prox_threshold_low,             0644,   attr_get_prox_threshold_low,                NULL),
+	__ATTR(taos_prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+#endif
+    __ATTR(taos_reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(taos_reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+	__ATTR(th_hi,                               0644,   attr_get_threshold_hi,                      attr_set_threshold_hi),
+	__ATTR(th_low,                              0644,   attr_get_threshold_lo,                      attr_set_threshold_lo),
+	__ATTR(prox_value,                          0644,   attr_get_prox_value,                        NULL),
+};
+*/
+
+
+///***************************************************************************************///
+//light
+static ssize_t attr_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_on);
+}
+
+static ssize_t attr_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        taos_sensors_als_poll_on();
+    }
+    else
+    {
+        taos_sensors_als_poll_off();
+    }
+
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "als_poll_time = %d\n", als_poll_delay);
+}
+
+static ssize_t attr_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+	als_poll_delay = time;
+	return size;
+}
+
+
+
+//prox
+static ssize_t attr_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_on);
+}
+
+static ssize_t attr_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value)
+    {
+        taos_prox_on();
+    }
+	else
+    {
+        taos_prox_off();
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_init_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "chip->init%d\n", chip->init);
+	
+}
+
+static ssize_t attr_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0,err=1;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+    {
+    	if((ret=taos_read_cal_value(CAL_THRESHOLD))<0)
+		{
+		    SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+		    err=taos_write_cal_file(CAL_THRESHOLD,0);
+			if(err<0)
+			{
+				SENSOR_LOG_ERROR("ERROR=%s\n",CAL_THRESHOLD);
+				mutex_unlock(&taos_datap->lock);
+				return -EINVAL;
+			}
+           	taos_datap->prox_calibrate_flag = true;
+		}
+		else if (ret==0){
+           	taos_datap->prox_calibrate_flag = true;
+		    SENSOR_LOG_ERROR("tmg399x_prox_calibrate==1\n");
+		}
+		else if(ret > (taos_datap->prox_thres_lo_min)){
+		taos_datap->prox_calibrate_flag = false;
+		taos_datap->prox_manual_calibrate_threshold =ret;
+        taos_cfgp->prox_threshold_hi = ret;
+        taos_cfgp->prox_threshold_lo  = ret - 110;
+		input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+		input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+		input_sync(taos_datap->p_idev);
+		SENSOR_LOG_ERROR("tmg399x_prox_init> 0\n");
+		}
+	}
+	else
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+
+
+
+static struct device_attribute attrs_light[] = {
+	__ATTR(enable,                         0640,   attr_als_enable_show,                       attr_als_enable_store),
+    __ATTR(light_gain,                     0644,   attr_get_als_gain,                          attr_set_als_gain),
+    __ATTR(light_debug,                    0644,   attr_get_als_debug,                         attr_set_als_debug),
+    __ATTR(light_adc_time,                 0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+    __ATTR(light_scale_factor_param,       0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+    __ATTR(prox_scale_factor_param,        0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+    __ATTR(delay,                          0640,   attr_als_poll_time_show,                    attr_als_poll_time_store),
+};
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                      0640,   attr_chip_name_show,                        NULL),
+	__ATTR(enable,                         0640,   attr_prox_enable_show,                      attr_prox_enable_store),    
+	__ATTR(prox_init,                      0640,   attr_prox_init_show,                        attr_prox_init_store),  
+	__ATTR(prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+    __ATTR(prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+    __ATTR(prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+    __ATTR(prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+    __ATTR(prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+    __ATTR(prox_threshold_high,            0644,   attr_get_prox_threshold_high,               attr_set_prox_threshold_high),
+    __ATTR(prox_threshold_low,             0644,   attr_get_prox_threshold_low,                attr_set_prox_threshold_low),
+    __ATTR(prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+    __ATTR(prox_value,                     0644,   attr_get_prox_value,                        NULL),
+    __ATTR(prox_calibrate_result,          0640,   attr_prox_calibrate_result_show,            NULL), 
+    __ATTR(prox_thres_param_high,          0640,   attr_prox_thres_high_show,                  attr_prox_thres_high_store),
+    __ATTR(prox_thres_param_low,           0640,   attr_prox_thres_low_show,                   attr_prox_thres_low_store),
+    __ATTR(prox_thres,                     0640,   attr_prox_thres_show,                       attr_prox_thres_store),
+    __ATTR(prox_debug,                     0640,   attr_prox_debug_show,                       attr_prox_debug_store),
+    __ATTR(prox_calibrate_start,           0640,   attr_prox_calibrate_start_show,             attr_prox_debug_store),
+    __ATTR(prox_thres_max,                 0644,   attr_prox_thres_hi_max,                     NULL), 
+    __ATTR(prox_thres_min,                 0644,   attr_prox_thres_lo_min,                     NULL), 
+    __ATTR(prox_data_max,                  0640,   attr_prox_data_max,                         NULL), 
+    __ATTR(prox_manual_calibrate_threshold,0644,   attr_prox_manual_calibrate_threshold,       NULL), 
+
+
+    __ATTR(prox_phone_is_sleep,            0640,   attr_prox_phone_is_sleep_show,              attr_prox_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                  0640,   attr_prox_prox_wakelock_show,               attr_prox_prox_wakelock_store),
+
+    __ATTR(reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+    __ATTR(irq_status,                     0644,   attr_get_irq,                               attr_set_irq),       
+    __ATTR(wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+};
+
+
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable)
+{
+    if (enable == wakelock->locked)
+    {
+        SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+static int taos_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+      
+    }
+       memset(write_buf, 0, sizeof(write_buf));
+      sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+
+static int taos_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+static void taos_irq_work_func(struct work_struct * work) //iVIZM
+{
+    int retry_times = 0;
+    int ret;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    if (wakeup_from_sleep)
+    {  
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        mdelay(50);
+        wakeup_from_sleep = false;
+    }
+
+    for (retry_times=0; retry_times<=50; retry_times++)
+    {
+        ret = taos_get_data();
+        if (ret >= 0)
+        {
+            break;
+        }
+        mdelay(20);
+    }
+    taos_interrupts_clear();
+
+    hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+    taos_datap->irq_work_status = false;
+   // SENSOR_LOG_INFO("########  taos_irq_work_func enter   hrtimer_start #########\n");
+    hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+   //  schedule_delayed_work(&taos_datap->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    taos_irq_ops(true, true);
+    SENSOR_LOG_INFO(" retry_times = %d\n",retry_times);
+    mutex_unlock(&taos_datap->lock);
+}
+
+static irqreturn_t taos_irq_handler(int irq, void *dev_id) //iVIZM
+{
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    taos_datap->irq_work_status = true;
+    taos_irq_ops(false, false);
+    taos_wakelock_ops(&(taos_datap->proximity_wakelock), true);
+    if (0==queue_work(taos_datap->irq_work_queue, &taos_datap->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+    return IRQ_HANDLED;
+}
+
+static int taos_get_data(void)//iVIZM
+{
+    int ret = 0;
+
+    ret = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS));
+    
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("read TAOS_TRITON_STATUS failed\n");
+        return ret;
+    }
+    else
+    { 
+        ret = taos_prox_threshold_set();
+    }
+    return ret;
+}
+
+
+static int taos_interrupts_clear(void)//iVIZM
+{
+    int ret = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_CMD_SPL_FN|0x07)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte(2) failed in taos_work_func()\n");
+        return (ret);
+    }
+    return ret;
+}
+
+static int taos_als_get_data(void)//iVIZM
+{
+    int ret = 0;
+    u8 reg_val;
+    int lux_val = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) != (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+        return -ENODATA;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) != TAOS_TRITON_STATUS_ADCVALID)
+        return -ENODATA;
+
+    if ((lux_val = taos_get_lux()) < 0)
+    {
+        printk(KERN_ERR "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n", lux_val);
+    }
+
+    if (lux_val<TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_8X)
+    {
+        taos_als_gain_set(TAOS_ALS_GAIN_8X);
+    }
+    else
+    {
+        if (lux_val>TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_1X)
+        {
+            taos_als_gain_set(TAOS_ALS_GAIN_1X);
+        }
+    }
+    
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "reg_val = %d lux_val = %d\n",reg_val,lux_val);
+    }
+
+    if (reg_val != prox_int_time_param)
+    {
+        lux_val = (lux_val * (101 - (0XFF - reg_val)))/20;
+    }
+
+    lux_val = taos_lux_filter(lux_val);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "lux_val = %d",lux_val);
+    }
+
+    input_report_rel(taos_datap->a_idev, REL_X, lux_val+1);
+    input_sync(taos_datap->a_idev);
+
+    return ret;
+}
+
+static int taos_prox_threshold_set(void)//iVIZM
+{
+    int i,ret = 0;
+    u8 chdata[6];
+    u16 proxdata = 0;
+    u16 cleardata = 0;
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_WORD_BLK_RW| (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    cleardata = chdata[0] + chdata[1]*256;
+    proxdata = chdata[4] + chdata[5]*256;
+
+	if (pro_ft || flag_prox_debug)
+    {
+        pro_buf[0] = 0xff;
+        pro_buf[1] = 0xff;
+        pro_buf[2] = 0xff;
+        pro_buf[3] = 0xff;
+        
+        for( mcount=0; mcount<4; mcount++ )
+        {
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+            {
+                 printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+                 return (ret);
+            }
+        }      
+
+        if (pro_ft)
+        {
+            SENSOR_LOG_INFO( "init the prox threshold");
+        }
+
+        if (flag_prox_debug)
+        {
+            mdelay(prox_debug_delay_time);
+            SENSOR_LOG_INFO( "proxdata = %d",proxdata);
+	        input_report_rel(taos_datap->p_idev, REL_MISC, proxdata);
+
+        }
+		pro_ft = false;
+	} 
+    else 
+    {
+        if (proxdata < taos_cfgp->prox_threshold_lo) 
+        {   //FAR
+            pro_buf[0] = 0x0;
+            pro_buf[1] = 0x0;
+            pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+            pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+    		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+            input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+        } 
+        else 
+        {
+                if (proxdata > taos_cfgp->prox_threshold_hi)
+                {   //NEAR
+                    if (cleardata > ((sat_als*80)/100))
+                    {
+                    	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                    	msleep(100);
+                        return -ENODATA;
+                    }
+                    pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                    pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                    pro_buf[2] = 0xff;
+                    pro_buf[3] = 0xff;
+                    SENSOR_LOG_INFO("Near!!! proxdata = %d\n",proxdata);
+                    input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                }
+                else
+                {
+                    if( (taos_cfgp->prox_threshold_hi-proxdata) > (proxdata-taos_cfgp->prox_threshold_lo))
+                    {
+                        //FAR
+                        pro_buf[0] = 0x0;
+                        pro_buf[1] = 0x0;
+                        pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+                        pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+                		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                    }
+                    else
+                    {
+                        //NEAR
+                        if (cleardata > ((sat_als*80)/100))
+                        {
+                        	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                        	msleep(100);
+                            return -ENODATA;
+                        }
+                        pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                        pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                        pro_buf[2] = 0xff;
+                        pro_buf[3] = 0xff;
+                        SENSOR_LOG_INFO( "Near!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                    }
+                }
+            }
+    }
+
+    input_sync(taos_datap->p_idev);
+
+    for( mcount=0; mcount<4; mcount++) 
+    { 
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+        {
+             printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+             return (ret);
+        }
+    }
+
+    return ret;
+}
+
+// driver init
+static int __init taos_init(void) 
+{
+
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmd2772_driver);
+#endif
+}
+
+// driver exit
+static void __exit taos_exit(void) 
+{
+	i2c_del_driver(&tmd2772_driver);
+}
+
+
+static void tmd2772_data_init(void)
+{
+    taos_datap->als_on  = false;
+    taos_datap->prox_on = false;
+    taos_datap->init = false;
+    taos_datap->als_poll_time_mul = 1;
+    taos_datap->prox_name = "proximity";
+    taos_datap->als_name  = "light";
+    taos_datap->chip_name = "tmd2772";
+    taos_datap->prox_calibrate_result = false;
+    taos_datap->prox_thres_hi_max = 800;
+    taos_datap->prox_thres_lo_min = 200;
+    taos_datap->prox_data_max     = 1023;
+    taos_datap->prox_calibrate_times = 10;
+    taos_datap->prox_calibrate_flag = true;//true :auto_calibrate,false :manual_calibrate
+    taos_datap->prox_manual_calibrate_threshold = 0;
+    taos_datap->proximity_wakelock.name = "proximity-wakelock";
+    taos_datap->proximity_wakelock.locked = false;
+    taos_datap->phone_is_sleep = false;
+    taos_datap->irq_work_status = false;
+    taos_datap->irq_enabled = true;
+}
+
+
+
+// client probe
+static int __devinit tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp) 
+{
+    int ret = 0;
+    int i = 0;
+    int chip_id = -1;
+    unsigned char buf[TAOS_MAX_DEVICE_REGS];
+    char *device_name;
+    SENSOR_LOG_INFO("Prob Start\n");
+    chip_id = i2c_smbus_read_byte_data(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12))); //iVIZM
+    /*TSL27711=0x00 TSL27713=0x09 TMD27711=0x20 TMD27713=0x29 	2011.09.07*/
+	SENSOR_LOG_ERROR(" TAOS chip_id = %x TMD27713=30,TMD27723=39\n",chip_id);	
+	//printk(" TAOS ID reg = %d\n",(TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12)));	
+    if(chip_id != 0x39) 
+    {
+    	printk(" chip id that was read does not match TMD27723\n");	
+        return -ENODEV;
+    }
+    if (device_found)
+        return -ENODEV;
+    if (!i2c_check_functionality(clientp->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) 
+    {
+        printk(KERN_ERR "TAOS: taos_probe() - i2c smbus byte data functions unsupported\n");
+        return -EOPNOTSUPP;
+    }
+
+    taos_datap = kmalloc(sizeof(struct taos_data), GFP_KERNEL);
+    if (!taos_datap) 
+    {
+         SENSOR_LOG_ERROR("kmalloc for struct taos_data failed\n");
+         return -ENOMEM;
+    }
+
+    taos_datap->client = clientp;
+
+    i2c_set_clientdata(clientp, taos_datap);
+
+    
+
+    INIT_WORK(&(taos_datap->irq_work),taos_irq_work_func);  
+
+	sema_init(&taos_datap->update_lock,1);
+	mutex_init(&(taos_datap->lock));
+    wake_lock_init(&taos_datap->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, "proximity-wakelock");
+
+    tmd2772_data_init();
+
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+        if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + i))))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+            return(ret);
+        }
+        buf[i] = i2c_smbus_read_byte(clientp);
+    }
+
+    if ((ret = taos_device_name(buf, &device_name)) == 0) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read found mismatched by taos_device_name(), in taos_probe()\n");
+        return -ENODEV;
+    }
+    if (strcmp(device_name, TAOS_DEVICE_ID)) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read does not match expected id in taos_probe()\n");
+        return -ENODEV;
+    }
+    else 
+    {
+        SENSOR_LOG_ERROR( "TAOS: chip id of %s that was read matches expected id in taos_probe()\n", device_name);
+        device_found = 1;
+    }
+    if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+        return(ret);
+    }
+    strlcpy(clientp->name, TAOS_DEVICE_ID, I2C_NAME_SIZE);
+    strlcpy(taos_datap->taos_name, TAOS_DEVICE_ID, TAOS_ID_NAME_SIZE);
+    taos_datap->valid = 0;
+    if (!(taos_cfgp = kmalloc(sizeof(struct taos_cfg), GFP_KERNEL))) {
+        printk(KERN_ERR "TAOS: kmalloc for struct taos_cfg failed in taos_probe()\n");
+        return -ENOMEM;
+    }
+    taos_cfgp->calibrate_target = calibrate_target_param;
+    taos_cfgp->als_time = als_time_param;
+    taos_cfgp->scale_factor_als = scale_factor_param_als;
+	taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+    taos_cfgp->gain_trim = gain_trim_param;
+    taos_cfgp->filter_history = filter_history_param;
+    taos_cfgp->filter_count = filter_count_param;
+    taos_cfgp->gain = gain_param;
+    taos_cfgp->als_threshold_hi = als_threshold_hi_param;//iVIZM
+    taos_cfgp->als_threshold_lo = als_threshold_lo_param;//iVIZM
+    taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+    taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+    taos_cfgp->prox_int_time = prox_int_time_param;
+    taos_cfgp->prox_adc_time = prox_adc_time_param;
+    taos_cfgp->prox_wait_time = prox_wait_time_param;
+    taos_cfgp->prox_intr_filter = prox_intr_filter_param;
+    taos_cfgp->prox_config = prox_config_param;
+    taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+    taos_cfgp->prox_gain = prox_gain_param;
+    taos_cfgp->prox_config_offset=prox_config_offset_param;
+    sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+    sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+
+    /*dmobile ::power down for init ,Rambo liu*/
+    SENSOR_LOG_ERROR("TAOS:Rambo::light sensor will pwr down \n");
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x00), 0x00))) < 0) {
+        printk(KERN_ERR "TAOS:Rambo, i2c_smbus_write_byte_data failed in power down\n");
+        return (ret);
+    }
+
+
+    taos_datap->irq_work_queue = create_singlethread_workqueue("taos_work_queue");
+    if (!taos_datap->irq_work_queue)
+    {
+        ret = -ENOMEM;
+        SENSOR_LOG_INFO( "---------%s: %d: cannot create work taos_work_queue, err = %d",__func__,__LINE__,ret);
+        return ret;
+    }
+
+    ret = gpio_request(ALS_PS_GPIO, "ALS_PS_INT");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",ALS_PS_GPIO);
+        
+        gpio_free(ALS_PS_GPIO);
+        ret = gpio_request(ALS_PS_GPIO, "ALS_PS_INT");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",ALS_PS_GPIO);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("get gpio %d success\n",ALS_PS_GPIO);
+    }
+
+
+    ret = gpio_tlmm_config(GPIO_CFG(ALS_PS_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    taos_datap->client->irq = gpio_to_irq(ALS_PS_GPIO);
+
+	ret = request_threaded_irq(taos_datap->client->irq, NULL, &taos_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "taos_irq", taos_datap);
+    if (ret != 0) 
+    {
+        gpio_free(ALS_PS_GPIO);
+        return(ret);
+    }
+
+    taos_irq_ops(false, true);
+    INIT_DELAYED_WORK(&taos_datap->als_poll_work, taos_als_poll_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_calibrate_work, taos_prox_calibrate_work_func);
+  //  INIT_DELAYED_WORK(&taos_datap->prox_unwakelock_work, taos_prox_unwakelock_work_func);
+    hrtimer_init(&taos_datap->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    ( taos_datap->prox_unwakelock_timer).function = taos_prox_unwakelock_work_func ;
+   // hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+
+    taos_datap->proximity_dev = device_create(proximity_class, NULL, tmd2772_proximity_dev_t, &tmd2772_driver ,"proximity");
+    if (IS_ERR(taos_datap->proximity_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->proximity_dev);
+      SENSOR_LOG_ERROR("device_create proximity failed\n");
+      goto create_proximity_dev_failed;
+    }
+
+    taos_datap->light_dev= device_create(light_class, NULL, tmd2772_light_dev_t, &tmd2772_driver ,"light");
+    if (IS_ERR(taos_datap->light_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->light_dev);
+      SENSOR_LOG_ERROR("device_create light failed\n");
+      goto create_light_dev_failed;
+    }
+
+    //prox input 
+    taos_datap->p_idev = input_allocate_device();
+    if (!taos_datap->p_idev)
+    {
+        SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->prox_name);
+        ret = -ENODEV;
+        goto input_p_alloc_failed;
+    }
+    taos_datap->p_idev->name = taos_datap->prox_name;
+    taos_datap->p_idev->id.bustype = BUS_I2C;
+    dev_set_drvdata(&taos_datap->p_idev->dev, taos_datap);
+    ret = input_register_device(taos_datap->p_idev);
+    if (ret) 
+    {
+        input_free_device(taos_datap->p_idev);
+        SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+        goto input_p_register_failed;
+    }
+
+    set_bit(EV_REL, taos_datap->p_idev->evbit);
+    set_bit(REL_X,  taos_datap->p_idev->relbit);
+    set_bit(REL_Y,  taos_datap->p_idev->relbit);
+    set_bit(REL_Z,  taos_datap->p_idev->relbit);
+    set_bit(REL_MISC,  taos_datap->p_idev->relbit);
+
+    //light input
+    taos_datap->a_idev = input_allocate_device();
+	if (!taos_datap->a_idev) 
+    {
+		SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	taos_datap->a_idev->name = taos_datap->als_name;
+	taos_datap->a_idev->id.bustype = BUS_I2C;
+    
+    /*
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+    */
+
+    set_bit(EV_REL, taos_datap->a_idev->evbit);
+    set_bit(REL_X,  taos_datap->a_idev->relbit);
+    set_bit(REL_Y,  taos_datap->a_idev->relbit);
+
+
+	//chip->a_idev->open = tmg399x_als_idev_open;
+	//chip->a_idev->close = tmg399x_als_idev_close;
+	dev_set_drvdata(&taos_datap->a_idev->dev, taos_datap);
+	ret = input_register_device(taos_datap->a_idev);
+	if (ret) 
+    {
+		input_free_device(taos_datap->a_idev);
+		SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+		goto input_a_register_failed;
+	}
+
+	dev_set_drvdata(taos_datap->proximity_dev, taos_datap);
+	dev_set_drvdata(taos_datap->light_dev, taos_datap);
+
+
+    create_sysfs_interfaces_prox(taos_datap->proximity_dev);
+    create_sysfs_interfaces_light(taos_datap->light_dev);
+
+    SENSOR_LOG_INFO("Prob OK\n");
+
+	return 0;
+
+
+input_a_register_failed:
+    input_free_device(taos_datap->a_idev);
+input_a_alloc_failed:
+
+input_p_register_failed:
+    input_free_device(taos_datap->p_idev);
+input_p_alloc_failed:
+
+create_light_dev_failed:
+    taos_datap->light_dev = NULL;
+    class_destroy(light_class);
+
+create_proximity_dev_failed:
+    taos_datap->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+    SENSOR_LOG_INFO("Prob Failed\n");
+
+    return (ret);
+}
+
+#ifdef CONFIG_PM_SLEEP
+//don't move these pm blew to ioctl
+//resume  
+static int taos_resume(struct i2c_client *client) {
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: disable irq wakeup\n",__func__,__LINE__);
+		ret = disable_irq_wake(taos_datap->client->irq);
+	}
+    if(ret < 0)
+		printk(KERN_ERR "TAOS: disable_irq_wake failed\n");
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+//suspend  
+static int taos_suspend(struct i2c_client *client, pm_message_t mesg) 
+{
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: enable irq wakeup\n",__func__,__LINE__);
+       	ret = enable_irq_wake(taos_datap->client->irq);
+    }
+	if(ret < 0)
+    {
+		printk(KERN_ERR "TAOS: enable_irq_wake failed\n");
+    }
+
+    wakeup_from_sleep = true;
+
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+#endif
+// client remove
+static int __devexit tmd2772_remove(struct i2c_client *client) {
+    int ret = 0;
+
+    return (ret);
+}
+
+
+// read/calculate lux value
+static int taos_get_lux(void) 
+{
+    int raw_clear = 0, raw_ir = 0, raw_lux = 0;
+    u32 lux = 0;
+    u32 ratio = 0;
+    u8 dev_gain = 0;
+    u16 Tint = 0;
+    struct lux_data *p;
+    int ret = 0;
+    u8 chdata[4];
+    int tmp = 0, i = 0,tmp_gain=1;
+    for (i = 0; i < 4; i++) {
+        if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_ALS_CHAN0LO + i))))) < 0) {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to chan0/1/lo/hi reg failed in taos_get_lux()\n");
+            return (ret);
+        }
+        chdata[i] = i2c_smbus_read_byte(taos_datap->client);
+    }
+
+    tmp = (taos_cfgp->als_time + 25)/50;            //if atime =100  tmp = (atime+25)/50=2.5   time = 2.7*(256-atime)=  412.5
+    TritonTime.numerator = 1;
+    TritonTime.denominator = tmp;
+
+    tmp = 300 * taos_cfgp->als_time;               //tmp = 300*atime  400
+    if(tmp > 65535)
+        tmp = 65535;
+    TritonTime.saturation = tmp;
+    raw_clear = chdata[1];
+    raw_clear <<= 8;
+    raw_clear |= chdata[0];
+    raw_ir    = chdata[3];
+    raw_ir    <<= 8;
+    raw_ir    |= chdata[2];
+
+    raw_clear *= ((taos_cfgp->scale_factor_als )*tmp_gain);
+    raw_ir *= (taos_cfgp->scale_factor_prox );
+
+    if(raw_ir > raw_clear) {
+        raw_lux = raw_ir;
+        raw_ir = raw_clear;
+        raw_clear = raw_lux;
+    }
+    dev_gain = taos_triton_gain_table[taos_cfgp->gain & 0x3];
+    if(raw_clear >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_ir >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_clear == 0)
+        return(0);
+    if(dev_gain == 0 || dev_gain > 127) {
+        printk(KERN_ERR "TAOS: dev_gain = 0 or > 127 in taos_get_lux()\n");
+        return -1;
+    }
+    if(lux_timep->denominator == 0) {
+        printk(KERN_ERR "TAOS: lux_timep->denominator = 0 in taos_get_lux()\n");
+        return -1;
+    }
+    ratio = (raw_ir<<15)/raw_clear;
+    for (p = lux_tablep; p->ratio && p->ratio < ratio; p++);
+	#ifdef WORK_UES_POLL_MODE
+    if(!p->ratio) {//iVIZM
+        if(lux_history[0] < 0)
+            return 0;
+        else
+            return lux_history[0];
+    }
+	#endif
+    Tint = taos_cfgp->als_time;
+    raw_clear = ((raw_clear*400 + (dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    raw_ir = ((raw_ir*400 +(dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    lux = ((raw_clear*(p->clear)) - (raw_ir*(p->ir)));
+    lux = (lux + 32000)/64000;
+    if(lux > TAOS_MAX_LUX) {
+        lux = TAOS_MAX_LUX;
+    }
+    return(lux);
+}
+
+static int taos_lux_filter(int lux)
+{
+    static u8 middle[] = {1,0,2,0,0,2,0,1};
+    int index;
+
+    lux_history[2] = lux_history[1];
+    lux_history[1] = lux_history[0];
+    lux_history[0] = lux;
+
+    if(lux_history[2] < 0) { //iVIZM
+        if(lux_history[1] > 0)
+            return lux_history[1];       
+        else 
+            return lux_history[0];
+    }
+    index = 0;
+    if( lux_history[0] > lux_history[1] ) 
+        index += 4;
+    if( lux_history[1] > lux_history[2] ) 
+        index += 2;
+    if( lux_history[0] > lux_history[2] )
+        index++;
+    return(lux_history[middle[index]]);
+}
+
+// verify device
+static int taos_device_name(unsigned char *bufp, char **device_name)
+{
+    /*
+    int i=0 ,j;
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+	  	j=bufp[i];
+	  	printk("(bufp[i=%x]=%x,\n",i,j);
+    }
+    */
+    *device_name="tritonFN";
+    return(1);
+}
+
+// proximity poll
+static int taos_prox_poll(struct taos_prox_info *prxp)
+{
+    int i = 0, ret = 0; //wait_count = 0;
+    u8 chdata[6];
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_AUTO | (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    prxp->prox_clear = chdata[1];
+    prxp->prox_clear <<= 8;
+    prxp->prox_clear |= chdata[0];
+    if (prxp->prox_clear > ((sat_als*80)/100))
+    {
+		printk(KERN_ERR "TAOS: %u <= %u*0.8 poll data\n",prxp->prox_clear,sat_als);
+        return -ENODATA;
+    }
+    prxp->prox_data = chdata[5];
+    prxp->prox_data <<= 8;
+    prxp->prox_data |= chdata[4];
+
+    return (ret);
+}
+
+// prox poll timer function
+static void taos_prox_poll_timer_func(unsigned long param) {
+    int ret = 0;
+
+    if (!device_released) {
+        if ((ret = taos_prox_poll(prox_cur_infop)) < 0) {
+            printk(KERN_ERR "TAOS: call to prox_poll failed in taos_prox_poll_timer_func()\n");
+            return;
+        }
+        taos_prox_poll_timer_start();
+    }
+    return;
+}
+
+// start prox poll timer
+static void taos_prox_poll_timer_start(void) {
+    init_timer(&prox_poll_timer);
+    prox_poll_timer.expires = jiffies + (HZ/10);
+    prox_poll_timer.function = taos_prox_poll_timer_func;
+    add_timer(&prox_poll_timer);
+    return;
+}
+
+static void taos_update_sat_als(void)
+{
+    u8 reg_val = 0;
+    int ret = 0;
+
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_calibrate\n");
+        return;
+    }
+    
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    sat_als = (256 - reg_val) << 10;
+}
+
+static int taos_als_gain_set(unsigned als_gain)
+{
+    int ret;
+    prox_gain_param = (prox_gain_param & 0xFC) | als_gain;
+    gain_param      = prox_gain_param & 0x03;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->gain      = gain_param;
+        taos_cfgp->prox_gain = prox_gain_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");        
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static void taos_als_poll_work_func(struct work_struct *work)
+{
+
+	   	 taos_als_get_data();
+		schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(als_poll_time_mul*als_poll_delay));
+
+}
+
+static void taos_prox_calibrate_work_func(struct work_struct *work)
+{
+
+		taos_prox_calibrate();
+	
+}
+
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer)
+{	 
+	SENSOR_LOG_INFO("######## taos_prox_unwakelock_timer_func #########\n");
+	if(false == taos_datap->irq_work_status )
+	taos_wakelock_ops(&(taos_datap->proximity_wakelock),false);
+	return HRTIMER_NORESTART;
+	
+}
+
+static int taos_sensors_als_poll_on(void) 
+{
+    int  ret = 0, i = 0;
+    u8   reg_val = 0, reg_cntrl = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS ON #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {
+        lux_history[i] = -ENODATA;
+    }
+
+    if (taos_datap->prox_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), taos_cfgp->prox_int_time))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+            return (ret);
+        }
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN));
+
+    //SENSOR_LOG_INFO("reg[0x0F] = 0x%02X\n",reg_val);
+
+    reg_val = reg_val & 0xFC;
+    reg_val = reg_val | (taos_cfgp->gain & 0x03);//*16
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN), reg_val))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+    reg_cntrl = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+    SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_cntrl);
+
+    reg_cntrl |= (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON);
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+	schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(200));
+
+    flag_just_open_light = true;
+
+    taos_datap->als_on = true;
+
+    taos_update_sat_als();
+
+	return ret;
+}	
+
+static int taos_sensors_als_poll_off(void)
+{
+    int  ret = 0, i = 0;
+    u8  reg_val = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS OFF #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {   
+        lux_history[i] = -ENODATA;
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+
+    //SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_val);
+
+    if ((reg_val & TAOS_TRITON_CNTL_PROX_DET_ENBL) == 0x00 && (0 == taos_datap->prox_on)) 
+    {        
+        SENSOR_LOG_INFO("TAOS_TRITON_CNTL_PROX_DET_ENBL = 0\n");
+        reg_val = 0x00;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_val))) < 0) 
+        {
+           printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+           return (ret);
+        }
+
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_ALS_TIME), 0XFF))) < 0) 
+    {
+       printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+       return (ret);
+    }
+
+    taos_datap->als_on = false;
+
+    cancel_delayed_work_sync(&taos_datap->als_poll_work);
+
+    taos_update_sat_als();
+
+    return (ret);
+}
+
+static int taos_prox_on(void)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    int  ret = 0;
+    u8 reg_cntrl = 0, i = 0 ,j = 0;
+
+    taos_datap->prox_on = 1;
+    als_poll_time_mul = 2;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL PROX ON  ######## \n");
+
+    if (true==taos_datap->als_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), 0XFF))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+
+    taos_update_sat_als();
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0C), taos_cfgp->prox_intr_filter))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    reg_cntrl = TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON    | TAOS_TRITON_CNTL_PROX_INT_ENBL | 
+		                                         TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_WAIT_TMR_ENBL  ;
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+	pro_ft = true;
+    if (taos_datap->prox_calibrate_flag)
+    {
+        prox_sum = 0;
+        prox_max = 0;
+
+        mdelay(20);
+        for (i = 0, j = 0; i < 5; i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {
+                j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            mdelay(20);
+        }
+
+        prox_mean = prox_sum/5;
+        if (j==0)
+        {
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+110;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+35;
+
+            printk("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+            printk("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+            if( prox_mean >800 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+            {
+                taos_cfgp->prox_threshold_hi= 800;
+                taos_cfgp->prox_threshold_lo =750;
+            }
+
+            if(taos_cfgp->prox_threshold_hi < 200)
+            {
+            	taos_cfgp->prox_threshold_hi = 200;
+            	taos_cfgp->prox_threshold_lo = 100;	
+            }
+
+            input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+            input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+            input_sync(taos_datap->p_idev);
+    	}
+    }
+    taos_prox_threshold_set();   
+    taos_irq_ops(true, true);
+    return (ret);
+}
+
+
+static int taos_prox_off(void)
+{    
+    int ret = 0;
+    SENSOR_LOG_INFO("########  TAOS IOCTL PROX OFF  ########\n");
+
+    if (true == (taos_datap->proximity_wakelock).locked)
+    {      
+    	  hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+        taos_wakelock_ops(&(taos_datap->proximity_wakelock), false);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), 0x00))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+        return (ret);
+    }
+
+    taos_datap->prox_on = 0;
+    als_poll_time_mul = 1;
+
+	if (true == taos_datap->als_on) 
+    {
+        taos_sensors_als_poll_on();
+	}
+
+   // cancel_work_sync(&taos_datap->irq_work);
+    if (true == taos_datap->irq_enabled)
+    {
+        taos_irq_ops(false, true);
+    }
+
+
+    return (ret);
+}
+
+
+static int taos_prox_calibrate(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    u8 reg_cntrl = 0;
+    u8 reg_val = 0;
+    int i = 0, j = 0;
+    
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_calibrate_error1;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_error;
+        }
+
+        prox_sum = 0;
+        prox_max = 0;   
+        mdelay(30);
+        for (i = 0; i < (taos_datap->prox_calibrate_times); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(taos_datap->prox_calibrate_times);
+	    if(j == 0)
+	 	{
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+120;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+40;
+	 	}
+
+		if( prox_mean >700 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+			{
+			 taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+			taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;	
+			prox_config_offset_param=0x0;
+			taos_cfgp->prox_config_offset = prox_config_offset_param;
+			}
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+     
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_error;
+
+                }
+             }
+         }
+
+        input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+        input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+        input_sync(taos_datap->p_idev);
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_error:
+    SENSOR_LOG_ERROR("exit\n");
+	 kfree(prox_cal_info);
+prox_calibrate_error1:
+
+	return -1;
+    }
+
+
+MODULE_AUTHOR("John Koshi - Surya Software");
+MODULE_DESCRIPTION("TAOS ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(taos_init);
+module_exit(taos_exit);
+
diff --git a/drivers/hwmon/tmd2772_nx404h.c b/drivers/hwmon/tmd2772_nx404h.c
new file mode 100644
index 0000000..07eb590
--- /dev/null
+++ b/drivers/hwmon/tmd2772_nx404h.c
@@ -0,0 +1,3142 @@
+/*******************************************************************************
+*                                                                              *
+*   File Name:    taos.c                                                      *
+*   Description:   Linux device driver for Taos ambient light and         *
+*   proximity sensors.                                     *
+*   Author:         John Koshi                                             *
+*   History:   09/16/2009 - Initial creation                          *
+*           10/09/2009 - Triton version         *
+*           12/21/2009 - Probe/remove mode                *
+*           02/07/2010 - Add proximity          *
+*                                                                                       *
+********************************************************************************
+*    Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// includes
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/delay.h>
+#include <linux/i2c/taos_common.h>
+#include <linux/delay.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h> 
+#include <linux/slab.h>
+#include <asm/gpio.h> 
+#include <linux/poll.h> 
+#include <linux/wakelock.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+
+
+#ifdef CONFIG_ZTE_DEVICE_INFO_SHOW
+#include <linux/zte_device_info.h>
+#endif
+
+#define LOG_TAG "SENSOR_ALS_PROX"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+
+// device name/id/address/counts
+#define TAOS_DEVICE_NAME                "taos"
+#define TAOS_DEVICE_ID                  "tritonFN"
+#define TAOS_ID_NAME_SIZE               10
+#define TAOS_TRITON_CHIPIDVAL           0x00
+#define TAOS_TRITON_MAXREGS             32
+#define TAOS_DEVICE_ADDR1               0x29
+#define TAOS_DEVICE_ADDR2               0x39
+#define TAOS_DEVICE_ADDR3               0x49
+#define TAOS_MAX_NUM_DEVICES            3
+#define TAOS_MAX_DEVICE_REGS            32
+#define I2C_MAX_ADAPTERS                12
+
+// TRITON register offsets
+#define TAOS_TRITON_CNTRL               0x00
+#define TAOS_TRITON_ALS_TIME            0X01
+#define TAOS_TRITON_PRX_TIME            0x02
+#define TAOS_TRITON_WAIT_TIME           0x03
+#define TAOS_TRITON_ALS_MINTHRESHLO     0X04
+#define TAOS_TRITON_ALS_MINTHRESHHI     0X05
+#define TAOS_TRITON_ALS_MAXTHRESHLO     0X06
+#define TAOS_TRITON_ALS_MAXTHRESHHI     0X07
+#define TAOS_TRITON_PRX_MINTHRESHLO     0X08
+#define TAOS_TRITON_PRX_MINTHRESHHI     0X09
+#define TAOS_TRITON_PRX_MAXTHRESHLO     0X0A
+#define TAOS_TRITON_PRX_MAXTHRESHHI     0X0B
+#define TAOS_TRITON_INTERRUPT           0x0C
+#define TAOS_TRITON_PRX_CFG             0x0D
+#define TAOS_TRITON_PRX_COUNT           0x0E
+#define TAOS_TRITON_GAIN                0x0F
+#define TAOS_TRITON_REVID               0x11
+#define TAOS_TRITON_CHIPID              0x12
+#define TAOS_TRITON_STATUS              0x13
+#define TAOS_TRITON_ALS_CHAN0LO         0x14
+#define TAOS_TRITON_ALS_CHAN0HI         0x15
+#define TAOS_TRITON_ALS_CHAN1LO         0x16
+#define TAOS_TRITON_ALS_CHAN1HI         0x17
+#define TAOS_TRITON_PRX_LO              0x18
+#define TAOS_TRITON_PRX_HI              0x19
+#define TAOS_TRITON_TEST_STATUS         0x1F
+
+// Triton cmd reg masks
+//0x by clli2
+#define TAOS_TRITON_CMD_REG             0X80
+#define TAOS_TRITON_CMD_AUTO            0x20 
+#define TAOS_TRITON_CMD_BYTE_RW         0x00 
+#define TAOS_TRITON_CMD_WORD_BLK_RW     0x20 
+#define TAOS_TRITON_CMD_SPL_FN          0x60 
+#define TAOS_TRITON_CMD_PROX_INTCLR     0X05 
+#define TAOS_TRITON_CMD_ALS_INTCLR      0X06 
+#define TAOS_TRITON_CMD_PROXALS_INTCLR  0X07 
+#define TAOS_TRITON_CMD_TST_REG         0X08 
+#define TAOS_TRITON_CMD_USER_REG        0X09
+
+// Triton cntrl reg masks
+#define TAOS_TRITON_CNTL_PROX_INT_ENBL  0X20
+#define TAOS_TRITON_CNTL_ALS_INT_ENBL   0X10
+#define TAOS_TRITON_CNTL_WAIT_TMR_ENBL  0X08
+#define TAOS_TRITON_CNTL_PROX_DET_ENBL  0X04
+#define TAOS_TRITON_CNTL_ADC_ENBL       0x02
+#define TAOS_TRITON_CNTL_PWRON          0x01
+
+// Triton status reg masks
+#define TAOS_TRITON_STATUS_ADCVALID     0x01
+#define TAOS_TRITON_STATUS_PRXVALID     0x02
+#define TAOS_TRITON_STATUS_ADCINTR      0x10
+#define TAOS_TRITON_STATUS_PRXINTR      0x20
+
+// lux constants
+#define TAOS_MAX_LUX                    10000
+#define TAOS_SCALE_MILLILUX             3
+#define TAOS_FILTER_DEPTH               3
+#define CHIP_ID                         0x3d
+
+#define TAOS_INPUT_NAME                 "lightsensor"
+#define	POLL_DELAY	                    msecs_to_jiffies(5)
+#define	TAOS_ALS_ADC_TIME_WHEN_PROX_ON	0xF0//0XF5//0XEB
+#define TAOS_ALS_GAIN_DIVIDE            1000
+#define TAOS_ALS_GAIN_1X                0
+#define TAOS_ALS_GAIN_8X                1
+#define TAOS_ALS_GAIN_16X               2
+#define TAOS_ALS_GAIN_120X              3
+#define CAL_THRESHOLD   "/persist/proxdata/threshold"
+
+
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501
+// added the work mode marco
+//#define WORK_UES_POLL_MODE
+// ZTEMT ADD by zhubing 2012-2-20 V8000/X501 END
+
+//#define IRQ_TRIGER_LEVEL_LOW
+
+// forward declarations
+static int tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp);
+static int tmd2772_remove(struct i2c_client *client);
+static int taos_get_lux(void);
+static int taos_lux_filter(int raw_lux);
+static int taos_device_name(unsigned char *bufp, char **device_name);
+static int taos_prox_poll(struct taos_prox_info *prxp);
+static void taos_prox_poll_timer_func(unsigned long param);
+static void taos_prox_poll_timer_start(void);
+//iVIZM
+static int taos_prox_threshold_set(void);
+static int taos_als_get_data(void);
+static int taos_interrupts_clear(void);
+static int taos_resume(struct i2c_client *client);
+static int taos_suspend(struct i2c_client *client,pm_message_t mesg);
+//CLLI@
+
+
+static int taos_sensors_als_poll_on(void);
+static int taos_sensors_als_poll_off(void);
+static void taos_als_poll_work_func(struct work_struct *work);
+static int taos_als_gain_set(unsigned als_gain);
+static void taos_update_sat_als(void);
+static int taos_prox_on(void);
+static int taos_prox_off(void);
+static int taos_prox_calibrate(void);
+static void taos_prox_calibrate_work_func(struct work_struct *work);
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable);
+static int taos_write_cal_file(char *file_path,unsigned int value);
+static int taos_read_cal_value(char *file_path);
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer);
+
+
+static dev_t const tmd2772_proximity_dev_t = MKDEV(MISC_MAJOR, 101);
+static dev_t const tmd2772_light_dev_t     = MKDEV(MISC_MAJOR, 102);
+
+
+DECLARE_WAIT_QUEUE_HEAD(waitqueue_read);//iVIZM
+
+struct ReadData { //iVIZM
+    unsigned int data;
+    unsigned int interrupt;
+};
+struct ReadData readdata[2];//iVIZM
+
+// workqueue struct
+//static struct workqueue_struct *taos_wq; //iVIZM
+
+// class structure for this device
+struct class *taos_class;
+
+// board and address info   iVIZM
+struct i2c_board_info taos_board_info[] = {
+    {I2C_BOARD_INFO(TAOS_DEVICE_ID, TAOS_DEVICE_ADDR2),},
+};
+
+unsigned short const taos_addr_list[2] = {TAOS_DEVICE_ADDR2, I2C_CLIENT_END};//iVIZM
+
+// client and device
+struct i2c_client *my_clientp;
+struct i2c_client *bad_clientp[TAOS_MAX_NUM_DEVICES];
+static int device_found = 0;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+
+
+//iVIZM
+static char pro_buf[4]; //iVIZM
+static int mcount = 0; //iVIZM
+static bool pro_ft = false; //by clli2
+static bool flag_prox_debug = false;
+static bool flag_als_debug  = false;
+static bool flag_just_open_light = false;
+static unsigned int als_poll_delay = 1000;
+static unsigned int prox_debug_delay_time = 0;
+u16 status = 0;
+static int als_poll_time_mul  = 1;
+static unsigned char reg_addr = 0;
+static bool wakeup_from_sleep = false;
+
+// ZTEMT ADD by zhubing
+// modify for input filter the same data
+static int last_proximity_data = -1;
+//static int last_als_data       = -1;
+// ZTEMT ADD by zhubing END
+
+
+static const struct i2c_device_id tmd2772_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmd2772_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmd2772_idtable);
+
+struct i2c_driver tmd2772_driver = {
+	.driver = {
+		.name = "ams-sensor",
+        .of_match_table = of_tmd2772_idtable,
+		//.pm = NULL,
+	},
+	.id_table = tmd2772_idtable_id,
+	.probe = tmd2772_probe,
+	.remove = __devexit_p(tmd2772_remove),
+#ifdef CONFIG_PM_SLEEP //by clli2
+    .resume = taos_resume,
+    .suspend = taos_suspend,
+#endif
+
+};
+
+
+
+
+
+
+// per-device data
+struct taos_data {
+	struct i2c_client *client;
+	struct cdev cdev;
+	unsigned int addr;
+	//struct input_dev *input_dev;//iVIZM
+	//struct work_struct work;//iVIZM
+	struct delayed_work work;//iVIZM
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+	struct taos_wake_lock proximity_wakelock;//iVIZM
+	struct mutex lock;
+	struct device *class_dev;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_calibrate_work;
+	struct hrtimer  prox_unwakelock_timer;
+	struct input_dev *p_idev;
+	struct input_dev *a_idev;
+
+	struct device *proximity_dev;
+	struct device *light_dev;
+	struct device *gesture_dev;
+
+	char taos_id;
+	char taos_name[TAOS_ID_NAME_SIZE];
+
+	char *prox_name;
+	char *als_name;
+	bool prox_calibrate_flag;
+	bool prox_calibrate_result;
+	bool phone_is_sleep;
+
+	int  prox_calibrate_times;
+	int  prox_thres_hi_max;
+	int  prox_thres_lo_min;
+	int  prox_data_max;
+	int  prox_manual_calibrate_threshold;
+	char *chip_name;
+
+
+	bool prox_on;
+	bool als_on;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool init;
+	int als_poll_time_mul;
+
+	struct semaphore update_lock;
+	char valid;
+	//int working;
+	unsigned long last_updated;
+} *taos_datap;
+
+// device configuration by clli2
+struct taos_cfg *taos_cfgp;
+static u32 calibrate_target_param = 300000;
+static u16 als_time_param = 41;
+static u16 scale_factor_param_prox = 6;    
+static u16 scale_factor_param_als = 13;
+static u16 gain_trim_param = 512;          //NULL
+static u8 filter_history_param = 3;        //NULL
+static u8 filter_count_param = 1;          //NULL
+/* gain_param  00--1X, 01--8X, 10--16X, 11--120X
+ */
+static u8 gain_param = 0;                  //same as prox-gain_param 1:0 8X
+static u16 prox_calibrate_hi_param = 500;
+static u16 prox_calibrate_lo_param = 330;
+static u16 prox_threshold_hi_param = 800;
+static u16 prox_threshold_lo_param = 750;
+static u16 als_threshold_hi_param  = 3000; 
+static u16 als_threshold_lo_param  = 10;   
+static u8  prox_int_time_param     = 0xF0;//0xCD; // time of the ALS ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_adc_time_param     = 0xFF; // time of the PRO ADC TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+static u8  prox_wait_time_param    = 0xFF; // time of the    Wait TIME, TIME = (255 - prox_int_time_param) * 2.72ms
+/*7~4->pls,3~0->als*/
+static u8  prox_intr_filter_param  = 0x33; // Int filter, Bit7--Bit4:PROX  Bit3--Bit0:ALS
+static u8  prox_config_param       = 0x00; // wait long time disable
+/*pulse/62.5Khz  less  32 recommand*/
+static u8  prox_pulse_cnt_param    = 0x09; //PROX LED pluse count to send for each measure 0x00--0xff:0--255
+/* 7:6 11->100ma        00->12.5ma
+   5:4 01->ch0          10->ch1    11->both
+   1:0(als gain ctrol)  1X 8X 16X 128X        */
+static u8  prox_gain_param = 0x20;   //50ma     8X
+static u8  prox_config_offset_param  = 0x93;
+// prox info
+struct taos_prox_info prox_cal_info[20];
+struct taos_prox_info prox_cur_info;
+struct taos_prox_info *prox_cur_infop = &prox_cur_info;
+static struct timer_list prox_poll_timer;
+static int device_released = 0;
+static u16 sat_als = 0;
+static u16 sat_prox = 0;
+
+
+
+// device reg init values
+u8 taos_triton_reg_init[16] = {0x00,0xFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00};
+
+// lux time scale
+struct time_scale_factor  {
+    u16 numerator;
+    u16 denominator;
+    u16 saturation;
+};
+struct time_scale_factor TritonTime = {1, 0, 0};
+struct time_scale_factor *lux_timep = &TritonTime;
+
+// gain table
+u8 taos_triton_gain_table[] = {1, 8, 16, 120};
+
+// lux data
+struct lux_data {
+    u16 ratio;
+    u16 clear;
+    u16 ir;
+};
+struct lux_data TritonFN_lux_data[] = {
+    { 9830,  8320,  15360 },
+    { 12452, 10554, 22797 },
+    { 14746, 6234,  11430 },
+    { 17695, 3968,  6400  },
+    { 0,     0,     0     }
+};
+struct lux_data *lux_tablep = TritonFN_lux_data;
+static int lux_history[TAOS_FILTER_DEPTH] = {-ENODATA, -ENODATA, -ENODATA};//iVIZM
+
+static int taos_get_data(void);
+
+
+static void taos_irq_ops(bool enable, bool flag_sync)
+{
+    if (enable == taos_datap->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(taos_datap->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(taos_datap->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(taos_datap->client->irq);
+        }
+    }
+
+    taos_datap->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static ssize_t attr_set_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_pulse_cnt_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_pulse_cnt reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_pluse_cnt(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_pluse_cnt is %d\n", taos_cfgp->prox_pulse_cnt);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_int_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_int_time = prox_int_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the als_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_int_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_adc_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_adc_time = prox_adc_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_adc_time reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_adc_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_adc_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_adc_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_wait_time(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_wait_time_param = 255 - val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_wait_time = prox_wait_time_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) 
+        {   
+            SENSOR_LOG_ERROR("failed to write the wait_time reg\n");
+        }
+
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_wait_time(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "wait_time is 2.72 * %d ms\n", 255 - taos_cfgp->prox_wait_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = 4 - val;
+        prox_gain_param = (prox_gain_param & 0x3F) | (val<<6);
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_led_strength_level(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    char *p_led_strength[4] = {"100", "50", "25", "12.5"};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_led_strength is %s mA\n", p_led_strength[(taos_cfgp->prox_gain) >> 6]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_als_gain(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val>4 || val<=0)
+    {        
+        SENSOR_LOG_ERROR("input error, please input a number 1~~4");
+    }
+    else
+    {
+        val = val-1;
+        prox_gain_param = (prox_gain_param & 0xFC) | val;
+        gain_param      = prox_gain_param & 0x03;
+
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->gain      = gain_param;
+            taos_cfgp->prox_gain = prox_gain_param;
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+            {
+                SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_gain(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    u8 als_gain[4] = {1, 8, 16, 120};
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "als gain is x%d\n", als_gain[taos_cfgp->prox_gain & 0x03]);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_debug_delay_time =  val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_debug_delay(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_debug_delay_time is %d\n", prox_debug_delay_time);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_debug_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_prox_debug = true;
+    }
+    else
+    {       
+        flag_prox_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_prox_debug_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_start_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_calibrate_startis %s\n", flag_prox_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+
+
+static ssize_t attr_prox_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "prox calibrate is %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t attr_prox_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        taos_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {       
+    	 //cancel_delayed_work_sync(&chip->prox_unwakelock_work);
+	hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+	taos_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t attr_prox_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+//als
+static ssize_t attr_set_als_debug(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        flag_als_debug = true;
+    }
+    else
+    {       
+        flag_als_debug = false;
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_als_debug(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "flag_prox_debug is %s\n", flag_als_debug? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_irq(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (val)
+    {
+        taos_irq_ops(true, true);
+    }
+    else
+    {       
+        taos_irq_ops(false, true);
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_irq(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "flag_irq is %s\n", taos_datap->irq_enabled? "true" : "false");
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_set_prox_calibrate(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    int val,ret;
+
+	ret=kstrtouint(buf, 10, &val);
+    SENSOR_LOG_ERROR("enter\n");
+    if (ret<0)
+    {
+        return -EINVAL;
+    }
+
+    if (val>1)
+    {
+     taos_datap->prox_calibrate_times= val;
+    taos_prox_calibrate();
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("your input error, please input a number that bigger than 1\n");
+    }
+   
+	return size;
+}
+
+static ssize_t attr_prox_thres_high_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_hi_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_hi_param is %d\n",prox_calibrate_hi_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_low_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        prox_calibrate_lo_param = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_prox_thres_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n",prox_calibrate_lo_param);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_calibrate_lo_param is %d\n prox_calibrate_hi_param is %d\n",taos_cfgp->prox_threshold_lo,taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+static ssize_t attr_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	mutex_lock(&taos_datap->lock);
+
+	if (value==1)
+    {
+   		if( (rc=taos_read_cal_value(CAL_THRESHOLD))<0)
+        {
+            mutex_unlock(&taos_datap->lock);
+            return -EINVAL;
+        }
+		else
+		{
+			if(rc > (taos_datap->prox_thres_lo_min))
+            		{
+			taos_datap->prox_calibrate_flag = false;
+			taos_datap->prox_manual_calibrate_threshold =rc;
+			taos_cfgp->prox_threshold_hi= rc;
+			taos_cfgp->prox_threshold_lo  = rc - 80;
+			input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+			input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+			input_sync(taos_datap->p_idev);
+			SENSOR_LOG_ERROR("prox_th_high  = %d\n",taos_cfgp->prox_threshold_hi);
+			SENSOR_LOG_ERROR("prox_th_low   = %d\n",taos_cfgp->prox_threshold_lo);
+           		 }
+
+		}
+	}
+	else
+    {	
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+static ssize_t attr_set_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_prox = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_prox(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_prox is %d\n",taos_cfgp->scale_factor_prox);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val>0)
+    {
+        scale_factor_param_als = val;
+        if (NULL!=taos_cfgp)
+        {
+            taos_cfgp->scale_factor_als = scale_factor_param_als;
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("you input error, please input a number that bigger than 0\n");
+    }
+
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_als_scale_factor_param_als(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        sprintf(buf, "als_scale_factor_param_als is %d\n",taos_cfgp->scale_factor_als);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_get_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_hi);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_high(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_hi = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+
+static ssize_t attr_get_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "%d", taos_cfgp->prox_threshold_lo);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_prox_threshold_low(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_threshold_lo = val;
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_set_prox_offset(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    prox_config_offset_param = val;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->prox_config_offset = prox_config_offset_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_config_offset  reg\n");
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_prox_offset(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+        return sprintf(buf, "prox_config_offset_param is %d\n", taos_cfgp->prox_config_offset);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_calibrate_result_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_calibrate_result);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_thres_hi_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+            SENSOR_LOG_ERROR( "prox_thres_hi_max is %d\n",taos_datap->prox_thres_hi_max);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_hi_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_thres_lo_min(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+                SENSOR_LOG_ERROR("prox_thres_lo_min is %d\n",taos_datap->prox_thres_lo_min);
+
+        return sprintf(buf, "%d", taos_datap->prox_thres_lo_min);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_chip_name_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%s", taos_datap->chip_name);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+
+static ssize_t attr_prox_data_max(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_data_max);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_prox_manual_calibrate_threshold(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_datap)
+    {
+        return sprintf(buf, "%d", taos_datap->prox_manual_calibrate_threshold);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t attr_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t attr_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t attr_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|reg_addr), val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+
+static ssize_t attr_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    unsigned char i;
+    if (100 == reg_addr)
+    {
+        for (i=0x00; i<=0x0F; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));
+        }
+        for (i=0x11; i<=0x19; i++)
+        {
+            i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | i));
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(taos_datap->client));            
+        }
+
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | 0x1F));
+        SENSOR_LOG_ERROR("reg[0x1F] = 0x%02X",i2c_smbus_read_byte(taos_datap->client));  
+    }   
+    else
+    {
+        i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | reg_addr));
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(taos_datap->client)); 
+    }
+
+	return strlen(buf);
+}
+
+static ssize_t attr_get_prox_value(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    if (NULL!=taos_cfgp)
+    {
+
+	 return sprintf(buf, "%d\n", last_proximity_data%100000);
+    }
+    else
+    {       
+        sprintf(buf, "taos_cfgp is NULL\n");
+    }
+	return strlen(buf);
+}
+
+/*
+static struct device_attribute attributes[] = {
+#ifdef CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+	__ATTR(taos_prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+	__ATTR(taos_als_adc_time,                   0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+	__ATTR(taos_prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+	__ATTR(taos_wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+	__ATTR(taos_prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+	__ATTR(taos_als_gain,                       0644,   attr_get_als_gain,                          attr_set_als_gain),
+	__ATTR(taos_prox_debug,                     0644,   attr_get_prox_debug,                        attr_set_prox_debug),
+	__ATTR(taos_als_debug,                      0644,   attr_get_als_debug,                         attr_set_als_debug),
+	__ATTR(taos_prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+	__ATTR(taos_irq,                            0644,   attr_get_irq,                               attr_set_irq),       
+	__ATTR(taos_prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+	__ATTR(taos_prox_calibrate_hi_param,        0644,   attr_get_prox_calibrate_hi_param,           attr_set_prox_calibrate_hi_param),
+	__ATTR(taos_prox_calibrate_lo_param,        0644,   attr_get_prox_calibrate_lo_param,           attr_set_prox_calibrate_lo_param),
+	__ATTR(taos_als_scale_factor_param_als,     0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+	__ATTR(taos_als_scale_factor_param_prox,    0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+	__ATTR(taos_prox_threshold_high,            0644,   attr_get_prox_threshold_high,               NULL),
+	__ATTR(taos_prox_threshold_low,             0644,   attr_get_prox_threshold_low,                NULL),
+	__ATTR(taos_prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+#endif
+    __ATTR(taos_reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(taos_reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+	__ATTR(th_hi,                               0644,   attr_get_threshold_hi,                      attr_set_threshold_hi),
+	__ATTR(th_low,                              0644,   attr_get_threshold_lo,                      attr_set_threshold_lo),
+	__ATTR(prox_value,                          0644,   attr_get_prox_value,                        NULL),
+};
+*/
+
+
+///***************************************************************************************///
+//light
+static ssize_t attr_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_on);
+}
+
+static ssize_t attr_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        taos_sensors_als_poll_on();
+    }
+    else
+    {
+        taos_sensors_als_poll_off();
+    }
+
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "als_poll_time = %d\n", als_poll_delay);
+}
+
+static ssize_t attr_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+	als_poll_delay = time;
+	return size;
+}
+
+
+
+//prox
+static ssize_t attr_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_on);
+}
+
+static ssize_t attr_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	bool value;
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value)
+    {
+        taos_prox_on();
+    }
+	else
+    {
+        taos_prox_off();
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t attr_prox_init_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct taos_data *chip = dev_get_drvdata(dev);
+	return sprintf(buf, "chip->init%d\n", chip->init);
+	
+}
+
+static ssize_t attr_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int value =1;
+	int ret =0,err=1;
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return -EINVAL;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+
+	if (value ==1)
+    {
+    	if((ret=taos_read_cal_value(CAL_THRESHOLD))<0)
+		{
+		    SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+		    err=taos_write_cal_file(CAL_THRESHOLD,0);
+			if(err<0)
+			{
+				SENSOR_LOG_ERROR("ERROR=%s\n",CAL_THRESHOLD);
+				mutex_unlock(&taos_datap->lock);
+				return -EINVAL;
+			}
+           	taos_datap->prox_calibrate_flag = true;
+		}
+		else if (ret==0){
+           	taos_datap->prox_calibrate_flag = true;
+		    SENSOR_LOG_ERROR("tmg399x_prox_calibrate==1\n");
+		}
+		else if(ret > (taos_datap->prox_thres_lo_min)){
+		taos_datap->prox_calibrate_flag = false;
+		taos_datap->prox_manual_calibrate_threshold =ret;
+        taos_cfgp->prox_threshold_hi = ret;
+        taos_cfgp->prox_threshold_lo  = ret - 80;
+		input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+		input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+		input_sync(taos_datap->p_idev);
+		SENSOR_LOG_ERROR("tmg399x_prox_init> 0\n");
+		}
+	}
+	else
+    {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		mutex_unlock(&taos_datap->lock);
+		return -EINVAL;
+	}
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+
+	return size;
+}
+
+
+
+static struct device_attribute attrs_light[] = {
+	__ATTR(enable,                         0640,   attr_als_enable_show,                       attr_als_enable_store),
+    __ATTR(light_gain,                     0644,   attr_get_als_gain,                          attr_set_als_gain),
+    __ATTR(light_debug,                    0644,   attr_get_als_debug,                         attr_set_als_debug),
+    __ATTR(light_adc_time,                 0644,   attr_get_als_adc_time,                      attr_set_als_adc_time),
+    __ATTR(light_scale_factor_param,       0644,   attr_get_als_scale_factor_param_als,        attr_set_als_scale_factor_param_als),
+    __ATTR(prox_scale_factor_param,        0644,   attr_get_als_scale_factor_param_prox,       attr_set_als_scale_factor_param_prox),
+    __ATTR(delay,                          0640,   attr_als_poll_time_show,                    attr_als_poll_time_store),
+};
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                      0640,   attr_chip_name_show,                        NULL),
+	__ATTR(enable,                         0640,   attr_prox_enable_show,                      attr_prox_enable_store),    
+	__ATTR(prox_init,                      0640,   attr_prox_init_show,                        attr_prox_init_store),  
+	__ATTR(prox_led_pluse_cnt,             0644,   attr_get_prox_led_pluse_cnt,                attr_set_prox_led_pluse_cnt),
+    __ATTR(prox_adc_time,                  0644,   attr_get_prox_adc_time,                     attr_set_prox_adc_time),
+    __ATTR(prox_led_strength_level,        0644,   attr_get_prox_led_strength_level,           attr_set_prox_led_strength_level),
+    __ATTR(prox_debug_delay,               0644,   attr_get_prox_debug_delay,                  attr_set_prox_debug_delay),   
+    __ATTR(prox_calibrate,                 0644,   NULL,                                       attr_set_prox_calibrate),
+    __ATTR(prox_threshold_high,            0644,   attr_get_prox_threshold_high,               attr_set_prox_threshold_high),
+    __ATTR(prox_threshold_low,             0644,   attr_get_prox_threshold_low,                attr_set_prox_threshold_low),
+    __ATTR(prox_offset,                    0644,   attr_get_prox_offset,                       attr_set_prox_offset),
+    __ATTR(prox_value,                     0644,   attr_get_prox_value,                        NULL),
+    __ATTR(prox_calibrate_result,          0640,   attr_prox_calibrate_result_show,            NULL), 
+    __ATTR(prox_thres_param_high,          0640,   attr_prox_thres_high_show,                  attr_prox_thres_high_store),
+    __ATTR(prox_thres_param_low,           0640,   attr_prox_thres_low_show,                   attr_prox_thres_low_store),
+    __ATTR(prox_thres,                     0640,   attr_prox_thres_show,                       attr_prox_thres_store),
+    __ATTR(prox_debug,                     0640,   attr_prox_debug_show,                       attr_prox_debug_store),
+    __ATTR(prox_calibrate_start,           0640,   attr_prox_calibrate_start_show,             attr_prox_debug_store),
+    __ATTR(prox_thres_max,                 0644,   attr_prox_thres_hi_max,                     NULL), 
+    __ATTR(prox_thres_min,                 0644,   attr_prox_thres_lo_min,                     NULL), 
+    __ATTR(prox_data_max,                  0640,   attr_prox_data_max,                         NULL), 
+    __ATTR(prox_manual_calibrate_threshold,0644,   attr_prox_manual_calibrate_threshold,       NULL), 
+
+
+    __ATTR(prox_phone_is_sleep,            0640,   attr_prox_phone_is_sleep_show,              attr_prox_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                  0640,   attr_prox_prox_wakelock_show,               attr_prox_prox_wakelock_store),
+
+    __ATTR(reg_addr,                       0644,   attr_get_reg_addr,                          attr_set_reg_addr),
+    __ATTR(reg_data,                       0644,   attr_get_reg_data,                          attr_set_reg_data),
+    __ATTR(irq_status,                     0644,   attr_get_irq,                               attr_set_irq),       
+    __ATTR(wait_time,                      0644,   attr_get_wait_time,                         attr_set_wait_time),
+};
+
+
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+
+static void taos_wakelock_ops(struct taos_wake_lock *wakelock, bool enable)
+{
+    if (enable == wakelock->locked)
+    {
+        SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+static int taos_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+      
+    }
+       memset(write_buf, 0, sizeof(write_buf));
+      sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+
+static int taos_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+static void taos_irq_work_func(struct work_struct * work) //iVIZM
+{
+    int retry_times = 0;
+    int ret;
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    if (wakeup_from_sleep)
+    {  
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        mdelay(50);
+        wakeup_from_sleep = false;
+    }
+
+    for (retry_times=0; retry_times<=50; retry_times++)
+    {
+        ret = taos_get_data();
+        if (ret >= 0)
+        {
+            break;
+        }
+        mdelay(20);
+    }
+    taos_interrupts_clear();
+
+    hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+    taos_datap->irq_work_status = false;
+   // SENSOR_LOG_INFO("########  taos_irq_work_func enter   hrtimer_start #########\n");
+    hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+   //  schedule_delayed_work(&taos_datap->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    taos_irq_ops(true, true);
+    SENSOR_LOG_INFO(" retry_times = %d\n",retry_times);
+    mutex_unlock(&taos_datap->lock);
+}
+
+static irqreturn_t taos_irq_handler(int irq, void *dev_id) //iVIZM
+{
+    mutex_lock(&taos_datap->lock);
+    SENSOR_LOG_INFO("enter\n");
+    taos_datap->irq_work_status = true;
+    taos_irq_ops(false, false);
+    taos_wakelock_ops(&(taos_datap->proximity_wakelock), true);
+    if (0==queue_work(taos_datap->irq_work_queue, &taos_datap->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+    SENSOR_LOG_INFO("exit\n");
+    mutex_unlock(&taos_datap->lock);
+    return IRQ_HANDLED;
+}
+
+static int taos_get_data(void)//iVIZM
+{
+    int ret = 0;
+
+    ret = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS));
+    
+    if (ret < 0)
+    {
+        SENSOR_LOG_ERROR("read TAOS_TRITON_STATUS failed\n");
+        return ret;
+    }
+    else
+    { 
+        ret = taos_prox_threshold_set();
+    }
+    return ret;
+}
+
+
+static int taos_interrupts_clear(void)//iVIZM
+{
+    int ret = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_CMD_SPL_FN|0x07)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte(2) failed in taos_work_func()\n");
+        return (ret);
+    }
+    return ret;
+}
+
+static int taos_als_get_data(void)//iVIZM
+{
+    int ret = 0;
+    u8 reg_val;
+    int lux_val = 0;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON)) != (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON))
+        return -ENODATA;
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_STATUS)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+    if ((reg_val & TAOS_TRITON_STATUS_ADCVALID) != TAOS_TRITON_STATUS_ADCVALID)
+        return -ENODATA;
+
+    if ((lux_val = taos_get_lux()) < 0)
+    {
+        printk(KERN_ERR "TAOS: call to taos_get_lux() returned error %d in ioctl als_data\n", lux_val);
+    }
+
+    if (lux_val<TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_8X)
+    {
+        taos_als_gain_set(TAOS_ALS_GAIN_8X);
+    }
+    else
+    {
+        if (lux_val>TAOS_ALS_GAIN_DIVIDE && gain_param!=TAOS_ALS_GAIN_1X)
+        {
+            taos_als_gain_set(TAOS_ALS_GAIN_1X);
+        }
+    }
+    
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_data\n");
+        return (ret);
+    }
+
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "reg_val = %d lux_val = %d\n",reg_val,lux_val);
+    }
+
+    if (reg_val != prox_int_time_param)
+    {
+        lux_val = (lux_val * (101 - (0XFF - reg_val)))/20;
+    }
+
+    lux_val = taos_lux_filter(lux_val);
+
+    if (flag_als_debug)
+    {        
+        SENSOR_LOG_ERROR(KERN_INFO "lux_val = %d",lux_val);
+    }
+
+    input_report_rel(taos_datap->a_idev, REL_X, lux_val+1);
+    input_sync(taos_datap->a_idev);
+
+    return ret;
+}
+
+static int taos_prox_threshold_set(void)//iVIZM
+{
+    int i,ret = 0;
+    u8 chdata[6];
+    u16 proxdata = 0;
+    u16 cleardata = 0;
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_WORD_BLK_RW| (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    cleardata = chdata[0] + chdata[1]*256;
+    proxdata = chdata[4] + chdata[5]*256;
+
+	if (pro_ft || flag_prox_debug)
+    {
+        pro_buf[0] = 0xff;
+        pro_buf[1] = 0xff;
+        pro_buf[2] = 0xff;
+        pro_buf[3] = 0xff;
+        
+        for( mcount=0; mcount<4; mcount++ )
+        {
+            if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+            {
+                 printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+                 return (ret);
+            }
+        }      
+
+        if (pro_ft)
+        {
+            SENSOR_LOG_INFO( "init the prox threshold");
+        }
+
+        if (flag_prox_debug)
+        {
+            mdelay(prox_debug_delay_time);
+            SENSOR_LOG_INFO( "proxdata = %d",proxdata);
+	        input_report_rel(taos_datap->p_idev, REL_MISC, proxdata);
+
+        }
+		pro_ft = false;
+	} 
+    else 
+    {
+        if (proxdata < taos_cfgp->prox_threshold_lo) 
+        {   //FAR
+            pro_buf[0] = 0x0;
+            pro_buf[1] = 0x0;
+            pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+            pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+    		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+            input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+        } 
+        else 
+        {
+                if (proxdata > taos_cfgp->prox_threshold_hi)
+                {   //NEAR
+                    if (cleardata > ((sat_als*80)/100))
+                    {
+                    	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                    	msleep(100);
+                        return -ENODATA;
+                    }
+                    pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                    pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                    pro_buf[2] = 0xff;
+                    pro_buf[3] = 0xff;
+                    SENSOR_LOG_INFO("Near!!! proxdata = %d\n",proxdata);
+                    input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                }
+                else
+                {
+                    if( (taos_cfgp->prox_threshold_hi-proxdata) > (proxdata-taos_cfgp->prox_threshold_lo))
+                    {
+                        //FAR
+                        pro_buf[0] = 0x0;
+                        pro_buf[1] = 0x0;
+                        pro_buf[2] = taos_cfgp->prox_threshold_hi & 0x0ff;
+                        pro_buf[3] = taos_cfgp->prox_threshold_hi >> 8;
+                		SENSOR_LOG_INFO( "Far!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                    }
+                    else
+                    {
+                        //NEAR
+                        if (cleardata > ((sat_als*80)/100))
+                        {
+                        	printk(KERN_ERR "TAOS: %u <= %u*0.8 int data\n",proxdata,sat_als);
+                        	msleep(100);
+                            return -ENODATA;
+                        }
+                        pro_buf[0] = taos_cfgp->prox_threshold_lo & 0x0ff;
+                        pro_buf[1] = taos_cfgp->prox_threshold_lo >> 8;
+                        pro_buf[2] = 0xff;
+                        pro_buf[3] = 0xff;
+                        SENSOR_LOG_INFO( "Near!!! proxdata = %d\n",proxdata);
+                        input_report_rel(taos_datap->p_idev, REL_X, proxdata);
+                    }
+                }
+            }
+    }
+
+    input_sync(taos_datap->p_idev);
+
+    for( mcount=0; mcount<4; mcount++) 
+    { 
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x08) + mcount, pro_buf[mcount]))) < 0)
+        {
+             printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in taos prox threshold set\n");
+             return (ret);
+        }
+    }
+
+    return ret;
+}
+
+// driver init
+static int __init taos_init(void) 
+{
+
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmd2772_driver);
+#endif
+}
+
+// driver exit
+static void __exit taos_exit(void) 
+{
+	i2c_del_driver(&tmd2772_driver);
+}
+
+
+static void tmd2772_data_init(void)
+{
+    taos_datap->als_on  = false;
+    taos_datap->prox_on = false;
+    taos_datap->init = false;
+    taos_datap->als_poll_time_mul = 1;
+    taos_datap->prox_name = "proximity";
+    taos_datap->als_name  = "light";
+    taos_datap->chip_name = "tmd2772";
+    taos_datap->prox_calibrate_result = false;
+    taos_datap->prox_thres_hi_max = 800;
+    taos_datap->prox_thres_lo_min = 200;
+    taos_datap->prox_data_max     = 1023;
+    taos_datap->prox_calibrate_times = 10;
+    taos_datap->prox_calibrate_flag = true;//true :auto_calibrate,false :manual_calibrate
+    taos_datap->prox_manual_calibrate_threshold = 0;
+    taos_datap->proximity_wakelock.name = "proximity-wakelock";
+    taos_datap->proximity_wakelock.locked = false;
+    taos_datap->phone_is_sleep = false;
+    taos_datap->irq_work_status = false;
+    taos_datap->irq_enabled = true;
+}
+
+
+
+// client probe
+static int __devinit tmd2772_probe(struct i2c_client *clientp, const struct i2c_device_id *idp) 
+{
+    int ret = 0;
+    int i = 0;
+    int chip_id = -1;
+    unsigned char buf[TAOS_MAX_DEVICE_REGS];
+    char *device_name;
+    SENSOR_LOG_INFO("Prob Start\n");
+    chip_id = i2c_smbus_read_byte_data(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12))); //iVIZM
+    /*TSL27711=0x00 TSL27713=0x09 TMD27711=0x20 TMD27713=0x29 	2011.09.07*/
+	SENSOR_LOG_ERROR(" TAOS chip_id = %x TMD27713=30,TMD27723=39\n",chip_id);	
+	//printk(" TAOS ID reg = %d\n",(TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + 0x12)));	
+    if(chip_id != 0x39) 
+    {
+    	printk(" chip id that was read does not match TMD27723\n");	
+        return -ENODEV;
+    }
+    if (device_found)
+        return -ENODEV;
+    if (!i2c_check_functionality(clientp->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) 
+    {
+        printk(KERN_ERR "TAOS: taos_probe() - i2c smbus byte data functions unsupported\n");
+        return -EOPNOTSUPP;
+    }
+
+    taos_datap = kmalloc(sizeof(struct taos_data), GFP_KERNEL);
+    if (!taos_datap) 
+    {
+         SENSOR_LOG_ERROR("kmalloc for struct taos_data failed\n");
+         return -ENOMEM;
+    }
+
+    taos_datap->client = clientp;
+
+    i2c_set_clientdata(clientp, taos_datap);
+
+    
+
+    INIT_WORK(&(taos_datap->irq_work),taos_irq_work_func);  
+
+	sema_init(&taos_datap->update_lock,1);
+	mutex_init(&(taos_datap->lock));
+    wake_lock_init(&taos_datap->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, "proximity-wakelock");
+
+    tmd2772_data_init();
+
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+        if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_CNTRL + i))))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+            return(ret);
+        }
+        buf[i] = i2c_smbus_read_byte(clientp);
+    }
+
+    if ((ret = taos_device_name(buf, &device_name)) == 0) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read found mismatched by taos_device_name(), in taos_probe()\n");
+        return -ENODEV;
+    }
+    if (strcmp(device_name, TAOS_DEVICE_ID)) 
+    {
+        printk(KERN_ERR "TAOS: chip id that was read does not match expected id in taos_probe()\n");
+        return -ENODEV;
+    }
+    else 
+    {
+        SENSOR_LOG_ERROR( "TAOS: chip id of %s that was read matches expected id in taos_probe()\n", device_name);
+        device_found = 1;
+    }
+    if ((ret = (i2c_smbus_write_byte(clientp, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL)))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to control reg failed in taos_probe()\n");
+        return(ret);
+    }
+    strlcpy(clientp->name, TAOS_DEVICE_ID, I2C_NAME_SIZE);
+    strlcpy(taos_datap->taos_name, TAOS_DEVICE_ID, TAOS_ID_NAME_SIZE);
+    taos_datap->valid = 0;
+    if (!(taos_cfgp = kmalloc(sizeof(struct taos_cfg), GFP_KERNEL))) {
+        printk(KERN_ERR "TAOS: kmalloc for struct taos_cfg failed in taos_probe()\n");
+        return -ENOMEM;
+    }
+    taos_cfgp->calibrate_target = calibrate_target_param;
+    taos_cfgp->als_time = als_time_param;
+    taos_cfgp->scale_factor_als = scale_factor_param_als;
+	taos_cfgp->scale_factor_prox = scale_factor_param_prox;
+    taos_cfgp->gain_trim = gain_trim_param;
+    taos_cfgp->filter_history = filter_history_param;
+    taos_cfgp->filter_count = filter_count_param;
+    taos_cfgp->gain = gain_param;
+    taos_cfgp->als_threshold_hi = als_threshold_hi_param;//iVIZM
+    taos_cfgp->als_threshold_lo = als_threshold_lo_param;//iVIZM
+    taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+    taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;
+    taos_cfgp->prox_int_time = prox_int_time_param;
+    taos_cfgp->prox_adc_time = prox_adc_time_param;
+    taos_cfgp->prox_wait_time = prox_wait_time_param;
+    taos_cfgp->prox_intr_filter = prox_intr_filter_param;
+    taos_cfgp->prox_config = prox_config_param;
+    taos_cfgp->prox_pulse_cnt = prox_pulse_cnt_param;
+    taos_cfgp->prox_gain = prox_gain_param;
+    taos_cfgp->prox_config_offset=prox_config_offset_param;
+    sat_als = (256 - taos_cfgp->prox_int_time) << 10;
+    sat_prox = (256 - taos_cfgp->prox_adc_time) << 10;
+
+    /*dmobile ::power down for init ,Rambo liu*/
+    SENSOR_LOG_ERROR("TAOS:Rambo::light sensor will pwr down \n");
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x00), 0x00))) < 0) {
+        printk(KERN_ERR "TAOS:Rambo, i2c_smbus_write_byte_data failed in power down\n");
+        return (ret);
+    }
+
+
+    taos_datap->irq_work_queue = create_singlethread_workqueue("taos_work_queue");
+    if (!taos_datap->irq_work_queue)
+    {
+        ret = -ENOMEM;
+        SENSOR_LOG_INFO( "---------%s: %d: cannot create work taos_work_queue, err = %d",__func__,__LINE__,ret);
+        return ret;
+    }
+
+    ret = gpio_request(ALS_PS_GPIO, "ALS_PS_INT");
+    if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",ALS_PS_GPIO);
+        
+        gpio_free(ALS_PS_GPIO);
+        ret = gpio_request(ALS_PS_GPIO, "ALS_PS_INT");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",ALS_PS_GPIO);
+            return ret;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_INFO("get gpio %d success\n",ALS_PS_GPIO);
+    }
+
+
+    ret = gpio_tlmm_config(GPIO_CFG(ALS_PS_GPIO, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    taos_datap->client->irq = gpio_to_irq(ALS_PS_GPIO);
+
+	ret = request_threaded_irq(taos_datap->client->irq, NULL, &taos_irq_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "taos_irq", taos_datap);
+    if (ret != 0) 
+    {
+        gpio_free(ALS_PS_GPIO);
+        return(ret);
+    }
+
+    taos_irq_ops(false, true);
+    INIT_DELAYED_WORK(&taos_datap->als_poll_work, taos_als_poll_work_func);
+    INIT_DELAYED_WORK(&taos_datap->prox_calibrate_work, taos_prox_calibrate_work_func);
+  //  INIT_DELAYED_WORK(&taos_datap->prox_unwakelock_work, taos_prox_unwakelock_work_func);
+    hrtimer_init(&taos_datap->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    ( taos_datap->prox_unwakelock_timer).function = taos_prox_unwakelock_work_func ;
+   // hrtimer_start(&taos_datap->prox_unwakelock_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+
+    taos_datap->proximity_dev = device_create(proximity_class, NULL, tmd2772_proximity_dev_t, &tmd2772_driver ,"proximity");
+    if (IS_ERR(taos_datap->proximity_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->proximity_dev);
+      SENSOR_LOG_ERROR("device_create proximity failed\n");
+      goto create_proximity_dev_failed;
+    }
+
+    taos_datap->light_dev= device_create(light_class, NULL, tmd2772_light_dev_t, &tmd2772_driver ,"light");
+    if (IS_ERR(taos_datap->light_dev)) 
+    {
+      ret = PTR_ERR(taos_datap->light_dev);
+      SENSOR_LOG_ERROR("device_create light failed\n");
+      goto create_light_dev_failed;
+    }
+
+    //prox input 
+    taos_datap->p_idev = input_allocate_device();
+    if (!taos_datap->p_idev)
+    {
+        SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->prox_name);
+        ret = -ENODEV;
+        goto input_p_alloc_failed;
+    }
+    taos_datap->p_idev->name = taos_datap->prox_name;
+    taos_datap->p_idev->id.bustype = BUS_I2C;
+    dev_set_drvdata(&taos_datap->p_idev->dev, taos_datap);
+    ret = input_register_device(taos_datap->p_idev);
+    if (ret) 
+    {
+        input_free_device(taos_datap->p_idev);
+        SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+        goto input_p_register_failed;
+    }
+
+    set_bit(EV_REL, taos_datap->p_idev->evbit);
+    set_bit(REL_X,  taos_datap->p_idev->relbit);
+    set_bit(REL_Y,  taos_datap->p_idev->relbit);
+    set_bit(REL_Z,  taos_datap->p_idev->relbit);
+    set_bit(REL_MISC,  taos_datap->p_idev->relbit);
+
+    //light input
+    taos_datap->a_idev = input_allocate_device();
+	if (!taos_datap->a_idev) 
+    {
+		SENSOR_LOG_ERROR("no memory for input_dev '%s'\n",taos_datap->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	taos_datap->a_idev->name = taos_datap->als_name;
+	taos_datap->a_idev->id.bustype = BUS_I2C;
+    
+    /*
+	set_bit(EV_ABS, chip->a_idev->evbit);
+	set_bit(ABS_MISC, chip->a_idev->absbit);
+	input_set_abs_params(chip->a_idev, ABS_MISC, 0, 65535, 0, 0);
+    */
+
+    set_bit(EV_REL, taos_datap->a_idev->evbit);
+    set_bit(REL_X,  taos_datap->a_idev->relbit);
+    set_bit(REL_Y,  taos_datap->a_idev->relbit);
+
+
+	//chip->a_idev->open = tmg399x_als_idev_open;
+	//chip->a_idev->close = tmg399x_als_idev_close;
+	dev_set_drvdata(&taos_datap->a_idev->dev, taos_datap);
+	ret = input_register_device(taos_datap->a_idev);
+	if (ret) 
+    {
+		input_free_device(taos_datap->a_idev);
+		SENSOR_LOG_ERROR("cant register input '%s'\n",taos_datap->prox_name);
+		goto input_a_register_failed;
+	}
+
+	dev_set_drvdata(taos_datap->proximity_dev, taos_datap);
+	dev_set_drvdata(taos_datap->light_dev, taos_datap);
+
+
+    create_sysfs_interfaces_prox(taos_datap->proximity_dev);
+    create_sysfs_interfaces_light(taos_datap->light_dev);
+
+    SENSOR_LOG_INFO("Prob OK\n");
+
+	return 0;
+
+
+input_a_register_failed:
+    input_free_device(taos_datap->a_idev);
+input_a_alloc_failed:
+
+input_p_register_failed:
+    input_free_device(taos_datap->p_idev);
+input_p_alloc_failed:
+
+create_light_dev_failed:
+    taos_datap->light_dev = NULL;
+    class_destroy(light_class);
+
+create_proximity_dev_failed:
+    taos_datap->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+    SENSOR_LOG_INFO("Prob Failed\n");
+
+    return (ret);
+}
+
+#ifdef CONFIG_PM_SLEEP
+//don't move these pm blew to ioctl
+//resume  
+static int taos_resume(struct i2c_client *client) {
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: disable irq wakeup\n",__func__,__LINE__);
+		ret = disable_irq_wake(taos_datap->client->irq);
+	}
+    if(ret < 0)
+		printk(KERN_ERR "TAOS: disable_irq_wake failed\n");
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+//suspend  
+static int taos_suspend(struct i2c_client *client, pm_message_t mesg) 
+{
+	int ret = 0;
+    SENSOR_LOG_INFO("enter\n");
+	if(1 == taos_datap->prox_on)
+    {
+        SENSOR_LOG_INFO( "----------%s: %d: enable irq wakeup\n",__func__,__LINE__);
+       	ret = enable_irq_wake(taos_datap->client->irq);
+    }
+	if(ret < 0)
+    {
+		printk(KERN_ERR "TAOS: enable_irq_wake failed\n");
+    }
+
+    wakeup_from_sleep = true;
+
+    SENSOR_LOG_INFO("eixt\n");
+    return ret ;
+}
+
+#endif
+// client remove
+static int __devexit tmd2772_remove(struct i2c_client *client) {
+    int ret = 0;
+
+    return (ret);
+}
+
+
+// read/calculate lux value
+static int taos_get_lux(void) 
+{
+    int raw_clear = 0, raw_ir = 0, raw_lux = 0;
+    u32 lux = 0;
+    u32 ratio = 0;
+    u8 dev_gain = 0;
+    u16 Tint = 0;
+    struct lux_data *p;
+    int ret = 0;
+    u8 chdata[4];
+    int tmp = 0, i = 0,tmp_gain=1;
+    for (i = 0; i < 4; i++) {
+        if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | (TAOS_TRITON_ALS_CHAN0LO + i))))) < 0) {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte() to chan0/1/lo/hi reg failed in taos_get_lux()\n");
+            return (ret);
+        }
+        chdata[i] = i2c_smbus_read_byte(taos_datap->client);
+    }
+
+    tmp = (taos_cfgp->als_time + 25)/50;            //if atime =100  tmp = (atime+25)/50=2.5   time = 2.7*(256-atime)=  412.5
+    TritonTime.numerator = 1;
+    TritonTime.denominator = tmp;
+
+    tmp = 300 * taos_cfgp->als_time;               //tmp = 300*atime  400
+    if(tmp > 65535)
+        tmp = 65535;
+    TritonTime.saturation = tmp;
+    raw_clear = chdata[1];
+    raw_clear <<= 8;
+    raw_clear |= chdata[0];
+    raw_ir    = chdata[3];
+    raw_ir    <<= 8;
+    raw_ir    |= chdata[2];
+
+    raw_clear *= ((taos_cfgp->scale_factor_als )*tmp_gain);
+    raw_ir *= (taos_cfgp->scale_factor_prox );
+
+    if(raw_ir > raw_clear) {
+        raw_lux = raw_ir;
+        raw_ir = raw_clear;
+        raw_clear = raw_lux;
+    }
+    dev_gain = taos_triton_gain_table[taos_cfgp->gain & 0x3];
+    if(raw_clear >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_ir >= lux_timep->saturation)
+        return(TAOS_MAX_LUX);
+    if(raw_clear == 0)
+        return(0);
+    if(dev_gain == 0 || dev_gain > 127) {
+        printk(KERN_ERR "TAOS: dev_gain = 0 or > 127 in taos_get_lux()\n");
+        return -1;
+    }
+    if(lux_timep->denominator == 0) {
+        printk(KERN_ERR "TAOS: lux_timep->denominator = 0 in taos_get_lux()\n");
+        return -1;
+    }
+    ratio = (raw_ir<<15)/raw_clear;
+    for (p = lux_tablep; p->ratio && p->ratio < ratio; p++);
+	#ifdef WORK_UES_POLL_MODE
+    if(!p->ratio) {//iVIZM
+        if(lux_history[0] < 0)
+            return 0;
+        else
+            return lux_history[0];
+    }
+	#endif
+    Tint = taos_cfgp->als_time;
+    raw_clear = ((raw_clear*400 + (dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    raw_ir = ((raw_ir*400 +(dev_gain>>1))/dev_gain + (Tint>>1))/Tint;
+    lux = ((raw_clear*(p->clear)) - (raw_ir*(p->ir)));
+    lux = (lux + 32000)/64000;
+    if(lux > TAOS_MAX_LUX) {
+        lux = TAOS_MAX_LUX;
+    }
+    return(lux);
+}
+
+static int taos_lux_filter(int lux)
+{
+    static u8 middle[] = {1,0,2,0,0,2,0,1};
+    int index;
+
+    lux_history[2] = lux_history[1];
+    lux_history[1] = lux_history[0];
+    lux_history[0] = lux;
+
+    if(lux_history[2] < 0) { //iVIZM
+        if(lux_history[1] > 0)
+            return lux_history[1];       
+        else 
+            return lux_history[0];
+    }
+    index = 0;
+    if( lux_history[0] > lux_history[1] ) 
+        index += 4;
+    if( lux_history[1] > lux_history[2] ) 
+        index += 2;
+    if( lux_history[0] > lux_history[2] )
+        index++;
+    return(lux_history[middle[index]]);
+}
+
+// verify device
+static int taos_device_name(unsigned char *bufp, char **device_name)
+{
+    /*
+    int i=0 ,j;
+    for (i = 0; i < TAOS_MAX_DEVICE_REGS; i++) 
+    {
+	  	j=bufp[i];
+	  	printk("(bufp[i=%x]=%x,\n",i,j);
+    }
+    */
+    *device_name="tritonFN";
+    return(1);
+}
+
+// proximity poll
+static int taos_prox_poll(struct taos_prox_info *prxp)
+{
+    int i = 0, ret = 0; //wait_count = 0;
+    u8 chdata[6];
+
+    for (i = 0; i < 6; i++) {
+        chdata[i] = (i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CMD_AUTO | (TAOS_TRITON_ALS_CHAN0LO + i))));
+    }
+    prxp->prox_clear = chdata[1];
+    prxp->prox_clear <<= 8;
+    prxp->prox_clear |= chdata[0];
+    if (prxp->prox_clear > ((sat_als*80)/100))
+    {
+		printk(KERN_ERR "TAOS: %u <= %u*0.8 poll data\n",prxp->prox_clear,sat_als);
+        return -ENODATA;
+    }
+    prxp->prox_data = chdata[5];
+    prxp->prox_data <<= 8;
+    prxp->prox_data |= chdata[4];
+
+    return (ret);
+}
+
+// prox poll timer function
+static void taos_prox_poll_timer_func(unsigned long param) {
+    int ret = 0;
+
+    if (!device_released) {
+        if ((ret = taos_prox_poll(prox_cur_infop)) < 0) {
+            printk(KERN_ERR "TAOS: call to prox_poll failed in taos_prox_poll_timer_func()\n");
+            return;
+        }
+        taos_prox_poll_timer_start();
+    }
+    return;
+}
+
+// start prox poll timer
+static void taos_prox_poll_timer_start(void) {
+    init_timer(&prox_poll_timer);
+    prox_poll_timer.expires = jiffies + (HZ/10);
+    prox_poll_timer.function = taos_prox_poll_timer_func;
+    add_timer(&prox_poll_timer);
+    return;
+}
+
+static void taos_update_sat_als(void)
+{
+    u8 reg_val = 0;
+    int ret = 0;
+
+    if ((ret = (i2c_smbus_write_byte(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME)))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte failed in ioctl als_calibrate\n");
+        return;
+    }
+    
+    reg_val = i2c_smbus_read_byte(taos_datap->client);
+
+    sat_als = (256 - reg_val) << 10;
+}
+
+static int taos_als_gain_set(unsigned als_gain)
+{
+    int ret;
+    prox_gain_param = (prox_gain_param & 0xFC) | als_gain;
+    gain_param      = prox_gain_param & 0x03;
+
+    if (NULL!=taos_cfgp)
+    {
+        taos_cfgp->gain      = gain_param;
+        taos_cfgp->prox_gain = prox_gain_param;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) 
+        {
+            SENSOR_LOG_ERROR("failed to write the prox_led_strength reg\n");
+            return -EINVAL;
+        }
+    }
+    else
+    {
+        SENSOR_LOG_ERROR("taos_cfgp is NULL\n");        
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static void taos_als_poll_work_func(struct work_struct *work)
+{
+
+	   	 taos_als_get_data();
+		schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(als_poll_time_mul*als_poll_delay));
+
+}
+
+static void taos_prox_calibrate_work_func(struct work_struct *work)
+{
+
+		taos_prox_calibrate();
+	
+}
+
+static enum hrtimer_restart  taos_prox_unwakelock_work_func(struct hrtimer *timer)
+{	 
+	SENSOR_LOG_INFO("######## taos_prox_unwakelock_timer_func #########\n");
+	if(false == taos_datap->irq_work_status )
+	taos_wakelock_ops(&(taos_datap->proximity_wakelock),false);
+	return HRTIMER_NORESTART;
+	
+}
+
+static int taos_sensors_als_poll_on(void) 
+{
+    int  ret = 0, i = 0;
+    u8   reg_val = 0, reg_cntrl = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS ON #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {
+        lux_history[i] = -ENODATA;
+    }
+
+    if (taos_datap->prox_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_ALS_TIME), taos_cfgp->prox_int_time))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+            return (ret);
+        }
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN));
+
+    //SENSOR_LOG_INFO("reg[0x0F] = 0x%02X\n",reg_val);
+
+    reg_val = reg_val & 0xFC;
+    reg_val = reg_val | (taos_cfgp->gain & 0x03);//*16
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_GAIN), reg_val))) < 0)
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+    reg_cntrl = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+    SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_cntrl);
+
+    reg_cntrl |= (TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_PWRON);
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_on\n");
+        return (ret);
+    }
+
+	schedule_delayed_work(&taos_datap->als_poll_work, msecs_to_jiffies(200));
+
+    flag_just_open_light = true;
+
+    taos_datap->als_on = true;
+
+    taos_update_sat_als();
+
+	return ret;
+}	
+
+static int taos_sensors_als_poll_off(void)
+{
+    int  ret = 0, i = 0;
+    u8  reg_val = 0;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL ALS OFF #########\n");
+
+    for (i = 0; i < TAOS_FILTER_DEPTH; i++)
+    {   
+        lux_history[i] = -ENODATA;
+    }
+
+    reg_val = i2c_smbus_read_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL));
+
+    //SENSOR_LOG_INFO("reg[0x00] = 0x%02X\n",reg_val);
+
+    if ((reg_val & TAOS_TRITON_CNTL_PROX_DET_ENBL) == 0x00 && (0 == taos_datap->prox_on)) 
+    {        
+        SENSOR_LOG_INFO("TAOS_TRITON_CNTL_PROX_DET_ENBL = 0\n");
+        reg_val = 0x00;
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_val))) < 0) 
+        {
+           printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+           return (ret);
+        }
+
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|TAOS_TRITON_ALS_TIME), 0XFF))) < 0) 
+    {
+       printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+       return (ret);
+    }
+
+    taos_datap->als_on = false;
+
+    cancel_delayed_work_sync(&taos_datap->als_poll_work);
+
+    taos_update_sat_als();
+
+    return (ret);
+}
+
+static int taos_prox_on(void)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    int  ret = 0;
+    u8 reg_cntrl = 0, i = 0 ,j = 0;
+
+    taos_datap->prox_on = 1;
+    als_poll_time_mul = 2;
+
+    SENSOR_LOG_INFO("######## TAOS IOCTL PROX ON  ######## \n");
+
+    if (true==taos_datap->als_on)
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), TAOS_ALS_ADC_TIME_WHEN_PROX_ON))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), 0XFF))) < 0) 
+        {
+            printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+            return (ret);
+        }
+    }
+
+    taos_update_sat_als();
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0C), taos_cfgp->prox_intr_filter))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0) {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+    reg_cntrl = TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON    | TAOS_TRITON_CNTL_PROX_INT_ENBL | 
+		                                         TAOS_TRITON_CNTL_ADC_ENBL | TAOS_TRITON_CNTL_WAIT_TMR_ENBL  ;
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+	pro_ft = true;
+    if (taos_datap->prox_calibrate_flag)
+    {
+        prox_sum = 0;
+        prox_max = 0;
+
+        mdelay(20);
+        for (i = 0, j = 0; i < 5; i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {
+                j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            mdelay(20);
+        }
+
+        prox_mean = prox_sum/5;
+        if (j==0)
+        {
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+110;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+35;
+
+            printk("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+            printk("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+            if( prox_mean >800 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+            {
+                taos_cfgp->prox_threshold_hi= 800;
+                taos_cfgp->prox_threshold_lo =750;
+            }
+
+            if(taos_cfgp->prox_threshold_hi < 200)
+            {
+            	taos_cfgp->prox_threshold_hi = 200;
+            	taos_cfgp->prox_threshold_lo = 150;	
+            }
+
+            input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+            input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+            input_sync(taos_datap->p_idev);
+    	}
+    }
+    taos_prox_threshold_set();   
+    taos_irq_ops(true, true);
+    return (ret);
+}
+
+
+static int taos_prox_off(void)
+{    
+    int ret = 0;
+    SENSOR_LOG_INFO("########  TAOS IOCTL PROX OFF  ########\n");
+
+    if (true == (taos_datap->proximity_wakelock).locked)
+    {      
+    	  hrtimer_cancel(&taos_datap->prox_unwakelock_timer);
+        taos_wakelock_ops(&(taos_datap->proximity_wakelock), false);
+    }
+
+    if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), 0x00))) < 0) 
+    {
+        printk(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl als_off\n");
+        return (ret);
+    }
+
+    taos_datap->prox_on = 0;
+    als_poll_time_mul = 1;
+
+	if (true == taos_datap->als_on) 
+    {
+        taos_sensors_als_poll_on();
+	}
+
+   // cancel_work_sync(&taos_datap->irq_work);
+    if (true == taos_datap->irq_enabled)
+    {
+        taos_irq_ops(false, true);
+    }
+
+
+    return (ret);
+}
+
+
+static int taos_prox_calibrate(void)
+{  
+    int ret;
+    int prox_sum = 0, prox_mean = 0, prox_max = 0;
+    u8 reg_cntrl = 0;
+    u8 reg_val = 0;
+    int i = 0, j = 0;
+    
+    struct taos_prox_info *prox_cal_info = NULL;
+        prox_cal_info = kmalloc(sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times), GFP_KERNEL); 
+        if (NULL == prox_cal_info)
+        {
+            SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+            ret = -1;
+            goto prox_calibrate_error1;
+        }
+        memset(prox_cal_info, 0, sizeof(struct taos_prox_info) * (taos_datap->prox_calibrate_times));
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x01), taos_cfgp->prox_int_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_int_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x02), taos_cfgp->prox_adc_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_adc_time reg\n");
+            goto prox_calibrate_error;
+        }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x03), taos_cfgp->prox_wait_time))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_wait_time reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0D), taos_cfgp->prox_config))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_config reg\n");
+            goto prox_calibrate_error;
+        }
+
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0E), taos_cfgp->prox_pulse_cnt))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_pulse_cnt reg\n");
+            goto prox_calibrate_error;
+        }
+	 if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x1E), taos_cfgp->prox_config_offset))) < 0) {
+        SENSOR_LOG_ERROR(KERN_ERR "TAOS: i2c_smbus_write_byte_data failed in ioctl prox_on\n");
+        return (ret);
+    }
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|0x0F), taos_cfgp->prox_gain))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write prox_gain reg\n");
+            goto prox_calibrate_error;
+        }
+
+        reg_cntrl = reg_val | (TAOS_TRITON_CNTL_PROX_DET_ENBL | TAOS_TRITON_CNTL_PWRON | TAOS_TRITON_CNTL_ADC_ENBL);
+        if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG | TAOS_TRITON_CNTRL), reg_cntrl))) < 0)
+        {
+           SENSOR_LOG_ERROR("failed write cntrl reg\n");
+           goto prox_calibrate_error;
+        }
+
+        prox_sum = 0;
+        prox_max = 0;   
+        mdelay(30);
+        for (i = 0; i < (taos_datap->prox_calibrate_times); i++) 
+        {
+            if ((ret = taos_prox_poll(&prox_cal_info[i])) < 0)
+            {  
+            	   j++;
+                printk(KERN_ERR "TAOS: call to prox_poll failed in ioctl prox_calibrate\n");
+            }
+            prox_sum += prox_cal_info[i].prox_data;
+            if (prox_cal_info[i].prox_data > prox_max)
+                prox_max = prox_cal_info[i].prox_data;
+            SENSOR_LOG_ERROR("prox get time %d data is %d",i,prox_cal_info[i].prox_data);
+            mdelay(30);
+        }
+
+        prox_mean = prox_sum/(taos_datap->prox_calibrate_times);
+	    if(j == 0)
+	 	{
+            taos_cfgp->prox_threshold_hi = ((((prox_max - prox_mean) * prox_calibrate_hi_param) + 50)/100) + prox_mean+120;
+            taos_cfgp->prox_threshold_lo = ((((prox_max - prox_mean) * prox_calibrate_lo_param) + 50)/100) + prox_mean+40;
+	 	}
+
+		if( prox_mean >700 || taos_cfgp->prox_threshold_hi > 1000 || taos_cfgp->prox_threshold_lo > 900)
+			{
+			 taos_cfgp->prox_threshold_hi = prox_threshold_hi_param;
+			taos_cfgp->prox_threshold_lo = prox_threshold_lo_param;	
+			prox_config_offset_param=0x0;
+			taos_cfgp->prox_config_offset = prox_config_offset_param;
+			}
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_hi = %d\n",taos_cfgp->prox_threshold_hi );
+        SENSOR_LOG_ERROR("TAOS:------------ taos_cfgp->prox_threshold_lo = %d\n",taos_cfgp->prox_threshold_lo );
+     
+        for (i = 0; i < sizeof(taos_triton_reg_init); i++)
+        {
+            if(i !=11)
+            {
+                if ((ret = (i2c_smbus_write_byte_data(taos_datap->client, (TAOS_TRITON_CMD_REG|(TAOS_TRITON_CNTRL +i)), taos_triton_reg_init[i]))) < 0)
+                {
+                    SENSOR_LOG_ERROR("failed write triton_init reg\n");
+                               goto prox_calibrate_error;
+
+                }
+             }
+         }
+
+        input_report_rel(taos_datap->p_idev, REL_Y, taos_cfgp->prox_threshold_hi);
+        input_report_rel(taos_datap->p_idev, REL_Z, taos_cfgp->prox_threshold_lo);
+        input_sync(taos_datap->p_idev);
+	 kfree(prox_cal_info);
+	return 1;
+prox_calibrate_error:
+    SENSOR_LOG_ERROR("exit\n");
+	 kfree(prox_cal_info);
+prox_calibrate_error1:
+
+	return -1;
+    }
+
+
+MODULE_AUTHOR("John Koshi - Surya Software");
+MODULE_DESCRIPTION("TAOS ambient light and proximity sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(taos_init);
+module_exit(taos_exit);
+
diff --git a/drivers/hwmon/tmg399x.c b/drivers/hwmon/tmg399x.c
new file mode 100644
index 0000000..a1e1f1a
--- /dev/null
+++ b/drivers/hwmon/tmg399x.c
@@ -0,0 +1,4526 @@
+/*
+ * Device driver for monitoring ambient light intensity in (lux)
+ * proximity detection (prox), and Gesture functionality within the
+ * AMS-TAOS TMG3992/3.
+ *
+ * Copyright (c) 2013, AMS-TAOS USA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/mutex.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/i2c/tmg399x.h>
+#include <mach/irqs.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/hrtimer.h>
+
+#define LOG_TAG "SENSOR_ALS_PROX_GES"
+#define DEBUG_ON //DEBUG SWITCH
+
+#define SENSOR_LOG_FILE__ strrchr(__FILE__, '/') ? (strrchr(__FILE__, '/')+1) : __FILE__
+
+#ifdef  CONFIG_FEATURE_ZTEMT_SENSORS_LOG_ON
+#define SENSOR_LOG_ERROR(fmt, args...) printk(KERN_ERR   "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #ifdef  DEBUG_ON
+#define SENSOR_LOG_INFO(fmt, args...)  printk(KERN_INFO  "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+                                              
+#define SENSOR_LOG_DEBUG(fmt, args...) printk(KERN_DEBUG "[%s] [%s: %d] "  fmt,\
+                                              LOG_TAG,__FUNCTION__, __LINE__, ##args)
+    #else
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+    #endif
+
+#else
+#define SENSOR_LOG_ERROR(fmt, args...)
+#define SENSOR_LOG_INFO(fmt, args...)
+#define SENSOR_LOG_DEBUG(fmt, args...)
+#endif
+
+#define CAL_THRESHOLD   "/persist/proxdata/threshold"
+
+
+static u8 const tmg399x_ids[] = {
+	0x9C,
+	0x9E,
+	0x9F,
+    0XAA,
+};
+
+static char const *tmg399x_names[] = {
+	"tmg399x",
+	"tmg399x",
+	"tmg399x",
+    "tmg399x",
+};
+
+static u8 const restorable_regs[] = {
+	TMG399X_ALS_TIME,
+	TMG399X_WAIT_TIME,
+	TMG399X_PERSISTENCE,
+	TMG399X_CONFIG_1,
+	TMG399X_PRX_PULSE,
+	TMG399X_GAIN,
+	TMG399X_CONFIG_2,
+	TMG399X_PRX_OFFSET_NE,
+	TMG399X_PRX_OFFSET_SW,
+	TMG399X_CONFIG_3,
+};
+
+static u8 const prox_gains[] = {
+	1,
+	2,
+	4,
+	8
+};
+
+static u8 const als_gains[] = {
+	1,
+	4,
+	16,
+	64
+};
+
+static u8 const prox_pplens[] = {
+	4,
+	8,
+	16,
+	32
+};
+
+static u8 const led_drives[] = {
+	100,
+	50,
+	25,
+	12
+};
+
+static u16 const led_boosts[] = {
+	100,
+	150,
+	200,
+	300
+};
+
+static struct lux_segment segment_default[] = {
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+};
+
+static struct tmg399x_parameters param_default = {
+#if 0
+	.als_time = 0xEE, /* 50ms */
+	.als_gain = AGAIN_16,
+	.als_deltaP = 10,
+	.wait_time = 0xFF, /* 2.78ms */
+	.prox_th_low = 50,
+	.prox_th_high = 80,
+	.persist = PRX_PERSIST(1) | ALS_PERSIST(2),
+	.als_prox_cfg1 = 0x60,
+	.prox_pulse = PPLEN_4US | PRX_PULSE_CNT(8),
+	.prox_gain = PGAIN_1,
+	.ldrive = PDRIVE_100MA,
+	.als_prox_cfg2 = LEDBOOST_300 | 0x01,
+	.prox_offset_ne = 0,
+	.prox_offset_sw = 0,
+	.als_prox_cfg3 = 0,
+
+	.ges_entry_th = 0,
+	.ges_exit_th = 0,
+	.ges_cfg1 = FIFOTH_1 | GEXPERS_2,
+	.ges_cfg2 = GGAIN_4 | GLDRIVE_100 | GWTIME_6,
+	.ges_offset_n = 0,
+	.ges_offset_s = 0,
+	.ges_pulse = GPLEN_16US | GES_PULSE_CNT(2),
+	.ges_offset_w = 0,
+	.ges_offset_e = 0,
+	.ges_dimension = GBOTH_PAIR,
+#endif
+};
+
+static int __devinit tmg399x_probe(struct i2c_client *client, const struct i2c_device_id *idp);
+static int __devexit tmg399x_remove(struct i2c_client *client);
+static int tmg399x_suspend(struct device *dev);
+static int tmg399x_resume(struct device *dev);
+static int tmg399x_prox_calibrate(struct tmg399x_chip *chip);
+int tmg399x_read_cal_value(char *file_path);
+int tmg399x_write_cal_file(char *file_path,unsigned int value);
+static int tmg399x_get_id(struct tmg399x_chip *chip, u8 *id, u8 *rev);
+
+
+static const struct i2c_device_id tmg399x_idtable_id[] = {
+	{ "ams,ams-sensor", 0 },
+	{ },
+};
+
+static struct of_device_id of_tmg399x_idtable[] = {
+	{ .compatible = "ams,ams-sensor",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, tmg399x_idtable);
+
+static const struct dev_pm_ops tmg399x_pm_ops = {
+	.suspend = tmg399x_suspend,
+	.resume  = tmg399x_resume,
+};
+
+
+struct i2c_driver tmg399x_driver = {
+	.driver = {
+		.name = "ams-sensor",
+        .of_match_table = of_tmg399x_idtable,
+		.pm = &tmg399x_pm_ops,
+	},
+	.id_table = tmg399x_idtable_id,
+	.probe = tmg399x_probe,
+	.remove = __devexit_p(tmg399x_remove),
+};
+
+
+
+/**********************************  MARCO START ****************************************/
+
+#define	AMS_ALS_POLL_DELAY_FAST	         500
+#define	AMS_ALS_POLL_DELAY_SLOW	         1000
+#define AMS_ALS_ATIME_LONG               0xEE
+#define AMS_ALS_ATIME_SHORT              0xF8
+
+#define PROX_FAR                     0
+#define PROX_NEAR                    1
+#define PROX_UNKNOW                 -1
+/**********************************  MARCO  END  ****************************************/
+
+/**********************************  VARIABLE START ****************************************/
+
+struct tmg399x_chip *p_global_tmg399x_chip;
+
+static struct class         *proximity_class;
+static struct class         *light_class;
+static struct class         *gesture_class;
+
+
+static dev_t const tmg399x_proximity_dev_t = MKDEV(MISC_MAJOR, 245);
+static dev_t const tmg399x_light_dev_t     = MKDEV(MISC_MAJOR, 246);
+static dev_t const tmg399x_gesture_dev_t   = MKDEV(MISC_MAJOR, 247);
+
+
+wait_queue_head_t   gesture_drdy_wq;
+atomic_t            gesture_drdy;
+
+
+static unsigned char reg_addr = 0;
+
+/**********************************  VARIABLE END ****************************************/
+static int tmg399x_ges_enable(struct tmg399x_chip *chip, int on);
+static int tmg399x_get_prox(struct tmg399x_chip *chip);
+static void tmg399x_report_prox(struct tmg399x_chip *chip);
+
+
+
+static int board_tmg399x_init(void)
+{
+    SENSOR_LOG_INFO("\n");
+	return 0;
+}
+
+static int board_tmg399x_power(struct device *dev, enum tmg399x_pwr_state state)
+{
+    SENSOR_LOG_INFO("\n");
+	return 0;
+}
+
+static void board_tmg399x_teardown(struct device *dev)
+{
+    SENSOR_LOG_INFO("\n");
+}
+
+static const struct lux_segment tmg399x_segment[] = {
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+	{
+		.d_factor = D_Factor1,
+		.r_coef = R_Coef1,
+		.g_coef = G_Coef1,
+		.b_coef = B_Coef1,
+		.ct_coef = CT_Coef1,
+		.ct_offset = CT_Offset1,
+	},
+};
+
+struct tmg399x_i2c_platform_data tmg399x_data = {
+	.platform_power = board_tmg399x_power,
+	.platform_init = board_tmg399x_init,
+	.platform_teardown = board_tmg399x_teardown,
+	.prox_name = "proximity",
+	.als_name = "light",
+    .ges_name = "gesture",
+	.parameters = {
+		.als_time = 0xEE, /* 50ms */
+		.als_gain = AGAIN_16,
+		.als_deltaP = 10,
+		.wait_time = 0xF6, //10* 2.78ms 
+		.prox_th_low = 120,
+		.prox_th_high = 150,
+		.persist = PRX_PERSIST(1) | ALS_PERSIST(2),
+		.als_prox_cfg1 = 0x60,
+		.prox_pulse = PPLEN_16US | PRX_PULSE_CNT(1),
+		.prox_gain = PGAIN_4,
+		.ldrive = PDRIVE_100MA,
+        .als_prox_cfg2 = LEDBOOST_300 | 0x01,
+		.prox_offset_ne = 0,
+		.prox_offset_sw = 0,
+		.als_prox_cfg3 = 0,
+		
+		.ges_entry_th = 0,
+		.ges_exit_th = 0,
+		.ges_cfg1 = FIFOTH_4| GEXPERS_1,
+		.ges_cfg2 = GGAIN_4 | GLDRIVE_100 | GWTIME_3,
+		.ges_offset_n = 30,
+		.ges_offset_s = 0,
+		.ges_pulse = GPLEN_32US | GES_PULSE_CNT(2),
+		.ges_offset_w = 0,
+		.ges_offset_e = 0,
+		.ges_dimension = GBOTH_PAIR,
+	},
+	.als_can_wake = false,
+	.proximity_can_wake = true,
+	.segment = (struct lux_segment *) tmg399x_segment,
+	.segment_num = ARRAY_SIZE(tmg399x_segment),
+
+};
+
+static int tmg399x_i2c_read(struct tmg399x_chip *chip, u8 reg, u8 *val)
+{
+	int ret;
+
+	s32 read;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret = i2c_smbus_write_byte(client, reg);
+	if (ret < 0) {
+		mdelay(3);
+		ret = i2c_smbus_write_byte(client, reg);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s: failed 2x to write register %x\n",
+				__func__, reg);
+		return ret;
+		}
+	}
+	read = i2c_smbus_read_byte(client);
+	if (read < 0) {
+		mdelay(3);
+		read = i2c_smbus_read_byte(client);
+		if (read < 0) {
+			dev_err(&client->dev, "%s: failed read from register %x\n",
+				__func__, reg);
+		}
+		return ret;
+	}
+
+	*val = (u8)read;
+	return 0;
+}
+
+static int tmg399x_i2c_write(struct tmg399x_chip *chip, u8 reg, u8 val)
+{
+	int ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		mdelay(3);
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s: failed to write register %x err= %d\n",
+				__func__, reg, ret);
+		}
+	}
+
+	return ret;
+}
+
+static int tmg399x_i2c_modify(struct tmg399x_chip *chip, u8 reg, u8 mask, u8 val)
+{
+	int ret;
+	u8 temp;
+    
+	ret = tmg399x_i2c_read(chip, reg, &temp);
+	temp &= ~mask;
+	temp |= val;
+	ret |= tmg399x_i2c_write(chip, reg, temp);
+
+	return ret;
+}
+
+static int tmg399x_i2c_reg_blk_write(struct tmg399x_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret =  i2c_smbus_write_i2c_block_data(client,
+			reg, size, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed 2X at address %x (%d bytes)\n",
+				__func__, reg, size);
+	}
+
+	return ret;
+}
+
+static int tmg399x_i2c_ram_blk_read(struct tmg399x_chip *chip,
+		u8 reg, u8 *val, int size)
+{
+	s32 ret;
+	struct i2c_client *client = chip->client;
+
+	reg += I2C_ADDR_OFFSET;
+	ret =  i2c_smbus_read_i2c_block_data(client,
+			reg, size, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed 2X at address %x (%d bytes)\n",
+				__func__, reg, size);
+	}
+
+	return ret;
+}
+
+static int tmg399x_flush_regs(struct tmg399x_chip *chip)
+{
+	unsigned i;
+	int ret;
+	u8 reg;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(restorable_regs); i++) {
+		reg = restorable_regs[i];
+		ret = tmg399x_i2c_write(chip, reg, chip->shadow[reg]);
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "%s: err on reg 0x%02x\n",
+					__func__, reg);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void tmg399x_wakelock_ops(struct tmg399x_wake_lock *wakelock, bool enable)
+{
+    if (enable == wakelock->locked)
+    {
+        SENSOR_LOG_INFO("doubule %s %s, retern here\n",enable? "lock" : "unlock",wakelock->name);
+        return;
+    }
+
+    if (enable)
+    {
+        wake_lock(&wakelock->lock);
+    }
+    else
+    {
+        wake_unlock(&wakelock->lock);
+    }
+
+    wakelock->locked = enable;
+
+    SENSOR_LOG_INFO("%s %s \n",enable? "lock" : "unlock",wakelock->name);
+}
+
+
+static void tmg399x_chip_data_init(struct tmg399x_chip *chip)
+{
+    chip->light_debug_enable      = false;
+    chip->prox_debug_enable       = false;
+    chip->ges_debug_enable        = false;
+    chip->prx_enabled             = false;
+    chip->als_enabled             = false;
+    chip->ges_enabled             = false;
+    chip->prox_calibrate_result   = false;
+    chip->prox_data_max           = 255;
+    chip->prox_manual_calibrate_threshold = 0;
+    chip->prox_thres_hi_max       = 200;
+    chip->prox_thres_lo_min       = 100;
+    chip->prox_calibrate_times    = 0;
+    chip->chip_name               = "tmg3993";
+    chip->wakeup_from_sleep       = false;
+    chip->wakelock_locked         = false;
+    chip->irq_enabled             = true;
+    chip->gesture_start           = false;
+    chip->prox_calibrate_start    = false;
+    chip->phone_is_sleep          = false;
+    chip->irq_work_status         = false;
+    chip->proximity_wakelock.name = "proximity-wakelock";
+    chip->proximity_wakelock.locked = false;
+    chip->light_poll_time         = AMS_ALS_POLL_DELAY_SLOW;
+}
+
+static void tmg399x_irq_enable(bool enable, bool flag_sync)
+{
+    if (enable == p_global_tmg399x_chip->irq_enabled)
+    {
+        SENSOR_LOG_INFO("doubule %s irq, retern here\n",enable? "enable" : "disable");
+        return;
+    }
+
+    if (enable)
+    {
+        enable_irq(p_global_tmg399x_chip->client->irq);
+    }
+    else
+    {
+        if (flag_sync)
+        {
+            disable_irq(p_global_tmg399x_chip->client->irq);
+
+        }
+        else
+        {
+            disable_irq_nosync(p_global_tmg399x_chip->client->irq);
+        }
+    }
+
+    p_global_tmg399x_chip->irq_enabled  = enable;
+    //SENSOR_LOG_INFO("%s irq \n",enable? "enable" : "disable");
+}
+
+
+static int tmg399x_irq_clr(struct tmg399x_chip *chip, u8 int2clr)
+{
+	int ret, ret2;
+    
+	ret = i2c_smbus_write_byte(chip->client, int2clr);
+
+	if (ret < 0) {
+		mdelay(3);
+		ret2 = i2c_smbus_write_byte(chip->client, int2clr);
+		if (ret2 < 0) {
+			dev_err(&chip->client->dev, "%s: failed 2x, int to clr %02x\n",
+					__func__, int2clr);
+		}
+		return ret2;
+	}
+	return ret;
+}
+
+static int tmg399x_update_enable_reg(struct tmg399x_chip *chip)
+{
+	int ret;
+	
+    SENSOR_LOG_INFO("\n");
+
+	//mutex_lock(&chip->lock);
+	ret  = tmg399x_i2c_write(chip, TMG399X_CONTROL, chip->shadow[TMG399X_CONTROL]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_4, chip->shadow[TMG399X_GES_CFG_4]);
+    SENSOR_LOG_INFO("TMG399X_CONTROL   = %X\n",chip->shadow[TMG399X_CONTROL]);
+    SENSOR_LOG_INFO("TMG399X_GES_CFG_4 = %X\n",chip->shadow[TMG399X_GES_CFG_4]);
+
+	//mutex_unlock(&chip->lock);
+	
+    SENSOR_LOG_INFO("\n");
+	return ret;
+}
+
+static int tmg399x_set_als_gain(struct tmg399x_chip *chip, int gain)
+{
+	int ret;
+	u8 ctrl_reg  = chip->shadow[TMG399X_GAIN] & ~TMG399X_ALS_GAIN_MASK;
+
+	switch (gain) {
+	case 1:
+		ctrl_reg |= AGAIN_1;
+		break;
+	case 4:
+		ctrl_reg |= AGAIN_4;
+		break;
+	case 16:
+		ctrl_reg |= AGAIN_16;
+		break;
+	case 64:
+		ctrl_reg |= AGAIN_64;
+		break;
+	default:
+		break;
+	}
+    
+    SENSOR_LOG_INFO("TMG399X_ALS_AGL_MASK = %d\n",TMG399X_ALS_AGL_MASK);
+
+
+	//mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_GAIN, ctrl_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GAIN] = ctrl_reg;
+		chip->params.als_gain = ctrl_reg & TMG399X_ALS_GAIN_MASK;
+	}
+	return ret;
+}
+
+static void tmg399x_calc_cpl(struct tmg399x_chip *chip)
+{
+	u32 cpl;
+	u32 sat;
+	u8 atime = chip->shadow[TMG399X_ALS_TIME];
+
+	cpl = 256 - chip->shadow[TMG399X_ALS_TIME];
+	cpl *= TMG399X_ATIME_PER_100;
+	cpl /= 100;
+	cpl *= als_gains[chip->params.als_gain];
+
+    //SENSOR_LOG_INFO("chip->params.als_gain = %d\n",chip->params.als_gain);
+
+	sat = min_t(u32, MAX_ALS_VALUE, (u32)(256 - atime) << 10);
+	sat = sat * 8 / 10;
+	chip->als_inf.cpl = cpl;
+	chip->als_inf.saturation = sat;
+}
+
+static int tmg399x_get_lux(struct tmg399x_chip *chip)
+{
+	u32 rp1, gp1, bp1, cp1;
+	u32 lux = 0;
+	u32 cct;
+	u32 sat;
+	u32 sf;
+    bool lux_is_too_low = false;
+
+
+	/* use time in ms get scaling factor */
+	tmg399x_calc_cpl(chip);
+	sat = chip->als_inf.saturation;
+
+	if (!chip->als_gain_auto) 
+    {
+		if (chip->als_inf.clear_raw <= MIN_ALS_VALUE) 
+        {
+            SENSOR_LOG_INFO("darkness\n");
+			lux = 0;
+			goto exit;
+		} 
+        else
+        {
+            if (chip->als_inf.clear_raw >= sat) 
+            {
+                SENSOR_LOG_INFO("saturation, keep lux & cct, sat = %d\n",sat);
+			    lux = chip->als_inf.lux;
+			    goto exit;
+		    }
+        }
+	} 
+    else
+    {
+		u8 gain = als_gains[chip->params.als_gain];
+		int ret = -EIO;
+
+
+        //SENSOR_LOG_INFO("gain = %d, sat = %d, clear_raw = %d\n",gain,sat,chip->als_inf.clear_raw);
+
+		if (gain == 16 && chip->als_inf.clear_raw >= sat) 
+        {
+			ret = tmg399x_set_als_gain(chip, 1);
+		}   
+        else
+        { 
+            if (gain == 16 && chip->als_inf.clear_raw < GAIN_SWITCH_LEVEL) 
+            {
+			    ret = tmg399x_set_als_gain(chip, 64);
+		    } 
+            else 
+            {
+                if ((gain == 64 &&
+			        chip->als_inf.clear_raw >= (sat - GAIN_SWITCH_LEVEL)) ||
+			        (gain == 1 && chip->als_inf.clear_raw < GAIN_SWITCH_LEVEL)) 
+                {
+    			    ret = tmg399x_set_als_gain(chip, 16);
+    		    }
+            }
+        }
+
+		if (!ret) 
+        {
+            SENSOR_LOG_INFO("gain adjusted, skip\n");
+			tmg399x_calc_cpl(chip);
+			ret = -EAGAIN;
+			lux = chip->als_inf.lux;
+			goto exit;
+		}
+
+		if (chip->als_inf.clear_raw <= MIN_ALS_VALUE)
+        {
+            //SENSOR_LOG_INFO("darkness\n");
+			lux = 0;
+			goto exit;
+		} 
+        else
+        { 
+            if (chip->als_inf.clear_raw >= sat)
+            {
+                SENSOR_LOG_INFO("saturation, keep lux, sat = %d\n",sat);
+			    lux = chip->als_inf.lux;
+			    goto exit;
+		    }
+        }
+	}
+
+	/* remove ir from counts*/
+	rp1 = chip->als_inf.red_raw   - chip->als_inf.ir;
+	gp1 = chip->als_inf.green_raw - chip->als_inf.ir;
+	bp1 = chip->als_inf.blue_raw  - chip->als_inf.ir;
+	cp1 = chip->als_inf.clear_raw - chip->als_inf.ir;
+
+    
+    if (0==rp1)
+    {
+        //SENSOR_LOG_INFO("!!!!!!!!! rp1 =0\n");
+        rp1 = 1;
+        lux_is_too_low = true;
+    }
+    else
+    {        
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {    
+            SENSOR_LOG_INFO("rp1 = %d\n",rp1);
+        }
+    }
+    
+    /*
+    SENSOR_LOG_INFO("chip->als_inf.red_raw   = %d\n",chip->als_inf.red_raw);
+    SENSOR_LOG_INFO("chip->als_inf.green_raw = %d\n",chip->als_inf.green_raw);
+    SENSOR_LOG_INFO("chip->als_inf.blue_raw  = %d\n",chip->als_inf.blue_raw);
+    SENSOR_LOG_INFO("chip->als_inf.clear_raw = %d\n",chip->als_inf.clear_raw);
+    SENSOR_LOG_INFO("lux = %d\n",lux);
+    */
+
+    //SENSOR_LOG_INFO("lux = %d\n",lux);
+
+
+	if (!chip->als_inf.cpl) 
+    {
+    	SENSOR_LOG_ERROR("zero cpl. Setting to 1\n");
+
+		chip->als_inf.cpl = 1;
+	}
+
+	if (chip->als_inf.red_raw > chip->als_inf.ir)
+    {
+		lux += chip->segment[chip->device_index].r_coef * rp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, r_coef = %d\n",lux,chip->segment[chip->device_index].r_coef);
+        }
+    }
+	else
+    {
+    	//SENSOR_LOG_ERROR("lux rp1 = %d\n",(chip->segment[chip->device_index].r_coef * rp1));
+    }
+
+	if (chip->als_inf.green_raw > chip->als_inf.ir)
+    {
+		lux += chip->segment[chip->device_index].g_coef * gp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, g_coef = %d\n",lux,chip->segment[chip->device_index].g_coef);
+        }
+    }
+	else
+	{	
+    	//SENSOR_LOG_ERROR("lux gp1 = %d\n",(chip->segment[chip->device_index].g_coef * rp1));
+    }
+
+	if (chip->als_inf.blue_raw > chip->als_inf.ir)
+	{
+    	lux -= chip->segment[chip->device_index].b_coef * bp1;
+        if (p_global_tmg399x_chip->light_debug_enable)
+        {  
+            //SENSOR_LOG_INFO("lux = %d, b_coef = %d\n",lux,chip->segment[chip->device_index].b_coef);
+	    }
+    }
+    else
+	{
+    	//SENSOR_LOG_ERROR("lux bp1 = %d\n",(chip->segment[chip->device_index].b_coef * rp1));
+    }
+
+    if (lux<0)
+    {
+        SENSOR_LOG_INFO("lux<0\n");
+        lux = 0;
+    }
+
+	sf = chip->als_inf.cpl;
+
+	if (sf > 131072)
+		goto error;
+
+    //SENSOR_LOG_INFO("sf = %d\n",sf);
+
+	lux /= sf;
+	lux *= chip->segment[chip->device_index].d_factor;
+	lux += 500;
+	lux /= 1000;
+	chip->als_inf.lux = (u16) lux;
+
+
+	cct = ((chip->segment[chip->device_index].ct_coef * bp1) / rp1) + chip->segment[chip->device_index].ct_offset;
+
+	chip->als_inf.cct = (u16) cct;
+
+    if (true == lux_is_too_low)
+    {
+        chip->als_inf.lux = 0;
+        lux_is_too_low = false;
+    }
+
+exit:
+return 0;
+
+error:
+	dev_err(&chip->client->dev, "ERROR Scale factor = %d", sf);
+
+return 1;
+
+}
+
+
+
+static int tmg399x_resume(struct device *dev)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int ret = 0;
+	mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+	if(true == chip->prx_enabled)
+    {
+        SENSOR_LOG_INFO( "disable irq wakeup\n");
+		ret = disable_irq_wake(chip->client->irq);
+	}
+    if(ret < 0)
+    {
+		SENSOR_LOG_INFO("disable_irq_wake failed\n");
+    }
+    SENSOR_LOG_INFO("eixt\n");
+	mutex_unlock(&chip->lock);
+    return ret ;
+}
+
+//suspend  
+static int tmg399x_suspend(struct device *dev)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int ret = 0;
+	mutex_lock(&chip->lock);
+    SENSOR_LOG_INFO("enter\n");
+	 tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+	if(true == chip->prx_enabled)
+    {  
+        SENSOR_LOG_INFO( "enable irq wakeup\n");
+       	ret = enable_irq_wake(chip->client->irq);
+        chip->wakeup_from_sleep = true;
+    }
+	if(ret < 0)
+    {
+		SENSOR_LOG_INFO("enable_irq_wake failed\n");
+    }
+
+    SENSOR_LOG_INFO("eixt\n");
+	mutex_unlock(&chip->lock);
+    return ret ;
+}
+
+static u8 tmg399x_get_ges(struct tmg399x_chip *chip)
+{
+	u8 gstatus = 0;
+	u8 buffer[512];
+    u8 gesflvl = 0;
+    int i = 0;
+    int j = 0;
+    
+	//mutex_lock(&chip->lock);
+
+	tmg399x_i2c_read(chip, TMG399X_GES_FLVL, &gesflvl);
+
+    
+    if (chip->ges_debug_enable)
+    {
+        SENSOR_LOG_ERROR("gesflvl = %d\n",gesflvl);
+    }
+
+    if (gesflvl>0)
+    {
+        if (gesflvl>8)
+        {
+            gesflvl = 8;
+        }
+
+        tmg399x_i2c_read(chip, TMG399X_GES_STAT, &gstatus);
+        
+        //SENSOR_LOG_INFO("gstatus = %d\n",gstatus);
+
+    	if ( (gstatus & TMG399X_GES_ST_MASK) == TMG399X_GES_VALID)
+        {
+            tmg399x_i2c_ram_blk_read(chip, TMG399X_GES_NFIFO, buffer, 4 * gesflvl);
+
+            j += 4;
+
+            for(i=0; i<(gesflvl-1); i++)
+            {
+                chip->gesture_data[i].north = buffer[j + 0];
+                chip->gesture_data[i].south = buffer[j + 1];
+                chip->gesture_data[i].west  = buffer[j + 2];
+                chip->gesture_data[i].east  = buffer[j + 3];
+                j += 4;
+
+                if (chip->ges_debug_enable)
+                {
+                    SENSOR_LOG_ERROR("%4d, %4d, %4d, %4d\n",
+                                                       chip->gesture_data[i].north,
+                                                       chip->gesture_data[i].south,
+                                                       chip->gesture_data[i].west,
+                                                       chip->gesture_data[i].east);   
+                }
+            }
+
+            if (true == chip->prx_enabled)
+            {
+                i--;
+                chip->shadow[TMG399X_PRX_CHAN] = (chip->gesture_data[i].east  + 
+                                                  chip->gesture_data[i].west  + 
+                                                  chip->gesture_data[i].north +
+                                                  chip->gesture_data[i].south)/4;
+
+
+                //chip->shadow[TMG399X_PRX_CHAN] = (chip->shadow[TMG399X_PRX_CHAN] * 6) / 10;
+
+                //SENSOR_LOG_INFO("chip->shadow[TMG399X_PRX_CHAN] = %d\n",chip->shadow[TMG399X_PRX_CHAN]);
+
+                if (tmg399x_get_prox(chip))
+                {
+                    tmg399x_report_prox(chip);
+                }
+            }
+        }
+        else
+        {
+            SENSOR_LOG_ERROR("over flow !!!\n");
+            gesflvl = 0;
+        }
+    }
+    else
+    {
+        //SENSOR_LOG_INFO("fifi data overflow!\n");
+  
+        //tmg399x_i2c_modify(chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+        /*
+        tmg399x_ges_enable(chip, 0);
+        tmg399x_ges_enable(chip, 1);
+        */
+
+        gesflvl = 0;
+
+    }
+
+    return ((gesflvl-1) >= 0)? (gesflvl-1) : 0;
+
+    //mutex_unlock(&chip->lock);
+
+}
+
+static int tmg399x_get_prox(struct tmg399x_chip *chip)
+{
+    int ret = 0;
+	chip->prx_inf.raw = chip->shadow[TMG399X_PRX_CHAN];
+
+    if (chip->prox_debug_enable || chip->prox_calibrate_start)
+    {
+        SENSOR_LOG_ERROR("state = %d, data = %d, hi = %d, low = %d\n",
+                                                                     chip->prx_inf.detected,
+                                                                     chip->prx_inf.raw,
+                                                                     chip->params.prox_th_high,
+                                                                     chip->params.prox_th_low);
+        if (chip->prox_calibrate_start)
+        {
+            ret = 1;
+        }
+    }
+    else
+    {
+        if (chip->prx_inf.detected == PROX_UNKNOW)
+        {
+            if (chip->prx_inf.raw >= chip->params.prox_th_high) 
+            {
+                SENSOR_LOG_INFO("NEAR!\n");
+                chip->prx_inf.detected = PROX_NEAR;
+                chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+                chip->shadow[TMG399X_PRX_THRES_HIGH] = 0xff;
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                ret = 1;
+            }
+            else
+            {
+                SENSOR_LOG_INFO("FAR!\n");
+                chip->prx_inf.detected = PROX_FAR;
+                chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                ret = 1;  
+            }
+         }
+         else
+         {
+            if (chip->prx_inf.detected == PROX_FAR) 
+            {
+                if (chip->prx_inf.raw >= chip->shadow[TMG399X_PRX_THRES_HIGH]) 
+                {
+                    SENSOR_LOG_INFO("NEAR!\n");
+                    chip->prx_inf.detected = PROX_NEAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = 0xff;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+                    ret = 1;
+                }
+            }
+            else 
+            {
+                if (chip->prx_inf.raw <= chip->shadow[TMG399X_PRX_THRES_LOW]) 
+                {
+                    SENSOR_LOG_INFO("FAR!\n");
+                    chip->prx_inf.detected = PROX_FAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]); 
+                    ret = 1;
+                }
+                /*
+                else
+                {
+                    SENSOR_LOG_INFO("FAR!\n");
+                    chip->prx_inf.detected = PROX_FAR;
+                    chip->shadow[TMG399X_PRX_THRES_LOW] = 0x00;
+                    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+                    tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]); 
+                }
+                */
+            }
+         }
+    }
+
+    
+   //SENSOR_LOG_INFO("HIGH = %d, LOW = %d\n",chip->shadow[TMG399X_PRX_THRES_HIGH],chip->shadow[TMG399X_PRX_THRES_LOW]);
+
+    return ret;
+}
+
+static void tmg399x_get_als(struct tmg399x_chip *chip)
+{
+	u8 *buf = &chip->shadow[TMG399X_CLR_CHANLO];
+
+	/* extract raw channel data */
+	chip->als_inf.clear_raw = le16_to_cpup((const __le16 *)&buf[0]);
+	chip->als_inf.red_raw   = le16_to_cpup((const __le16 *)&buf[2]);
+	chip->als_inf.green_raw = le16_to_cpup((const __le16 *)&buf[4]);
+	chip->als_inf.blue_raw  = le16_to_cpup((const __le16 *)&buf[6]);
+	chip->als_inf.ir =
+		(chip->als_inf.red_raw + chip->als_inf.green_raw +
+		chip->als_inf.blue_raw - chip->als_inf.clear_raw + 1) >> 1;
+	if (chip->als_inf.ir < 0)
+		chip->als_inf.ir = 0;
+}
+
+static int tmg399x_read_all(struct tmg399x_chip *chip)
+{
+	int ret;
+
+	//mutex_lock(&chip->lock);
+	
+	tmg399x_i2c_read(chip, TMG399X_STATUS,
+			&chip->shadow[TMG399X_STATUS]);
+
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANLO,
+			&chip->shadow[TMG399X_CLR_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANHI,
+			&chip->shadow[TMG399X_CLR_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANLO,
+			&chip->shadow[TMG399X_RED_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANHI,
+			&chip->shadow[TMG399X_RED_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANLO,
+			&chip->shadow[TMG399X_GRN_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANHI,
+			&chip->shadow[TMG399X_GRN_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANLO,
+			&chip->shadow[TMG399X_BLU_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANHI,
+			&chip->shadow[TMG399X_BLU_CHANHI]);
+
+	ret = tmg399x_i2c_read(chip, TMG399X_PRX_CHAN,
+			&chip->shadow[TMG399X_PRX_CHAN]);
+
+	//mutex_unlock(&chip->lock);
+	return (ret < 0) ? ret : 0;
+}
+
+/*
+static int tmg399x_read_status(struct tmg399x_chip *chip)
+{
+	int ret = 0;
+    
+	//mutex_lock(&chip->lock);
+
+    ret = tmg399x_i2c_read(chip, TMG399X_STATUS, &chip->shadow[TMG399X_STATUS]);
+
+	//mutex_unlock(&chip->lock);
+
+	return (ret < 0) ? ret : 0;
+}
+*/
+
+static int tmg399x_read_prox_data(struct tmg399x_chip *chip)
+{
+	int ret = 0;
+    ret = tmg399x_i2c_read(chip, TMG399X_PRX_CHAN, &chip->shadow[TMG399X_PRX_CHAN]);
+	return (ret < 0) ? ret : 0;
+}
+
+static int tmg399x_read_rgb_data(struct tmg399x_chip *chip)
+{
+    
+	//mutex_lock(&chip->lock);
+
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANLO, &chip->shadow[TMG399X_CLR_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_CLR_CHANHI, &chip->shadow[TMG399X_CLR_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANLO, &chip->shadow[TMG399X_RED_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_RED_CHANHI, &chip->shadow[TMG399X_RED_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANLO, &chip->shadow[TMG399X_GRN_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_GRN_CHANHI, &chip->shadow[TMG399X_GRN_CHANHI]);
+
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANLO, &chip->shadow[TMG399X_BLU_CHANLO]);
+	tmg399x_i2c_read(chip, TMG399X_BLU_CHANHI, &chip->shadow[TMG399X_BLU_CHANHI]);
+
+	//mutex_unlock(&chip->lock);
+
+	return 0;
+}
+
+static void tmg399x_als_atime_set(u8 time)
+{
+	p_global_tmg399x_chip->shadow[TMG399X_ALS_TIME] = time;
+	p_global_tmg399x_chip->params.als_time = time;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_ALS_TIME, p_global_tmg399x_chip->shadow[TMG399X_ALS_TIME]);
+}
+
+static int tmg399x_update_als_thres(struct tmg399x_chip *chip, bool on_enable)
+{
+	s32 ret;
+	u8 *buf = &chip->shadow[TMG399X_ALS_MINTHRESHLO];
+	u16 deltaP = chip->params.als_deltaP;
+	u16 from, to, cur;
+	u16 saturation = chip->als_inf.saturation;
+
+	cur = chip->als_inf.clear_raw;
+
+	if (on_enable) {
+		/* move deltaP far away from current position to force an irq */
+		from = to = cur > saturation / 2 ? 0 : saturation;
+	} else {
+		deltaP = cur * deltaP / 100;
+		if (!deltaP)
+			deltaP = 1;
+
+		if (cur > deltaP)
+			from = cur - deltaP;
+		else
+			from = 0;
+
+		if (cur < (saturation - deltaP))
+			to = cur + deltaP;
+		else
+			to = saturation;
+
+	}
+
+	*buf++ = from & 0xff;
+	*buf++ = from >> 8;
+	*buf++ = to & 0xff;
+	*buf++ = to >> 8;
+	ret = tmg399x_i2c_reg_blk_write(chip, TMG399X_ALS_MINTHRESHLO,
+			&chip->shadow[TMG399X_ALS_MINTHRESHLO],
+			TMG399X_ALS_MAXTHRESHHI - TMG399X_ALS_MINTHRESHLO + 1);
+
+	return (ret < 0) ? ret : 0;
+}
+
+static int tmg399x_ges_init(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+	
+	if (on) 
+    {
+		if (chip->pdata) 
+        {
+			chip->params.ges_entry_th = chip->pdata->parameters.ges_entry_th;
+			chip->params.ges_exit_th = chip->pdata->parameters.ges_exit_th;
+			chip->params.ges_cfg1 = chip->pdata->parameters.ges_cfg1;
+			chip->params.ges_cfg2 = chip->pdata->parameters.ges_cfg2;
+			chip->params.ges_offset_n = chip->pdata->parameters.ges_offset_n;
+			chip->params.ges_offset_s = chip->pdata->parameters.ges_offset_s;
+			chip->params.ges_pulse = chip->pdata->parameters.ges_pulse;
+			chip->params.ges_offset_w = chip->pdata->parameters.ges_offset_w;
+			chip->params.ges_offset_e = chip->pdata->parameters.ges_offset_e;
+			chip->params.ges_dimension = chip->pdata->parameters.ges_dimension;
+		} 
+        else 
+        {
+			chip->params.ges_entry_th = param_default.ges_entry_th;
+			chip->params.ges_exit_th = param_default.ges_exit_th;
+			chip->params.ges_cfg1 = param_default.ges_cfg1;
+			chip->params.ges_cfg2 = param_default.ges_cfg2;
+			chip->params.ges_offset_n = param_default.ges_offset_n;
+			chip->params.ges_offset_s = param_default.ges_offset_s;
+			chip->params.ges_pulse = param_default.ges_pulse;
+			chip->params.ges_offset_w = param_default.ges_offset_w;
+			chip->params.ges_offset_e = param_default.ges_offset_e;
+			chip->params.ges_dimension = param_default.ges_dimension;
+		}
+	}
+    else 
+    {
+		chip->params.ges_entry_th = 0;
+		chip->params.ges_exit_th = 0;
+		chip->params.ges_cfg1 = 0;
+		chip->params.ges_cfg2 = 0;
+		chip->params.ges_offset_n = 0;
+		chip->params.ges_offset_s = 0;
+		chip->params.ges_pulse = 0;
+		chip->params.ges_offset_w = 0;
+		chip->params.ges_offset_e = 0;
+		chip->params.ges_dimension = 0;	
+	}
+
+	/* Initial gesture registers */
+	chip->shadow[TMG399X_GES_ENTH]  = chip->params.ges_entry_th;
+	chip->shadow[TMG399X_GES_EXTH]  = chip->params.ges_exit_th;
+	chip->shadow[TMG399X_GES_CFG_1] = chip->params.ges_cfg1;
+	chip->shadow[TMG399X_GES_CFG_2] = chip->params.ges_cfg2;
+	chip->shadow[TMG399X_GES_OFFSET_N] = chip->params.ges_offset_n;
+	chip->shadow[TMG399X_GES_OFFSET_S] = chip->params.ges_offset_s;
+	chip->shadow[TMG399X_GES_PULSE] = chip->params.ges_pulse;
+	chip->shadow[TMG399X_GES_OFFSET_W] = chip->params.ges_offset_w;
+	chip->shadow[TMG399X_GES_OFFSET_E] = chip->params.ges_offset_e;
+	chip->shadow[TMG399X_GES_CFG_3] = chip->params.ges_dimension;
+	
+	ret  = tmg399x_i2c_write(chip, TMG399X_GES_ENTH,     chip->shadow[TMG399X_GES_ENTH]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_EXTH,     chip->shadow[TMG399X_GES_EXTH]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_1,    chip->shadow[TMG399X_GES_CFG_1]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_2,    chip->shadow[TMG399X_GES_CFG_2]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, chip->shadow[TMG399X_GES_OFFSET_N]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, chip->shadow[TMG399X_GES_OFFSET_S]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_PULSE,    chip->shadow[TMG399X_GES_PULSE]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, chip->shadow[TMG399X_GES_OFFSET_W]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, chip->shadow[TMG399X_GES_OFFSET_E]);
+	ret |= tmg399x_i2c_write(chip, TMG399X_GES_CFG_3,    chip->shadow[TMG399X_GES_CFG_3]);
+
+	return ret;
+}
+
+static int tmg399x_ges_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret = 0;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+	if (on) 
+    {
+		/* initialize */		
+		ret |= tmg399x_ges_init(chip, 1);		
+		if (ret < 0)
+        {
+            SENSOR_LOG_INFO("tmg399x_ges_init failed!\n");
+			return ret;
+        }
+        
+        chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX | TMG399X_EN_GES);
+	    chip->shadow[TMG399X_CONTROL] &=(~(TMG399X_EN_WAIT));
+		chip->shadow[TMG399X_GES_CFG_4] |= (TMG399X_GES_EN_IRQ | TMG399X_GES_MODE);
+		ret |= tmg399x_update_enable_reg(chip);
+		
+		mdelay(3);
+
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+        tmg399x_irq_enable(true, true);
+
+	} 
+    else 
+    {
+        if (false == chip->prx_enabled)
+        {                        
+            chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+            tmg399x_als_atime_set(AMS_ALS_ATIME_LONG);
+            tmg399x_irq_enable(false, true);
+        }
+
+		chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_GES;
+
+        if ((false == chip->prx_enabled) && (false == chip->als_enabled))
+        {
+			chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_PWR_ON;
+        }
+		chip->shadow[TMG399X_GES_CFG_4] &= ~(TMG399X_GES_EN_IRQ | TMG399X_GES_MODE);
+
+		ret = tmg399x_update_enable_reg(chip);
+        
+		/* deinitialize */		
+		ret |= tmg399x_ges_init(chip, 0);
+		if (ret)
+        {
+            SENSOR_LOG_INFO("tmg399x_ges_init failed!\n");
+			return ret;
+        }
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	return ret;
+}
+
+static int tmg399x_prox_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+
+	if (on) 
+    {
+		tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+
+        tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW,  0x01);
+        tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, 0x01);
+
+		chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX | TMG399X_EN_PRX_IRQ | TMG399X_EN_WAIT);
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+    
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+
+        chip->prx_inf.detected = PROX_UNKNOW;
+        tmg399x_irq_enable(true, true);
+	} 
+    else 
+    {
+        if (true == (chip->proximity_wakelock).locked)
+        {
+            tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+        }
+
+
+        if (false == chip->ges_enabled)
+        {
+            chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+            tmg399x_als_atime_set(AMS_ALS_ATIME_LONG);
+            tmg399x_irq_enable(false, true);
+        }
+
+        chip->shadow[TMG399X_CONTROL] &= ~(TMG399X_EN_PRX_IRQ | TMG399X_EN_PRX);
+
+        if ((false == chip->als_enabled) && (false == chip->ges_enabled))
+        {            
+            chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_PWR_ON;
+        }
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+        chip->prx_inf.detected = PROX_UNKNOW;
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	return ret;
+}
+
+static int tmg399x_als_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+    SENSOR_LOG_INFO("on = %d\n",on);
+
+	if (on) 
+    {
+        chip->als_enabled = true;
+		tmg399x_irq_clr(chip, TMG399X_CMD_ALS_INT_CLR);
+		tmg399x_update_als_thres(chip, 1);
+		chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_ALS /*| TMG399X_EN_ALS_IRQ*/);
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+        schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(chip->light_poll_time));
+	}
+    else
+    {
+        chip->als_enabled = false;
+		//chip->shadow[TMG399X_CONTROL] &= ~(TMG399X_EN_ALS_IRQ);
+
+        if ((false == chip->prx_enabled) && (false == chip->ges_enabled))
+        {
+             chip->shadow[TMG399X_CONTROL] &= ~ (TMG399X_EN_ALS | TMG399X_EN_PWR_ON);
+        }     
+
+		ret = tmg399x_update_enable_reg(chip);
+
+		if (ret < 0)
+			return ret;
+		tmg399x_irq_clr(chip, TMG399X_CMD_ALS_INT_CLR);
+        //cancel_delayed_work_sync(&p_global_tmg399x_chip->als_poll_work);
+	}
+
+    SENSOR_LOG_INFO("chip->shadow[TMG399X_CONTROL] = %X\n",chip->shadow[TMG399X_CONTROL]);
+
+	if (!ret)
+		chip->als_enabled = on;
+
+	return ret;
+}
+
+static int tmg399x_wait_enable(struct tmg399x_chip *chip, int on)
+{
+	int ret;
+
+	dev_info(&chip->client->dev, "%s: on = %d\n", __func__, on);
+	if (on) {
+		chip->shadow[TMG399X_CONTROL] |= TMG399X_EN_WAIT;
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+		mdelay(3);
+	} else {
+		chip->shadow[TMG399X_CONTROL] &= ~TMG399X_EN_WAIT;
+
+		ret = tmg399x_update_enable_reg(chip);
+		if (ret < 0)
+			return ret;
+	}
+	if (!ret)
+	        chip->wait_enabled = on;
+
+	return ret;
+}
+
+static ssize_t tmg399x_ges_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->ges_enabled);
+}
+
+static ssize_t tmg399x_ges_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+    chip->ges_enabled = (value>0) ? true : false;
+
+	if (value)
+    {
+        if (false==chip->prx_enabled)
+        {
+		    tmg399x_ges_enable(chip, true);
+        }
+	}
+    else
+    {   
+		tmg399x_ges_enable(chip, false);
+        chip->gesture_start = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_enabled);
+}
+
+static ssize_t tmg399x_prox_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+    chip->prx_enabled = (value>0) ? true : false;
+
+	if (value)
+    {
+        if (true == chip->ges_enabled)
+        {
+            tmg399x_ges_enable(chip, false);
+        }
+
+		tmg399x_prox_enable(chip, true);
+    }
+	else
+    {
+		tmg399x_prox_enable(chip, false);
+
+        if (true == chip->ges_enabled)
+        {
+            tmg399x_ges_enable(chip, true);
+        }
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_als_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_enabled);
+}
+
+static ssize_t tmg399x_als_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+		tmg399x_als_enable(chip, true);
+	}
+    else
+    {
+		tmg399x_als_enable(chip, false);
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_light_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "light_debug_enable is %s\n", chip->light_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_light_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->light_debug_enable = true;
+	}
+    else
+    {
+        chip->light_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "prox_debug_enable is %s\n", chip->prox_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_prox_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->prox_debug_enable = true;
+	}
+    else
+    {
+        chip->prox_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_calibrate_result_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_calibrate_result);
+}
+
+static ssize_t tmg399x_chip_name_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n", chip->chip_name);
+}
+
+static ssize_t tmg399x_prox_thres_hi_max(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_thres_hi_max);
+}
+
+static ssize_t tmg399x_prox_thres_lo_min(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_thres_lo_min);
+}
+
+static ssize_t tmg399x_prox_data_max(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_data_max);
+}
+static ssize_t tmg399x_manual_calibrate_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_manual_calibrate_threshold);
+}
+
+
+static ssize_t tmg399x_ges_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "ges_debug_enable is %s\n", chip->ges_debug_enable? "true":"false");
+}
+
+static ssize_t tmg399x_ges_debug_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+    mutex_lock(&chip->lock);
+
+	if (value)
+    {
+        chip->ges_debug_enable = true;
+	}
+    else
+    {
+        chip->ges_debug_enable = false;
+    }
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_wait_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->wait_enabled);
+}
+
+static ssize_t tmg399x_wait_enable_store(struct device *dev,
+                                struct device_attribute *attr,
+                                const char *buf, size_t size)
+{
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    bool value;
+
+    if (strtobool(buf, &value))
+            return -EINVAL;
+	mutex_lock(&chip->lock);
+
+    if (value)
+            tmg399x_wait_enable(chip, 1);
+    else
+            tmg399x_wait_enable(chip, 0);
+
+	mutex_unlock(&chip->lock);
+    return size;
+}
+
+static ssize_t tmg399x_als_itime_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int t;
+	t = 256 - chip->params.als_time;
+	t *= TMG399X_ATIME_PER_100;
+	t /= 100;
+	return snprintf(buf, PAGE_SIZE, "%d (in ms)\n", t);
+}
+
+static ssize_t tmg399x_als_itime_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long itime;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &itime);
+	if (rc)
+		return -EINVAL;
+	if (itime > 712 || itime < 3) {
+		dev_err(&chip->client->dev,
+			"als integration time range [3,712]\n");
+		return -EINVAL;
+	}
+
+	itime *= 100;
+	itime /= TMG399X_ATIME_PER_100;
+	itime = (256 - itime);
+   
+	mutex_lock(&chip->lock);
+	/*
+    chip->shadow[TMG399X_ALS_TIME] = (u8)itime;
+	chip->params.als_time = (u8)itime;
+	tmg399x_i2c_write(chip, TMG399X_ALS_TIME, chip->shadow[TMG399X_ALS_TIME]);
+	*/
+
+    tmg399x_als_atime_set((u8)itime);
+
+    mutex_unlock(&chip->lock);
+	
+    return size;
+}
+
+static ssize_t tmg399x_als_poll_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "delay is %d ms\n", chip->light_poll_time);
+}
+
+static ssize_t tmg399x_als_poll_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long time;
+	int rc;
+    struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+	rc = kstrtoul(buf, 10, &time);
+	if (rc)
+		return -EINVAL;
+    SENSOR_LOG_INFO("set delay to %d ms\n",(int)time);
+	chip->light_poll_time = (int)time;
+	return size;
+}
+
+
+static ssize_t tmg399x_wait_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int t;
+	t = 256 - chip->params.wait_time;
+	t *= TMG399X_ATIME_PER_100;
+	t /= 100;
+	if (chip->params.als_prox_cfg1 & WLONG)
+		t *= 12;
+	return snprintf(buf, PAGE_SIZE, "%d (in ms)\n", t);
+}
+
+static ssize_t tmg399x_wait_time_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long time;
+	int ret;
+	u8 cfg1;
+
+	ret = kstrtoul(buf, 10, &time);
+	if (ret) {
+		return -EINVAL;
+	}
+	if (time > 8540 || time < 3) {
+		dev_err(&chip->client->dev,
+			"wait time range [3,8540]\n");
+		return -EINVAL;
+	}
+	
+	cfg1 = chip->shadow[TMG399X_CONFIG_1] & ~0x02;
+	if (time > 712) {
+		cfg1 |= WLONG;
+		time /= 12;
+	}
+
+	time *= 100;
+	time /= TMG399X_ATIME_PER_100;
+	time = (256 - time);
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_WAIT_TIME] = (u8)time;
+	chip->params.wait_time = (u8)time;
+	chip->shadow[TMG399X_CONFIG_1] = cfg1;
+	chip->params.als_prox_cfg1 = cfg1;
+	tmg399x_i2c_write(chip, TMG399X_WAIT_TIME,
+		chip->shadow[TMG399X_WAIT_TIME]);
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_1,
+		chip->shadow[TMG399X_CONFIG_1]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_persist_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.persist & 0xF0) >> 4);
+}
+
+static ssize_t tmg399x_prox_persist_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long persist;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &persist);
+	if (ret) {
+		return -EINVAL;
+	}
+	
+	if (persist > 15) {
+		dev_err(&chip->client->dev,
+			"prox persistence range [0,15]\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PERSISTENCE] &= 0x0F;
+	chip->shadow[TMG399X_PERSISTENCE] |= (((u8)persist << 4) & 0xF0);
+	chip->params.persist = chip->shadow[TMG399X_PERSISTENCE];
+	tmg399x_i2c_write(chip, TMG399X_PERSISTENCE,
+		chip->shadow[TMG399X_PERSISTENCE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_persist_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.persist & 0x0F));
+}
+
+static ssize_t tmg399x_als_persist_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long persist;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &persist);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (persist > 15) {
+		dev_err(&chip->client->dev,
+			"als persistence range [0,15]\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PERSISTENCE] &= 0xF0;
+	chip->shadow[TMG399X_PERSISTENCE] |= ((u8)persist & 0x0F);
+	chip->params.persist = chip->shadow[TMG399X_PERSISTENCE];
+	tmg399x_i2c_write(chip, TMG399X_PERSISTENCE,
+		chip->shadow[TMG399X_PERSISTENCE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_pulse_len_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.prox_pulse & 0xC0) >> 6;
+	return snprintf(buf, PAGE_SIZE, "%duS\n", prox_pplens[i]);
+}
+
+static ssize_t tmg399x_prox_pulse_len_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long length;
+	int ret;
+	u8 ppulse;
+
+	ret = kstrtoul(buf, 10, &length);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (length != 4 && length != 8 &&
+		length != 16 &&	length != 32) {
+		dev_err(&chip->client->dev, 
+			"pulse length set: {4, 8, 16, 32}\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	ppulse = chip->shadow[TMG399X_PRX_PULSE] & 0x3F;
+	switch (length){
+	case 4:
+		ppulse |= PPLEN_4US;
+		break;
+	case 8:
+		ppulse |= PPLEN_8US;
+		break;
+	case 16:
+		ppulse |= PPLEN_16US;
+		break;
+	case 32:
+		ppulse |= PPLEN_32US;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_PRX_PULSE] = ppulse;
+	chip->params.prox_pulse = ppulse;
+	tmg399x_i2c_write(chip, TMG399X_PRX_PULSE,
+		chip->shadow[TMG399X_PRX_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_pulse_cnt_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.prox_pulse & 0x3F) + 1);
+}
+
+static ssize_t tmg399x_prox_pulse_cnt_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long count;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &count);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (count > 32 || count == 0) {
+		dev_err(&chip->client->dev,
+			"prox pulse count range [1,32]\n");
+		return -EINVAL;
+	}
+	count -= 1;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_PULSE] &= 0xC0;
+	chip->shadow[TMG399X_PRX_PULSE] |= ((u8)count & 0x3F);
+	chip->params.prox_pulse = chip->shadow[TMG399X_PRX_PULSE];
+	tmg399x_i2c_write(chip, TMG399X_PRX_PULSE,
+		chip->shadow[TMG399X_PRX_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+static ssize_t tmg399x_ges_pulse_cnt_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.ges_pulse & 0x3F) + 1);
+}
+
+static ssize_t tmg399x_ges_pulse_cnt_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long count;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &count);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (count > 32 || count == 0) {
+		dev_err(&chip->client->dev,
+			"prox pulse count range [1,32]\n");
+		return -EINVAL;
+	}
+	count -= 1;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_GES_PULSE] &= 0xC0;
+	chip->shadow[TMG399X_GES_PULSE] |= ((u8)count & 0x3F);
+	chip->params.ges_pulse = chip->shadow[TMG399X_GES_PULSE];
+	tmg399x_i2c_write(chip, TMG399X_GES_PULSE, chip->shadow[TMG399X_GES_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+
+static ssize_t tmg399x_ges_pulse_len_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.ges_pulse & 0xC0) >> 6;
+	return snprintf(buf, PAGE_SIZE, "%duS\n", prox_pplens[i]);
+}
+
+static ssize_t tmg399x_ges_pulse_len_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long length;
+	int ret;
+	u8 ppulse;
+
+	ret = kstrtoul(buf, 10, &length);
+	if (ret) {
+		return -EINVAL;
+	}
+
+	if (length != 4 && length != 8 &&
+		length != 16 &&	length != 32) {
+		dev_err(&chip->client->dev, 
+			"pulse length set: {4, 8, 16, 32}\n");
+		return -EINVAL;
+	}
+	
+	mutex_lock(&chip->lock);
+	ppulse = chip->shadow[TMG399X_GES_PULSE] & 0x3F;
+	switch (length){
+	case 4:
+		ppulse |= GPLEN_4US;
+		break;
+	case 8:
+		ppulse |= GPLEN_8US;
+		break;
+	case 16:
+		ppulse |= GPLEN_16US;
+		break;
+	case 32:
+		ppulse |= GPLEN_32US;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_GES_PULSE] = ppulse;
+	chip->params.ges_pulse = ppulse;
+	tmg399x_i2c_write(chip, TMG399X_GES_PULSE,
+		chip->shadow[TMG399X_GES_PULSE]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+static ssize_t tmg399x_ges_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = chip->params.ges_cfg2 >> 2;
+	return snprintf(buf, PAGE_SIZE, "%d\n", prox_gains[i]);
+}
+
+static ssize_t tmg399x_ges_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret)
+    {
+		return -EINVAL;
+    }
+	if (gain != 1 && gain != 2 && gain != 4 && gain != 8) {
+		dev_err(&chip->client->dev,
+			"prox gain set: {1, 2, 4, 8}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GES_CFG_2] & ~TMG399X_GES_GAIN_MASK;
+	switch (gain){
+	case 1:
+		ctrl_reg |= GGAIN_1;
+		break;
+	case 2:
+		ctrl_reg |= GGAIN_2;
+		break;
+	case 4:
+		ctrl_reg |= GGAIN_4;
+		break;
+	case 8:
+		ctrl_reg |= GGAIN_8;
+		break;
+	default:
+		break;
+	}
+
+	ret = tmg399x_i2c_write(chip, TMG399X_GES_CFG_2, ctrl_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GES_CFG_2] = ctrl_reg;
+		chip->params.ges_cfg2 = ctrl_reg & TMG399X_GES_GAIN_MASK;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+
+
+
+static ssize_t tmg399x_prox_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = chip->params.prox_gain >> 2;
+	return snprintf(buf, PAGE_SIZE, "%d\n", prox_gains[i]);
+}
+
+static ssize_t tmg399x_prox_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret)
+    {
+		return -EINVAL;
+    }
+	if (gain != 1 && gain != 2 && gain != 4 && gain != 8) {
+		dev_err(&chip->client->dev,
+			"prox gain set: {1, 2, 4, 8}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GAIN] & ~TMG399X_PRX_GAIN_MASK;
+	//cfg1_reg = chip->shadow[TMG399X_CONFIG_1] & ~0x80;
+	switch (gain){
+	case 1:
+		ctrl_reg |= PGAIN_1;
+		break;
+	case 2:
+		ctrl_reg |= PGAIN_2;
+		break;
+	case 4:
+		ctrl_reg |= PGAIN_4;
+		break;
+	case 8:
+		ctrl_reg |= PGAIN_8;
+		break;
+	default:
+		break;
+	}
+
+	ret = tmg399x_i2c_write(chip, TMG399X_GAIN, ctrl_reg);
+//	ret |= tmg399x_i2c_write(chip, TMG399X_CONFIG_1, cfg1_reg);
+	if (!ret) {
+		chip->shadow[TMG399X_GAIN] = ctrl_reg;
+		chip->params.prox_gain = ctrl_reg & TMG399X_PRX_GAIN_MASK;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+static ssize_t tmg399x_prox_led_drive_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%dmA\n",
+			led_drives[chip->params.ldrive]);
+}
+
+static ssize_t tmg399x_prox_led_drive_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long ldrive;
+	int ret;
+	u8 ctrl_reg;
+
+	ret = kstrtoul(buf, 10, &ldrive);
+	if (ret) 
+    {
+		return -EINVAL;
+    }
+	if (ldrive != 100 && ldrive != 50 &&
+		ldrive != 25 && ldrive != 12) {
+		dev_err(&chip->client->dev,
+			"led drive set: {100, 50, 25, 12}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	ctrl_reg = chip->shadow[TMG399X_GAIN] & ~TMG399X_LDRIVE_MASK;
+	switch (ldrive){
+	case 100:
+		ctrl_reg |= PDRIVE_100MA;
+		chip->params.ldrive = 0;
+		break;
+	case 50:
+		ctrl_reg |= PDRIVE_50MA;
+		chip->params.ldrive = 1;
+		break;
+	case 25:
+		ctrl_reg |= PDRIVE_25MA;
+		chip->params.ldrive = 2;
+		break;
+	case 12:
+		ctrl_reg |= PDRIVE_12MA;
+		chip->params.ldrive = 3;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_GAIN] = ctrl_reg;
+	tmg399x_i2c_write(chip, TMG399X_GAIN, chip->shadow[TMG399X_GAIN]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_gain_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d (%s)\n",
+			als_gains[chip->params.als_gain],
+			chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t tmg399x_als_gain_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long gain;
+	int i = 0;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &gain);
+	if (ret) 
+    {
+		return -EINVAL;
+	}	
+	if (gain != 0 && gain != 1 && gain != 4 &&
+		gain != 16 && gain != 64) {
+		dev_err(&chip->client->dev,
+			"als gain set: {0(auto), 1, 4, 16, 64}\n");
+		return -EINVAL;
+	}
+
+	while (i < sizeof(als_gains)) {
+		if (gain == als_gains[i])
+			break;
+		i++;
+	}
+
+	if (gain) {
+		chip->als_gain_auto = false;
+		ret = tmg399x_set_als_gain(chip, als_gains[i]);
+		if (!ret)
+			tmg399x_calc_cpl(chip);
+	} else {
+		chip->als_gain_auto = true;
+	}
+	mutex_unlock(&chip->lock);
+	return ret ? ret : size;
+}
+
+static ssize_t tmg399x_led_boost_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i = (chip->params.als_prox_cfg2 & 0x30) >> 4;
+	return snprintf(buf, PAGE_SIZE, "%d percents\n", led_boosts[i]);
+}
+
+static ssize_t tmg399x_led_boost_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long lboost;
+	int ret;
+	u8 cfg2;
+
+	ret = kstrtoul(buf, 10, &lboost);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (lboost != 100 && lboost != 150 &&
+		lboost != 200 && lboost != 300) {
+		dev_err(&chip->client->dev,
+			"led boost set: {100, 150, 200, 300}\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+	cfg2 = chip->shadow[TMG399X_CONFIG_2] & ~0x30;
+	switch (lboost){
+	case 100:
+		cfg2 |= LEDBOOST_100;
+		break;
+	case 150:
+		cfg2 |= LEDBOOST_150;
+		break;
+	case 200:
+		cfg2 |= LEDBOOST_200;
+		break;
+	case 300:
+		cfg2 |= LEDBOOST_300;
+		break;
+	default:
+		break;
+	}
+	chip->shadow[TMG399X_CONFIG_2] = cfg2;
+	chip->params.als_prox_cfg2 = cfg2;
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_2,
+		chip->shadow[TMG399X_CONFIG_2]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_sat_irq_en_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			(chip->params.als_prox_cfg2 & 0x80) >> 7);
+}
+
+static ssize_t tmg399x_sat_irq_en_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool psien;
+	int rc;
+
+	rc = strtobool(buf, &psien);
+	if (rc)
+		return -EINVAL;
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_CONFIG_2] &= 0x7F;
+	if (psien)
+		chip->shadow[TMG399X_CONFIG_2] |= PSIEN;
+	chip->params.als_prox_cfg2 = chip->shadow[TMG399X_CONFIG_2];
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_2, chip->shadow[TMG399X_CONFIG_2]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+static ssize_t tmg399x_prox_init_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int ret,err;
+	ret = kstrtol(buf, 10, &value);
+	if(ret)
+		return -EINVAL;
+	if (value==1)
+    {
+		mutex_lock(&chip->lock);
+    		if((ret=tmg399x_read_cal_value(CAL_THRESHOLD))<0)
+		{
+		SENSOR_LOG_ERROR("tmg399x_prox_init<0\n");
+		err=tmg399x_write_cal_file(CAL_THRESHOLD,0);
+			if(err<0)
+			{
+				SENSOR_LOG_ERROR("ERROR=%s\n",CAL_THRESHOLD);
+				mutex_unlock(&chip->lock);
+				return -EINVAL;
+			}
+		chip->prox_calibrate_times = 5;	
+	       schedule_delayed_work(&p_global_tmg399x_chip->prox_calibrate_work, msecs_to_jiffies(1000));
+		}
+		else if (ret==0){
+		chip->prox_calibrate_times = 5;	
+	       schedule_delayed_work(&p_global_tmg399x_chip->prox_calibrate_work, msecs_to_jiffies(1000));
+		SENSOR_LOG_ERROR("tmg399x_prox_calibrate==1\n");
+		}
+		else if(ret > 0){
+	      chip->prox_manual_calibrate_threshold = ret;
+            chip->params.prox_th_high = ret;
+            chip->params.prox_th_low  = ret - 20;
+		input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+		input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+		input_sync(chip->p_idev);
+		SENSOR_LOG_ERROR("tmg399x_prox_init> 0\n");
+		}
+		mutex_unlock(&chip->lock);
+	}
+	else {
+		SENSOR_LOG_ERROR("ERROR=tmg399x_prox_init_store\n");
+		return -EINVAL;
+	}
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+	return size;
+}
+
+static ssize_t tmg399x_prox_offset_ne_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			chip->params.prox_offset_ne);
+}
+
+static ssize_t tmg399x_prox_offset_ne_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset_ne;
+	int ret;
+	u8 offset = 0;
+
+	ret = kstrtol(buf, 10, &offset_ne);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (offset_ne > 127 || offset_ne < -127) {
+		dev_err(&chip->client->dev, "prox offset range [-127, 127]\n");
+		return -EINVAL;
+	}
+	if (offset_ne < 0)
+		offset = 128 - offset_ne;
+	else
+		offset = offset_ne;
+	mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_NE, offset);
+	if (!ret) {
+		chip->params.prox_offset_ne = (s8)offset_ne;
+		chip->shadow[TMG399X_PRX_OFFSET_NE] = offset;
+	}
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_offset_sw_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			chip->params.prox_offset_sw);
+}
+
+static ssize_t tmg399x_prox_offset_sw_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset_sw;
+	int ret;
+	u8 offset = 0;
+
+	ret = kstrtol(buf, 10, &offset_sw);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (offset_sw > 127 || offset_sw < -127) {
+		dev_err(&chip->client->dev, "prox offset range [-127, 127]\n");
+		return -EINVAL;
+	}
+	if (offset_sw < 0)
+		offset = 128 - offset_sw;
+	else
+		offset = offset_sw;
+	mutex_lock(&chip->lock);
+	ret = tmg399x_i2c_write(chip, TMG399X_PRX_OFFSET_SW, offset);
+	if (!ret) {
+		chip->params.prox_offset_sw = (s8)offset_sw;
+		chip->shadow[TMG399X_PRX_OFFSET_SW] = offset;
+	}
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_thres_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+	if (value==1){
+   		if( (rc=tmg399x_read_cal_value(CAL_THRESHOLD))<0)
+			return -EINVAL;
+		else{
+			mutex_lock(&chip->lock);
+				if(rc > 30){
+					chip->prox_manual_calibrate_threshold = rc;
+			             chip->params.prox_th_high = rc;
+			             chip->params.prox_th_low  = rc - 20;
+					input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+					input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+					input_sync(chip->p_idev);
+					mutex_unlock(&chip->lock);
+					SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+			    		SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+					}
+	 
+			}
+	}
+	else{		
+		return -EINVAL;
+	}
+	return size;
+}
+
+
+static ssize_t tmg399x_prox_thres_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+    SENSOR_LOG_ERROR("prox_th_high  = %d\n",chip->params.prox_th_high);
+    SENSOR_LOG_ERROR("prox_th_low   = %d\n",chip->params.prox_th_low);
+
+	return snprintf(buf, PAGE_SIZE, "prox_th_high  = %d, prox_th_low = %d\n", 
+                                                   chip->params.prox_th_high,
+                                                   chip->params.prox_th_low);
+}
+
+
+
+static ssize_t tmg399x_gesture_offset_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+    u8 ges_offset_N = 0;
+    u8 ges_offset_S = 0;
+    u8 ges_offset_W = 0;
+    u8 ges_offset_E = 0;
+
+	mutex_lock(&chip->lock);    
+
+
+        
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_N, &ges_offset_N);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_S, &ges_offset_S);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_W, &ges_offset_W);
+	tmg399x_i2c_read(chip, TMG399X_GES_OFFSET_E, &ges_offset_E);
+
+    SENSOR_LOG_INFO("N = %X\n", (unsigned int)ges_offset_N);
+    SENSOR_LOG_INFO("S = %X\n", (unsigned int)ges_offset_S);
+    SENSOR_LOG_INFO("W = %X\n", (unsigned int)ges_offset_W);
+    SENSOR_LOG_INFO("E = %X\n", (unsigned int)ges_offset_E);
+
+	mutex_unlock(&chip->lock);  
+
+	return sizeof(buf);
+
+//	return snprintf(buf, PAGE_SIZE, "%d\n", chip->params.prox_offset_sw);
+}
+
+//add by zhubing
+static ssize_t tmg399x_gesture_offset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	long offset;
+	int rc;
+    mutex_lock(&chip->lock);
+    SENSOR_LOG_ERROR("Enter!\n");
+	rc = kstrtol(buf, 10, &offset);
+	if (rc)
+		return -EINVAL;
+
+    SENSOR_LOG_ERROR("offset = %X\n", (unsigned int)offset);
+
+    switch( (offset>>8) & 0x0f)
+    {
+        case 1<<0: // E
+        {            
+            SENSOR_LOG_ERROR("Set E offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_E, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<1: // W
+        {
+            SENSOR_LOG_ERROR("Set W offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_W, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<2: // S
+        {
+            SENSOR_LOG_ERROR("Set S offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_S, (u8)(offset & 0xff));
+            break;
+        }
+
+        case 1<<3: // N
+        {
+            SENSOR_LOG_ERROR("Set N offset = %X\n", (u8)(offset & 0xff));
+            rc = tmg399x_i2c_write(chip, TMG399X_GES_OFFSET_N, (u8)(offset & 0xff));
+            break;
+        }
+
+        default:
+        {
+            
+            SENSOR_LOG_ERROR("error!\n");
+            break;
+        }
+    }
+
+    SENSOR_LOG_ERROR("Exit!\n");
+    mutex_unlock(&chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_gesture_data_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);    
+    u8 ret = 0;
+
+    wait_event_interruptible(gesture_drdy_wq, (atomic_read(&gesture_drdy) == 1));
+
+    mutex_lock(&chip->lock);
+
+    ret = tmg399x_get_ges(chip);
+    if (ret>0)
+    {
+        memcpy(buf, &(chip->gesture_data[0]), ret * sizeof(struct tmg399x_ges_raw_data));
+    }
+
+    tmg399x_i2c_modify(chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+    
+    atomic_set(&gesture_drdy, 0);
+
+    mutex_unlock(&chip->lock);
+
+	return (sizeof(struct tmg399x_ges_raw_data) * ret);
+}
+
+
+static ssize_t tmg399x_gesture_data_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    struct sGesture_Result Gesture_Result;
+
+    memcpy(&Gesture_Result, buf, sizeof(struct sGesture_Result));
+
+    input_report_rel(chip->g_idev, REL_RX,      Gesture_Result.gesture_style);
+    input_report_rel(chip->g_idev, REL_RY,      Gesture_Result.enter_time);
+    input_report_rel(chip->g_idev, REL_RZ,      Gesture_Result.exit_time);
+    input_report_rel(chip->g_idev, REL_HWHEEL,  Gesture_Result.enter_angle);
+    input_report_rel(chip->g_idev, REL_DIAL,    Gesture_Result.exit_angle);
+    input_sync(chip->g_idev);
+
+    if (true==chip->ges_debug_enable)
+    {
+        SENSOR_LOG_INFO("gesture_style = %d, enter_time = %ld, exit_time = %ld, enter_angle = %d, exit_angle = %d",
+                                                                                    Gesture_Result.gesture_style,
+                                                                                    Gesture_Result.enter_time,
+                                                                                    Gesture_Result.exit_time,
+                                                                                    Gesture_Result.enter_angle,
+                                                                                    Gesture_Result.exit_angle);
+    }
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_mask_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%.2x\n",
+			chip->params.als_prox_cfg3 & 0x0F);
+}
+
+static ssize_t tmg399x_prox_mask_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned long prx_mask;
+	int ret;
+
+	ret = kstrtol(buf, 10, &prx_mask);
+	if (ret) {
+		return -EINVAL;
+    }
+	if (prx_mask > 15) {
+		dev_err(&chip->client->dev, "prox mask range [0, 15]\n");
+		return -EINVAL;
+	}
+	if ((prx_mask >> 3) ^ ((prx_mask >> 2) & 0x01) ||
+		((prx_mask >> 1) & 0x01) ^ (prx_mask & 0x01))
+		prx_mask |= PCMP;
+
+	mutex_unlock(&chip->lock);
+	chip->shadow[TMG399X_CONFIG_3] &= 0xD0;
+	chip->shadow[TMG399X_CONFIG_3] |= (u8)prx_mask;
+	chip->params.als_prox_cfg3 = chip->shadow[TMG399X_CONFIG_3];
+	tmg399x_i2c_write(chip, TMG399X_CONFIG_3,
+		chip->shadow[TMG399X_CONFIG_3]);
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_device_prx_raw(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    mutex_lock(&chip->lock);
+    tmg399x_get_prox(chip);
+    mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.raw);
+}
+
+static ssize_t tmg399x_device_prx_detected(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    mutex_lock(&chip->lock);
+    tmg399x_get_prox(chip);
+    mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prx_inf.detected);
+}
+
+
+static ssize_t tmg399x_prox_calibrate_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    int ret = kstrtouint(buf, 10, &(chip->prox_calibrate_times));
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    tmg399x_prox_calibrate(chip);
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_calibrate_start_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        chip->prox_calibrate_start = true;
+        SENSOR_LOG_INFO("enable prox calibrate\n");
+    }
+    else
+    {
+        chip->prox_calibrate_start = false;
+        SENSOR_LOG_INFO("disable prox calibrate\n");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_calibrate_start_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("prox calibrate is %s\n",chip->prox_calibrate_start ? "enable" : "disable");
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->prox_calibrate_start);
+}
+
+
+static ssize_t tmg399x_phone_is_sleep_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv==chip->phone_is_sleep)
+    {
+        SENSOR_LOG_INFO("double %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    else
+    {        
+        chip->phone_is_sleep = recv;
+        SENSOR_LOG_INFO("success %s phone_is_sleep\n",recv? "enable" : "false");
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_phone_is_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("phone_is_sleep is %s\n",chip->phone_is_sleep? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "phone_is_sleep %s\n\n", chip->phone_is_sleep? "true" : "false");
+}
+
+static ssize_t tmg399x_prox_wakelock_store(struct device *dev, struct device_attribute *attr, 
+                                            const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	unsigned int recv;
+    int ret = kstrtouint(buf, 10, &recv);
+    if (ret) 
+    {
+        SENSOR_LOG_ERROR("input error\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&chip->lock);
+    if (recv)
+    {
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),true);
+    }
+    else
+    {
+        //cancel_delayed_work_sync(&p_global_tmg399x_chip->prox_unwakelock_work);
+        hrtimer_cancel(&p_global_tmg399x_chip->prox_unwakelock_timer);
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),false);
+    }
+    mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_prox_wakelock_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+    SENSOR_LOG_INFO("proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+	return snprintf(buf, PAGE_SIZE, "proximity_wakelock is %s\n",chip->proximity_wakelock.locked ? "true" : "false");
+}
+
+
+static ssize_t tmg399x_lux_table_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	struct lux_segment *s = chip->segment;
+	int i, k;
+
+	for (i = k = 0; i < chip->segment_num; i++)
+		k += snprintf(buf + k, PAGE_SIZE - k,
+				"%d:%d,%d,%d,%d,%d,%d\n", i,
+				s[i].d_factor,
+				s[i].r_coef,
+				s[i].g_coef,
+				s[i].b_coef,
+				s[i].ct_coef,
+				s[i].ct_offset
+				);
+	return k;
+}
+
+static ssize_t tmg399x_lux_table_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	int i;
+	u32 d_factor, r_coef, g_coef, b_coef, ct_coef, ct_offset;
+
+	if (7 != sscanf(buf, "%10d:%10d,%10d,%10d,%10d,%10d,%10d",
+		&i, &d_factor, &r_coef, &g_coef, &b_coef, &ct_coef, &ct_offset))
+		return -EINVAL;
+	if (i >= chip->segment_num)
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+	chip->segment[i].d_factor = d_factor;
+	chip->segment[i].r_coef = r_coef;
+	chip->segment[i].g_coef = g_coef;
+	chip->segment[i].b_coef = b_coef;
+	chip->segment[i].ct_coef = ct_coef;
+	chip->segment[i].ct_offset = ct_offset;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_als_deltaP_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE,
+			"%d (in %%)\n", chip->params.als_deltaP);
+}
+
+static ssize_t tmg399x_als_deltaP_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long deltaP;
+	int ret;
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+
+	ret = kstrtoul(buf, 10, &deltaP);
+	if (ret || deltaP > 100) 
+    {
+		return -EINVAL;
+    }
+	mutex_lock(&chip->lock);
+	chip->params.als_deltaP = deltaP;
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_auto_gain_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+				chip->als_gain_auto ? "auto" : "manual");
+}
+
+static ssize_t tmg399x_auto_gain_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	bool value;
+
+	if (strtobool(buf, &value))
+		return -EINVAL;
+	mutex_lock(&chip->lock);
+
+	if (value)
+		chip->als_gain_auto = true;
+	else
+		chip->als_gain_auto = false;
+
+	mutex_unlock(&chip->lock);
+	return size;
+}
+
+static ssize_t tmg399x_device_als_lux(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	mutex_lock(&chip->lock);
+	tmg399x_get_als(chip);
+	tmg399x_get_lux(chip);
+	mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.lux);
+}
+
+static ssize_t tmg399x_als_red_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+		{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.red_raw);
+}
+
+static ssize_t tmg399x_als_green_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.green_raw);
+}
+
+static ssize_t tmg399x_als_blue_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.blue_raw);
+}
+
+static ssize_t tmg399x_als_clear_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.clear_raw);
+}
+
+static ssize_t tmg399x_als_cct_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	mutex_lock(&chip->lock);
+	tmg399x_read_all(chip);
+	tmg399x_get_als(chip);
+	tmg399x_get_lux(chip);
+	mutex_unlock(&chip->lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", chip->als_inf.cct);
+}
+
+
+
+static ssize_t tmg399x_set_reg_addr(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+
+    reg_addr = val;
+
+    SENSOR_LOG_ERROR("exit\n");
+	return size;
+}
+
+static ssize_t tmg399x_get_reg_addr(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+   
+    SENSOR_LOG_ERROR("enter\n");
+    SENSOR_LOG_ERROR("reg_addr = 0x%02X\n",reg_addr);
+	return strlen(buf);
+    SENSOR_LOG_ERROR("exit\n");
+
+}
+
+
+static ssize_t tmg399x_set_reg_data(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+    int ret;
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("enter\n");
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (100==reg_addr)
+    {
+        SENSOR_LOG_ERROR("reg addr error!\n");
+    }
+    else
+    {
+        if ((ret = (i2c_smbus_write_byte_data(p_global_tmg399x_chip->client, reg_addr, val))) < 0)
+        {
+            SENSOR_LOG_ERROR("failed write reg\n");
+        }   
+    }
+
+    SENSOR_LOG_ERROR("exit\n");
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_reg_data(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    int i;
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (1 == reg_addr)
+    {
+        for (i=0x80; i<=0xFF; i++)
+        {
+            i2c_smbus_write_byte(p_global_tmg399x_chip->client, i);
+            SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",i,i2c_smbus_read_byte(p_global_tmg399x_chip->client));
+        }
+    }   
+    else
+    {
+        i2c_smbus_write_byte(p_global_tmg399x_chip->client, reg_addr);
+        SENSOR_LOG_ERROR("reg[0x%02X] = 0x%02X",reg_addr,i2c_smbus_read_byte(p_global_tmg399x_chip->client)); 
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return strlen(buf);
+}
+
+
+static ssize_t tmg399x_irq_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("irq_enabled  = %d\n",p_global_tmg399x_chip->irq_enabled );
+	return snprintf(buf, PAGE_SIZE, "irq_enabled  = %d\n",p_global_tmg399x_chip->irq_enabled );
+}
+
+static ssize_t tmg399x_irq_store(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val)
+    {
+        tmg399x_irq_enable(true, true);
+    }
+    else
+    {
+        tmg399x_irq_enable(false, true);
+    }
+ 
+	return size;
+}
+
+
+static ssize_t tmg399x_irq_clear(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (1==val)
+    {
+        SENSOR_LOG_ERROR("CLEAR ALS INT!\n");
+        tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_ALS_INT_CLR);
+    }
+    else
+    {
+        if (2==val)
+        {
+            SENSOR_LOG_ERROR("CLEAR PROX INT!\n");
+            tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_PROX_INT_CLR);
+        }
+        else
+        {
+            if (3==val)
+            {
+                SENSOR_LOG_ERROR("CLEAR GESTURE INT!\n");
+                tmg399x_i2c_modify(p_global_tmg399x_chip, TMG399X_GES_CFG_4, TMG399X_GES_INT_CLR, TMG399X_GES_INT_CLR);
+            }
+            else
+            {
+                if (4==val)
+                {
+                    SENSOR_LOG_ERROR("CLEAR ALL INT!\n");
+                    tmg399x_irq_clr(p_global_tmg399x_chip, TMG399X_CMD_NON_GES_INT_CLR);
+                }
+            }
+        }
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_set_ges_enter_thres(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    tmg399x_data.parameters.ges_entry_th = (val & 0xff);
+	p_global_tmg399x_chip->shadow[TMG399X_GES_ENTH]  = p_global_tmg399x_chip->params.ges_entry_th;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_ENTH, p_global_tmg399x_chip->shadow[TMG399X_GES_ENTH]);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_ges_enter_thres(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+    
+    SENSOR_LOG_ERROR("ges_entry_th = %d\n",tmg399x_data.parameters.ges_entry_th);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_set_ges_exit_thres(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    tmg399x_data.parameters.ges_exit_th = (val & 0xff);
+	p_global_tmg399x_chip->shadow[TMG399X_GES_EXTH]  = p_global_tmg399x_chip->params.ges_exit_th;
+	tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_EXTH, p_global_tmg399x_chip->shadow[TMG399X_GES_EXTH]);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return size;
+}
+
+
+static ssize_t tmg399x_get_ges_exit_thres(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+    SENSOR_LOG_ERROR("enter\n");
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+    
+    SENSOR_LOG_ERROR("ges_exit_th = %d\n",tmg399x_data.parameters.ges_exit_th);
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+    SENSOR_LOG_ERROR("exit\n");
+
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_set_ges_start(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+    unsigned long val;
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if (strict_strtoul(buf, 10, &val))
+    {
+        return -EINVAL;
+    }
+    
+    if (val)
+    {
+        p_global_tmg399x_chip->gesture_start = true;
+    }
+    else
+    {
+        p_global_tmg399x_chip->gesture_start = false;
+    }
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+
+	return size;
+}
+
+static ssize_t tmg399x_prox_threshold_high_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev); 
+
+	if (NULL!=chip)
+    {
+        return sprintf(buf, "%d", chip->params.prox_th_high);
+    }
+    else
+    {       
+        sprintf(buf, "chip->params.prox_th_high is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_prox_threshold_high_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+
+    chip->params.prox_th_high = (u8)(value&0xff);
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+    /*
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+	*/
+    mutex_unlock(&chip->lock);
+
+    SENSOR_LOG_ERROR("prox_th_high = %d\n",chip->params.prox_th_high);
+
+	return size;
+}
+
+
+
+static ssize_t tmg399x_prox_threshold_low_show(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev); 
+
+	if (NULL!=chip)
+    {
+        return sprintf(buf, "%d", chip->params.prox_th_low);
+    }
+    else
+    {       
+        sprintf(buf, "chip->params.prox_th_low is NULL\n");
+    }
+	return strlen(buf);
+}
+
+static ssize_t tmg399x_prox_threshold_low_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct tmg399x_chip *chip = dev_get_drvdata(dev);
+	static long value;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc)
+		return -EINVAL;
+
+    chip->params.prox_th_low = (u8)(value&0xff);
+
+	mutex_lock(&chip->lock);
+	chip->shadow[TMG399X_PRX_THRES_LOW] = chip->params.prox_th_low;
+    /*
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+	*/
+    mutex_unlock(&chip->lock);
+
+    SENSOR_LOG_ERROR("prox_th_low = %d\n",chip->params.prox_th_low);
+
+	return size;
+}
+
+
+
+static struct device_attribute attrs_prox[] = {
+    __ATTR(chip_name,                       0640,   tmg399x_chip_name_show,              NULL), 
+	__ATTR(enable,                          0640,   tmg399x_prox_enable_show,            tmg399x_prox_enable_store),
+	__ATTR(prox_init,                       0640,   NULL,                                tmg399x_prox_init_store),
+	__ATTR(prox_persist,                    0640,   tmg399x_prox_persist_show,           tmg399x_prox_persist_store),
+	__ATTR(prx_pulse_length,                0640,   tmg399x_prox_pulse_len_show,         tmg399x_prox_pulse_len_store),
+	__ATTR(prox_pulse_count,                0640,   tmg399x_prox_pulse_cnt_show,	     tmg399x_prox_pulse_cnt_store),
+	__ATTR(prox_gain,                       0640,   tmg399x_prox_gain_show,	             tmg399x_prox_gain_store),
+	__ATTR(prox_led_drive,                  0640,   tmg399x_prox_led_drive_show,         tmg399x_prox_led_drive_store),
+	__ATTR(prox_led_boost,                  0640,   tmg399x_led_boost_show,	             tmg399x_led_boost_store),
+	__ATTR(prox_sat_irq_en,                 0640,   tmg399x_sat_irq_en_show,             tmg399x_sat_irq_en_store),
+	__ATTR(prox_offset_ne,                  0640,   tmg399x_prox_offset_ne_show,         tmg399x_prox_offset_ne_store),
+	__ATTR(prox_offset_sw,                  0640,   tmg399x_prox_offset_sw_show,         tmg399x_prox_offset_sw_store),
+	__ATTR(prox_mask,                       0640,   tmg399x_prox_mask_show,              tmg399x_prox_mask_store),
+	__ATTR(prox_raw,                        0640,   tmg399x_device_prx_raw,              NULL),
+	__ATTR(prox_detect,                     0640,   tmg399x_device_prx_detected,         NULL),
+    __ATTR(prox_calibrate,                  0640,   NULL,                                tmg399x_prox_calibrate_store), 
+    __ATTR(prox_calibrate_start,            0640,   tmg399x_prox_calibrate_start_show,   tmg399x_prox_calibrate_start_store),
+    __ATTR(prox_calibrate_result,           0640,   tmg399x_prox_calibrate_result_show,  NULL), 
+    __ATTR(prox_thres,                      0640,   tmg399x_prox_thres_show,             tmg399x_prox_thres_store),
+    __ATTR(prox_debug,                      0640,   tmg399x_prox_debug_show,             tmg399x_prox_debug_store),
+    __ATTR(prox_phone_is_sleep,             0640,   tmg399x_phone_is_sleep_show,         tmg399x_phone_is_sleep_store),
+    __ATTR(prox_wakelock,                   0640,   tmg399x_prox_wakelock_show,          tmg399x_prox_wakelock_store),
+    __ATTR(prox_thres_max,                  0644,   tmg399x_prox_thres_hi_max,           NULL), 
+    __ATTR(prox_thres_min,                  0644,   tmg399x_prox_thres_lo_min,           NULL), 
+    __ATTR(prox_data_max,                   0640,   tmg399x_prox_data_max,               NULL),
+    __ATTR(prox_manual_calibrate_threshold, 0644,   tmg399x_manual_calibrate_threshold,               NULL), 
+    __ATTR(tmg_irq,                         0640,   tmg399x_irq_show,                    tmg399x_irq_store),
+    __ATTR(tmg_reg_addr,                    0640,   tmg399x_get_reg_addr,                tmg399x_set_reg_addr),
+    __ATTR(tmg_reg_data,                    0640,   tmg399x_get_reg_data,                tmg399x_set_reg_data),
+    __ATTR(tmg_clear_irq,                   0640,   NULL,                                tmg399x_irq_clear),
+    __ATTR(prox_threshold_high,             0644,   tmg399x_prox_threshold_high_show,    tmg399x_prox_threshold_high_store),
+    __ATTR(prox_threshold_low,              0644,   tmg399x_prox_threshold_low_show,     tmg399x_prox_threshold_low_store),
+};
+
+
+static struct device_attribute attrs_gesture[] = {
+    __ATTR(chip_name,                   0640,   tmg399x_chip_name_show,              NULL),
+	__ATTR(enable,                      0640,   tmg399x_ges_enable_show,             tmg399x_ges_enable_store),
+	__ATTR(gesture_pulse_length,        0640,   tmg399x_ges_pulse_len_show,          tmg399x_ges_pulse_len_store),
+	__ATTR(gesture_pulse_count,         0640,   tmg399x_ges_pulse_cnt_show,	         tmg399x_ges_pulse_cnt_store),
+	__ATTR(gesture_gain,                0640,   tmg399x_ges_gain_show,	             tmg399x_ges_gain_store),
+    __ATTR(gesture_data,                0640,   tmg399x_gesture_data_show,           tmg399x_gesture_data_store),
+    __ATTR(gesture_offset,              0640,   tmg399x_gesture_offset_show,         tmg399x_gesture_offset_store),
+    __ATTR(gesture_enter_thres,         0640,   tmg399x_get_ges_enter_thres,         tmg399x_set_ges_enter_thres),
+    __ATTR(gesture_exit_thres,          0640,   tmg399x_get_ges_exit_thres,          tmg399x_set_ges_exit_thres),
+    __ATTR(gesture_start_flag,          0640,   NULL,                                tmg399x_set_ges_start),
+    __ATTR(gesture_debug,               0640,   tmg399x_ges_debug_show,              tmg399x_ges_debug_store),
+    __ATTR(led_boost,                   0640,   tmg399x_led_boost_show,              tmg399x_led_boost_store),
+    __ATTR(reg_addr,                    0640,   tmg399x_get_reg_addr,                tmg399x_set_reg_addr),
+    __ATTR(reg_data,                    0640,   tmg399x_get_reg_data,                tmg399x_set_reg_data),
+    __ATTR(clear_irq,                   0640,   NULL,                                tmg399x_irq_clear),
+};
+
+
+static struct device_attribute attrs_light[] = {
+    __ATTR(chip_name,               0640,   tmg399x_chip_name_show,              NULL), 
+	__ATTR(enable,                  0640,   tmg399x_als_enable_show,             tmg399x_als_enable_store),
+    __ATTR(delay,                   0640,   tmg399x_als_poll_time_show,          tmg399x_als_poll_time_store),
+	__ATTR(light_wait_time_en,      0640,   tmg399x_wait_enable_show,            tmg399x_wait_enable_store),
+	__ATTR(light_Itime,             0640,   tmg399x_als_itime_show,              tmg399x_als_itime_store),
+	__ATTR(light_wait_time,         0640,   tmg399x_wait_time_show,              tmg399x_wait_time_store),
+	__ATTR(light_persist,           0640,   tmg399x_als_persist_show,            tmg399x_als_persist_store),
+	__ATTR(light_light_gain,        0640,   tmg399x_als_gain_show,               tmg399x_als_gain_store),
+	__ATTR(light_lux_table,         0640,   tmg399x_lux_table_show,              tmg399x_lux_table_store),
+	__ATTR(light_thresh_deltaP,     0640,   tmg399x_als_deltaP_show,             tmg399x_als_deltaP_store),
+	__ATTR(light_auto_gain,         0640,   tmg399x_auto_gain_enable_show,       tmg399x_auto_gain_enable_store),
+	__ATTR(light_lux,               0640,   tmg399x_device_als_lux,              NULL),
+	__ATTR(light_red,               0640,   tmg399x_als_red_show,                NULL),
+	__ATTR(light_green,             0640,   tmg399x_als_green_show,              NULL),
+	__ATTR(light_blue,              0640,   tmg399x_als_blue_show,               NULL),
+	__ATTR(light_clear,             0640,   tmg399x_als_clear_show,              NULL),
+	__ATTR(light_cct,               0640,   tmg399x_als_cct_show,                NULL),
+    __ATTR(light_debug,             0640,   tmg399x_light_debug_show,            tmg399x_light_debug_store),
+};
+
+int tmg399x_read_cal_value(char *file_path)
+{
+    struct file *file_p;
+    int vfs_read_retval = 0;
+    mm_segment_t old_fs; 
+    char read_buf[32];
+    unsigned short read_value;
+
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+        goto error;
+    }
+
+    memset(read_buf, 0, 32);
+
+    file_p = filp_open(file_path, O_RDONLY , 0);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_read_retval = vfs_read(file_p, (char*)read_buf, 16, &file_p->f_pos);
+    if (vfs_read_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[read file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+    if (kstrtou16(read_buf, 10, &read_value) < 0)
+    {
+        SENSOR_LOG_ERROR("[kstrtou16 %s failed]\n",read_buf);
+        goto error;
+    }
+    
+    SENSOR_LOG_ERROR("[the content of %s is %s]\n", file_path, read_buf);
+
+    return read_value;
+
+error:
+    return -1;
+}
+
+int tmg399x_write_cal_file(char *file_path,unsigned int value)
+{
+    struct file *file_p;
+    char write_buf[10];
+	 mm_segment_t old_fs; 
+    int vfs_write_retval=0;
+    if (NULL==file_path)
+    {
+        SENSOR_LOG_ERROR("file_path is NULL\n");
+      
+    }
+       memset(write_buf, 0, sizeof(write_buf));
+      sprintf(write_buf, "%d\n", value);
+    file_p = filp_open(file_path, O_CREAT|O_RDWR , 0665);
+    if (IS_ERR(file_p))
+    {
+        SENSOR_LOG_ERROR("[open file <%s>failed]\n",file_path);
+        goto error;
+    }
+    old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    vfs_write_retval = vfs_write(file_p, (char*)write_buf, sizeof(write_buf), &file_p->f_pos);
+    if (vfs_write_retval < 0)
+    {
+        SENSOR_LOG_ERROR("[write file <%s>failed]\n",file_path);
+        goto error;
+    }
+
+    set_fs(old_fs);
+    filp_close(file_p, NULL);
+
+
+    return 1;
+
+error:
+    return -1;
+}
+
+static int create_sysfs_interfaces_prox(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_prox); i++)
+		if (device_create_file(dev, attrs_prox + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_prox + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_light(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_light); i++)
+		if (device_create_file(dev, attrs_light + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_light + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int create_sysfs_interfaces_gesture(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attrs_gesture); i++)
+		if (device_create_file(dev, attrs_gesture + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attrs_gesture + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int tmg399x_check_chip_ready(struct tmg399x_chip *chip)
+{
+	u8 id, rev;
+    return tmg399x_get_id(chip, &id, &rev);
+}
+
+static int tmg399x_wait_chip_ready(struct tmg399x_chip *chip)
+{
+    int i = 0;
+    msleep(50);
+    for (i=1; i<100; i++)
+    {
+        if (tmg399x_check_chip_ready(chip) < 0)
+        {
+            msleep(10);
+        }
+        else
+        {
+            SENSOR_LOG_INFO("retry %d times\n",(i-1));
+            return 0;
+        }
+    }
+
+    SENSOR_LOG_INFO("retry times out \n");
+    return -1;
+}
+
+
+static void tmg399x_input_far_event(struct tmg399x_chip *chip)
+{
+    input_report_rel(chip->p_idev, REL_X, 250);
+    input_sync(chip->p_idev);
+}
+
+static void tmg399x_report_prox(struct tmg399x_chip *chip)
+{
+	if (chip->p_idev) 
+    {
+        SENSOR_LOG_INFO("data = %d, high = %d, low = %d",chip->prx_inf.raw,chip->params.prox_th_high, chip->params.prox_th_low);
+        if (chip->prox_calibrate_start)
+        {
+            input_report_rel(chip->p_idev, REL_MISC, chip->prx_inf.raw);
+        }
+        else
+        {
+            input_report_rel(chip->p_idev, REL_X, chip->prx_inf.raw);
+        }
+		input_sync(chip->p_idev);
+	}
+}
+
+static int tmg399x_check_and_report(struct tmg399x_chip *chip)
+{   
+	u8 status;
+	
+    tmg399x_i2c_read(chip, TMG399X_STATUS, &chip->shadow[TMG399X_STATUS]);
+	status = chip->shadow[TMG399X_STATUS];
+
+    if (true == chip->prx_enabled)
+    {
+        tmg399x_read_prox_data(chip);
+        if (tmg399x_get_prox(chip))
+        {
+            tmg399x_report_prox(chip);
+        }
+        tmg399x_irq_clr(chip, TMG399X_CMD_PROX_INT_CLR);
+    }
+
+    if ((status & (TMG399X_ST_GES_IRQ)) == (TMG399X_ST_GES_IRQ)) 
+    {
+        atomic_set(&gesture_drdy, 1);
+        wake_up(&gesture_drdy_wq);
+    }
+    
+	return 0;
+}
+
+static void tmg399x_irq_work(struct work_struct *work)
+{
+	struct tmg399x_chip *chip = container_of(work, struct tmg399x_chip, irq_work);
+    mutex_lock(&chip->lock);
+    if (true == chip->wakeup_from_sleep)
+    {        
+        chip->wakeup_from_sleep = false;
+        SENSOR_LOG_INFO(" wakeup_from_sleep = true\n");
+        if (tmg399x_wait_chip_ready(chip) < 0)
+        {
+            tmg399x_input_far_event(chip);
+        }
+    }
+	tmg399x_check_and_report(chip);
+	hrtimer_cancel(&p_global_tmg399x_chip->prox_unwakelock_timer);
+	p_global_tmg399x_chip->irq_work_status = false;
+	//SENSOR_LOG_INFO("########  tmg399x_irq_work enter   hrtimer_start #########\n");
+
+	hrtimer_start(&p_global_tmg399x_chip->prox_unwakelock_timer, ktime_set(3, 0), HRTIMER_MODE_REL);
+
+	//schedule_delayed_work(&p_global_tmg399x_chip->prox_unwakelock_work, msecs_to_jiffies(1000));
+	
+    tmg399x_irq_enable(true, true);
+    mutex_unlock(&chip->lock);
+};
+
+static irqreturn_t tmg399x_irq(int irq, void *handle)
+{
+	struct tmg399x_chip *chip = handle;
+    chip->irq_work_status =true;
+    tmg399x_irq_enable(false, false);
+    if (true == chip->prx_enabled)
+    {
+        tmg399x_wakelock_ops(&(chip->proximity_wakelock),true);
+	}
+    if (0==schedule_work(&chip->irq_work))
+    {
+        SENSOR_LOG_INFO("schedule_work failed!\n");
+    }
+	return IRQ_HANDLED;
+}
+
+static int tmg399x_set_segment_table(struct tmg399x_chip *chip,
+		struct lux_segment *segment, int seg_num)
+{
+	int i;
+	struct device *dev = &chip->client->dev;
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+
+	if (!chip->segment) 
+    {
+		dev_info(dev, "%s: allocating segment table\n", __func__);
+		chip->segment = kzalloc(sizeof(*chip->segment) *
+				chip->seg_num_max, GFP_KERNEL);
+		if (!chip->segment) {
+			dev_err(dev, "%s: no memory!\n", __func__);
+			return -ENOMEM;
+		}
+	}
+	if (seg_num > chip->seg_num_max) {
+		dev_warn(dev, "%s: %d segment requested, %d applied\n",
+				__func__, seg_num, chip->seg_num_max);
+		chip->segment_num = chip->seg_num_max;
+	} else {
+		chip->segment_num = seg_num;
+	}
+	memcpy(chip->segment, segment,
+			chip->segment_num * sizeof(*chip->segment));
+	dev_info(dev, "%s: %d segment requested, %d applied\n", __func__,
+			seg_num, chip->seg_num_max);
+	for (i = 0; i < chip->segment_num; i++)
+		dev_info(dev,
+		"seg %d: d_factor %d, r_coef %d, g_coef %d, b_coef %d, ct_coef %d ct_offset %d\n",
+		i, chip->segment[i].d_factor, chip->segment[i].r_coef,
+		chip->segment[i].g_coef, chip->segment[i].b_coef,
+		chip->segment[i].ct_coef, chip->segment[i].ct_offset);
+	return 0;
+}
+
+static void tmg399x_set_defaults(struct tmg399x_chip *chip)
+{
+	struct device *dev = &chip->client->dev;
+
+	if (chip->pdata) {
+		dev_info(dev, "%s: Loading pltform data\n", __func__);
+		chip->params.als_time = chip->pdata->parameters.als_time;
+		chip->params.als_gain = chip->pdata->parameters.als_gain;
+		chip->params.als_deltaP = chip->pdata->parameters.als_deltaP;
+		chip->params.wait_time = chip->pdata->parameters.wait_time;
+		chip->params.prox_th_low = chip->pdata->parameters.prox_th_low;
+		chip->params.prox_th_high = chip->pdata->parameters.prox_th_high;
+		chip->params.persist = chip->pdata->parameters.persist;
+		chip->params.als_prox_cfg1 = chip->pdata->parameters.als_prox_cfg1;
+		chip->params.prox_pulse = chip->pdata->parameters.prox_pulse;
+		chip->params.prox_gain = chip->pdata->parameters.prox_gain;
+		chip->params.ldrive = chip->pdata->parameters.ldrive;
+		chip->params.als_prox_cfg2 = chip->pdata->parameters.als_prox_cfg2;
+		chip->params.prox_offset_ne = chip->pdata->parameters.prox_offset_ne;
+		chip->params.prox_offset_sw = chip->pdata->parameters.prox_offset_sw;
+		chip->params.als_prox_cfg3 = chip->pdata->parameters.als_prox_cfg3;
+	} else {
+		dev_info(dev, "%s: use defaults\n", __func__);
+		chip->params.als_time = param_default.als_time;
+		chip->params.als_gain = param_default.als_gain;
+		chip->params.als_deltaP = param_default.als_deltaP;
+		chip->params.wait_time = param_default.wait_time;
+		chip->params.prox_th_low = param_default.prox_th_low;
+		chip->params.prox_th_high = param_default.prox_th_high;
+		chip->params.persist = param_default.persist;
+		chip->params.als_prox_cfg1 = param_default.als_prox_cfg1;
+		chip->params.prox_pulse = param_default.prox_pulse;
+		chip->params.prox_gain = param_default.prox_gain;
+		chip->params.ldrive = param_default.ldrive;
+		chip->params.als_prox_cfg2 = param_default.als_prox_cfg2;
+		chip->params.prox_offset_ne = param_default.prox_offset_ne;
+		chip->params.prox_offset_sw = param_default.prox_offset_sw;
+		chip->params.als_prox_cfg3 = param_default.als_prox_cfg3;
+	}
+
+	chip->als_gain_auto = true;
+
+	/* Initial proximity threshold */
+	chip->shadow[TMG399X_PRX_THRES_LOW] = 0;//chip->params.prox_th_low;
+	chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_LOW, chip->shadow[TMG399X_PRX_THRES_LOW]);
+	tmg399x_i2c_write(chip, TMG399X_PRX_THRES_HIGH, chip->shadow[TMG399X_PRX_THRES_HIGH]);
+			
+	chip->shadow[TMG399X_ALS_TIME]      = chip->params.als_time;
+	chip->shadow[TMG399X_WAIT_TIME]     = chip->params.wait_time;
+	chip->shadow[TMG399X_PERSISTENCE]   = chip->params.persist;
+	chip->shadow[TMG399X_CONFIG_1]      = chip->params.als_prox_cfg1;	
+	chip->shadow[TMG399X_PRX_PULSE]     = chip->params.prox_pulse;
+	chip->shadow[TMG399X_GAIN]          = chip->params.als_gain | chip->params.prox_gain | chip->params.ldrive;
+	chip->shadow[TMG399X_CONFIG_2]      = chip->params.als_prox_cfg2;
+	chip->shadow[TMG399X_PRX_OFFSET_NE] = chip->params.prox_offset_ne;
+	chip->shadow[TMG399X_PRX_OFFSET_SW] = chip->params.prox_offset_sw;
+	chip->shadow[TMG399X_CONFIG_3]      = chip->params.als_prox_cfg3;
+}
+
+static int tmg399x_get_id(struct tmg399x_chip *chip, u8 *id, u8 *rev)
+{
+	int ret;
+	ret = tmg399x_i2c_read(chip, TMG399X_REVID, rev);
+	ret |= tmg399x_i2c_read(chip, TMG399X_CHIPID, id);
+	return ret;
+}
+
+static int tmg399x_add_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		if (device_create_file(dev, a + i))
+			goto undo;
+	return 0;
+undo:
+	for (; i >= 0 ; i--)
+		device_remove_file(dev, a + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void tmg399x_remove_sysfs_interfaces(struct device *dev,
+	struct device_attribute *a, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		device_remove_file(dev, a + i);
+}
+
+static void tmg399x_als_poll_work_func(struct work_struct *work)
+{
+    int ret = 0;
+    u8 temp = 0;
+
+    if (p_global_tmg399x_chip->gesture_start)
+    {
+        if (true == p_global_tmg399x_chip->als_enabled)
+        {
+    	    schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(p_global_tmg399x_chip->light_poll_time));
+        }
+        return;
+    }
+
+    mutex_lock(&p_global_tmg399x_chip->lock);
+
+    if ((true==p_global_tmg399x_chip->ges_enabled) && (false==p_global_tmg399x_chip->prx_enabled))
+    {
+    
+        ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_CONTROL, &temp);
+
+        temp &= ~TMG399X_EN_GES;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_CONTROL, temp);
+
+        msleep(10);
+        
+        ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_CONTROL, &temp);
+
+        temp |= TMG399X_EN_GES;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_CONTROL, temp);
+
+
+	    ret = tmg399x_i2c_read(p_global_tmg399x_chip, TMG399X_GES_CFG_4, &temp);
+	    temp |= 0x01;
+	    ret = tmg399x_i2c_write(p_global_tmg399x_chip, TMG399X_GES_CFG_4, temp);
+    }
+
+	tmg399x_read_rgb_data(p_global_tmg399x_chip);
+    tmg399x_get_als(p_global_tmg399x_chip);
+	tmg399x_get_lux(p_global_tmg399x_chip);
+    if (p_global_tmg399x_chip->light_debug_enable)
+    {
+        SENSOR_LOG_INFO("R = %d, G = %d, B = %d, C = %d, Lux = %d cct = %d",
+                                                                p_global_tmg399x_chip->als_inf.red_raw,
+                                                                p_global_tmg399x_chip->als_inf.green_raw,
+                                                                p_global_tmg399x_chip->als_inf.blue_raw,
+                                                                p_global_tmg399x_chip->als_inf.clear_raw,
+                                                                p_global_tmg399x_chip->als_inf.lux,
+                                                                p_global_tmg399x_chip->als_inf.cct);
+    }
+
+    if (p_global_tmg399x_chip->als_inf.lux>10000)
+    {
+        p_global_tmg399x_chip->als_inf.lux = 10000;
+    }
+    input_report_rel(p_global_tmg399x_chip->a_idev, REL_X, (p_global_tmg399x_chip->als_inf.lux + 1));
+    input_report_rel(p_global_tmg399x_chip->a_idev, REL_Y, p_global_tmg399x_chip->als_inf.cct);
+    input_sync(p_global_tmg399x_chip->a_idev);
+
+    if (true == p_global_tmg399x_chip->als_enabled)
+    {
+	    schedule_delayed_work(&p_global_tmg399x_chip->als_poll_work, msecs_to_jiffies(p_global_tmg399x_chip->light_poll_time));
+    }
+
+    mutex_unlock(&p_global_tmg399x_chip->lock);
+}
+
+static void tmg399x_prox_calibrate_work_func(struct work_struct *work)
+{
+    tmg399x_prox_calibrate(p_global_tmg399x_chip);
+}
+
+static enum hrtimer_restart tmg399x_unwakelock_work_func(struct hrtimer *timer)
+{ 
+
+   SENSOR_LOG_INFO("########  in  tmg399x_prox_unwakelock_timer_func #########\n");
+   if (false == p_global_tmg399x_chip->irq_work_status )
+   tmg399x_wakelock_ops(&(p_global_tmg399x_chip->proximity_wakelock),false);
+
+   return HRTIMER_NORESTART;
+}
+static int __devinit tmg399x_probe(struct i2c_client *client, const struct i2c_device_id *idp)
+{
+	int i, ret;
+	u8 id, rev;
+	struct device *dev = &client->dev;
+	static struct tmg399x_chip *chip;
+	struct tmg399x_i2c_platform_data *pdata = &tmg399x_data;
+	bool powered = 0;
+    SENSOR_LOG_INFO("Prob Start\n");
+
+    dev->platform_data = &tmg399x_data;
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "%s: i2c smbus byte data unsupported\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto init_failed;
+	}
+	if (!pdata) {
+		dev_err(dev, "%s: platform data required\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+
+	if (!(pdata->prox_name || pdata->als_name) || client->irq < 0) {
+		dev_err(dev, "%s: no reason to run.\n", __func__);
+		ret = -EINVAL;
+		goto init_failed;
+	}
+
+	if (pdata->platform_init) {
+		ret = pdata->platform_init();
+		if (ret)
+			goto init_failed;
+	}
+	if (pdata->platform_power) {
+		ret = pdata->platform_power(dev, POWER_ON);
+		if (ret) {
+			dev_err(dev, "%s: pltf power on failed\n", __func__);
+			goto pon_failed;
+		}
+		powered = true;
+		mdelay(10);
+	}
+	chip = kzalloc(sizeof(struct tmg399x_chip), GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto malloc_failed;
+	}
+
+    tmg399x_chip_data_init(chip);
+
+    p_global_tmg399x_chip = chip;
+
+	chip->client = client;
+	chip->pdata = pdata;
+	i2c_set_clientdata(client, chip);
+
+	chip->seg_num_max = chip->pdata->segment_num ?
+			chip->pdata->segment_num : ARRAY_SIZE(segment_default);
+	if (chip->pdata->segment)
+		ret = tmg399x_set_segment_table(chip, chip->pdata->segment,
+			chip->pdata->segment_num);
+	else
+		ret =  tmg399x_set_segment_table(chip, segment_default,
+			ARRAY_SIZE(segment_default));
+	if (ret)
+		goto set_segment_failed;
+
+	ret = tmg399x_get_id(chip, &id, &rev);
+	if (ret < 0)
+		dev_err(&chip->client->dev,
+			"%s: failed to get tmg399x id\n",
+			__func__);
+
+	dev_info(dev, "%s: device id:%02x device rev:%02x\n", __func__,
+				id, rev);
+
+	for (i = 0; i < ARRAY_SIZE(tmg399x_ids); i++) 
+    {
+		if (id == tmg399x_ids[i])
+        {
+            SENSOR_LOG_INFO("id = %d\n",id);
+            if (i>=1)
+            {
+                i = 1;
+            }
+			break;
+        }
+	}
+
+	if (i < ARRAY_SIZE(tmg399x_names)) 
+    {
+		dev_info(dev, "%s: '%s rev. %d' detected\n", __func__, tmg399x_names[i], rev);
+		chip->device_index = i;
+	} 
+    else 
+    {
+		dev_err(dev, "%s: not supported chip id\n", __func__);
+		ret = -EOPNOTSUPP;
+		goto id_failed;
+	}
+
+	mutex_init(&chip->lock);
+    wake_lock_init(&chip->proximity_wakelock.lock, WAKE_LOCK_SUSPEND, (chip->proximity_wakelock).name);
+
+	tmg399x_set_defaults(chip);
+	ret = tmg399x_flush_regs(chip);
+	if (ret)
+		goto flush_regs_failed;
+	if (pdata->platform_power) {
+		pdata->platform_power(dev, POWER_OFF);
+		powered = false;
+		chip->unpowered = true;
+	}
+
+	if (!pdata->prox_name)
+		goto bypass_prox_idev;
+	chip->p_idev = input_allocate_device();
+	if (!chip->p_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->prox_name);
+		ret = -ENODEV;
+		goto input_p_alloc_failed;
+	}
+	chip->p_idev->name = pdata->prox_name;
+	chip->p_idev->id.bustype = BUS_I2C;
+
+
+    // for prox
+    set_bit(EV_REL,     chip->p_idev->evbit);
+    set_bit(REL_X,      chip->p_idev->relbit);
+    set_bit(REL_Y,      chip->p_idev->relbit);
+    set_bit(REL_Z,      chip->p_idev->relbit);
+    set_bit(REL_MISC,   chip->p_idev->relbit);
+
+    // for ges
+    set_bit(REL_RX,     chip->p_idev->relbit);  //gesture style
+    set_bit(REL_RY,     chip->p_idev->relbit);  //gesture enter time
+    set_bit(REL_RZ,     chip->p_idev->relbit);  //gesture exit time
+    set_bit(REL_HWHEEL, chip->p_idev->relbit);  //gesture enter angle
+    set_bit(REL_DIAL,   chip->p_idev->relbit);  //gesture exit angle
+
+
+  
+	dev_set_drvdata(&chip->p_idev->dev, chip);
+	ret = input_register_device(chip->p_idev);
+	if (ret) {
+		input_free_device(chip->p_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_p_register_failed;
+	}
+   
+	ret = tmg399x_add_sysfs_interfaces(&chip->p_idev->dev,
+			attrs_prox, ARRAY_SIZE(attrs_prox));
+    if (ret)
+		goto input_p_sysfs_failed;
+
+bypass_prox_idev:
+
+	if (!pdata->als_name)
+		goto bypass_als_idev;
+	chip->a_idev = input_allocate_device();
+	if (!chip->a_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->als_name);
+		ret = -ENODEV;
+		goto input_a_alloc_failed;
+	}
+	chip->a_idev->name = pdata->als_name;
+	chip->a_idev->id.bustype = BUS_I2C;
+
+    set_bit(EV_REL, chip->a_idev->evbit);
+    set_bit(REL_X,  chip->a_idev->relbit);
+    set_bit(REL_Y,  chip->a_idev->relbit);
+
+	dev_set_drvdata(&chip->a_idev->dev, chip);
+	ret = input_register_device(chip->a_idev);
+	if (ret) {
+		input_free_device(chip->a_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->prox_name);
+		goto input_a_register_failed;
+	}
+	ret = tmg399x_add_sysfs_interfaces(&chip->a_idev->dev,
+			attrs_light, ARRAY_SIZE(attrs_light));
+	if (ret)
+		goto input_a_sysfs_failed;
+
+bypass_als_idev:
+
+	if (!pdata->ges_name)
+		goto bypass_ges_idev;
+	chip->g_idev = input_allocate_device();
+	if (!chip->g_idev) {
+		dev_err(dev, "%s: no memory for input_dev '%s'\n",
+				__func__, pdata->ges_name);
+		ret = -ENODEV;
+		goto input_g_alloc_failed;
+	}
+	chip->g_idev->name = pdata->ges_name;
+	chip->g_idev->id.bustype = BUS_I2C;
+
+    // for ges
+    set_bit(EV_REL,     chip->g_idev->evbit);
+    set_bit(REL_RX,     chip->g_idev->relbit);  //gesture style
+    set_bit(REL_RY,     chip->g_idev->relbit);  //gesture enter time
+    set_bit(REL_RZ,     chip->g_idev->relbit);  //gesture exit  time
+    set_bit(REL_HWHEEL, chip->g_idev->relbit);  //gesture enter angle
+    set_bit(REL_DIAL,   chip->g_idev->relbit);  //gesture exit  angle
+
+
+	dev_set_drvdata(&chip->g_idev->dev, chip);
+	ret = input_register_device(chip->g_idev);
+	if (ret) {
+		input_free_device(chip->g_idev);
+		dev_err(dev, "%s: cant register input '%s'\n",
+				__func__, pdata->ges_name);
+		goto input_g_register_failed;
+	}
+	ret = tmg399x_add_sysfs_interfaces(&chip->g_idev->dev,
+			attrs_gesture, ARRAY_SIZE(attrs_gesture));
+	if (ret)
+		goto input_g_sysfs_failed;
+bypass_ges_idev:
+
+    ret = gpio_request(TMG399X_INT_PIN, "tmg3993");
+	if (ret)    
+    {
+        SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",TMG399X_INT_PIN);
+        
+        gpio_free(TMG399X_INT_PIN);
+        ret = gpio_request(TMG399X_INT_PIN, "tmg3993");
+        if (ret) 
+        {
+            SENSOR_LOG_INFO("gpio %d is busy and then to free it\n",TMG399X_INT_PIN);
+            return ret;
+        }
+	}
+    
+    ret = gpio_tlmm_config(GPIO_CFG(TMG399X_INT_PIN, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
+
+    client->irq = gpio_to_irq(TMG399X_INT_PIN);///ztemt
+    SENSOR_LOG_INFO("client->irq = %d\n",client->irq);
+	INIT_WORK(&chip->irq_work, tmg399x_irq_work);
+	ret = request_threaded_irq(client->irq, NULL, &tmg399x_irq, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "tmg399x", chip);
+	if (ret) {
+		dev_info(dev, "Failed to request irq %d\n", client->irq);
+		goto irq_register_fail;
+	}
+
+    INIT_DELAYED_WORK(&chip->als_poll_work, tmg399x_als_poll_work_func);
+    INIT_DELAYED_WORK(&chip->prox_calibrate_work, tmg399x_prox_calibrate_work_func);
+  //  INIT_DELAYED_WORK(&chip->prox_unwakelock_work, tmg399x_unwakelock_work_func);
+    hrtimer_init(&chip->prox_unwakelock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    chip->prox_unwakelock_timer.function = tmg399x_unwakelock_work_func;
+  //  hrtimer_start(&chip->prox_unwakelock_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+
+	init_waitqueue_head(&gesture_drdy_wq);
+	atomic_set(&gesture_drdy, 0);
+    chip->light_poll_time = AMS_ALS_POLL_DELAY_FAST;
+
+    proximity_class = class_create(THIS_MODULE, "proximity");
+    light_class     = class_create(THIS_MODULE, "light");
+    gesture_class   = class_create(THIS_MODULE, "gesture");
+
+ 
+    chip->proximity_dev = device_create(proximity_class, NULL, tmg399x_proximity_dev_t, &tmg399x_driver ,"proximity");
+    if (IS_ERR(chip->proximity_dev)) 
+    {
+       ret = PTR_ERR(chip->proximity_dev);
+       goto create_proximity_dev_failed;
+    }
+
+    chip->light_dev= device_create(light_class, NULL, tmg399x_light_dev_t, &tmg399x_driver ,"light");
+    if (IS_ERR(chip->light_dev)) 
+    {
+       ret = PTR_ERR(chip->light_dev);
+       goto create_light_dev_failed;
+    }
+
+    chip->gesture_dev = device_create(gesture_class, NULL, tmg399x_gesture_dev_t, &tmg399x_driver ,"gesture");
+    if (IS_ERR(chip->gesture_dev)) 
+    {
+       ret = PTR_ERR(chip->gesture_dev);
+       goto create_gesture_dev_failed;
+    }
+
+	dev_set_drvdata(chip->proximity_dev, chip);
+	dev_set_drvdata(chip->light_dev, chip);
+	dev_set_drvdata(chip->gesture_dev, chip);
+
+    create_sysfs_interfaces_prox(chip->proximity_dev);
+    create_sysfs_interfaces_light(chip->light_dev);
+    create_sysfs_interfaces_gesture(chip->gesture_dev);
+
+    tmg399x_irq_enable(false, true);
+
+	SENSOR_LOG_INFO("Probe ok.\n");
+	return 0;
+
+create_proximity_dev_failed:
+    chip->proximity_dev = NULL;
+    class_destroy(proximity_class);
+
+create_light_dev_failed:
+    chip->proximity_dev = NULL;
+    chip->light_dev     = NULL;
+    class_destroy(proximity_class);
+    class_destroy(proximity_class);
+
+create_gesture_dev_failed:
+    chip->proximity_dev = NULL;
+    chip->light_dev     = NULL;
+    chip->gesture_dev     = NULL;
+    class_destroy(proximity_class);
+    class_destroy(light_class);
+    class_destroy(gesture_class);
+
+
+irq_register_fail:
+    if (chip->a_idev) {
+            tmg399x_remove_sysfs_interfaces(&chip->g_idev->dev,attrs_gesture, ARRAY_SIZE(attrs_gesture));
+input_g_sysfs_failed:
+            input_unregister_device(chip->g_idev);
+input_g_register_failed:
+            input_free_device(chip->g_idev);
+        }
+input_g_alloc_failed:
+
+	if (chip->a_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->a_idev->dev,attrs_light, ARRAY_SIZE(attrs_light));
+input_a_sysfs_failed:
+		input_unregister_device(chip->a_idev);
+input_a_register_failed:
+		input_free_device(chip->a_idev);
+	}
+input_a_alloc_failed:
+	if (chip->p_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->p_idev->dev, attrs_prox, ARRAY_SIZE(attrs_prox));
+input_p_sysfs_failed:
+		input_unregister_device(chip->p_idev);
+input_p_register_failed:
+		input_free_device(chip->p_idev);
+	}	
+input_p_alloc_failed:
+flush_regs_failed:
+id_failed:
+	kfree(chip->segment);
+set_segment_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+malloc_failed:
+	if (powered && pdata->platform_power)
+		pdata->platform_power(dev, POWER_OFF);
+pon_failed:
+	if (pdata->platform_teardown)
+		pdata->platform_teardown(dev);
+init_failed:
+	SENSOR_LOG_INFO("Probe failed.\n");
+	return ret;
+}
+
+static int tmg399x_prox_calibrate(struct tmg399x_chip *chip)
+{
+    int prox_sum = 0, prox_mean = 0, prox_max = 0,prox_min = 0;
+    u8  i = 0 ;
+    int ret = 0;
+    struct tmg399x_prox_info *prox_cal_info = NULL;
+    chip->prox_calibrate_result = false;
+
+    prox_cal_info = kmalloc(sizeof(struct tmg399x_prox_info) * (chip->prox_calibrate_times), GFP_KERNEL); 
+    if (NULL == prox_cal_info)
+    {
+        SENSOR_LOG_ERROR("malloc prox_cal_info failed\n");
+        ret = -1;
+        goto prox_calibrate_failed;
+    }
+
+    memset(prox_cal_info, 0, sizeof(struct tmg399x_prox_info) * (chip->prox_calibrate_times));
+
+    if (false == (chip->prx_enabled))
+    {
+        chip->shadow[TMG399X_CONTROL] |= (TMG399X_EN_PWR_ON | TMG399X_EN_PRX|TMG399X_EN_WAIT);
+        ret = tmg399x_update_enable_reg(chip);
+        if (ret < 0)
+        {
+            
+            SENSOR_LOG_ERROR("enable prox failed\n");
+            kfree(prox_cal_info);
+            goto prox_calibrate_failed;
+        }    
+        chip->light_poll_time = AMS_ALS_POLL_DELAY_SLOW;
+        tmg399x_als_atime_set(AMS_ALS_ATIME_SHORT);
+    }
+	
+    mdelay(20);
+
+	for (i = 0; i < chip->prox_calibrate_times; i++) 
+    {
+        tmg399x_read_prox_data(chip);   
+        prox_cal_info[i].raw = chip->shadow[TMG399X_PRX_CHAN];
+		prox_sum += prox_cal_info[i].raw;
+
+		if (prox_cal_info[i].raw> prox_max)
+        {
+		    	prox_max = prox_cal_info[i].raw;
+		}
+        if (prox_cal_info[i].raw < prox_min)
+		{
+   	        prox_min = prox_cal_info[i].raw;
+        }
+
+        SENSOR_LOG_ERROR("prox data = %d\n",prox_cal_info[i].raw);
+
+	    mdelay(30);
+	}
+             
+    prox_mean = prox_sum/chip->prox_calibrate_times;
+				
+    if (prox_max <= 50)
+    {
+
+		chip->params.prox_th_high = prox_mean + 110;
+		chip->params.prox_th_low  = prox_mean + 30;
+    }
+	  else
+	 {
+        if (prox_max > 170)
+        {
+		chip->params.prox_th_high = 250;
+		chip->params.prox_th_low  = 230;
+        }
+        else
+        {
+           
+		chip->params.prox_th_high = prox_mean +50;
+		chip->params.prox_th_low  = prox_mean +30;
+            
+        }        
+	}
+
+	SENSOR_LOG_ERROR("chip->params.prox_th_high = %d\n",chip->params.prox_th_high );
+	SENSOR_LOG_ERROR("chip->params.prox_th_low  = %d\n",chip->params.prox_th_low);
+
+    chip->shadow[TMG399X_PRX_THRES_HIGH] = chip->params.prox_th_high;
+    chip->shadow[TMG399X_PRX_THRES_LOW]  = chip->params.prox_th_low;
+
+    input_report_rel(chip->p_idev, REL_Y, chip->params.prox_th_high);
+    input_report_rel(chip->p_idev, REL_Z, chip->params.prox_th_low);
+	input_sync(chip->p_idev);
+    
+    if (true == (chip->prx_enabled))
+    {
+        tmg399x_prox_enable(chip, true);
+    }
+    else
+    {
+        tmg399x_prox_enable(chip, false);
+    }
+    
+    kfree(prox_cal_info);
+    chip->prox_calibrate_result = true;
+    return 0;
+
+prox_calibrate_failed:
+    return ret;
+}
+
+
+
+static int __devexit tmg399x_remove(struct i2c_client *client)
+{
+	struct tmg399x_chip *chip = i2c_get_clientdata(client);
+	mutex_lock(&chip->lock);
+	free_irq(client->irq, chip);
+	if (chip->a_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->a_idev->dev,
+			attrs_light, ARRAY_SIZE(attrs_light));
+		input_unregister_device(chip->a_idev);
+	}
+	if (chip->p_idev) {
+		tmg399x_remove_sysfs_interfaces(&chip->p_idev->dev,
+			attrs_prox, ARRAY_SIZE(attrs_prox));
+		input_unregister_device(chip->p_idev);
+	}
+	if (chip->pdata->platform_teardown)
+		chip->pdata->platform_teardown(&client->dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(chip->segment);
+	kfree(chip);
+	mutex_unlock(&chip->lock);
+	return 0;
+}
+
+static int __init tmg399x_init(void)
+{
+#ifdef CONFIG_ZTEMT_SENSORS_ALS_PS_AUTO_DETECT
+    return 0;
+#else
+    return i2c_add_driver(&tmg399x_driver);
+#endif
+}
+
+static void __exit tmg399x_exit(void)
+{
+	i2c_del_driver(&tmg399x_driver);
+}
+
+module_init(tmg399x_init);
+module_exit(tmg399x_exit);
+
+MODULE_AUTHOR("J. August Brenner<jon.brenner@ams.com>");
+MODULE_AUTHOR("Byron Shi<byron.shi@ams.com>");
+MODULE_DESCRIPTION("AMS-TAOS tmg3992/3 Ambient, Proximity, Gesture sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
old mode 100644
new mode 100755
index 1e08169..635e32b
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -11,6 +11,8 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+source "drivers/input/touchscreen/gt915/Kconfig"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
old mode 100644
new mode 100755
index 2b98145..75ae5cc
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -6,6 +6,8 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+obj-$(CONFIG_ZTEMT_TOUCHSCREEN_GT9XX) += gt915/
+
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
diff --git a/drivers/input/touchscreen/gt915/Kconfig b/drivers/input/touchscreen/gt915/Kconfig
new file mode 100755
index 0000000..dce99b4
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/Kconfig
@@ -0,0 +1,81 @@
+#
+# Goodix GT9xx Touchscreen driver
+#
+
+menuconfig ZTEMT_TOUCHSCREEN_GT9XX
+	bool "ZTEMT_TOUCHSCREEN_GT9XX"
+	help
+	  Say Y here, and a list of supported touchscreens will be displayed.
+	  This option doesn't affect the kernel.
+
+	  If unsure, say Y.
+
+if ZTEMT_TOUCHSCREEN_GT9XX
+
+config ZTEMT_GT9XX_TOUCHSCREEN_DRIVER
+	tristate "Goodix GT9xx touchpanel driver"
+	depends on ZTEMT_TOUCHSCREEN_GT9XX
+	default n
+	help
+	  This is the main file for touchpanel driver for Goodix GT9xx
+	  touchscreens.
+
+	  Say Y here if you have a Goodix GT9xx touchscreen connected
+	  to your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gt9xx_update.
+
+config ZTEMT_GT9XX_TOUCHSCREEN_UPDATE
+	tristate "Goodix GT9xx touchpanel auto update support"
+	depends on ZTEMT_GT9XX_TOUCHSCREEN_DRIVER
+	default n
+	help
+	  This enables support for firmware update for Goodix GT9xx
+	  touchscreens.
+
+	  Say Y here if you have a Goodix GT9xx touchscreen connected
+	  to your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gt9xx_update.
+
+config ZTEMT_GT9XX_TOUCHSCREEN_DEBUG
+	tristate "Goodix GT9xx Tools for debuging"
+	depends on ZTEMT_GT9XX_TOUCHSCREEN_DRIVER
+	default n
+	help
+	  This is application debug interface support for Goodix GT9xx
+	  touchscreens.
+
+	  Say Y here if you want to have a Android app debug interface
+	  to your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gt9xx_update.
+
+config ZTEMT_GT9XX_TOUCHSCREEN_TEST
+       tristate "Goodix GT9xx Tools for testing"
+       depends on ZTEMT_GT9XX_TOUCHSCREEN_DRIVER
+       default n
+       help
+         This is application test interface support for Goodix GT9xx
+         touchscreens.
+
+         Say Y here if you want to have a Android app debug interface
+         to your system.
+
+         If unsure, say N.
+
+         To compile this driver as a module, choose M here: the
+         module will be called gt9xx_update.
+
+
+endif
+
diff --git a/drivers/input/touchscreen/gt915/Makefile b/drivers/input/touchscreen/gt915/Makefile
new file mode 100755
index 0000000..cbb4b69
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Goodix touchscreen drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_DRIVER)	+= gt9xx.o
+obj-$(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_UPDATE)	+= gt9xx_update.o
+obj-$(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_DEBUG)     += goodix_tool.o
+obj-$(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_TEST)      += gt9xx_openshort.o
+
diff --git a/drivers/input/touchscreen/gt915/goodix_tool.c b/drivers/input/touchscreen/gt915/goodix_tool.c
new file mode 100755
index 0000000..b2dffcb
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/goodix_tool.c
@@ -0,0 +1,627 @@
+/* drivers/input/touchscreen/goodix_tool.c
+ * 
+ * 2010 - 2012 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ * Version:2.2
+ *        V1.0:2012/05/01,create file.
+ *        V1.2:2012/06/08,modify some warning.
+ *        V1.4:2012/08/28,modified to support GT9XX
+ *        V1.6:new proc name
+ *        V2.2: compatible with Linux 3.10, 2014/01/14
+ */
+
+#include "gt9xx.h"
+
+#define DATA_LENGTH_UINT    512
+#define CMD_HEAD_LENGTH     (sizeof(st_cmd_head) - sizeof(u8*))
+static char procname[20] = {0};
+
+#define UPDATE_FUNCTIONS
+
+#ifdef UPDATE_FUNCTIONS
+extern s32 gup_enter_update_mode(struct i2c_client *client);
+extern void gup_leave_update_mode(void);
+extern s32 gup_update_proc(void *dir);
+#endif
+
+extern void gtp_irq_disable(struct goodix_ts_data *);
+extern void gtp_irq_enable(struct goodix_ts_data *);
+
+#pragma pack(1)
+typedef struct{
+    u8  wr;         //write read flag��0:R  1:W  2:PID 3:
+    u8  flag;       //0:no need flag/int 1: need flag  2:need int
+    u8 flag_addr[2];  //flag address
+    u8  flag_val;   //flag val
+    u8  flag_relation;  //flag_val:flag 0:not equal 1:equal 2:> 3:<
+    u16 circle;     //polling cycle 
+    u8  times;      //plling times
+    u8  retry;      //I2C retry times
+    u16 delay;      //delay befor read or after write
+    u16 data_len;   //data length
+    u8  addr_len;   //address length
+    u8  addr[2];    //address
+    u8  res[3];     //reserved
+    u8* data;       //data pointer
+}st_cmd_head;
+#pragma pack()
+st_cmd_head cmd_head;
+
+static struct i2c_client *gt_client = NULL;
+
+static struct proc_dir_entry *goodix_proc_entry;
+
+static ssize_t goodix_tool_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t goodix_tool_write(struct file *, const char __user *, size_t, loff_t *);
+static const struct file_operations tool_ops = {
+    .owner = THIS_MODULE,
+    .read = goodix_tool_read,
+    .write = goodix_tool_write,
+};
+
+//static s32 goodix_tool_write(struct file *filp, const char __user *buff, unsigned long len, void *data);
+//static s32 goodix_tool_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+static s32 (*tool_i2c_read)(u8 *, u16);
+static s32 (*tool_i2c_write)(u8 *, u16);
+
+#if GTP_ESD_PROTECT
+extern void gtp_esd_switch(struct i2c_client *, s32);
+#endif
+s32 DATA_LENGTH = 0;
+s8 IC_TYPE[16] = "GT9XX";
+
+static void tool_set_proc_name(char * procname)
+{
+    char *months[12] = {"Jan", "Feb", "Mar", "Apr", "May", 
+        "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+    char date[20] = {0};
+    char month[4] = {0};
+    int i = 0, n_month = 1, n_day = 0, n_year = 0;
+    
+    sprintf(date, "%s", __DATE__);
+    
+    //GTP_DEBUG("compile date: %s", date);
+    
+    sscanf(date, "%s %d %d", month, &n_day, &n_year);
+    
+    for (i = 0; i < 12; ++i)
+    {
+        if (!memcmp(months[i], month, 3))
+        {
+            n_month = i+1;
+            break;
+        }
+    }
+    
+    sprintf(procname, "gmnode%04d%02d%02d", n_year, n_month, n_day);    
+    //sprintf(procname, "goodix_tool");
+    //GTP_DEBUG("procname = %s", procname);
+}
+
+
+static s32 tool_i2c_read_no_extra(u8* buf, u16 len)
+{
+    s32 ret = -1;
+    s32 i = 0;
+    struct i2c_msg msgs[2];
+    
+    msgs[0].flags = !I2C_M_RD;
+    msgs[0].addr  = gt_client->addr;
+    msgs[0].len   = cmd_head.addr_len;
+    msgs[0].buf   = &buf[0];
+    
+    msgs[1].flags = I2C_M_RD;
+    msgs[1].addr  = gt_client->addr;
+    msgs[1].len   = len;
+    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
+
+    for (i = 0; i < cmd_head.retry; i++)
+    {
+        ret=i2c_transfer(gt_client->adapter, msgs, 2);
+        if (ret > 0)
+        {
+            break;
+        }
+    }
+    return ret;
+}
+
+static s32 tool_i2c_write_no_extra(u8* buf, u16 len)
+{
+    s32 ret = -1;
+    s32 i = 0;
+    struct i2c_msg msg;
+
+    msg.flags = !I2C_M_RD;
+    msg.addr  = gt_client->addr;
+    msg.len   = len;
+    msg.buf   = buf;
+
+    for (i = 0; i < cmd_head.retry; i++)
+    {
+        ret=i2c_transfer(gt_client->adapter, &msg, 1);
+        if (ret > 0)
+        {
+            break;
+        }
+    }
+    return ret;
+}
+
+static s32 tool_i2c_read_with_extra(u8* buf, u16 len)
+{
+    s32 ret = -1;
+    u8 pre[2] = {0x0f, 0xff};
+    u8 end[2] = {0x80, 0x00};
+
+    tool_i2c_write_no_extra(pre, 2);
+    ret = tool_i2c_read_no_extra(buf, len);
+    tool_i2c_write_no_extra(end, 2);
+
+    return ret;
+}
+
+static s32 tool_i2c_write_with_extra(u8* buf, u16 len)
+{
+    s32 ret = -1;
+    u8 pre[2] = {0x0f, 0xff};
+    u8 end[2] = {0x80, 0x00};
+
+    tool_i2c_write_no_extra(pre, 2);
+    ret = tool_i2c_write_no_extra(buf, len);
+    tool_i2c_write_no_extra(end, 2);
+
+    return ret;
+}
+
+static void register_i2c_func(void)
+{
+//    if (!strncmp(IC_TYPE, "GT818", 5) || !strncmp(IC_TYPE, "GT816", 5) 
+//        || !strncmp(IC_TYPE, "GT811", 5) || !strncmp(IC_TYPE, "GT818F", 6) 
+//        || !strncmp(IC_TYPE, "GT827", 5) || !strncmp(IC_TYPE,"GT828", 5)
+//        || !strncmp(IC_TYPE, "GT813", 5))
+    if (strncmp(IC_TYPE, "GT8110", 6) && strncmp(IC_TYPE, "GT8105", 6)
+        && strncmp(IC_TYPE, "GT801", 5) && strncmp(IC_TYPE, "GT800", 5)
+        && strncmp(IC_TYPE, "GT801PLUS", 9) && strncmp(IC_TYPE, "GT811", 5)
+        && strncmp(IC_TYPE, "GTxxx", 5) && strncmp(IC_TYPE, "GT9XX", 5))
+    {
+        tool_i2c_read = tool_i2c_read_with_extra;
+        tool_i2c_write = tool_i2c_write_with_extra;
+        GTP_DEBUG("I2C function: with pre and end cmd!");
+    }
+    else
+    {
+        tool_i2c_read = tool_i2c_read_no_extra;
+        tool_i2c_write = tool_i2c_write_no_extra;
+        GTP_INFO("I2C function: without pre and end cmd!");
+    }
+}
+
+static void unregister_i2c_func(void)
+{
+    tool_i2c_read = NULL;
+    tool_i2c_write = NULL;
+    GTP_INFO("I2C function: unregister i2c transfer function!");
+}
+
+s32 init_wr_node(struct i2c_client *client)
+{
+    s32 i;
+
+    gt_client = client;
+    memset(&cmd_head, 0, sizeof(cmd_head));
+    cmd_head.data = NULL;
+
+    i = 5;
+    while ((!cmd_head.data) && i)
+    {
+        cmd_head.data = kzalloc(i * DATA_LENGTH_UINT, GFP_KERNEL);
+        if (NULL != cmd_head.data)
+        {
+            break;
+        }
+        i--;
+    }
+    if (i)
+    {
+        DATA_LENGTH = i * DATA_LENGTH_UINT + GTP_ADDR_LENGTH;
+        GTP_INFO("Applied memory size:%d.", DATA_LENGTH);
+    }
+    else
+    {
+        GTP_ERROR("Apply for memory failed.");
+        return FAIL;
+    }
+
+    cmd_head.addr_len = 2;
+    cmd_head.retry = 5;
+
+    register_i2c_func();
+
+    tool_set_proc_name(procname);
+    //goodix_proc_entry = create_proc_entry(procname, 0666, NULL);
+    goodix_proc_entry = proc_create(procname, 0666, NULL, &tool_ops);
+    if (goodix_proc_entry == NULL)
+    {
+        GTP_ERROR("Couldn't create proc entry!");
+        return FAIL;
+    }
+    else
+    {
+        GTP_INFO("Create proc entry success!");
+        //goodix_proc_entry->write_proc = goodix_tool_write;
+        //goodix_proc_entry->read_proc = goodix_tool_read;
+    }
+
+    return SUCCESS;
+}
+
+void uninit_wr_node(void)
+{
+    kfree(cmd_head.data);
+    cmd_head.data = NULL;
+    unregister_i2c_func();
+    remove_proc_entry(procname, NULL);
+}
+
+static u8 relation(u8 src, u8 dst, u8 rlt)
+{
+    u8 ret = 0;
+    
+    switch (rlt)
+    {
+    case 0:
+        ret = (src != dst) ? true : false;
+        break;
+
+    case 1:
+        ret = (src == dst) ? true : false;
+        GTP_DEBUG("equal:src:0x%02x   dst:0x%02x   ret:%d.", src, dst, (s32)ret);
+        break;
+
+    case 2:
+        ret = (src > dst) ? true : false;
+        break;
+
+    case 3:
+        ret = (src < dst) ? true : false;
+        break;
+
+    case 4:
+        ret = (src & dst) ? true : false;
+        break;
+
+    case 5:
+        ret = (!(src | dst)) ? true : false;
+        break;
+
+    default:
+        ret = false;
+        break;    
+    }
+
+    return ret;
+}
+
+/*******************************************************    
+Function:
+    Comfirm function.
+Input:
+  None.
+Output:
+    Return write length.
+********************************************************/
+static u8 comfirm(void)
+{
+    s32 i = 0;
+    u8 buf[32];
+    
+//    memcpy(&buf[GTP_ADDR_LENGTH - cmd_head.addr_len], &cmd_head.flag_addr, cmd_head.addr_len);
+//    memcpy(buf, &cmd_head.flag_addr, cmd_head.addr_len);//Modified by Scott, 2012-02-17
+    memcpy(buf, cmd_head.flag_addr, cmd_head.addr_len);
+   
+    for (i = 0; i < cmd_head.times; i++)
+    {
+        if (tool_i2c_read(buf, 1) <= 0)
+        {
+            GTP_ERROR("Read flag data failed!");
+            return FAIL;
+        }
+        if (true == relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val, cmd_head.flag_relation))
+        {
+            GTP_DEBUG("value at flag addr:0x%02x.", buf[GTP_ADDR_LENGTH]);
+            GTP_DEBUG("flag value:0x%02x.", cmd_head.flag_val);
+            break;
+        }
+
+        msleep(cmd_head.circle);
+    }
+
+    if (i >= cmd_head.times)
+    {
+        GTP_ERROR("Didn't get the flag to continue!");
+        return FAIL;
+    }
+
+    return SUCCESS;
+}
+
+/*******************************************************    
+Function:
+    Goodix tool write function.
+Input:
+  standard proc write function param.
+Output:
+    Return write length.
+********************************************************/
+//static s32 goodix_tool_write(struct file *filp, const char __user *buff, unsigned long len, void *data)
+ssize_t goodix_tool_write(struct file *filp, const char __user *buff, size_t len, loff_t *off)
+{
+    s32 ret = 0;
+    
+    GTP_DEBUG_FUNC();
+    GTP_DEBUG_ARRAY((u8*)buff, len);
+    
+    ret = copy_from_user(&cmd_head, buff, CMD_HEAD_LENGTH);
+    if(ret)
+    {
+        GTP_ERROR("copy_from_user failed.");
+        return -EPERM;
+    }
+
+    
+    GTP_DEBUG("[Operation]wr: %02X", cmd_head.wr);
+    GTP_DEBUG("[Flag]flag: %02X, addr: %02X%02X, value: %02X, relation: %02X", cmd_head.flag, cmd_head.flag_addr[0], 
+                        cmd_head.flag_addr[1], cmd_head.flag_val, cmd_head.flag_relation);
+    GTP_DEBUG("[Retry]circle: %d, times: %d, retry: %d, delay: %d", (s32)cmd_head.circle, (s32)cmd_head.times, 
+                        (s32)cmd_head.retry, (s32)cmd_head.delay);
+    GTP_DEBUG("[Data]data len: %d, addr len: %d, addr: %02X%02X, buffer len: %d, data[0]: %02X", (s32)cmd_head.data_len, 
+                        (s32)cmd_head.addr_len, cmd_head.addr[0], cmd_head.addr[1], (s32)len, buff[CMD_HEAD_LENGTH]);
+                        
+    if (1 == cmd_head.wr)
+    {
+        ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH], &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+        if(ret)
+        {
+            GTP_ERROR("copy_from_user failed.");
+            return -EPERM;
+        }
+        memcpy(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len], cmd_head.addr, cmd_head.addr_len);
+
+        GTP_DEBUG_ARRAY(cmd_head.data, cmd_head.data_len + cmd_head.addr_len);
+        GTP_DEBUG_ARRAY((u8*)&buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+
+        if (1 == cmd_head.flag)
+        {
+            if (FAIL == comfirm())
+            {
+                GTP_ERROR("[WRITE]Comfirm fail!");
+                return -EPERM;
+            }
+        }
+        else if (2 == cmd_head.flag)
+        {
+            //Need interrupt!
+        }
+        if (tool_i2c_write(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+            cmd_head.data_len + cmd_head.addr_len) <= 0)
+        {
+            GTP_ERROR("[WRITE]Write data failed!");
+            return -EPERM;
+        }
+
+        GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],cmd_head.data_len + cmd_head.addr_len);
+        if (cmd_head.delay)
+        {
+            msleep(cmd_head.delay);
+        }
+    }
+    else if (3 == cmd_head.wr)  //Write ic type
+    {
+        ret = copy_from_user(&cmd_head.data[0], &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+        if(ret)
+        {
+            GTP_ERROR("copy_from_user failed.");
+            return -EPERM;
+        }
+        memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);
+
+        register_i2c_func();
+    }
+    else if (5 == cmd_head.wr)
+    {
+        //memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);
+    }
+    else if (7 == cmd_head.wr)//disable irq!
+    {
+        gtp_irq_disable(i2c_get_clientdata(gt_client));
+        
+    #if GTP_ESD_PROTECT
+        gtp_esd_switch(gt_client, SWITCH_OFF);
+    #endif
+    }
+    else if (9 == cmd_head.wr) //enable irq!
+    {
+        gtp_irq_enable(i2c_get_clientdata(gt_client));
+
+    #if GTP_ESD_PROTECT
+        gtp_esd_switch(gt_client, SWITCH_ON);
+    #endif
+    }
+    else if(17 == cmd_head.wr)
+    {
+        struct goodix_ts_data *ts = i2c_get_clientdata(gt_client);
+        ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH], &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+        if(ret)
+        {
+            GTP_DEBUG("copy_from_user failed.");
+            return -EPERM;
+        }
+        if(cmd_head.data[GTP_ADDR_LENGTH])
+        {
+            GTP_INFO("gtp enter rawdiff.");
+            ts->gtp_rawdiff_mode = true;
+        }
+        else
+        {
+            ts->gtp_rawdiff_mode = false;
+            GTP_INFO("gtp leave rawdiff.");
+        }
+    }
+#ifdef UPDATE_FUNCTIONS
+    else if (11 == cmd_head.wr)//Enter update mode!
+    {
+        if (FAIL == gup_enter_update_mode(gt_client))
+        {
+            return -EPERM;
+        }
+    }
+    else if (13 == cmd_head.wr)//Leave update mode!
+    {
+        gup_leave_update_mode();
+    }
+    else if (15 == cmd_head.wr) //Update firmware!
+    {
+        show_len = 0;
+        total_len = 0;
+        memset(cmd_head.data, 0, cmd_head.data_len + 1);
+        memcpy(cmd_head.data, &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
+
+        if (FAIL == gup_update_proc((void*)cmd_head.data))
+        {
+            return -EPERM;
+        }
+    }
+
+#endif
+
+    return len;
+}
+
+/*******************************************************    
+Function:
+    Goodix tool read function.
+Input:
+  standard proc read function param.
+Output:
+    Return read length.
+********************************************************/
+//static s32 goodix_tool_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+ssize_t goodix_tool_read(struct file *file, char __user *page, size_t size, loff_t *ppos)
+{
+    s32 ret = 0;
+    
+    GTP_DEBUG_FUNC();
+    
+    if (*ppos)      // ADB call again
+    {
+        //GTP_DEBUG("[HEAD]wr: %d", cmd_head.wr);
+        //GTP_DEBUG("[PARAM]size: %d, *ppos: %d", size, (int)*ppos);
+        //GTP_DEBUG("[TOOL_READ]ADB call again, return it.");
+        return 0;
+    }
+    
+    if (cmd_head.wr % 2)
+    {
+        return -EPERM;
+    }
+    else if (!cmd_head.wr)
+    {
+        u16 len = 0;
+        s16 data_len = 0;
+        u16 loc = 0;
+        
+        if (1 == cmd_head.flag)
+        {
+            if (FAIL == comfirm())
+            {
+                GTP_ERROR("[READ]Comfirm fail!");
+                return -EPERM;
+            }
+        }
+        else if (2 == cmd_head.flag)
+        {
+            //Need interrupt!
+        }
+
+        memcpy(cmd_head.data, cmd_head.addr, cmd_head.addr_len);
+
+        GTP_DEBUG("[CMD HEAD DATA] ADDR:0x%02x%02x.", cmd_head.data[0], cmd_head.data[1]);
+        GTP_DEBUG("[CMD HEAD ADDR] ADDR:0x%02x%02x.", cmd_head.addr[0], cmd_head.addr[1]);
+        
+        if (cmd_head.delay)
+        {
+            msleep(cmd_head.delay);
+        }
+        
+        data_len = cmd_head.data_len;
+
+        while(data_len > 0)
+        {
+            if (data_len > DATA_LENGTH)
+            {
+                len = DATA_LENGTH;
+            }
+            else
+            {
+                len = data_len;
+            }
+            data_len -= len;
+
+            if (tool_i2c_read(cmd_head.data, len) <= 0)
+            {
+                GTP_ERROR("[READ]Read data failed!");
+                return -EPERM;
+            }
+
+            //memcpy(&page[loc], &cmd_head.data[GTP_ADDR_LENGTH], len);
+            ret = simple_read_from_buffer(&page[loc], size, ppos, &cmd_head.data[GTP_ADDR_LENGTH], len);
+            if (ret < 0)
+            {
+                return ret;
+            }
+            loc += len;
+
+            GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH], len);
+            GTP_DEBUG_ARRAY(page, len);
+        }
+        return cmd_head.data_len; 
+    }
+    else if (2 == cmd_head.wr)
+    {
+        ret = simple_read_from_buffer(page, size, ppos, IC_TYPE, sizeof(IC_TYPE));
+        return ret;
+    }
+    else if (4 == cmd_head.wr)
+    {
+        u8 progress_buf[4];
+        progress_buf[0] = show_len >> 8;
+        progress_buf[1] = show_len & 0xff;
+        progress_buf[2] = total_len >> 8;
+        progress_buf[3] = total_len & 0xff;
+        
+        ret = simple_read_from_buffer(page, size, ppos, progress_buf, 4);
+        return ret;
+    }
+    else if (6 == cmd_head.wr)
+    {
+        //Read error code!
+    }
+    else if (8 == cmd_head.wr)  //Read driver version
+    {
+        ret = simple_read_from_buffer(page, size, ppos, GTP_DRIVER_VERSION, strlen(GTP_DRIVER_VERSION));
+        return ret;
+    }
+    return -EPERM;
+}
diff --git a/drivers/input/touchscreen/gt915/gt9xx.c b/drivers/input/touchscreen/gt915/gt9xx.c
new file mode 100755
index 0000000..4b9a6ae
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx.c
@@ -0,0 +1,3416 @@
+/* drivers/input/touchscreen/gt9xx.c
+ * 
+ * 2010 - 2013 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ * Version: 2.2
+ * Authors: andrew@goodix.com, meta@goodix.com
+ * Release Date: 2014/01/14
+ * Revision record:
+ *      V1.0:   
+ *          first Release. By Andrew, 2012/08/31 
+ *      V1.2:
+ *          modify gtp_reset_guitar,slot report,tracking_id & 0x0F. By Andrew, 2012/10/15
+ *      V1.4:
+ *          modify gt9xx_update.c. By Andrew, 2012/12/12
+ *      V1.6: 
+ *          1. new heartbeat/esd_protect mechanism(add external watchdog)
+ *          2. doze mode, sliding wakeup 
+ *          3. 3 more cfg_group(GT9 Sensor_ID: 0~5) 
+ *          3. config length verification
+ *          4. names & comments
+ *                  By Meta, 2013/03/11
+ *      V1.8:
+ *          1. pen/stylus identification 
+ *          2. read double check & fixed config support
+ *          3. new esd & slide wakeup optimization
+ *                  By Meta, 2013/06/08
+ *      V2.0:
+ *          1. compatible with GT9XXF
+ *          2. send config after resume
+ *                  By Meta, 2013/08/06
+ *      V2.2:
+ *          1. gt9xx_config for debug
+ *          2. gesture wakeup
+ *          3. pen separate input device, active-pen button support
+ *          4. coordinates & keys optimization
+ *                  By Meta, 2014/01/14
+ */
+
+#include <linux/irq.h>
+#include "gt9xx.h"
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#ifdef CONFIG_OF
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#endif
+/*ZTEMT END*/
+
+#if GTP_ICS_SLOT_REPORT
+    #include <linux/input/mt.h>
+#endif
+
+static const char *goodix_ts_name = "Goodix Capacitive TouchScreen";
+static struct workqueue_struct *goodix_wq;
+struct i2c_client * i2c_connect_client = NULL; 
+u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH]
+                = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
+
+/*ZTEMT Added by luochangyang For charge detect, 2014/02/25*/
+#if GTP_CHARGER_SWITCH
+    #ifdef MT6573
+        #define CHR_CON0      (0xF7000000+0x2FA00)
+    #else
+        extern kal_bool upmu_is_chr_det(void);
+    #endif
+    static void gtp_charger_switch(s32 dir_update);
+#endif 
+/*ZTEMT END*/
+
+#if GTP_HAVE_TOUCH_KEY
+    static const u16 touch_key_array[] = GTP_KEY_TAB;
+    #define GTP_MAX_KEY_NUM  (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
+    
+#if GTP_DEBUG_ON
+    static const int  key_codes[] = {KEY_MENU, KEY_HOME, KEY_BACK};
+    static const char *key_names[] = {"Key_Menu", "Key_Home", "Key_Back"};
+#endif
+    
+#endif
+
+static s8 gtp_i2c_test(struct i2c_client *client);
+void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+s32 gtp_send_cfg(struct i2c_client *client);
+void gtp_int_sync(s32 ms);
+
+static ssize_t gt91xx_config_read_proc(struct file *, char __user *, size_t, loff_t *);
+static ssize_t gt91xx_config_write_proc(struct file *, const char __user *, size_t, loff_t *);
+
+static struct proc_dir_entry *gt91xx_config_proc = NULL;
+static const struct file_operations config_proc_ops = {
+    .owner = THIS_MODULE,
+    .read = gt91xx_config_read_proc,
+    .write = gt91xx_config_write_proc,
+};
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#define VCC_I2C
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+#endif
+ 
+#if GTP_CREATE_WR_NODE
+extern s32 init_wr_node(struct i2c_client*);
+extern void uninit_wr_node(void);
+#endif
+
+#if GTP_AUTO_UPDATE
+extern u8 gup_init_update_proc(struct goodix_ts_data *);
+#endif
+
+#if GTP_ESD_PROTECT
+static struct delayed_work gtp_esd_check_work;
+static struct workqueue_struct * gtp_esd_check_workqueue = NULL;
+static void gtp_esd_check_func(struct work_struct *);
+static s32 gtp_init_ext_watchdog(struct i2c_client *client);
+void gtp_esd_switch(struct i2c_client *, s32);
+#endif
+
+//*********** For GT9XXF Start **********//
+#if GTP_COMPATIBLE_MODE
+extern s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len);
+extern s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len);
+extern s32 gup_clk_calibration(void);
+extern s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
+extern u8 gup_check_fs_mounted(char *path_name);
+
+void gtp_recovery_reset(struct i2c_client *client);
+static s32 gtp_esd_recovery(struct i2c_client *client);
+s32 gtp_fw_startup(struct i2c_client *client);
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts);
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode);
+
+#endif
+//********** For GT9XXF End **********//
+
+//+++duguowei,2014.3.6
+#if GTP_TP_TEST
+extern s32 gtp_test_sysfs_init(void);
+#endif
+//---duguowei,2014.3.6
+u8 sensor_manufacture = 0; 
+
+#if GTP_GESTURE_WAKEUP
+typedef enum
+{
+    DOZE_DISABLED = 0,
+    DOZE_ENABLED = 1,
+    DOZE_WAKEUP = 2,
+}DOZE_T;
+static DOZE_T doze_status = DOZE_DISABLED;
+static s8 gtp_enter_doze(struct goodix_ts_data *ts);
+#endif
+
+u8 gtp_cfg_version = 0;	//move to .h file
+
+/*******************************************************
+Function:
+    Read data from the i2c slave device.
+Input:
+    client:     i2c device.
+    buf[0~1]:   read start address.
+    buf[2~len-1]:   read data buffer.
+    len:    GTP_ADDR_LENGTH + read bytes count
+Output:
+    numbers of i2c_msgs to transfer: 
+      2: succeed, otherwise: failed
+*********************************************************/
+s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
+{
+    struct i2c_msg msgs[2];
+    s32 ret=-1;
+    s32 retries = 0;
+
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);	//add by luochangyang 2014/04/30
+
+    GTP_DEBUG_FUNC();
+
+    msgs[0].flags = !I2C_M_RD;
+    msgs[0].addr  = client->addr;
+    msgs[0].len   = GTP_ADDR_LENGTH;
+    msgs[0].buf   = &buf[0];
+    //msgs[0].scl_rate = 300 * 1000;    // for Rockchip, etc.
+    
+    msgs[1].flags = I2C_M_RD;
+    msgs[1].addr  = client->addr;
+    msgs[1].len   = len - GTP_ADDR_LENGTH;
+    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
+    //msgs[1].scl_rate = 300 * 1000;
+
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, msgs, 2);
+        if(ret == 2)break;
+        retries++;
+    }
+    if((retries >= 5))
+    {
+    #if GTP_COMPATIBLE_MODE
+        struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    #endif
+    
+    #if GTP_GESTURE_WAKEUP
+	if (ts->wakeup_gesture == 1) {	//add by luochangyang 2014/04/30
+        // reset chip would quit doze mode
+        if (DOZE_ENABLED == doze_status)
+        {
+            return ret;
+        }
+	}
+    #endif
+        GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d! Process reset.", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
+    #if GTP_COMPATIBLE_MODE
+        if (CHIP_TYPE_GT9F == ts->chip_type)
+        { 
+            gtp_recovery_reset(client);
+        }
+        else
+    #endif
+        {
+            gtp_reset_guitar(client, 10);  
+        }
+    }
+    return ret;
+}
+
+
+
+/*******************************************************
+Function:
+    Write data to the i2c slave device.
+Input:
+    client:     i2c device.
+    buf[0~1]:   write start address.
+    buf[2~len-1]:   data buffer
+    len:    GTP_ADDR_LENGTH + write bytes count
+Output:
+    numbers of i2c_msgs to transfer: 
+        1: succeed, otherwise: failed
+*********************************************************/
+s32 gtp_i2c_write(struct i2c_client *client,u8 *buf,s32 len)
+{
+    struct i2c_msg msg;
+    s32 ret = -1;
+    s32 retries = 0;
+
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);	//add by luochangyang 2014/04/30
+
+    GTP_DEBUG_FUNC();
+
+    msg.flags = !I2C_M_RD;
+    msg.addr  = client->addr;
+    msg.len   = len;
+    msg.buf   = buf;
+    //msg.scl_rate = 300 * 1000;    // for Rockchip, etc
+
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, &msg, 1);
+        if (ret == 1)break;
+        retries++;
+    }
+    if((retries >= 5))
+    {
+    #if GTP_COMPATIBLE_MODE
+        struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    #endif
+    
+    #if GTP_GESTURE_WAKEUP
+	if (ts->wakeup_gesture == 1) {	//add by luochangyang 2014/04/30
+        if (DOZE_ENABLED == doze_status)
+        {
+            return ret;
+        }
+	}
+    #endif
+        GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d! Process reset.", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
+    #if GTP_COMPATIBLE_MODE
+        if (CHIP_TYPE_GT9F == ts->chip_type)
+        { 
+            gtp_recovery_reset(client);
+        }
+        else
+    #endif
+        {
+            gtp_reset_guitar(client, 10);  
+        }
+    }
+    return ret;
+}
+
+
+/*******************************************************
+Function:
+    i2c read twice, compare the results
+Input:
+    client:  i2c device
+    addr:    operate address
+    rxbuf:   read data to store, if compare successful
+    len:     bytes to read
+Output:
+    FAIL:    read failed
+    SUCCESS: read successful
+*********************************************************/
+s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
+{
+    u8 buf[16] = {0};
+    u8 confirm_buf[16] = {0};
+    u8 retry = 0;
+    
+    while (retry++ < 3)
+    {
+        memset(buf, 0xAA, 16);
+        buf[0] = (u8)(addr >> 8);
+        buf[1] = (u8)(addr & 0xFF);
+        gtp_i2c_read(client, buf, len + 2);
+        
+        memset(confirm_buf, 0xAB, 16);
+        confirm_buf[0] = (u8)(addr >> 8);
+        confirm_buf[1] = (u8)(addr & 0xFF);
+        gtp_i2c_read(client, confirm_buf, len + 2);
+        
+        if (!memcmp(buf, confirm_buf, len+2))
+        {
+            memcpy(rxbuf, confirm_buf+2, len);
+            return SUCCESS;
+        }
+    }    
+    GTP_ERROR("I2C read 0x%04X, %d bytes, double check failed!", addr, len);
+    return FAIL;
+}
+
+/*******************************************************
+Function:
+    Send config.
+Input:
+    client: i2c device.
+Output:
+    result of i2c write operation. 
+        1: succeed, otherwise: failed
+*********************************************************/
+
+s32 gtp_send_cfg(struct i2c_client *client)
+{
+    s32 ret = 2;
+
+#if GTP_DRIVER_SEND_CFG
+    s32 retry = 0;
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    if (ts->fixed_cfg)
+    {
+        GTP_INFO("Ic fixed config, no config sent!");
+        return 0;
+    }
+    else if (ts->pnl_init_error)
+    {
+        GTP_INFO("Error occured in init_panel, no config sent");
+        return 0;
+    }
+    
+    GTP_INFO("Driver send config.");
+    for (retry = 0; retry < 5; retry++)
+    {
+        ret = gtp_i2c_write(client, config , GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+        if (ret > 0)
+        {
+            break;
+        }
+    }
+#endif
+    return ret;
+}
+/*******************************************************
+Function:
+    Disable irq function
+Input:
+    ts: goodix i2c_client private data
+Output:
+    None.
+*********************************************************/
+void gtp_irq_disable(struct goodix_ts_data *ts)
+{
+    unsigned long irqflags;
+
+    GTP_DEBUG_FUNC();
+
+    spin_lock_irqsave(&ts->irq_lock, irqflags);
+    if (!ts->irq_is_disable)
+    {
+        ts->irq_is_disable = 1; 
+        //disable_irq_nosync(ts->client->irq);
+        disable_irq_wake(ts->client->irq);
+    }
+    spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+/*******************************************************
+Function:
+    Enable irq function
+Input:
+    ts: goodix i2c_client private data
+Output:
+    None.
+*********************************************************/
+void gtp_irq_enable(struct goodix_ts_data *ts)
+{
+    unsigned long irqflags = 0;
+
+    GTP_DEBUG_FUNC();
+    
+    spin_lock_irqsave(&ts->irq_lock, irqflags);
+    if (ts->irq_is_disable) 
+    {
+        //enable_irq(ts->client->irq);
+        enable_irq_wake(ts->client->irq);
+        ts->irq_is_disable = 0; 
+    }
+    spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+
+/*******************************************************
+Function:
+    Report touch point event 
+Input:
+    ts: goodix i2c_client private data
+    id: trackId
+    x:  input x coordinate
+    y:  input y coordinate
+    w:  input pressure
+Output:
+    None.
+*********************************************************/
+static void gtp_touch_down(struct goodix_ts_data* ts,s32 id,s32 x,s32 y,s32 w)
+{
+#if GTP_CHANGE_X2Y
+    GTP_SWAP(x, y);
+#endif
+
+#if GTP_ICS_SLOT_REPORT
+    input_mt_slot(ts->input_dev, id);
+    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
+    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
+    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
+    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+#else
+    input_report_key(ts->input_dev, BTN_TOUCH, 1);
+    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
+    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
+    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
+    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+    input_mt_sync(ts->input_dev);
+#endif
+
+    GTP_DEBUG("ID:%d, X:%d, Y:%d, W:%d", id, x, y, w);
+}
+
+/*******************************************************
+Function:
+    Report touch release event
+Input:
+    ts: goodix i2c_client private data
+Output:
+    None.
+*********************************************************/
+static void gtp_touch_up(struct goodix_ts_data* ts, s32 id)
+{
+#if GTP_ICS_SLOT_REPORT
+    input_mt_slot(ts->input_dev, id);
+    input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
+    GTP_DEBUG("Touch id[%2d] release!", id);
+#else
+    input_report_key(ts->input_dev, BTN_TOUCH, 0);
+#endif
+}
+
+#if GTP_WITH_PEN
+
+static void gtp_pen_init(struct goodix_ts_data *ts)
+{
+    s32 ret = 0;
+    
+    GTP_INFO("Request input device for pen/stylus.");
+    
+    ts->pen_dev = input_allocate_device();
+    if (ts->pen_dev == NULL)
+    {
+        GTP_ERROR("Failed to allocate input device for pen/stylus.");
+        return;
+    }
+    
+    ts->pen_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+    
+#if GTP_ICS_SLOT_REPORT
+    input_mt_init_slots(ts->pen_dev, 16);               // 
+#else
+    ts->pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+
+    set_bit(BTN_TOOL_PEN, ts->pen_dev->keybit);
+    set_bit(INPUT_PROP_DIRECT, ts->pen_dev->propbit);
+    //set_bit(INPUT_PROP_POINTER, ts->pen_dev->propbit);
+    
+#if GTP_PEN_HAVE_BUTTON
+    input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS);
+    input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS2);
+#endif
+
+    input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
+    input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);
+    input_set_abs_params(ts->pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+    input_set_abs_params(ts->pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(ts->pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+    
+    ts->pen_dev->name = "goodix-pen";
+    ts->pen_dev->id.bustype = BUS_I2C;
+    
+    ret = input_register_device(ts->pen_dev);
+    if (ret)
+    {
+        GTP_ERROR("Register %s input device failed", ts->pen_dev->name);
+        return;
+    }
+}
+
+static void gtp_pen_down(s32 x, s32 y, s32 w, s32 id)
+{
+    struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+#if GTP_CHANGE_X2Y
+    GTP_SWAP(x, y);
+#endif
+    
+    input_report_key(ts->pen_dev, BTN_TOOL_PEN, 1);
+#if GTP_ICS_SLOT_REPORT
+    input_mt_slot(ts->pen_dev, id);
+    input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+    input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+    input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+    input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+    input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+#else
+    input_report_key(ts->pen_dev, BTN_TOUCH, 1);
+    input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+    input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+    input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+    input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+    input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+    input_mt_sync(ts->pen_dev);
+#endif
+    GTP_DEBUG("(%d)(%d, %d)[%d]", id, x, y, w);
+}
+
+static void gtp_pen_up(s32 id)
+{
+    struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+    
+    input_report_key(ts->pen_dev, BTN_TOOL_PEN, 0);
+    
+#if GTP_ICS_SLOT_REPORT
+    input_mt_slot(ts->pen_dev, id);
+    input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, -1);
+#else
+    
+    input_report_key(ts->pen_dev, BTN_TOUCH, 0);
+#endif
+
+}
+#endif
+
+/*ZTEMT Added by luochangyang For charge detect, 2014/02/25*/
+#if GTP_CHARGER_SWITCH
+static void gtp_charger_switch(s32 dir_update)
+{
+    u32 chr_status = 0;
+    u8 chr_cmd[3] = {0x80, 0x40};
+    static u8 chr_pluggedin = 0;
+    int ret = 0;
+    
+#ifdef MT6573
+    chr_status = *(volatile u32 *)CHR_CON0;
+    chr_status &= (1 << 13);
+#else   // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
+    chr_status = upmu_is_chr_det();
+#endif
+    
+    if (chr_status)     // charger plugged in
+    {
+        if (!chr_pluggedin || dir_update)
+        {
+            chr_cmd[2] = 6;
+            ret = gtp_i2c_write(i2c_connect_client, chr_cmd, 3);
+            if (ret > 0)
+            {
+                GTP_INFO("Update status for Charger Plugin");
+            }
+            chr_pluggedin = 1;
+        }
+    }
+    else            // charger plugged out
+    {
+        if (chr_pluggedin || dir_update)
+        {
+            chr_cmd[2] = 7;
+            ret = gtp_i2c_write(i2c_connect_client, chr_cmd, 3);
+            if (ret > 0)
+            {
+                GTP_INFO("Update status for Charger Plugout");
+            }
+            chr_pluggedin = 0;
+        }
+    }
+}
+#endif
+/*ZTEMT END*/
+
+/*luochangyang 2014/04/30*/
+static ssize_t ztemt_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	ssize_t ret;
+
+	pr_info("----pdata->wakeup_gesture =%d\n", ts->wakeup_gesture);
+	
+	ret = sprintf(buf, "0x%02X\n", ts->wakeup_gesture);
+
+	return ret;
+}
+
+static ssize_t ztemt_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value > 0xFF && value < 0)
+		return -EINVAL;
+
+	ts->wakeup_gesture = (u8)value;
+
+	return size;
+}
+
+static DEVICE_ATTR(wakeup_gesture, 0664, ztemt_wakeup_gesture_show, ztemt_wakeup_gesture_store);
+/*luochangyang END*/
+
+
+/*******************************************************
+Function:
+    Goodix touchscreen work function
+Input:
+    work: work struct of goodix_workqueue
+Output:
+    None.
+*********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{
+    u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
+    u8  point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1]={GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF};
+    u8  touch_num = 0;
+    u8  finger = 0;
+    static u16 pre_touch = 0;
+    static u8 pre_key = 0;
+#if GTP_WITH_PEN
+    u8 pen_active = 0;
+    static u8 pre_pen = 0;
+#endif
+    u8  key_value = 0;
+    u8* coor_data = NULL;
+    s32 input_x = 0;
+    s32 input_y = 0;
+    s32 input_w = 0;
+    s32 id = 0;
+    s32 i  = 0;
+    s32 ret = -1;
+    struct goodix_ts_data *ts = NULL;
+
+#if GTP_COMPATIBLE_MODE
+    u8 rqst_buf[3] = {0x80, 0x43};  // for GT9XXF
+#endif
+
+#if GTP_GESTURE_WAKEUP
+    u8 doze_buf[3] = {0x81, 0x4B};
+#endif
+
+    GTP_DEBUG_FUNC();
+    ts = container_of(work, struct goodix_ts_data, work);
+    if (ts->enter_update)
+    {
+        return;
+    }
+
+/*ZTEMT Added by luochangyang For charge detect, 2014/02/25*/
+#if GTP_CHARGER_SWITCH
+    gtp_charger_switch(0);
+#endif
+/*ZTEMT END*/
+
+#if GTP_GESTURE_WAKEUP
+    if (ts->wakeup_gesture == 1 && DOZE_ENABLED == doze_status)	//add by luochangyang 2014/04/30
+    {               
+        ret = gtp_i2c_read(i2c_connect_client, doze_buf, 3);
+        GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
+        if (ret > 0)
+        {     
+            if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b') || (doze_buf[2] == 'c') ||
+                (doze_buf[2] == 'd') || (doze_buf[2] == 'e') || (doze_buf[2] == 'g') || 
+                (doze_buf[2] == 'h') || (doze_buf[2] == 'm') || (doze_buf[2] == 'o') ||
+                (doze_buf[2] == 'q') || (doze_buf[2] == 's') || (doze_buf[2] == 'v') || 
+                (doze_buf[2] == 'w') || (doze_buf[2] == 'y') || (doze_buf[2] == 'z') ||
+                (doze_buf[2] == 0x5E) /* ^ */
+                )
+            {
+                if (doze_buf[2] != 0x5E)
+                {
+                    GTP_INFO("Wakeup by gesture(%c), light up the screen!", doze_buf[2]);
+                }
+                else
+                {
+                    GTP_INFO("Wakeup by gesture(^), light up the screen!");
+                }
+                doze_status = DOZE_WAKEUP;
+                input_report_key(ts->input_dev, KEY_POWER, 1);
+                input_sync(ts->input_dev);
+                input_report_key(ts->input_dev, KEY_POWER, 0);
+                input_sync(ts->input_dev);
+                // clear 0x814B
+                doze_buf[2] = 0x00;
+                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			}
+			else if ( (doze_buf[2] == 0xAA) || (doze_buf[2] == 0xBB) ||
+				(doze_buf[2] == 0xAB) || (doze_buf[2] == 0xBA) )
+            {
+                char *direction[4] = {"Right", "Down", "Up", "Left"};
+                u8 type = ((doze_buf[2] & 0x0F) - 0x0A) + (((doze_buf[2] >> 4) & 0x0F) - 0x0A) * 2;
+                
+                GTP_INFO("%s slide to light up the screen!", direction[type]);
+                doze_status = DOZE_WAKEUP;
+                input_report_key(ts->input_dev, KEY_POWER, 1);
+                input_sync(ts->input_dev);
+                input_report_key(ts->input_dev, KEY_POWER, 0);
+                input_sync(ts->input_dev);
+                // clear 0x814B
+                doze_buf[2] = 0x00;
+                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+            }
+            else if (0xCC == doze_buf[2])
+            {
+                GTP_INFO("Double click to light up the screen!");
+                doze_status = DOZE_WAKEUP;
+#if 1
+				input_report_key(ts->input_dev, KEY_F10, 1);
+				input_sync(ts->input_dev);
+
+				input_report_key(ts->input_dev, KEY_F10, 0);
+				input_sync(ts->input_dev);
+#else
+                input_report_key(ts->input_dev, KEY_POWER, 1);
+                input_sync(ts->input_dev);
+                input_report_key(ts->input_dev, KEY_POWER, 0);
+                input_sync(ts->input_dev);
+#endif				
+                // clear 0x814B
+                doze_buf[2] = 0x00;
+                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+            }
+            else
+            {
+                // clear 0x814B
+                doze_buf[2] = 0x00;
+                gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+                gtp_enter_doze(ts);
+            }
+        }
+        if (ts->use_irq)
+        {
+            gtp_irq_enable(ts);
+        }
+        return;
+    }
+#endif
+
+    ret = gtp_i2c_read(ts->client, point_data, 12);
+    if (ret < 0)
+    {
+        GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
+        if (ts->use_irq)
+        {
+            gtp_irq_enable(ts);
+        }
+        return;
+    }
+    
+    finger = point_data[GTP_ADDR_LENGTH];
+
+#if GTP_COMPATIBLE_MODE
+    // GT9XXF
+    if ((finger == 0x00) && (CHIP_TYPE_GT9F == ts->chip_type))     // request arrived
+    {
+        ret = gtp_i2c_read(ts->client, rqst_buf, 3);
+        if (ret < 0)
+        {
+           GTP_ERROR("Read request status error!");
+           goto exit_work_func;
+        } 
+        
+        switch (rqst_buf[2])
+        {
+        case GTP_RQST_CONFIG:
+            GTP_INFO("Request for config.");
+            ret = gtp_send_cfg(ts->client);
+            if (ret < 0)
+            {
+                GTP_ERROR("Request for config unresponded!");
+            }
+            else
+            {
+                rqst_buf[2] = GTP_RQST_RESPONDED;
+                gtp_i2c_write(ts->client, rqst_buf, 3);
+                GTP_INFO("Request for config responded!");
+            }
+            break;
+            
+        case GTP_RQST_BAK_REF:
+            GTP_INFO("Request for backup reference.");
+            ts->rqst_processing = 1;
+            ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_SEND);
+            if (SUCCESS == ret)
+            {
+                rqst_buf[2] = GTP_RQST_RESPONDED;
+                gtp_i2c_write(ts->client, rqst_buf, 3);
+                ts->rqst_processing = 0;
+                GTP_INFO("Request for backup reference responded!");
+            }
+            else
+            {
+                GTP_ERROR("Requeset for backup reference unresponed!");
+            }
+            break;
+            
+        case GTP_RQST_RESET:
+            GTP_INFO("Request for reset.");
+            gtp_recovery_reset(ts->client);
+            break;
+            
+        case GTP_RQST_MAIN_CLOCK:
+            GTP_INFO("Request for main clock.");
+            ts->rqst_processing = 1;
+            ret = gtp_main_clk_proc(ts);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("Request for main clock unresponded!");
+            }
+            else
+            {
+                GTP_INFO("Request for main clock responded!");
+                rqst_buf[2] = GTP_RQST_RESPONDED;
+                gtp_i2c_write(ts->client, rqst_buf, 3);
+                ts->rqst_processing = 0;
+                ts->clk_chk_fs_times = 0;
+            }
+            break;
+            
+        default:
+            GTP_INFO("Undefined request: 0x%02X", rqst_buf[2]);
+            rqst_buf[2] = GTP_RQST_RESPONDED;  
+            gtp_i2c_write(ts->client, rqst_buf, 3);
+            break;
+        }
+    }
+#endif
+    if (finger == 0x00)
+    {
+        if (ts->use_irq)
+        {
+            gtp_irq_enable(ts);
+        }
+        return;
+    }
+
+    if((finger & 0x80) == 0)
+    {
+        goto exit_work_func;
+    }
+#if 1
+    /*ZTEMT Added by luochangyang, For palm to sleep 2014/02/19*/
+    if (finger & 0x40)      //0x814E bit6
+    {
+        /* For large area event */        
+#if 1
+		//report palm event
+		input_report_key(ts->input_dev, BTN_TOUCH, 1);
+		input_report_abs(ts->input_dev, ABS_MT_PRESSURE,300);
+		input_mt_sync(ts->input_dev);
+		input_sync(ts->input_dev);
+
+		input_report_key(ts->input_dev, BTN_TOUCH, 0);
+		input_sync(ts->input_dev);
+#else
+		input_report_key(ts->input_dev, KEY_POWER, 1);
+		input_sync(ts->input_dev);
+		
+		input_report_key(ts->input_dev, KEY_POWER, 0);
+		input_sync(ts->input_dev);
+#endif
+
+        //release finger
+        if(pre_touch)
+            gtp_touch_up(ts, 0);
+
+        pre_touch = 0;
+        pre_key = 0;
+
+        goto exit_work_func;
+    }
+    /*ZTEMT END*/
+#endif
+    touch_num = finger & 0x0f;
+    if (touch_num > GTP_MAX_TOUCH)
+    {
+        goto exit_work_func;
+    }
+
+    if (touch_num > 1)
+    {
+        u8 buf[8 * GTP_MAX_TOUCH] = {(GTP_READ_COOR_ADDR + 10) >> 8, (GTP_READ_COOR_ADDR + 10) & 0xff};
+
+        ret = gtp_i2c_read(ts->client, buf, 2 + 8 * (touch_num - 1)); 
+        memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
+    }
+
+#if (GTP_HAVE_TOUCH_KEY || GTP_PEN_HAVE_BUTTON)
+    key_value = point_data[3 + 8 * touch_num];
+    
+    if(key_value || pre_key)
+    {
+    #if GTP_PEN_HAVE_BUTTON
+        if (key_value == 0x40)
+        {
+            GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Down.");
+            input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+            input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+            pen_active = 1;
+        }
+        else if (key_value == 0x10)
+        {
+            GTP_DEBUG("BTN_STYLUS Down, BTN_STYLUS2 Up.");
+            input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+            input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+            pen_active = 1;
+        }
+        else if (key_value == 0x20)
+        {
+            GTP_DEBUG("BTN_STYLUS Up, BTN_STYLUS2 Down.");
+            input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+            input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+            pen_active = 1;
+        }
+        else
+        {
+            GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Up.");
+            input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+            input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+            if ( (pre_key == 0x40) || (pre_key == 0x20) ||
+                 (pre_key == 0x10) 
+               )
+            {
+                pen_active = 1;
+            }
+        }
+        if (pen_active)
+        {
+            touch_num = 0;      // shield pen point
+            //pre_touch = 0;    // clear last pen status
+        }
+    #endif
+    
+    #if GTP_HAVE_TOUCH_KEY
+        if (!pre_touch)
+        {
+            for (i = 0; i < GTP_MAX_KEY_NUM; i++)
+            {
+            #if GTP_DEBUG_ON
+                for (ret = 0; ret < 4; ++ret)
+                {
+                    if (key_codes[ret] == touch_key_array[i])
+                    {
+                        GTP_DEBUG("Key: %s %s", key_names[ret], (key_value & (0x01 << i)) ? "Down" : "Up");
+                        break;
+                    }
+                }
+            #endif
+                input_report_key(ts->input_dev, touch_key_array[i], key_value & (0x01<<i));   
+            }
+            touch_num = 0;  // shield fingers
+        }
+    #endif
+    }
+#endif
+    pre_key = key_value;
+
+    GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
+
+#if GTP_ICS_SLOT_REPORT
+
+#if GTP_WITH_PEN
+    if (pre_pen && (touch_num == 0))
+    {
+        GTP_DEBUG("Pen touch UP(Slot)!");
+        gtp_pen_up(0);
+        pen_active = 1;
+        pre_pen = 0;
+    }
+#endif
+    if (pre_touch || touch_num)
+    {
+        s32 pos = 0;
+        u16 touch_index = 0;
+        u8 report_num = 0;
+        coor_data = &point_data[3];
+        
+        if(touch_num)
+        {
+            id = coor_data[pos] & 0x0F;
+        
+        #if GTP_WITH_PEN
+            id = coor_data[pos];
+            if ((id & 0x80))  
+            {
+                GTP_DEBUG("Pen touch DOWN(Slot)!");
+                input_x  = coor_data[pos + 1] | (coor_data[pos + 2] << 8);
+                input_y  = coor_data[pos + 3] | (coor_data[pos + 4] << 8);
+                input_w  = coor_data[pos + 5] | (coor_data[pos + 6] << 8);
+                
+                gtp_pen_down(input_x, input_y, input_w, 0);
+                pre_pen = 1;
+                pre_touch = 0;
+                pen_active = 1;
+            }    
+        #endif
+        
+            touch_index |= (0x01<<id);
+        }
+        
+        GTP_DEBUG("id = %d,touch_index = 0x%x, pre_touch = 0x%x\n",id, touch_index,pre_touch);
+        for (i = 0; i < GTP_MAX_TOUCH; i++)
+        {
+        #if GTP_WITH_PEN
+            if (pre_pen == 1)
+            {
+                break;
+            }
+        #endif
+        
+            if ((touch_index & (0x01<<i)))
+            {
+                input_x  = coor_data[pos + 1] | (coor_data[pos + 2] << 8);
+                input_y  = coor_data[pos + 3] | (coor_data[pos + 4] << 8);
+                input_w  = coor_data[pos + 5] | (coor_data[pos + 6] << 8);
+
+                gtp_touch_down(ts, id, input_x, input_y, input_w);
+                pre_touch |= 0x01 << i;
+                
+                report_num++;
+                if (report_num < touch_num)
+                {
+                    pos += 8;
+                    id = coor_data[pos] & 0x0F;
+                    touch_index |= (0x01<<id);
+                }
+            }
+            else
+            {
+                gtp_touch_up(ts, i);
+                pre_touch &= ~(0x01 << i);
+            }
+        }
+    }
+#else
+
+    if (touch_num)
+    {
+        for (i = 0; i < touch_num; i++)
+        {
+            coor_data = &point_data[i * 8 + 3];
+
+            id = coor_data[0] & 0x0F;
+            input_x  = coor_data[1] | (coor_data[2] << 8);
+            input_y  = coor_data[3] | (coor_data[4] << 8);
+            input_w  = coor_data[5] | (coor_data[6] << 8);
+        
+        #if GTP_WITH_PEN
+            id = coor_data[0];
+            if (id & 0x80)
+            {
+                GTP_DEBUG("Pen touch DOWN!");
+                gtp_pen_down(input_x, input_y, input_w, 0);
+                pre_pen = 1;
+                pen_active = 1;
+                break;
+            }
+            else
+        #endif
+            {
+                gtp_touch_down(ts, id, input_x, input_y, input_w);
+            }
+        }
+    }
+    else if (pre_touch)
+    {
+    #if GTP_WITH_PEN
+        if (pre_pen == 1)
+        {
+            GTP_DEBUG("Pen touch UP!");
+            gtp_pen_up(0);
+            pre_pen = 0;
+            pen_active = 1;
+        }
+        else
+    #endif
+        {
+            GTP_DEBUG("Touch Release!");
+            gtp_touch_up(ts, 0);
+        }
+    }
+
+    pre_touch = touch_num;
+#endif
+
+#if GTP_WITH_PEN
+    if (pen_active)
+    {
+        pen_active = 0;
+        input_sync(ts->pen_dev);
+    }
+    else
+#endif
+    {
+        input_sync(ts->input_dev);
+    }
+
+exit_work_func:
+    if(!ts->gtp_rawdiff_mode)
+    {
+        ret = gtp_i2c_write(ts->client, end_cmd, 3);
+        if (ret < 0)
+        {
+            GTP_INFO("I2C write end_cmd error!");
+        }
+    }
+    if (ts->use_irq)
+    {
+        gtp_irq_enable(ts);
+    }
+}
+
+/*******************************************************
+Function:
+    Timer interrupt service routine for polling mode.
+Input:
+    timer: timer struct pointer
+Output:
+    Timer work mode. 
+        HRTIMER_NORESTART: no restart mode
+*********************************************************/
+static enum hrtimer_restart goodix_ts_timer_handler(struct hrtimer *timer)
+{
+    struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
+
+    GTP_DEBUG_FUNC();
+
+    queue_work(goodix_wq, &ts->work);
+    hrtimer_start(&ts->timer, ktime_set(0, (GTP_POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+    return HRTIMER_NORESTART;
+}
+
+/*******************************************************
+Function:
+    External interrupt service routine for interrupt mode.
+Input:
+    irq:  interrupt number.
+    dev_id: private data pointer
+Output:
+    Handle Result.
+        IRQ_HANDLED: interrupt handled successfully
+*********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+    struct goodix_ts_data *ts = dev_id;
+
+    GTP_DEBUG_FUNC();
+ 
+    gtp_irq_disable(ts);
+
+    queue_work(goodix_wq, &ts->work);
+    
+    return IRQ_HANDLED;
+}
+/*******************************************************
+Function:
+    Synchronization.
+Input:
+    ms: synchronization time in millisecond.
+Output:
+    None.
+*******************************************************/
+void gtp_int_sync(s32 ms)
+{
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+    msleep(ms);
+    GTP_GPIO_AS_INT(GTP_INT_PORT);
+}
+
+
+/*******************************************************
+Function:
+    Reset chip.
+Input:
+    ms: reset time in millisecond
+Output:
+    None.
+*******************************************************/
+void gtp_reset_guitar(struct i2c_client *client, s32 ms)
+{
+#if GTP_COMPATIBLE_MODE
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#endif    
+
+    GTP_DEBUG_FUNC();
+    GTP_INFO("Guitar reset");
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   // begin select I2C slave addr
+    msleep(ms);                         // T2: > 10ms
+    // HIGH: 0x28/0x29, LOW: 0xBA/0xBB
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, client->addr == 0x14);
+
+    msleep(2);                          // T3: > 100us
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
+    
+    msleep(6);                          // T4: > 5ms
+
+    GTP_GPIO_AS_INPUT(GTP_RST_PORT);    // end select I2C slave addr
+
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        return;
+    }
+#endif
+
+    gtp_int_sync(50);  
+#if GTP_ESD_PROTECT
+    gtp_init_ext_watchdog(client);
+#endif
+}
+
+#if GTP_GESTURE_WAKEUP
+/*******************************************************
+Function:
+    Enter doze mode for sliding wakeup.
+Input:
+    ts: goodix tp private data
+Output:
+    1: succeed, otherwise failed
+*******************************************************/
+static s8 gtp_enter_doze(struct goodix_ts_data *ts)
+{
+    s8 ret = -1;
+    s8 retry = 0;
+    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 8};
+
+    GTP_DEBUG_FUNC();
+
+    GTP_DEBUG("Entering gesture mode.");
+    while(retry++ < 5)
+    {
+        i2c_control_buf[0] = 0x80;
+        i2c_control_buf[1] = 0x46;
+        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+        if (ret < 0)
+        {
+            GTP_DEBUG("failed to set doze flag into 0x8046, %d", retry);
+            continue;
+        }
+        i2c_control_buf[0] = 0x80;
+        i2c_control_buf[1] = 0x40;
+        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+        if (ret > 0)
+        {
+            doze_status = DOZE_ENABLED;
+            GTP_INFO("Gesture mode enabled.");
+            return ret;
+        }
+        msleep(10);
+    }
+    GTP_ERROR("GTP send gesture cmd failed.");
+    return ret;
+}
+//#else 
+/*******************************************************
+Function:
+    Enter sleep mode.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+       1: succeed, otherwise failed.
+*******************************************************/
+static s8 gtp_enter_sleep(struct goodix_ts_data * ts)
+{
+    s8 ret = -1;
+    s8 retry = 0;
+    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
+
+#if GTP_COMPATIBLE_MODE
+    u8 status_buf[3] = {0x80, 0x44};
+#endif
+    
+    GTP_DEBUG_FUNC();
+    
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        // GT9XXF: host interact with ic
+        ret = gtp_i2c_read(ts->client, status_buf, 3);
+        if (ret < 0)
+        {
+            GTP_ERROR("failed to get backup-reference status");
+        }
+        
+        if (status_buf[2] & 0x80)
+        {
+            ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_STORE);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("failed to store bak_ref");
+            }
+        }
+    }
+#endif
+
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+    msleep(5);
+    
+    while(retry++ < 5)
+    {
+        ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+        if (ret > 0)
+        {
+            GTP_INFO("GTP enter sleep!");
+            
+            return ret;
+        }
+        msleep(10);
+    }
+    GTP_ERROR("GTP send sleep cmd failed.");
+    return ret;
+}
+#endif 
+/*******************************************************
+Function:
+    Wakeup from sleep.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+        >0: succeed, otherwise: failed.
+*******************************************************/
+static s8 gtp_wakeup_sleep(struct goodix_ts_data * ts)
+{
+    u8 retry = 0;
+    s8 ret = -1;
+    
+    GTP_DEBUG_FUNC();
+
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        u8 opr_buf[3] = {0x41, 0x80};
+        
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+        msleep(5);
+    
+        for (retry = 0; retry < 10; ++retry)
+        {
+            // hold ss51 & dsp
+            opr_buf[2] = 0x0C;
+            ret = gtp_i2c_write(ts->client, opr_buf, 3);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("failed to hold ss51 & dsp!");
+                continue;
+            }
+            opr_buf[2] = 0x00;
+            ret = gtp_i2c_read(ts->client, opr_buf, 3);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("failed to get ss51 & dsp status!");
+                continue;
+            }
+            if (0x0C != opr_buf[2])
+            {
+                GTP_DEBUG("ss51 & dsp not been hold, %d", retry+1);
+                continue;
+            }
+            GTP_DEBUG("ss51 & dsp confirmed hold");
+            
+            ret = gtp_fw_startup(ts->client);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("failed to startup GT9XXF, process recovery");
+                gtp_esd_recovery(ts->client);
+            }
+            break;
+        }
+        if (retry >= 10)
+        {
+            GTP_ERROR("failed to wakeup, processing esd recovery");
+            gtp_esd_recovery(ts->client);
+        }
+        else
+        {
+            GTP_INFO("GT9XXF gtp wakeup success");
+        }
+        return ret;
+    }
+#endif
+
+#if GTP_POWER_CTRL_SLEEP
+    while(retry++ < 5)
+    {
+        gtp_reset_guitar(ts->client, 20);
+        
+        GTP_INFO("GTP wakeup sleep.");
+        return 1;
+    }
+#else
+    while(retry++ < 10)
+    {
+    #if GTP_GESTURE_WAKEUP
+	if (ts->wakeup_gesture == 1) {	//add by luochangyang 2014/04/30
+        if (DOZE_WAKEUP != doze_status)  
+        {
+            GTP_INFO("Powerkey wakeup.");
+        }
+        else   
+        {
+            GTP_INFO("Gesture wakeup.");
+        }
+        doze_status = DOZE_DISABLED;
+		if (ts->enter_update == 0) {	//if not this, FW update would fail	add by luochangyang 2014/04/30
+	        gtp_irq_disable(ts);
+	        gtp_reset_guitar(ts->client, 10);
+	        gtp_irq_enable(ts);
+		}
+	} else {
+    //#else
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+        msleep(5);
+	}
+    #endif
+    
+        ret = gtp_i2c_test(ts->client);
+        if (ret > 0)
+        {
+            GTP_INFO("GTP wakeup sleep.");
+            
+        //#if (!GTP_GESTURE_WAKEUP)
+		if (ts->wakeup_gesture == 0) {	//add by luochangyang 2014/04/30
+            {
+                gtp_int_sync(25);
+            #if GTP_ESD_PROTECT
+                gtp_init_ext_watchdog(ts->client);
+            #endif
+            }
+		}
+        //#endif
+            
+            return ret;
+        }
+        gtp_reset_guitar(ts->client, 20);
+    }
+#endif
+
+    GTP_ERROR("GTP wakeup sleep failed.");
+    return ret;
+}
+#if GTP_DRIVER_SEND_CFG
+static s32 gtp_get_info(struct goodix_ts_data *ts)
+{
+    u8 opr_buf[6] = {0};
+    s32 ret = 0;
+    
+    ts->abs_x_max = GTP_MAX_WIDTH;
+    ts->abs_y_max = GTP_MAX_HEIGHT;
+    ts->int_trigger_type = GTP_INT_TRIGGER;
+        
+    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+1) >> 8);
+    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+1) & 0xFF);
+    
+    ret = gtp_i2c_read(ts->client, opr_buf, 6);
+    if (ret < 0)
+    {
+        return FAIL;
+    }
+    
+    ts->abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
+    ts->abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
+    
+    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+6) >> 8);
+    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+6) & 0xFF);
+    
+    ret = gtp_i2c_read(ts->client, opr_buf, 3);
+    if (ret < 0)
+    {
+        return FAIL;
+    }
+    ts->int_trigger_type = opr_buf[2] & 0x03;
+    
+    GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+            ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
+    
+    return SUCCESS;    
+}
+#endif 
+
+/*******************************************************
+Function:
+    Initialize gtp.
+Input:
+    ts: goodix private data
+Output:
+    Executive outcomes.
+        0: succeed, otherwise: failed
+*******************************************************/
+static s32 gtp_init_panel(struct goodix_ts_data *ts)
+{
+    s32 ret = -1;
+
+#if GTP_DRIVER_SEND_CFG
+    s32 i = 0;
+    u8 check_sum = 0;
+    u8 opr_buf[16] = {0};
+    u8 sensor_id = 0; 
+    
+    u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+    u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+    u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+    u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+    u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+    u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+    u8 *send_cfg_buf[] = {cfg_info_group1, cfg_info_group2, cfg_info_group3,
+                        cfg_info_group4, cfg_info_group5, cfg_info_group6};
+    u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1),
+                          CFG_GROUP_LEN(cfg_info_group2),
+                          CFG_GROUP_LEN(cfg_info_group3),
+                          CFG_GROUP_LEN(cfg_info_group4),
+                          CFG_GROUP_LEN(cfg_info_group5),
+                          CFG_GROUP_LEN(cfg_info_group6)};
+
+    GTP_DEBUG_FUNC();
+    GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d", 
+        cfg_info_len[0], cfg_info_len[1], cfg_info_len[2], cfg_info_len[3],
+        cfg_info_len[4], cfg_info_len[5]);
+
+    
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        ts->fw_error = 0;
+    }
+    else
+#endif
+    {
+        ret = gtp_i2c_read_dbl_check(ts->client, 0x41E4, opr_buf, 1);
+        if (SUCCESS == ret) 
+        {
+            if (opr_buf[0] != 0xBE)
+            {
+                ts->fw_error = 1;
+                GTP_ERROR("Firmware error, no config sent!");
+                return -1;
+            }
+        }
+    }
+
+    if ((!cfg_info_len[1]) && (!cfg_info_len[2]) && 
+        (!cfg_info_len[3]) && (!cfg_info_len[4]) && 
+        (!cfg_info_len[5]))
+    {
+        sensor_id = 0; 
+    }
+    else
+    {
+    #if GTP_COMPATIBLE_MODE
+        msleep(50);
+    #endif
+        ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID, &sensor_id, 1);
+        if (SUCCESS == ret)
+        {
+            if (sensor_id >= 0x06)
+            {
+                GTP_ERROR("Invalid sensor_id(0x%02X), No Config Sent!", sensor_id);
+                ts->pnl_init_error = 1;
+                return -1;
+            }
+        }
+        else
+        {
+            GTP_ERROR("Failed to get sensor_id, No config sent!");
+            ts->pnl_init_error = 1;
+            return -1;
+        }
+        GTP_ERROR("Sensor_ID: %d", sensor_id);
+    }
+    ts->gtp_cfg_len = cfg_info_len[sensor_id];
+    GTP_ERROR("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1, ts->gtp_cfg_len);
+    sensor_manufacture = sensor_id + 1;
+    if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH)
+    {
+        GTP_ERROR("Config Group%d is INVALID CONFIG GROUP(Len: %d)! NO Config Sent! You need to check you header file CFG_GROUP section!", sensor_id+1, ts->gtp_cfg_len);
+        ts->pnl_init_error = 1;
+        return -1;
+    }
+
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        ts->fixed_cfg = 0;
+    }
+    else
+#endif
+    {
+        ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA, &opr_buf[0], 1);
+        
+        if (ret == SUCCESS)
+        {
+            GTP_DEBUG("CFG_GROUP%d Config Version: %d, 0x%02X; IC Config Version: %d, 0x%02X", sensor_id+1, 
+                        send_cfg_buf[sensor_id][0], send_cfg_buf[sensor_id][0], opr_buf[0], opr_buf[0]);
+            
+            if (opr_buf[0] < 90)    
+            {
+                gtp_cfg_version = send_cfg_buf[sensor_id][0];       // backup group config version
+                send_cfg_buf[sensor_id][0] = 0x00;
+                ts->fixed_cfg = 0;
+            }
+            else        // treated as fixed config, not send config
+            {
+                GTP_INFO("Ic fixed config with config version(%d, 0x%02X)", opr_buf[0], opr_buf[0]);
+                ts->fixed_cfg = 1;
+                gtp_get_info(ts);
+                return 0;
+            }
+        }
+        else
+        {
+            GTP_ERROR("Failed to get ic config version!No config sent!");
+            return -1;
+        }
+    }
+    
+    memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+    memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id], ts->gtp_cfg_len);
+
+#if GTP_CUSTOM_CFG
+    config[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
+    config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
+    config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
+    config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
+    
+    if (GTP_INT_TRIGGER == 0)  //RISING
+    {
+        config[TRIGGER_LOC] &= 0xfe; 
+    }
+    else if (GTP_INT_TRIGGER == 1)  //FALLING
+    {
+        config[TRIGGER_LOC] |= 0x01;
+    }
+#endif  // GTP_CUSTOM_CFG
+    
+    check_sum = 0;
+    for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
+    {
+        check_sum += config[i];
+    }
+    config[ts->gtp_cfg_len] = (~check_sum) + 1;
+
+#else // driver not send config
+
+    ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
+    ret = gtp_i2c_read(ts->client, config, ts->gtp_cfg_len + GTP_ADDR_LENGTH);
+    if (ret < 0)
+    {
+        GTP_ERROR("Read Config Failed, Using Default Resolution & INT Trigger!");
+        ts->abs_x_max = GTP_MAX_WIDTH;
+        ts->abs_y_max = GTP_MAX_HEIGHT;
+        ts->int_trigger_type = GTP_INT_TRIGGER;
+    }
+    
+#endif // GTP_DRIVER_SEND_CFG
+
+    if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0))
+    {
+        ts->abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
+        ts->abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
+        ts->int_trigger_type = (config[TRIGGER_LOC]) & 0x03; 
+    }
+
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        u8 sensor_num = 0;
+        u8 driver_num = 0;
+        u8 have_key = 0;
+        
+        have_key = (config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01);
+        
+        if (1 == ts->is_950)
+        {
+            driver_num = config[GTP_REG_MATRIX_DRVNUM - GTP_REG_CONFIG_DATA + 2];
+            sensor_num = config[GTP_REG_MATRIX_SENNUM - GTP_REG_CONFIG_DATA + 2];
+            if (have_key)
+            {
+                driver_num--;
+            }
+            ts->bak_ref_len = (driver_num * (sensor_num - 1) + 2) * 2 * 6;
+        }
+        else
+        {
+            driver_num = (config[CFG_LOC_DRVA_NUM] & 0x1F) + (config[CFG_LOC_DRVB_NUM]&0x1F);
+            if (have_key)
+            {
+                driver_num--;
+            }
+            sensor_num = (config[CFG_LOC_SENS_NUM] & 0x0F) + ((config[CFG_LOC_SENS_NUM] >> 4) & 0x0F);
+            ts->bak_ref_len = (driver_num * (sensor_num - 2) + 2) * 2;
+        }
+    
+        GTP_INFO("Drv * Sen: %d * %d(key: %d), X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x",
+           driver_num, sensor_num, have_key, ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
+        return 0;
+    }
+    else
+#endif
+    {
+    #if GTP_DRIVER_SEND_CFG
+        ret = gtp_send_cfg(ts->client);
+        if (ret < 0)
+        {
+            GTP_ERROR("Send config error.");
+        }
+        // set config version to CTP_CFG_GROUP, for resume to send config
+        config[GTP_ADDR_LENGTH] = gtp_cfg_version;
+        check_sum = 0;
+        for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
+        {
+            check_sum += config[i];
+        }
+        config[ts->gtp_cfg_len] = (~check_sum) + 1;
+    #endif
+        GTP_INFO("X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x", ts->abs_x_max,ts->abs_y_max,ts->int_trigger_type);
+    }
+    
+    msleep(10);
+    return 0;
+}
+
+
+static ssize_t gt91xx_config_read_proc(struct file *file, char __user *page, size_t size, loff_t *ppos)
+{
+    char *ptr = page;
+    char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = {0x80, 0x47};
+    int i;
+    
+    if (*ppos)
+    {
+        return 0;
+    }
+    ptr += sprintf(ptr, "==== GT9XX config init value====\n");
+
+    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
+    {
+        ptr += sprintf(ptr, "0x%02X ", config[i + 2]);
+
+        if (i % 8 == 7)
+            ptr += sprintf(ptr, "\n");
+    }
+
+    ptr += sprintf(ptr, "\n");
+
+    ptr += sprintf(ptr, "==== GT9XX config real value====\n");
+    gtp_i2c_read(i2c_connect_client, temp_data, GTP_CONFIG_MAX_LENGTH + 2);
+    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
+    {
+        ptr += sprintf(ptr, "0x%02X ", temp_data[i+2]);
+
+        if (i % 8 == 7)
+            ptr += sprintf(ptr, "\n");
+    }
+    *ppos += ptr - page;
+    return (ptr - page);
+}
+
+static ssize_t gt91xx_config_write_proc(struct file *filp, const char __user *buffer, size_t count, loff_t *off)
+{
+    s32 ret = 0;
+
+    GTP_DEBUG("write count %d\n", count);
+
+    if (count > GTP_CONFIG_MAX_LENGTH)
+    {
+        GTP_ERROR("size not match [%d:%d]\n", GTP_CONFIG_MAX_LENGTH, count);
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&config[2], buffer, count))
+    {
+        GTP_ERROR("copy from user fail\n");
+        return -EFAULT;
+    }
+
+    ret = gtp_send_cfg(i2c_connect_client);
+
+    if (ret < 0)
+    {
+        GTP_ERROR("send config failed.");
+    }
+
+    return count;
+}
+/*******************************************************
+Function:
+    Read chip version.
+Input:
+    client:  i2c device
+    version: buffer to keep ic firmware version
+Output:
+    read operation return.
+        2: succeed, otherwise: failed
+*******************************************************/
+s32 gtp_read_version(struct i2c_client *client, u16* version)
+{
+    s32 ret = -1;
+    u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
+	
+	/*ZTEMT Added by luochangyang, 2014/04/25*/
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    /*ZTEMT END*/
+
+    GTP_DEBUG_FUNC();
+
+    ret = gtp_i2c_read(client, buf, sizeof(buf));
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP read version failed");
+        return ret;
+    }
+
+    if (version)
+    {
+        *version = (buf[7] << 8) | buf[6];
+    }
+    if (buf[5] == 0x00)
+    {
+        GTP_INFO("IC Version: %c%c%c_%02x%02x", buf[2], buf[3], buf[4], buf[7], buf[6]);
+    }
+    else
+    {
+        GTP_INFO("IC Version: %c%c%c%c_%02x%02x\n", buf[2], buf[3], buf[4], buf[5], buf[7], buf[6]);
+    }
+
+	/*ZTEMT Added by luochangyang, 2014/04/25*/
+	gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA, &(ts->ic_cfg_version), 1);
+    GTP_INFO("IC ic_cfg_version: %d\n", ts->ic_cfg_version);
+    /*ZTEMT END*/
+	
+    return ret;
+}
+
+/*******************************************************
+Function:
+    I2c test Function.
+Input:
+    client:i2c client.
+Output:
+    Executive outcomes.
+        2: succeed, otherwise failed.
+*******************************************************/
+static s8 gtp_i2c_test(struct i2c_client *client)
+{
+    u8 test[3] = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
+    u8 retry = 0;
+    s8 ret = -1;
+  
+    GTP_DEBUG_FUNC();
+  
+    while(retry++ < 5)
+    {
+        ret = gtp_i2c_read(client, test, 3);
+        if (ret > 0)
+        {
+            return ret;
+        }
+        GTP_ERROR("GTP i2c test failed time %d.",retry);
+        msleep(10);
+    }
+    return ret;
+}
+
+/*******************************************************
+Function:
+    Request gpio(INT & RST) ports.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+        >= 0: succeed, < 0: failed
+*******************************************************/
+static s8 gtp_request_io_port(struct goodix_ts_data *ts)
+{
+    s32 ret = 0;
+
+    GTP_DEBUG_FUNC();
+    ret = GTP_GPIO_REQUEST(GTP_INT_PORT, "GTP_INT_IRQ");
+    if (ret < 0) 
+    {
+        GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d", (s32)GTP_INT_PORT, ret);
+        ret = -ENODEV;
+    }
+    else
+    {
+        GTP_GPIO_AS_INT(GTP_INT_PORT);  
+        ts->client->irq = GTP_INT_IRQ;
+    }
+
+    ret = GTP_GPIO_REQUEST(GTP_RST_PORT, "GTP_RST_PORT");
+    if (ret < 0) 
+    {
+        GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",(s32)GTP_RST_PORT,ret);
+        ret = -ENODEV;
+    }
+
+    GTP_GPIO_AS_INPUT(GTP_RST_PORT);
+
+    gtp_reset_guitar(ts->client, 20);
+    
+    if(ret < 0)
+    {
+        GTP_GPIO_FREE(GTP_RST_PORT);
+        GTP_GPIO_FREE(GTP_INT_PORT);
+    }
+
+    return ret;
+}
+
+/*******************************************************
+Function:
+    Request interrupt.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+        0: succeed, -1: failed.
+*******************************************************/
+static s8 gtp_request_irq(struct goodix_ts_data *ts)
+{
+    s32 ret = -1;
+    const u8 irq_table[] = GTP_IRQ_TAB;
+
+    GTP_DEBUG_FUNC();
+    GTP_DEBUG("INT trigger type:%x", ts->int_trigger_type);
+
+    ret  = request_irq(ts->client->irq, 
+                       goodix_ts_irq_handler,
+                       irq_table[ts->int_trigger_type],
+                       ts->client->name,
+                       ts);
+    if (ret)
+    {
+        GTP_ERROR("Request IRQ failed!ERRNO:%d.", ret);
+        GTP_GPIO_AS_INPUT(GTP_INT_PORT);
+        GTP_GPIO_FREE(GTP_INT_PORT);
+
+        hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+        ts->timer.function = goodix_ts_timer_handler;
+        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+        return -1;
+    }
+    else 
+    {
+        gtp_irq_disable(ts);
+        ts->use_irq = 1;
+        return 0;
+    }
+}
+
+/*******************************************************
+Function:
+    Request input device Function.
+Input:
+    ts:private data.
+Output:
+    Executive outcomes.
+        0: succeed, otherwise: failed.
+*******************************************************/
+static s8 gtp_request_input_dev(struct goodix_ts_data *ts)
+{
+    s8 ret = -1;
+    s8 phys[32];
+#if GTP_HAVE_TOUCH_KEY
+    u8 index = 0;
+#endif
+  
+    GTP_DEBUG_FUNC();
+  
+    ts->input_dev = input_allocate_device();
+    if (ts->input_dev == NULL)
+    {
+        GTP_ERROR("Failed to allocate input device.");
+        return -ENOMEM;
+    }
+
+    ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+#if GTP_ICS_SLOT_REPORT
+    input_mt_init_slots(ts->input_dev, 16);     // in case of "out of memory"
+#else
+    ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+    __set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+
+#if GTP_HAVE_TOUCH_KEY
+    for (index = 0; index < GTP_MAX_KEY_NUM; index++)
+    {
+        input_set_capability(ts->input_dev, EV_KEY, touch_key_array[index]);  
+    }
+#endif
+
+    input_set_capability(ts->input_dev, EV_KEY, KEY_F10); //Added by luochangyang, 2014/02/19
+
+#if GTP_GESTURE_WAKEUP
+    input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+#endif 
+
+#if GTP_CHANGE_X2Y
+    GTP_SWAP(ts->abs_x_max, ts->abs_y_max);
+#endif
+
+    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+    sprintf(phys, "input/ts");
+    ts->input_dev->name = goodix_ts_name;
+    ts->input_dev->phys = phys;
+    ts->input_dev->id.bustype = BUS_I2C;
+    ts->input_dev->id.vendor = 0xDEAD;
+    ts->input_dev->id.product = 0xBEEF;
+    ts->input_dev->id.version = 10427;
+    
+    ret = input_register_device(ts->input_dev);
+    if (ret)
+    {
+        GTP_ERROR("Register %s input device failed", ts->input_dev->name);
+        return -ENODEV;
+    }
+    
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#if defined(CONFIG_FB)
+    ts->fb_notif.notifier_call = fb_notifier_callback;
+    ret = fb_register_client(&ts->fb_notif);
+    if (ret)
+        dev_err(&ts->client->dev,
+            "Unable to register fb_notifier: %d\n",
+            ret);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*ZTEMT END*/
+    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    ts->early_suspend.suspend = goodix_ts_early_suspend;
+    ts->early_suspend.resume = goodix_ts_late_resume;
+    register_early_suspend(&ts->early_suspend);
+#endif
+
+#if GTP_WITH_PEN
+    gtp_pen_init(ts);
+#endif
+
+    return 0;
+}
+
+//************** For GT9XXF Start *************//
+#if GTP_COMPATIBLE_MODE
+
+s32 gtp_fw_startup(struct i2c_client *client)
+{
+    u8 opr_buf[4];
+    s32 ret = 0;
+    
+    //init sw WDT
+	opr_buf[0] = 0xAA;
+	ret = i2c_write_bytes(client, 0x8041, opr_buf, 1);
+    if (ret < 0)
+    {
+        return FAIL;
+    }
+    
+    //release SS51 & DSP
+    opr_buf[0] = 0x00;
+    ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
+    if (ret < 0)
+    {
+        return FAIL;
+    }
+    //int sync
+    gtp_int_sync(25);  
+    
+    //check fw run status
+    ret = i2c_read_bytes(client, 0x8041, opr_buf, 1);
+    if (ret < 0)
+    {
+        return FAIL;
+    }
+    if(0xAA == opr_buf[0])
+    {
+        GTP_ERROR("IC works abnormally,startup failed.");
+        return FAIL;
+    }
+    else
+    {
+        GTP_INFO("IC works normally, Startup success.");
+        opr_buf[0] = 0xAA;
+        i2c_write_bytes(client, 0x8041, opr_buf, 1);
+        return SUCCESS;
+    }
+}
+
+static s32 gtp_esd_recovery(struct i2c_client *client)
+{
+    s32 retry = 0;
+    s32 ret = 0;
+    struct goodix_ts_data *ts;
+    
+    ts = i2c_get_clientdata(client);
+    
+    gtp_irq_disable(ts);
+    
+    GTP_INFO("GT9XXF esd recovery mode");
+    for (retry = 0; retry < 5; retry++)
+    {
+        ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY); 
+        if (FAIL == ret)
+        {
+            GTP_ERROR("esd recovery failed %d", retry+1);
+            continue;
+        }
+        ret = gtp_fw_startup(ts->client);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("GT9XXF start up failed %d", retry+1);
+            continue;
+        }
+        break;
+    }
+    gtp_irq_enable(ts);
+    
+    if (retry >= 5)
+    {
+        GTP_ERROR("failed to esd recovery");
+        return FAIL;
+    }
+    
+    GTP_INFO("Esd recovery successful");
+    return SUCCESS;
+}
+
+void gtp_recovery_reset(struct i2c_client *client)
+{
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(client, SWITCH_OFF);
+#endif
+    GTP_DEBUG_FUNC();
+    
+    gtp_esd_recovery(client); 
+    
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(client, SWITCH_ON);
+#endif
+}
+
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    s32 j = 0;
+    u16 ref_sum = 0;
+    u16 learn_cnt = 0;
+    u16 chksum = 0;
+    s32 ref_seg_len = 0;
+    s32 ref_grps = 0;
+    struct file *ref_filp = NULL;
+    u8 *p_bak_ref;
+    
+    ret = gup_check_fs_mounted("/data");
+    if (FAIL == ret)
+    {
+        ts->ref_chk_fs_times++;
+        GTP_DEBUG("Ref check /data times/MAX_TIMES: %d / %d", ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+        if (ts->ref_chk_fs_times < GTP_CHK_FS_MNT_MAX)
+        {
+            msleep(50);
+            GTP_INFO("/data not mounted.");
+            return FAIL;
+        }
+        GTP_INFO("check /data mount timeout...");
+    }
+    else
+    {
+        GTP_INFO("/data mounted!!!(%d/%d)", ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+    }
+    
+    p_bak_ref = (u8 *)kzalloc(ts->bak_ref_len, GFP_KERNEL);
+    
+    if (NULL == p_bak_ref)
+    {
+        GTP_ERROR("Allocate memory for p_bak_ref failed!");
+        return FAIL;
+    }
+    
+    if (ts->is_950)
+    {
+        ref_seg_len = ts->bak_ref_len / 6;
+        ref_grps = 6;
+    }
+    else
+    {
+        ref_seg_len = ts->bak_ref_len;
+        ref_grps = 1;
+    }
+    ref_filp = filp_open(GTP_BAK_REF_PATH, O_RDWR | O_CREAT, 0666);
+    if (IS_ERR(ref_filp))
+    { 
+        GTP_ERROR("Failed to open/create %s.", GTP_BAK_REF_PATH);
+        if (GTP_BAK_REF_SEND == mode)
+        {
+            goto bak_ref_default;
+        }
+        else
+        {
+            goto bak_ref_exit;
+        }
+    }
+    
+    switch (mode)
+    {
+    case GTP_BAK_REF_SEND:
+        GTP_INFO("Send backup-reference");
+        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+        ret = ref_filp->f_op->read(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
+        if (ret < 0)
+        {
+            GTP_ERROR("failed to read bak_ref info from file, sending defualt bak_ref");
+            goto bak_ref_default;
+        }
+        for (j = 0; j < ref_grps; ++j)
+        {
+            ref_sum = 0;
+            for (i = 0; i < (ref_seg_len); i += 2)
+            {
+                ref_sum += (p_bak_ref[i + j * ref_seg_len] << 8) + p_bak_ref[i+1 + j * ref_seg_len];
+            }
+            learn_cnt = (p_bak_ref[j * ref_seg_len + ref_seg_len -4] << 8) + (p_bak_ref[j * ref_seg_len + ref_seg_len -3]);
+            chksum = (p_bak_ref[j * ref_seg_len + ref_seg_len -2] << 8) + (p_bak_ref[j * ref_seg_len + ref_seg_len -1]);
+            GTP_DEBUG("learn count = %d", learn_cnt);
+            GTP_DEBUG("chksum = %d", chksum);
+            GTP_DEBUG("ref_sum = 0x%04X", ref_sum & 0xFFFF);
+            // Sum(1~ref_seg_len) == 1
+            if (1 != ref_sum)
+            {
+                GTP_INFO("wrong chksum for bak_ref, reset to 0x00 bak_ref");
+                memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
+                p_bak_ref[ref_seg_len + j * ref_seg_len - 1] = 0x01;
+            }
+            else
+            {
+                if (j == (ref_grps - 1))
+                {
+                    GTP_INFO("backup-reference data in %s used", GTP_BAK_REF_PATH);
+                }
+            }
+        }
+        ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("failed to send bak_ref because of iic comm error");
+            goto bak_ref_exit;
+        }
+        break;
+        
+    case GTP_BAK_REF_STORE:
+        GTP_INFO("Store backup-reference");
+        ret = i2c_read_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
+        if (ret < 0)
+        {
+            GTP_ERROR("failed to read bak_ref info, sending default back-reference");
+            goto bak_ref_default;
+        }
+        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+        ref_filp->f_op->write(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
+        break;
+        
+    default:
+        GTP_ERROR("invalid backup-reference request");
+        break;
+    }
+    ret = SUCCESS;
+    goto bak_ref_exit;
+
+bak_ref_default:
+    
+    for (j = 0; j < ref_grps; ++j)
+    {
+        memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
+        p_bak_ref[j * ref_seg_len + ref_seg_len - 1] = 0x01;  // checksum = 1     
+    }
+    ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref, ts->bak_ref_len);
+    if (!IS_ERR(ref_filp))
+    {
+        GTP_INFO("write backup-reference data into %s", GTP_BAK_REF_PATH);
+        ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+        ref_filp->f_op->write(ref_filp, (char*)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
+    }
+    if (ret == FAIL)
+    {
+        GTP_ERROR("failed to load the default backup reference");
+    }
+    
+bak_ref_exit:
+    
+    if (p_bak_ref)
+    {
+        kfree(p_bak_ref);
+    }
+    if (ref_filp && !IS_ERR(ref_filp))
+    {
+        filp_close(ref_filp, NULL);
+    }
+    return ret;
+}
+
+
+static s32 gtp_verify_main_clk(u8 *p_main_clk)
+{
+    u8 chksum = 0;
+    u8 main_clock = p_main_clk[0];
+    s32 i = 0;
+    
+    if (main_clock < 50 || main_clock > 120)    
+    {
+        return FAIL;
+    }
+    
+    for (i = 0; i < 5; ++i)
+    {
+        if (main_clock != p_main_clk[i])
+        {
+            return FAIL;
+        }
+        chksum += p_main_clk[i];
+    }
+    chksum += p_main_clk[5];
+    if ( (chksum) == 0)
+    {
+        return SUCCESS;
+    }
+    else
+    {
+        return FAIL;
+    }
+}
+
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    s32 clk_chksum = 0;
+    struct file *clk_filp = NULL;
+    u8 p_main_clk[6] = {0};
+
+    ret = gup_check_fs_mounted("/data");
+    if (FAIL == ret)
+    {
+        ts->clk_chk_fs_times++;
+        GTP_DEBUG("Clock check /data times/MAX_TIMES: %d / %d", ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+        if (ts->clk_chk_fs_times < GTP_CHK_FS_MNT_MAX)
+        {
+            msleep(50);
+            GTP_INFO("/data not mounted.");
+            return FAIL;
+        }
+        GTP_INFO("Check /data mount timeout!");
+    }
+    else
+    {
+        GTP_INFO("/data mounted!!!(%d/%d)", ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+    }
+    
+    clk_filp = filp_open(GTP_MAIN_CLK_PATH, O_RDWR | O_CREAT, 0666);
+    if (IS_ERR(clk_filp))
+    {
+        GTP_ERROR("%s is unavailable, calculate main clock", GTP_MAIN_CLK_PATH);
+    }
+    else
+    {
+        clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+        clk_filp->f_op->read(clk_filp, (char *)p_main_clk, 6, &clk_filp->f_pos);
+       
+        ret = gtp_verify_main_clk(p_main_clk);
+        if (FAIL == ret)
+        {
+            // recalculate main clock & rewrite main clock data to file
+            GTP_ERROR("main clock data in %s is wrong, recalculate main clock", GTP_MAIN_CLK_PATH);
+        }
+        else
+        { 
+            GTP_INFO("main clock data in %s used, main clock freq: %d", GTP_MAIN_CLK_PATH, p_main_clk[0]);
+            filp_close(clk_filp, NULL);
+            goto update_main_clk;
+        }
+    }
+    
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+    ret = gup_clk_calibration();
+    gtp_esd_recovery(ts->client);
+    
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+
+    GTP_INFO("calibrate main clock: %d", ret);
+    if (ret < 50 || ret > 120)
+    {
+        GTP_ERROR("wrong main clock: %d", ret);
+        goto exit_main_clk;
+    }
+    
+    // Sum{0x8020~0x8025} = 0
+    for (i = 0; i < 5; ++i)
+    {
+        p_main_clk[i] = ret;
+        clk_chksum += p_main_clk[i];
+    }
+    p_main_clk[5] = 0 - clk_chksum;
+    
+    if (!IS_ERR(clk_filp))
+    {
+        GTP_DEBUG("write main clock data into %s", GTP_MAIN_CLK_PATH);
+        clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+        clk_filp->f_op->write(clk_filp, (char *)p_main_clk, 6, &clk_filp->f_pos);
+        filp_close(clk_filp, NULL);
+    }
+    
+update_main_clk:
+    ret = i2c_write_bytes(ts->client, GTP_REG_MAIN_CLK, p_main_clk, 6);
+    if (FAIL == ret)
+    {
+        GTP_ERROR("update main clock failed!");
+        return FAIL;
+    }
+    return SUCCESS;
+    
+exit_main_clk:
+    if (!IS_ERR(clk_filp))
+    {
+        filp_close(clk_filp, NULL);
+    }
+    return FAIL;
+}
+
+
+s32 gtp_gt9xxf_init(struct i2c_client *client)
+{
+    s32 ret = 0;
+    
+    ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN); 
+    if (FAIL == ret)
+    {
+        return FAIL;
+    }
+    
+    ret = gtp_fw_startup(client);
+    if (FAIL == ret)
+    {
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+void gtp_get_chip_type(struct goodix_ts_data *ts)
+{
+    u8 opr_buf[10] = {0x00};
+    s32 ret = 0;
+    
+    msleep(10);
+    
+    ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CHIP_TYPE, opr_buf, 10);
+    
+    if (FAIL == ret)
+    {
+        GTP_ERROR("Failed to get chip-type, set chip type default: GOODIX_GT9");
+        ts->chip_type = CHIP_TYPE_GT9;
+        return;
+    }
+    
+    if (!memcmp(opr_buf, "GOODIX_GT9", 10))
+    {
+        ts->chip_type = CHIP_TYPE_GT9;
+    }
+    else // GT9XXF
+    {
+        ts->chip_type = CHIP_TYPE_GT9F;
+    }
+    GTP_INFO("Chip Type: %s", (ts->chip_type == CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
+}
+
+#endif
+//************* For GT9XXF End ************//
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#ifdef CONFIG_OF
+static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
+{
+	return (regulator_count_voltages(reg) > 0) ?
+		regulator_set_optimum_mode(reg, load_uA) : 0;
+}
+
+static int goodix_power_on(struct device *dev)
+{
+	int rc;
+    static struct regulator *vcc_ana;
+#if defined (VCC_I2C)
+    static struct regulator *vcc_i2c;
+#endif
+	vcc_ana = regulator_get(dev, "vdd_ana");
+	if (IS_ERR(vcc_ana))
+    {
+		rc = PTR_ERR(vcc_ana);
+		dev_err(dev, "Regulator get failed vcc_ana rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(vcc_ana) > 0)
+    {
+		rc = regulator_set_voltage(vcc_ana, 2850000, 2850000);
+		if (rc)
+        {
+			dev_err(dev, "Regulator set ana vtg failed rc=%d\n", rc);
+			goto error_set_vtg_vcc_ana;
+		}
+	}
+    
+    rc = reg_set_optimum_mode_check(vcc_ana, 15000);
+    if (rc < 0)
+    {
+        dev_err(dev, "Regulator vcc_ana set_opt failed rc=%d\n", rc);
+        return rc;
+    }
+    
+    rc = regulator_enable(vcc_ana);
+    if (rc)
+    {
+        dev_err(dev, "Regulator vcc_ana enable failed rc=%d\n", rc);
+        goto error_reg_en_vcc_ana;
+    }
+#if defined (VCC_I2C)
+	vcc_i2c = regulator_get(dev, "vcc_i2c");
+	if (IS_ERR(vcc_i2c))
+    {
+		rc = PTR_ERR(vcc_i2c);
+		dev_err(dev, "Regulator get failed rc=%d\n", rc);
+		goto error_reg_opt_vcc_dig;
+	}
+
+    rc = regulator_enable(vcc_i2c);
+    if (rc)
+    {
+        dev_err(dev, "Regulator vcc_i2c enable failed rc=%d\n", rc);
+        goto error_reg_en_vcc_i2c;
+    }
+#endif
+    msleep(100);
+    
+    return 0;
+#if defined (VCC_I2C)
+error_reg_en_vcc_i2c:
+    reg_set_optimum_mode_check(vcc_i2c, 0);
+
+error_reg_opt_vcc_dig:
+    regulator_disable(vcc_ana);
+#endif
+error_reg_en_vcc_ana:
+    reg_set_optimum_mode_check(vcc_ana, 0);
+error_set_vtg_vcc_ana:
+	regulator_put(vcc_ana);
+	return rc;
+}
+#if 0
+static int goodix_parse_dt(struct device *dev,
+			struct goodix_ts_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+	
+	/* reset, irq gpio info */
+	pdata->reset_gpio = of_get_named_gpio(np, "goodix,reset-gpio", 0);
+	pdata->irq_gpio = of_get_named_gpio(np, "goodix,irq-gpio", 0);
+    pdata->irq_gpio_flags = IRQF_TRIGGER_FALLING;
+
+	return 0;
+}
+#endif
+#endif
+/*ZTEMT END*/
+
+/*******************************************************
+Function:
+    I2c probe.
+Input:
+    client: i2c device struct.
+    id: device id.
+Output:
+    Executive outcomes. 
+        0: succeed.
+*******************************************************/
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    s32 ret = -1;
+    struct goodix_ts_data *ts;
+    u16 version_info;
+    
+    GTP_DEBUG_FUNC();
+    
+    //do NOT remove these logs
+    GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
+    GTP_INFO("GTP Driver Built@%s, %s", __TIME__, __DATE__);
+    GTP_INFO("GTP I2C Address: 0x%02x", client->addr);
+
+    i2c_connect_client = client;
+    
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+    {
+        GTP_ERROR("I2C check functionality failed.");
+        return -ENODEV;
+    }
+    ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+    if (ts == NULL)
+    {
+        GTP_ERROR("Alloc GFP_KERNEL memory failed.");
+        return -ENOMEM;
+    }
+
+    /*ZTEMT Added by luochangyang, 2014/01/08*/
+#ifdef CONFIG_OF
+        #if 0
+        if (client->dev.of_node) {
+            pdata = devm_kzalloc(&client->dev,
+                sizeof(struct goodix_ts_platform_data), GFP_KERNEL);
+            if (!pdata) {
+                dev_err(&client->dev,
+                    "GTP Failed to allocate memory for pdata\n");
+                return -ENOMEM;
+            }
+    
+            ret = goodix_parse_dt(&client->dev, pdata);
+            if (ret)
+                return ret;
+        } else {
+            dev_info(&client->dev, "%s: No of_node.\n", __func__);
+            pdata = client->dev.platform_data;
+        }
+    
+        if (!pdata) {
+            dev_err(&client->dev, "GTP invalid pdata\n");
+            return -EINVAL;
+        }
+        #endif
+        goodix_power_on(&client->dev);
+        
+#endif
+    /*ZTEMT END*/
+
+    memset(ts, 0, sizeof(*ts));
+//+++duguowei,2014.3.1
+#if 0
+    INIT_WORK(&ts->work, goodix_ts_work_func);
+#endif
+//---duguowei,2014.3.1
+    ts->client = client;
+    spin_lock_init(&ts->irq_lock);          // 2.6.39 later
+    // ts->irq_lock = SPIN_LOCK_UNLOCKED;   // 2.6.39 & before
+#if GTP_ESD_PROTECT
+    ts->clk_tick_cnt = 2 * HZ;      // HZ: clock ticks in 1 second generated by system
+    GTP_DEBUG("Clock ticks for an esd cycle: %d", ts->clk_tick_cnt);  
+    spin_lock_init(&ts->esd_lock);
+    // ts->esd_lock = SPIN_LOCK_UNLOCKED;
+#endif
+    i2c_set_clientdata(client, ts);
+    
+    ts->gtp_rawdiff_mode = 0;
+
+    ret = gtp_request_io_port(ts);
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP request IO port failed.");
+        kfree(ts);
+        return ret;
+    }
+    
+#if GTP_COMPATIBLE_MODE
+    gtp_get_chip_type(ts);
+    
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        ret = gtp_gt9xxf_init(ts->client);
+        if (FAIL == ret)
+        {
+            GTP_INFO("Failed to init GT9XXF.");
+        }
+    }
+#endif
+
+    ret = gtp_i2c_test(client);
+    if (ret < 0)
+    {
+        GTP_ERROR("I2C communication ERROR!");
+    }
+
+    ret = gtp_read_version(client, &version_info);
+    if (ret < 0)
+    {
+        GTP_ERROR("Read version failed.");
+    }
+//+++duguowei,2014.3.1
+		if(ret < 0){
+			GTP_GPIO_FREE(GTP_INT_PORT);
+			GTP_GPIO_FREE(GTP_RST_PORT);
+			return ret;
+		}
+#if 1
+		INIT_WORK(&ts->work, goodix_ts_work_func);
+#endif
+//---duguowei,2014.3.1	
+
+    ret = gtp_init_panel(ts);
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP init panel failed.");
+        ts->abs_x_max = GTP_MAX_WIDTH;
+        ts->abs_y_max = GTP_MAX_HEIGHT;
+        ts->int_trigger_type = GTP_INT_TRIGGER;
+    }
+    
+    // Create proc file system
+    gt91xx_config_proc = proc_create(GT91XX_CONFIG_PROC_FILE, 0666, NULL, &config_proc_ops);
+    if (gt91xx_config_proc == NULL)
+    {
+        GTP_ERROR("create_proc_entry %s failed\n", GT91XX_CONFIG_PROC_FILE);
+    }
+    else
+    {
+        GTP_INFO("create proc entry %s success", GT91XX_CONFIG_PROC_FILE);
+    }
+    
+#if GTP_AUTO_UPDATE
+    ret = gup_init_update_proc(ts);
+    if (ret < 0)
+    {
+        GTP_ERROR("Create update thread error.");
+    }
+#endif
+
+    ret = gtp_request_input_dev(ts);
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP request input dev failed");
+    }
+    
+    ret = gtp_request_irq(ts); 
+    if (ret < 0)
+    {
+        GTP_INFO("GTP works in polling mode.");
+    }
+    else
+    {
+        GTP_INFO("GTP works in interrupt mode.");
+    }
+
+    if (ts->use_irq)
+    {
+        gtp_irq_enable(ts);
+    }
+    
+	/*luochangyang For wakeup gesture 2014/04/29*/
+	ret = device_create_file(&(client->dev), &dev_attr_wakeup_gesture);
+	if (ret) {
+		dev_err(&(client->dev), "%s: Error, could not create wakeup_gesture", __func__);
+	}
+	/*Default enable or disable*/
+#if 0
+	ts->wakeup_gesture = 1;
+#else
+	ts->wakeup_gesture = 0;
+#endif
+	/*luochangyang END*/
+
+#if GTP_CREATE_WR_NODE
+    init_wr_node(client);
+#endif
+    
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(client, SWITCH_ON);
+#endif
+//+++duguowei,2014.3.6
+#if GTP_TP_TEST
+	gtp_test_sysfs_init();
+#endif
+//---duguowei,2014.3.6
+    return 0;
+}
+
+
+/*******************************************************
+Function:
+    Goodix touchscreen driver release function.
+Input:
+    client: i2c device struct.
+Output:
+    Executive outcomes. 0---succeed.
+*******************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    
+    GTP_DEBUG_FUNC();
+    
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#if defined(CONFIG_FB)
+    if (fb_unregister_client(&ts->fb_notif))
+        dev_err(&client->dev,
+            "Error occurred while unregistering fb_notifier.\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*ZTEMT END*/
+    unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#if GTP_CREATE_WR_NODE
+    uninit_wr_node();
+#endif
+
+#if GTP_ESD_PROTECT
+    destroy_workqueue(gtp_esd_check_workqueue);
+#endif
+
+    if (ts) 
+    {
+        if (ts->use_irq)
+        {
+            GTP_GPIO_AS_INPUT(GTP_INT_PORT);
+            GTP_GPIO_FREE(GTP_INT_PORT);
+            free_irq(client->irq, ts);
+        }
+        else
+        {
+            hrtimer_cancel(&ts->timer);
+        }
+    }   
+    
+    GTP_INFO("GTP driver removing...");
+    i2c_set_clientdata(client, NULL);
+    input_unregister_device(ts->input_dev);
+    kfree(ts);
+
+    return 0;
+}
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+/*******************************************************
+Function:
+    Early suspend function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_suspend(struct goodix_ts_data *ts)
+{
+    s8 ret = -1;
+	u8 buf[3] = {0x81, 0xaa, 0};
+    
+    GTP_DEBUG_FUNC();
+    
+    GTP_INFO("System suspend.");
+
+	if(ts->enter_update)
+	{
+		GTP_INFO("firmware is updating,return...");
+		return;
+	}
+
+	gtp_i2c_read(i2c_connect_client, buf, sizeof(buf));
+	if (buf[2] == 0x55) {
+		return;
+	}
+
+    ts->gtp_is_suspend = 1;
+
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	if (ts->wakeup_gesture == 1) {	//add by luochangyang 2014/04/30
+		ret = gtp_enter_doze(ts);
+	//#else
+	} else {
+	    if (ts->use_irq)
+	    {
+	        gtp_irq_disable(ts);
+	    }
+	    else
+	    {
+	        hrtimer_cancel(&ts->timer);
+	    }
+	    ret = gtp_enter_sleep(ts);
+	}
+#endif 
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP early suspend failed.");
+    }
+    // to avoid waking up while not sleeping
+    //  delay 48 + 10ms to ensure reliability    
+    msleep(58);   
+}
+
+/*******************************************************
+Function:
+    Late resume function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_resume(struct goodix_ts_data *ts)
+{
+    s8 ret = -1;
+    
+    GTP_DEBUG_FUNC();
+    
+    GTP_INFO("System resume.");
+//+++
+	if(ts->enter_update)
+	{
+		GTP_INFO("firmware is updating,return...");
+		return;
+	}
+//---
+    ret = gtp_wakeup_sleep(ts);
+    
+/*ZTEMT Added by luochangyang For charge detect, 2014/02/25*/
+#if GTP_CHARGER_SWITCH
+    gtp_charger_switch(1);  // force update
+#endif
+/*ZTEMT END*/
+
+#if GTP_GESTURE_WAKEUP
+	if (ts->wakeup_gesture == 1) {	//add by luochangyang 2014/04/30
+	    doze_status = DOZE_DISABLED;
+	}
+#endif
+
+    if (ret < 0)
+    {
+        GTP_ERROR("GTP later resume failed.");
+    }
+#if (GTP_COMPATIBLE_MODE)
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        // do nothing
+    }
+    else
+#endif
+    {
+        gtp_send_cfg(ts->client);
+    }
+
+    if (ts->use_irq)
+    {
+        gtp_irq_enable(ts);
+    }
+    else
+    {
+        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+    }
+
+    ts->gtp_is_suspend = 0;
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+}
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct goodix_ts_data *ts =
+		container_of(self, struct goodix_ts_data, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+			ts && ts->client) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			goodix_ts_resume(ts);
+			GTP_INFO("ztemt %s: Wake!\n", __func__);
+		}
+		else if (*blank == FB_BLANK_POWERDOWN) {
+			goodix_ts_suspend(ts);
+			GTP_INFO("ztemt %s: Sleep!\n", __func__);
+		}
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*ZTEMT END*/
+
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+    struct goodix_ts_data *ts;
+    ts = container_of(h, struct goodix_ts_data, early_suspend);
+    
+	goodix_ts_suspend(ts);
+	return;
+}
+
+/*******************************************************
+Function:
+	Late resume function.
+Input:
+	h: early_suspend struct.
+Output:
+	None.
+*******************************************************/
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts;
+
+	ts = container_of(h, struct goodix_ts_data, early_suspend);
+	goodix_ts_resume(ts);
+	return;
+}
+#endif
+#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB*/
+
+#if GTP_ESD_PROTECT
+s32 gtp_i2c_read_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+{
+    struct i2c_msg msgs[2];
+    s32 ret=-1;
+    s32 retries = 0;
+
+    GTP_DEBUG_FUNC();
+
+    msgs[0].flags = !I2C_M_RD;
+    msgs[0].addr  = client->addr;
+    msgs[0].len   = GTP_ADDR_LENGTH;
+    msgs[0].buf   = &buf[0];
+    //msgs[0].scl_rate = 300 * 1000;    // for Rockchip, etc.
+    
+    msgs[1].flags = I2C_M_RD;
+    msgs[1].addr  = client->addr;
+    msgs[1].len   = len - GTP_ADDR_LENGTH;
+    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
+    //msgs[1].scl_rate = 300 * 1000;
+
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, msgs, 2);
+        if(ret == 2)break;
+        retries++;
+    }
+    if ((retries >= 5))
+    {    
+        GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d!", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
+    }
+    return ret;
+}
+
+s32 gtp_i2c_write_no_rst(struct i2c_client *client,u8 *buf,s32 len)
+{
+    struct i2c_msg msg;
+    s32 ret = -1;
+    s32 retries = 0;
+
+    GTP_DEBUG_FUNC();
+
+    msg.flags = !I2C_M_RD;
+    msg.addr  = client->addr;
+    msg.len   = len;
+    msg.buf   = buf;
+    //msg.scl_rate = 300 * 1000;    // for Rockchip, etc
+
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, &msg, 1);
+        if (ret == 1)break;
+        retries++;
+    }
+    if((retries >= 5))
+    {
+        GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d!", (((u16)(buf[0] << 8)) | buf[1]), len-2, ret);
+    }
+    return ret;
+}
+/*******************************************************
+Function:
+    switch on & off esd delayed work
+Input:
+    client:  i2c device
+    on:      SWITCH_ON / SWITCH_OFF
+Output:
+    void
+*********************************************************/
+void gtp_esd_switch(struct i2c_client *client, s32 on)
+{
+    struct goodix_ts_data *ts;
+    
+    ts = i2c_get_clientdata(client);
+    spin_lock(&ts->esd_lock);
+    
+    if (SWITCH_ON == on)     // switch on esd 
+    {
+        if (!ts->esd_running)
+        {
+            ts->esd_running = 1;
+            spin_unlock(&ts->esd_lock);
+            GTP_INFO("Esd started");
+            queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, ts->clk_tick_cnt);
+        }
+        else
+        {
+            spin_unlock(&ts->esd_lock);
+        }
+    }
+    else    // switch off esd
+    {
+        if (ts->esd_running)
+        {
+            ts->esd_running = 0;
+            spin_unlock(&ts->esd_lock);
+            GTP_INFO("Esd cancelled");
+            cancel_delayed_work_sync(&gtp_esd_check_work);
+        }
+        else
+        {
+            spin_unlock(&ts->esd_lock);
+        }
+    }
+}
+
+/*******************************************************
+Function:
+    Initialize external watchdog for esd protect
+Input:
+    client:  i2c device.
+Output:
+    result of i2c write operation. 
+        1: succeed, otherwise: failed
+*********************************************************/
+static s32 gtp_init_ext_watchdog(struct i2c_client *client)
+{
+    u8 opr_buffer[3] = {0x80, 0x41, 0xAA};
+    GTP_DEBUG("[Esd]Init external watchdog");
+    return gtp_i2c_write_no_rst(client, opr_buffer, 3);
+}
+
+/*******************************************************
+Function:
+    Esd protect function.
+    External watchdog added by meta, 2013/03/07
+Input:
+    work: delayed work
+Output:
+    None.
+*******************************************************/
+static void gtp_esd_check_func(struct work_struct *work)
+{
+    s32 i;
+    s32 ret = -1;
+    struct goodix_ts_data *ts = NULL;
+    u8 esd_buf[5] = {0x80, 0x40};
+    
+    GTP_DEBUG_FUNC();
+   
+    ts = i2c_get_clientdata(i2c_connect_client);
+
+    if (ts->gtp_is_suspend)
+    {
+        GTP_INFO("Esd suspended!");
+        return;
+    }
+    
+    for (i = 0; i < 3; i++)
+    {
+        ret = gtp_i2c_read_no_rst(ts->client, esd_buf, 4);
+        
+        GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[2], esd_buf[3]);
+        if ((ret < 0))
+        {
+            // IIC communication problem
+            continue;
+        }
+        else
+        { 
+            if ((esd_buf[2] == 0xAA) || (esd_buf[3] != 0xAA))
+            {
+                // IC works abnormally..
+                u8 chk_buf[4] = {0x80, 0x40};
+                
+                gtp_i2c_read_no_rst(ts->client, chk_buf, 4);
+                
+                GTP_DEBUG("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X", chk_buf[2], chk_buf[3]);
+                
+                if ((chk_buf[2] == 0xAA) || (chk_buf[3] != 0xAA))
+                {
+                    i = 3;
+                    break;
+                }
+                else
+                {
+                    continue;
+                }
+            }
+            else 
+            {
+                // IC works normally, Write 0x8040 0xAA, feed the dog
+                esd_buf[2] = 0xAA; 
+                gtp_i2c_write_no_rst(ts->client, esd_buf, 3);
+                break;
+            }
+        }
+    }
+    if (i >= 3)
+    {
+    #if GTP_COMPATIBLE_MODE
+        if (CHIP_TYPE_GT9F == ts->chip_type)
+        {        
+            if (ts->rqst_processing)
+            {
+                GTP_INFO("Request processing, no esd recovery");
+            }
+            else
+            {
+                GTP_ERROR("IC working abnormally! Process esd recovery.");
+                esd_buf[0] = 0x42;
+                esd_buf[1] = 0x26;
+                esd_buf[2] = 0x01;
+                esd_buf[3] = 0x01;
+                esd_buf[4] = 0x01;
+                gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+                msleep(50);
+                gtp_esd_recovery(ts->client);
+            }
+        }
+        else
+    #endif
+        {
+            GTP_ERROR("IC working abnormally! Process reset guitar.");
+            esd_buf[0] = 0x42;
+            esd_buf[1] = 0x26;
+            esd_buf[2] = 0x01;
+            esd_buf[3] = 0x01;
+            esd_buf[4] = 0x01;
+            gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+            msleep(50);
+            gtp_reset_guitar(ts->client, 50);
+            msleep(50);
+            gtp_send_cfg(ts->client);
+        }
+    }
+
+    if(!ts->gtp_is_suspend)
+    {
+        queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, ts->clk_tick_cnt);
+    }
+    else
+    {
+        GTP_INFO("Esd suspended!");
+    }
+    return;
+}
+#endif
+
+static const struct i2c_device_id goodix_ts_id[] = {
+    { GTP_I2C_NAME, 0 },
+    { }
+};
+
+/*ZTEMT Added by luochangyang, 2014/01/07*/
+#ifdef CONFIG_OF                //Open firmware must be defined for dts useage
+static struct of_device_id goodix_match_table[] = {
+	{ .compatible = "goodix,gt915_i2c",}, //Compatible node must match dts
+    { },
+};
+#else
+#define goodix_match_table NULL
+#endif
+/*ZTEMT END*/
+
+static struct i2c_driver goodix_ts_driver = {
+    .probe      = goodix_ts_probe,
+    .remove     = goodix_ts_remove,
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    .suspend    = goodix_ts_early_suspend,
+    .resume     = goodix_ts_late_resume,
+#endif
+    .id_table   = goodix_ts_id,
+    .driver = {
+        .name     = GTP_I2C_NAME,
+        .owner    = THIS_MODULE,
+        .of_match_table = goodix_match_table,
+    },
+};
+
+/*******************************************************    
+Function:
+    Driver Install function.
+Input:
+    None.
+Output:
+    Executive Outcomes. 0---succeed.
+********************************************************/
+static int __devinit goodix_ts_init(void)
+{
+    s32 ret;
+
+    GTP_DEBUG_FUNC();   
+    GTP_INFO("GTP driver installing...");
+    goodix_wq = create_singlethread_workqueue("goodix_wq");
+    if (!goodix_wq)
+    {
+        GTP_ERROR("Creat workqueue failed.");
+        return -ENOMEM;
+    }
+#if GTP_ESD_PROTECT
+    INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
+    gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
+#endif
+    ret = i2c_add_driver(&goodix_ts_driver);
+    return ret; 
+}
+
+/*******************************************************    
+Function:
+    Driver uninstall function.
+Input:
+    None.
+Output:
+    Executive Outcomes. 0---succeed.
+********************************************************/
+static void __exit goodix_ts_exit(void)
+{
+    GTP_DEBUG_FUNC();
+    GTP_INFO("GTP driver exited.");
+    i2c_del_driver(&goodix_ts_driver);
+    if (goodix_wq)
+    {
+        destroy_workqueue(goodix_wq);
+    }
+}
+
+module_init(goodix_ts_init);
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("GTP Series Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/gt915/gt9xx.h b/drivers/input/touchscreen/gt915/gt9xx.h
new file mode 100755
index 0000000..33b05d4
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx.h
@@ -0,0 +1,351 @@
+/* drivers/input/touchscreen/gt9xx.h
+ * 
+ * 2010 - 2013 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ */
+
+#ifndef _GOODIX_GT9XX_H_
+#define _GOODIX_GT9XX_H_
+
+#include <linux/kernel.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <asm/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <mach/gpio.h>
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+#define GTP_CHARGER_SWITCH    0
+/*ZTEMT END*/
+
+//***************************PART1:ON/OFF define*******************************
+#define GTP_CUSTOM_CFG        0
+#define GTP_CHANGE_X2Y        0
+#define GTP_DRIVER_SEND_CFG   1
+#define GTP_HAVE_TOUCH_KEY    1
+#define GTP_POWER_CTRL_SLEEP  0
+#define GTP_ICS_SLOT_REPORT   0
+
+#define GTP_COMPATIBLE_MODE   0    // compatible with GT9XXF
+
+#if defined(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_UPDATE)
+#define GTP_AUTO_UPDATE       1    // auto update fw by .bin file as default
+#define GTP_HEADER_FW_UPDATE  1    // auto update fw by gtp_default_FW in gt9xx_firmware.h, function together with GTP_AUTO_UPDATE
+#define GTP_AUTO_UPDATE_CFG   0    // auto update config by .cfg file, function together with GTP_AUTO_UPDATE
+#else
+#define GTP_AUTO_UPDATE       0
+#define GTP_HEADER_FW_UPDATE  0
+#define GTP_AUTO_UPDATE_CFG   0
+#endif
+
+#if defined(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_DEBUG)
+#define GTP_CREATE_WR_NODE    1
+#else
+#define GTP_CREATE_WR_NODE    0
+#endif
+#define GTP_ESD_PROTECT       0    // esd protection with a cycle of 2 seconds
+
+#define GTP_WITH_PEN          0
+#define GTP_PEN_HAVE_BUTTON   0    // active pen has buttons, function together with GTP_WITH_PEN
+
+#define GTP_GESTURE_WAKEUP    1    // gesture wakeup
+
+#define GTP_DEBUG_ON          0
+#define GTP_DEBUG_ARRAY_ON    0
+#define GTP_DEBUG_FUNC_ON     0
+
+//+++duguowei,2014.3.6
+#if defined(CONFIG_ZTEMT_GT9XX_TOUCHSCREEN_TEST)
+#define GTP_TP_TEST			  1
+#else
+#define GTP_TP_TEST			  0
+#endif
+//---duguowei,2014.3.6
+
+#if GTP_COMPATIBLE_MODE
+typedef enum
+{
+    CHIP_TYPE_GT9  = 0,
+    CHIP_TYPE_GT9F = 1,
+} CHIP_TYPE_T;
+#endif
+
+struct goodix_ts_data {
+    spinlock_t irq_lock;
+    struct i2c_client *client;
+    struct input_dev  *input_dev;
+    struct hrtimer timer;
+    struct work_struct  work;
+
+/*ZTEMT Added by luochangyang, 2014/01/08*/
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+
+	u8  ic_cfg_version;
+	u8	wakeup_gesture;
+/*ZTEMT END*/
+
+    s32 irq_is_disable;
+    s32 use_irq;
+    u16 abs_x_max;
+    u16 abs_y_max;
+    u8  max_touch_num;
+    u8  int_trigger_type;
+    u8  green_wake_mode;
+    u8  enter_update;
+    u8  gtp_is_suspend;
+    u8  gtp_rawdiff_mode;
+    u8  gtp_cfg_len;
+    u8  fixed_cfg;
+    u8  fw_error;
+    u8  pnl_init_error;
+    
+#if GTP_WITH_PEN
+    struct input_dev *pen_dev;
+#endif
+
+#if GTP_ESD_PROTECT
+    spinlock_t esd_lock;
+    u8  esd_running;
+    s32 clk_tick_cnt;
+#endif
+
+#if GTP_COMPATIBLE_MODE
+    u16 bak_ref_len;
+    s32 ref_chk_fs_times;
+    s32 clk_chk_fs_times;
+    CHIP_TYPE_T chip_type;
+    u8 rqst_processing;
+    u8 is_950;
+#endif
+    
+};
+
+extern u16 show_len;
+extern u16 total_len;
+
+extern u8 gtp_cfg_version;	//move from .c file
+
+//*************************** PART2:TODO define **********************************
+// STEP_1(REQUIRED): Define Configuration Information Group(s)
+// Sensor_ID Map:
+/* sensor_opt1 sensor_opt2 Sensor_ID
+    GND         GND         0 
+    VDDIO       GND         1 
+    NC          GND         2 
+    GND         NC/300K     3 
+    VDDIO       NC/300K     4 
+    NC          NC/300K     5 
+*/
+// TODO: define your own default or for Sensor_ID == 0 config here. 
+// The predefined one is just a sample config, which is not suitable for your tp in most cases.
+//lianchuang
+#define CTP_CFG_GROUP1 {\
+	0x42,0xD0,0x02,0x00,0x05,0x05,0x75,0x01,0x01,0x0F,0x24,\
+	0x0F,0x64,0x3C,0x03,0x05,0x00,0x00,0x00,0x02,0x00,0x00,\
+	0x00,0x16,0x19,0x1C,0x14,0x8C,0x0E,0x0E,0x24,0x00,0x31,\
+	0x0D,0x00,0x00,0x00,0x83,0x33,0x1D,0x00,0x41,0x00,0x00,\
+	0x00,0x00,0x00,0x08,0x0A,0x00,0x2B,0x1C,0x3C,0x94,0xD5,\
+	0x03,0x08,0x00,0x00,0x04,0x93,0x1E,0x00,0x82,0x23,0x00,\
+	0x74,0x29,0x00,0x69,0x2F,0x00,0x5F,0x37,0x00,0x5F,0x20,\
+	0x40,0x60,0x00,0xF0,0x40,0x30,0x55,0x50,0x27,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x19,0x00,0x00,\
+	0x50,0x50,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,\
+	0x14,0x16,0x18,0x1A,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,\
+	0x1E,0x1F,0x20,0x21,0x22,0x24,0x26,0x28,0x29,0x2A,0x1C,\
+	0x18,0x16,0x14,0x13,0x12,0x10,0x0F,0x0C,0x0A,0x08,0x06,\
+	0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9C,0x01\
+    }
+    
+// TODO: define your config for Sensor_ID == 1 here, if needed
+#define CTP_CFG_GROUP2 {\
+    }
+
+// TODO: define your config for Sensor_ID == 2 here, if needed
+//chaosheng
+#define CTP_CFG_GROUP3 {\
+	0x48,0xD0,0x02,0x00,0x05,0x05,0x75,0x01,0x01,0x0F,0x24,\
+	0x0F,0x64,0x3C,0x03,0x05,0x00,0x00,0x00,0x02,0x00,0x00,\
+	0x00,0x16,0x19,0x1C,0x14,0x8C,0x0E,0x0E,0x24,0x00,0x31,\
+	0x0D,0x00,0x00,0x00,0x83,0x33,0x1D,0x00,0x41,0x00,0x00,\
+	0x3C,0x0A,0x14,0x08,0x0A,0x00,0x2B,0x1C,0x3C,0x94,0xD5,\
+	0x03,0x08,0x00,0x00,0x04,0x93,0x1E,0x00,0x82,0x23,0x00,\
+	0x74,0x29,0x00,0x69,0x2F,0x00,0x5F,0x37,0x00,0x5F,0x20,\
+	0x40,0x60,0x00,0xF0,0x40,0x30,0x55,0x50,0x27,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x19,0x00,0x00,\
+	0x50,0x50,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,\
+	0x14,0x16,0x18,0x1A,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,\
+	0x1E,0x1F,0x20,0x21,0x22,0x24,0x26,0x28,0x29,0x2A,0x1C,\
+	0x18,0x16,0x14,0x13,0x12,0x10,0x0F,0x0C,0x0A,0x08,0x06,\
+	0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x01\
+	}
+
+// TODO: define your config for Sensor_ID == 3 here, if needed
+#define CTP_CFG_GROUP4 {\
+}
+// TODO: define your config for Sensor_ID == 4 here, if needed
+#define CTP_CFG_GROUP5 {\
+    }
+
+// TODO: define your config for Sensor_ID == 5 here, if needed
+#define CTP_CFG_GROUP6 {\
+    }
+
+// STEP_2(REQUIRED): Customize your I/O ports & I/O operations
+#define GTP_RST_PORT    16
+#define GTP_INT_PORT    17
+#define GTP_INT_IRQ     gpio_to_irq(GTP_INT_PORT)
+#define GTP_INT_CFG     S3C_GPIO_SFN(0xF)
+
+#define GTP_GPIO_AS_INPUT(pin)     gpio_direction_input(pin);
+
+#define GTP_GPIO_AS_INT(pin)          GTP_GPIO_AS_INPUT(pin);
+
+#define GTP_GPIO_GET_VALUE(pin)         gpio_get_value(pin)
+#define GTP_GPIO_OUTPUT(pin,level)      gpio_direction_output(pin,level)
+#define GTP_GPIO_REQUEST(pin, label)    gpio_request(pin, label)
+#define GTP_GPIO_FREE(pin)              gpio_free(pin)
+#define GTP_IRQ_TAB                     {IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH}
+
+// STEP_3(optional): Specify your special config info if needed
+#if GTP_CUSTOM_CFG
+  #define GTP_MAX_HEIGHT   800
+  #define GTP_MAX_WIDTH    480
+  #define GTP_INT_TRIGGER  0            // 0: Rising 1: Falling
+#else
+  #define GTP_MAX_HEIGHT   1280
+  #define GTP_MAX_WIDTH    720
+  #define GTP_INT_TRIGGER  1
+#endif
+#define GTP_MAX_TOUCH         5
+
+// STEP_4(optional): If keys are available and reported as keys, config your key info here                             
+#if GTP_HAVE_TOUCH_KEY
+    #define GTP_KEY_TAB  {KEY_MENU, KEY_HOME, KEY_BACK}
+#endif
+
+//***************************PART3:OTHER define*********************************
+#define GTP_DRIVER_VERSION          "V2.2<2014/01/14>"
+#define GTP_I2C_NAME                "Goodix-TS"
+#define GT91XX_CONFIG_PROC_FILE     "gt9xx_config"
+#define GTP_POLL_TIME         10    
+#define GTP_ADDR_LENGTH       2
+#define GTP_CONFIG_MIN_LENGTH 186
+#define GTP_CONFIG_MAX_LENGTH 240
+#define FAIL                  0
+#define SUCCESS               1
+#define SWITCH_OFF            0
+#define SWITCH_ON             1
+
+//******************** For GT9XXF Start **********************//
+#define GTP_REG_BAK_REF                 0x99D0
+#define GTP_REG_MAIN_CLK                0x8020
+#define GTP_REG_CHIP_TYPE               0x8000
+#define GTP_REG_HAVE_KEY                0x804E
+#define GTP_REG_MATRIX_DRVNUM           0x8069     
+#define GTP_REG_MATRIX_SENNUM           0x806A
+
+#define GTP_FL_FW_BURN              0x00
+#define GTP_FL_ESD_RECOVERY         0x01
+#define GTP_FL_READ_REPAIR          0x02
+
+#define GTP_BAK_REF_SEND                0
+#define GTP_BAK_REF_STORE               1
+#define CFG_LOC_DRVA_NUM                29
+#define CFG_LOC_DRVB_NUM                30
+#define CFG_LOC_SENS_NUM                31
+
+#define GTP_CHK_FW_MAX                  40
+#define GTP_CHK_FS_MNT_MAX              300
+#define GTP_BAK_REF_PATH                "/data/gtp_ref.bin"
+#define GTP_MAIN_CLK_PATH               "/data/gtp_clk.bin"
+#define GTP_RQST_CONFIG                 0x01
+#define GTP_RQST_BAK_REF                0x02
+#define GTP_RQST_RESET                  0x03
+#define GTP_RQST_MAIN_CLOCK             0x04
+#define GTP_RQST_RESPONDED              0x00
+#define GTP_RQST_IDLE                   0xFF
+
+//******************** For GT9XXF End **********************//
+// Registers define
+#define GTP_READ_COOR_ADDR    0x814E
+#define GTP_REG_SLEEP         0x8040
+#define GTP_REG_SENSOR_ID     0x814A
+#define GTP_REG_CONFIG_DATA   0x8047
+#define GTP_REG_VERSION       0x8140
+
+#define RESOLUTION_LOC        3
+#define TRIGGER_LOC           8
+
+#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
+// Log define
+#define GTP_INFO(fmt,arg...)           printk("<<-GTP-INFO->> "fmt"\n",##arg)
+#define GTP_ERROR(fmt,arg...)          printk("<<-GTP-ERROR->> "fmt"\n",##arg)
+#define GTP_DEBUG(fmt,arg...)          do{\
+                                         if(GTP_DEBUG_ON)\
+                                         printk("<<-GTP-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);\
+                                       }while(0)
+#define GTP_DEBUG_ARRAY(array, num)    do{\
+                                         s32 i;\
+                                         u8* a = array;\
+                                         if(GTP_DEBUG_ARRAY_ON)\
+                                         {\
+                                            printk("<<-GTP-DEBUG-ARRAY->>\n");\
+                                            for (i = 0; i < (num); i++)\
+                                            {\
+                                                printk("%02x   ", (a)[i]);\
+                                                if ((i + 1 ) %10 == 0)\
+                                                {\
+                                                    printk("\n");\
+                                                }\
+                                            }\
+                                            printk("\n");\
+                                        }\
+                                       }while(0)
+#define GTP_DEBUG_FUNC()               do{\
+                                         if(GTP_DEBUG_FUNC_ON)\
+                                         printk("<<-GTP-FUNC->> Func:%s@Line:%d\n",__func__,__LINE__);\
+                                       }while(0)
+#define GTP_SWAP(x, y)                 do{\
+                                         typeof(x) z = x;\
+                                         x = y;\
+                                         y = z;\
+                                       }while (0)
+
+//*****************************End of Part III********************************
+
+#endif /* _GOODIX_GT9XX_H_ */
diff --git a/drivers/input/touchscreen/gt915/gt9xx_firmware-1030.h b/drivers/input/touchscreen/gt915/gt9xx_firmware-1030.h
new file mode 100755
index 0000000..dadddc4
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx_firmware-1030.h
@@ -0,0 +1,4528 @@
+/* Copyright Statement:
+*This firmware are protected under relevant copyright laws,this information contained
+*herein is confidential and proprietary to Goodix.
+*
+*GOODIX (C) 2013. All rights reserved.
+*
+*WARNING:The GTP_COMPATIBLE_MODE part of this file was generated by the specialized tools,
+*please do not modify it manually!
+*
+*/
+
+
+#ifndef _GT9XX_FIRMWARE_H_
+#define _GT9XX_FIRMWARE_H_
+
+#if GTP_HEADER_FW_UPDATE
+unsigned char gtp_default_FW[] = {
+	0x00,0x01,0x60,0x00,0x39,0x31,0x35,0x4C,0x00,0x00,0x00,0x00,0x10,0x30,0x80,0x00,0x55,0x40,0xBD,0xDA,
+	0xFD,0x24,0x34,0xDF,0x44,0x40,0xD9,0xA6,0x8D,0xBF,0x88,0xA4,0x8A,0x41,0x81,0xE9,0x19,0x63,0x22,0xB7,
+	0xED,0x5E,0x24,0x56,0x10,0x21,0x01,0x85,0x05,0x02,0x72,0x43,0xE8,0x99,0x39,0x25,0xC8,0xE2,0xAB,0xC7,
+	0x52,0x4A,0x09,0x98,0x7C,0x08,0xD5,0xDD,0x70,0x25,0x23,0xB6,0x6D,0x4B,0xE1,0xB7,0xD2,0x87,0xF7,0xE8,
+	0x04,0x44,0xBF,0x34,0x1A,0x2D,0x59,0x8D,0x02,0x06,0xCB,0xE6,0xD2,0x0E,0x38,0x16,0xA1,0xFB,0xC0,0x44,
+	0x20,0x41,0x87,0x28,0x7C,0xCE,0x01,0x06,0xF4,0x75,0x93,0xBC,0x92,0x48,0xC7,0x3E,0x1D,0xD0,0x8F,0x4F,
+	0xB5,0x62,0xE9,0x96,0xCD,0x7D,0xB0,0x17,0x69,0xA3,0x72,0xB3,0xE4,0x1B,0x63,0x8A,0xC5,0x9C,0x83,0x35,
+	0x74,0x61,0x02,0x2C,0x2E,0x48,0xA6,0x0C,0xBB,0x2E,0x96,0xDE,0xC8,0x68,0xC8,0x3C,0xFB,0x6E,0xDA,0xBC,
+	0x2F,0x49,0xF2,0x98,0x36,0x02,0x3A,0x11,0xA8,0x2F,0x12,0x90,0xB8,0x66,0xDA,0x4B,0xC0,0x9A,0xA7,0x41,
+	0xFB,0xD5,0xEB,0x21,0x17,0xC5,0xDB,0x3B,0x7B,0x6C,0x18,0x93,0x2A,0x6E,0xEB,0xDD,0x57,0x26,0xAF,0xD3,
+	0x8A,0xAB,0x2F,0x2D,0x7A,0x29,0x93,0x4E,0xC2,0x3F,0x1D,0xE3,0x25,0x3D,0x6C,0xEC,0x19,0xFC,0xF2,0xCB,
+	0xFB,0xE6,0x48,0x9E,0xA9,0x48,0xF4,0xA0,0x82,0xD6,0x7A,0x81,0xEA,0xC7,0x1A,0xE8,0x8B,0x56,0xE7,0xB5,
+	0x0A,0xF5,0x9C,0xB2,0x9C,0xF5,0x93,0x95,0xC5,0x48,0x54,0x0D,0xC6,0x63,0x39,0xFC,0x2F,0xE8,0x47,0xB0,
+	0xAB,0x94,0x73,0x86,0x35,0x4B,0x06,0x9A,0x32,0x60,0x04,0x80,0x78,0xF8,0x94,0x7F,0x43,0x3C,0x74,0x48,
+	0x7D,0xDD,0x16,0x46,0xF2,0x58,0xDE,0xB0,0x26,0xE9,0x88,0xFE,0x4A,0x30,0x6F,0x97,0x9E,0xDB,0xFC,0xF5,
+	0x31,0x7E,0x4F,0x28,0x82,0x11,0x7A,0x79,0x30,0x70,0xCE,0xA0,0x6E,0x5B,0x93,0x55,0xAC,0x7D,0x02,0x1D,
+	0x24,0xE6,0xD6,0x95,0xCE,0x33,0xCA,0x11,0x08,0x63,0x5D,0xD0,0x43,0x7A,0xAB,0x37,0x06,0x58,0xD2,0xA6,
+	0xD9,0x6D,0x0D,0xE6,0xC5,0x19,0x2C,0xEC,0x11,0x78,0xF7,0x3D,0x51,0xAE,0x48,0x25,0x06,0x3D,0xD8,0x00,
+	0x2B,0x1A,0xE4,0xA6,0x30,0x85,0xD6,0x3D,0x3B,0xED,0x29,0x57,0xB3,0x3E,0xB9,0x73,0xAA,0x5E,0x2D,0x67,
+	0x72,0xF1,0xB2,0x55,0xD4,0xBA,0xAD,0xD7,0xB0,0x3A,0x3D,0xF3,0xBE,0x5A,0xC5,0xED,0x52,0xFD,0xC6,0x75,
+	0x3E,0x03,0x5D,0xCE,0x3E,0xF1,0x5C,0x35,0x9F,0xD5,0x54,0x4C,0x3A,0x87,0x71,0x1A,0xA9,0x11,0x8F,0x1E,
+	0x30,0xD4,0x9D,0xE7,0x2A,0x55,0xA4,0x43,0x8E,0x3B,0xF8,0xFB,0x4F,0x04,0x74,0xF2,0xED,0x33,0xF3,0x8E,
+	0xC9,0x7A,0x6C,0x29,0x83,0x08,0xD0,0xDB,0xDE,0xE3,0xD5,0x67,0x1A,0x3F,0x09,0xDB,0xC8,0x4E,0x46,0x8F,
+	0x18,0x84,0x7C,0x20,0xBA,0x53,0xEC,0x49,0x34,0xB6,0x1C,0xF5,0x59,0x47,0xAE,0xDD,0xDB,0x47,0xA6,0xD0,
+	0x39,0x52,0x75,0x5B,0x08,0xB9,0x5C,0xE8,0xCC,0x59,0x9B,0x1B,0x48,0x26,0xEF,0x50,0x2D,0xAE,0x43,0x32,
+	0x38,0xA5,0xAF,0x8F,0x15,0x55,0x1D,0x0A,0x1B,0x1D,0xE7,0xC4,0x2E,0xBF,0x37,0x62,0xB7,0x9F,0xDA,0x86,
+	0x64,0xD9,0x1F,0x68,0x3A,0x64,0xB0,0xA6,0x04,0xC0,0xBA,0x28,0x35,0x58,0x22,0x3A,0xD5,0xAC,0x6F,0x46,
+	0x2B,0x93,0x28,0x12,0x05,0xC1,0xA2,0x1E,0xB6,0xA7,0x32,0x12,0xD4,0xA5,0xC9,0x2E,0xD2,0xF4,0x21,0x97,
+	0x84,0x82,0xC1,0x46,0x18,0xAF,0xE5,0x71,0x87,0x32,0x71,0xDA,0x68,0x49,0x29,0x9F,0x85,0x83,0xA1,0x5A,
+	0xF6,0xE3,0x31,0x23,0x26,0x09,0xD9,0x77,0x72,0x68,0xB4,0x04,0xA4,0x7A,0x1F,0xC2,0x61,0x09,0xF4,0xE6,
+	0x22,0x68,0xB5,0x81,0x65,0xFE,0x83,0x29,0x98,0xB8,0x35,0x5A,0xF6,0x1A,0xBC,0xF7,0x04,0x36,0xA0,0x90,
+	0xD5,0xE1,0x1B,0xC7,0x86,0x54,0x3A,0x0C,0xE9,0x2B,0x11,0x61,0x9F,0xCB,0xCB,0x81,0xC6,0x6D,0xC1,0xF1,
+	0x00,0xA0,0x29,0xAB,0x7E,0x7C,0xBD,0xF5,0xC9,0xC1,0x8B,0x15,0x94,0x17,0x22,0x0A,0x0C,0xC8,0xDA,0x8C,
+	0x1D,0xF0,0x12,0x2B,0x09,0x07,0xB6,0xCC,0xD9,0x3D,0x2A,0x1A,0x0D,0xC9,0x3D,0xFC,0x9F,0xE1,0x3E,0x3E,
+	0x0D,0xD9,0xDA,0x7F,0x11,0x62,0x23,0x2A,0x8C,0x8A,0xE1,0xED,0x1E,0xE2,0xDC,0x59,0x4C,0xBA,0x5B,0x00,
+	0x5B,0x7F,0xF5,0x1C,0x8D,0x8B,0x38,0x6D,0x3E,0xD0,0x7B,0x1B,0xCC,0xCF,0x39,0xDD,0x5F,0xC3,0xF2,0xCE,
+	0x0A,0x4F,0x49,0xB3,0x2F,0xD7,0x52,0x8A,0xEF,0xAE,0xEA,0x63,0xFF,0xAE,0x6B,0xFF,0x89,0x4A,0x31,0x2D,
+	0x9D,0xA9,0xBE,0xFF,0xC9,0xCC,0x06,0x0D,0xFC,0xDF,0x59,0xB4,0x73,0x75,0x62,0x3D,0x65,0xEC,0x93,0xF6,
+	0x6F,0xA2,0x31,0x75,0xE5,0xD4,0x83,0xF9,0x0A,0x88,0xA3,0x3D,0xF7,0xA2,0x1B,0x79,0x9E,0xC2,0x07,0x97,
+	0x94,0x62,0x1E,0x60,0x88,0x6E,0x5F,0x02,0x4B,0xE2,0x3C,0x08,0x85,0xB6,0x4F,0x22,0x57,0x25,0x2C,0x6F,
+	0x25,0x1C,0xE6,0x61,0x96,0xB7,0x88,0x58,0x84,0xB7,0x1F,0x03,0xA9,0xE2,0x5E,0x5D,0x13,0x89,0xC5,0xC6,
+	0x38,0xBF,0x81,0x4D,0x05,0xB4,0x75,0x06,0xC5,0xB3,0xD5,0x9B,0x7A,0x0C,0xE5,0x00,0xD6,0xE6,0x89,0xF9,
+	0x2C,0x97,0x9E,0x1E,0x2D,0xA0,0xCC,0xD6,0xA3,0xB4,0xDA,0xAA,0xBB,0xD6,0xF6,0xA2,0x2E,0xCF,0xB9,0x80,
+	0xA8,0xE6,0x94,0x21,0x74,0x8E,0xD4,0x06,0x6B,0xAE,0x25,0x1A,0xC2,0x2A,0x43,0xC6,0x75,0xE5,0x3C,0xD0,
+	0x01,0x86,0x1D,0x45,0x36,0x0C,0x2C,0x13,0xA2,0x99,0x4D,0x79,0xF5,0xC6,0xC8,0x35,0x94,0x73,0x4C,0x31,
+	0x12,0xBC,0x7F,0x0D,0x26,0x5D,0x05,0x85,0x81,0xE5,0x78,0xA8,0xF9,0x33,0xDE,0x48,0x44,0xFA,0x1F,0xE4,
+	0xA5,0xBC,0x5E,0x1D,0xF9,0xBF,0x1E,0x6B,0x3D,0x72,0x6E,0x63,0x2B,0xFB,0x10,0xBC,0xFC,0x85,0x7E,0xBA,
+	0x57,0x0C,0xF9,0xD0,0xC7,0x81,0x72,0x3D,0x39,0x4F,0x9E,0x49,0x40,0xC6,0x1F,0x0C,0x83,0x89,0x71,0x90,
+	0xAD,0x30,0xB5,0x9D,0xBB,0x00,0x11,0xBC,0x78,0x25,0x69,0x3B,0xF9,0x38,0x9C,0x22,0x26,0xD3,0x62,0x3E,
+	0x7E,0xF3,0x0E,0x02,0x21,0x93,0x0E,0x06,0x6D,0xBE,0x96,0x26,0xA7,0x66,0xB7,0x2B,0x98,0xBB,0x54,0x2A,
+	0x33,0x5D,0x46,0x61,0x6D,0xB0,0x3E,0xF2,0xCD,0xFE,0x87,0xCD,0xB5,0xB3,0x17,0xE9,0xB3,0xD3,0x31,0xBD,
+	0xCD,0x34,0xE5,0x23,0x2F,0x24,0xCF,0x0F,0x1E,0x10,0x26,0xFC,0x48,0x92,0x1C,0x3F,0xB7,0x22,0xF8,0x08,
+	0xFD,0x4F,0xB8,0xFA,0x92,0x24,0x07,0x53,0x18,0x2C,0xA8,0xD7,0x20,0x66,0xD3,0x47,0x7E,0x8D,0xD1,0xD1,
+	0xB6,0x9C,0x3E,0x29,0x39,0xEC,0x1D,0x13,0xF0,0x7A,0x3B,0xE9,0x18,0x4D,0x08,0x67,0x6B,0xFF,0x77,0x3D,
+	0xC1,0x22,0xB1,0xC9,0x71,0xCD,0x52,0x13,0xFA,0xAD,0x88,0xF3,0x97,0xE8,0x0E,0x00,0xD5,0xC1,0x7F,0xC3,
+	0x34,0x0F,0xBF,0xC2,0xCB,0x83,0x1F,0x58,0x21,0xF5,0x68,0xE2,0x8B,0x48,0x2F,0x17,0x38,0x26,0x5E,0x36,
+	0xF4,0x89,0x08,0xA8,0xFA,0xFE,0xD9,0xB0,0x4F,0xCE,0xA0,0x53,0xBA,0xCE,0x79,0x1C,0x7D,0x1D,0x79,0xBE,
+	0xAD,0xE0,0x29,0x03,0x4F,0xC0,0x58,0xEA,0x3B,0xED,0x9D,0xF4,0xC0,0x0B,0x67,0xA8,0x20,0x5C,0xA6,0x93,
+	0xC5,0xAC,0xA1,0x06,0xB5,0xE6,0xDF,0x24,0x0E,0xE3,0x03,0x8E,0x98,0xF2,0x6C,0x11,0x80,0x18,0xF0,0xD3,
+	0x59,0x28,0xDA,0xE0,0x89,0xB2,0x3E,0x7E,0x2A,0x4E,0xE0,0xBC,0x18,0x59,0x36,0xAF,0x45,0x61,0xB2,0xF5,
+	0x5D,0xF1,0xBB,0xE5,0x3E,0x65,0x6B,0x3B,0xFB,0x6C,0x49,0xD3,0x31,0x1B,0xFD,0xF4,0xDF,0x49,0x73,0x3A,
+	0x38,0x30,0x21,0xC6,0xCF,0x80,0xDD,0x4E,0xA9,0xCD,0xCD,0x18,0x28,0x73,0xC3,0xB5,0x1E,0x6E,0x82,0xEC,
+	0x62,0xA0,0xD6,0x97,0xBB,0xCF,0x8A,0xA5,0x6F,0x80,0x0A,0xBA,0x28,0xAC,0x42,0x78,0x78,0x5C,0x01,0x53,
+	0x5D,0x26,0x74,0x3D,0x76,0x5E,0x18,0x3E,0x7B,0x35,0x93,0x94,0xDF,0x0C,0x85,0x97,0xA5,0x6C,0x5B,0x41,
+	0xC7,0xA0,0x33,0xB5,0xD5,0x60,0x01,0x86,0x6C,0x4C,0x37,0x3A,0x3A,0x99,0x2A,0x32,0x43,0x14,0xE4,0xC4,
+	0x8E,0xBD,0x94,0xE1,0x5B,0x54,0xC2,0x57,0x48,0xCD,0x8F,0x63,0x48,0x0A,0xDC,0x91,0x92,0x37,0x26,0x59,
+	0x16,0x3E,0x9B,0x30,0x0E,0xDB,0x7D,0xF2,0xF8,0xB3,0xFD,0xC3,0x04,0x34,0xEF,0xD2,0x85,0x4D,0xEB,0x89,
+	0xD0,0xA3,0xC8,0x77,0x81,0x83,0xAD,0x6C,0x10,0x30,0x24,0x80,0x40,0x61,0xFD,0xB7,0x98,0x7E,0x7C,0x92,
+	0x2C,0x76,0xB9,0xF5,0x0E,0x9B,0xFC,0x6C,0xE0,0x50,0xD4,0x18,0xD1,0x36,0xB4,0xB2,0x60,0xE6,0x8E,0x36,
+	0x35,0xD7,0xA6,0x86,0xEE,0xD3,0x69,0x05,0x55,0x77,0x0F,0xC4,0x91,0xC4,0x50,0x41,0xFC,0x04,0x8F,0x83,
+	0xD1,0x42,0x0C,0x25,0x99,0x55,0x14,0xEC,0x04,0x5A,0x88,0x35,0xFB,0x2C,0x5C,0x31,0xE7,0x9C,0x83,0x50,
+	0x50,0xDC,0x84,0x7B,0x70,0x95,0x3C,0x88,0xBF,0x98,0xEA,0xDB,0x01,0x47,0xE8,0x81,0xD4,0x75,0x2E,0xE4,
+	0x88,0xE6,0x5A,0x1A,0x2D,0x3A,0x27,0x89,0xC8,0x6B,0x45,0xBC,0x7F,0x02,0x79,0x95,0x0B,0x1C,0xE7,0x8F,
+	0xC3,0x37,0x2D,0x40,0x68,0x35,0xE9,0x95,0x87,0xF3,0xCB,0x1C,0xEA,0xE9,0x0E,0xFD,0x3B,0x3F,0xE3,0xCB,
+	0x6B,0x67,0xA8,0x55,0xFB,0xD6,0x18,0x2A,0x26,0x99,0x06,0xAA,0x7A,0x73,0x46,0x6A,0xEA,0xB7,0x84,0xEC,
+	0x93,0x7F,0x2E,0x8B,0xC0,0x12,0x97,0x5C,0x9E,0xC2,0xE4,0xBF,0xA9,0x0D,0xE9,0x4C,0x8B,0x1E,0x19,0x2B,
+	0xE2,0x9A,0xC1,0xF4,0x3A,0x10,0x6F,0x01,0x76,0x91,0xCF,0xD8,0x1B,0x01,0x2F,0xDB,0xDC,0x12,0xCE,0xBB,
+	0x39,0xC3,0x17,0xFD,0x8C,0xD6,0x68,0x59,0x0F,0x5C,0xFE,0x2C,0x86,0x84,0xD2,0xE0,0xB8,0xAD,0x46,0x51,
+	0x2D,0x64,0x35,0x66,0x08,0xFB,0x56,0x0B,0xA4,0xE2,0x1F,0x50,0x1F,0xE3,0x40,0x5A,0xAE,0xF8,0x2D,0xF1,
+	0x8B,0xEB,0xB9,0x61,0xC7,0x70,0xF8,0xB4,0x33,0xEE,0xAB,0xC1,0x24,0x66,0x57,0x51,0x2B,0x4F,0xC9,0x93,
+	0x29,0x8E,0xB7,0x3D,0x74,0x0C,0x37,0x5B,0xE4,0xB3,0xBF,0x44,0xA5,0x15,0xAC,0x6D,0x63,0x3B,0xE1,0xA0,
+	0x25,0x96,0x76,0x6A,0xC4,0x68,0x8F,0x14,0x80,0x7B,0xDD,0x26,0xFF,0xD5,0xFF,0x25,0x6F,0xC9,0xFD,0x94,
+	0x41,0x1E,0x07,0x05,0x3D,0x86,0x41,0x57,0x6D,0xEC,0x19,0x4F,0x31,0x09,0x8D,0x01,0x4B,0x60,0xCF,0xD3,
+	0xBE,0xEB,0xDE,0x5F,0x81,0x7C,0x8F,0x23,0x94,0xB6,0x2F,0x01,0xF4,0x73,0x02,0x87,0xD1,0xA5,0x68,0x97,
+	0xE7,0x58,0xA1,0xE6,0x08,0xE7,0xDE,0x59,0x75,0x4E,0xBA,0x3F,0x5A,0x13,0x29,0x3D,0xAC,0x03,0xEC,0xF8,
+	0x1B,0x4B,0x38,0x7A,0x59,0xCF,0x24,0x78,0x5E,0xA9,0x1B,0x2D,0x65,0xCC,0xFA,0x15,0x3B,0xB1,0x08,0x58,
+	0xFD,0x4C,0xFD,0x2D,0x90,0xA8,0xAC,0xE8,0xE8,0x8D,0x06,0x9B,0xA2,0x67,0x1F,0x3B,0x6C,0xC2,0x53,0x03,
+	0xDB,0x09,0xB2,0xC8,0x2C,0xEC,0xB8,0xEA,0x76,0x1D,0x88,0x82,0x86,0x03,0x7B,0xF1,0xAF,0xE3,0xB1,0xCF,
+	0x2D,0xDD,0x94,0x73,0x92,0x2B,0x80,0x72,0xA8,0xD6,0xE8,0x7B,0xAA,0x6E,0x39,0x4A,0x2D,0xCC,0x9A,0x29,
+	0x13,0xCC,0x72,0x9D,0xFD,0x8A,0x47,0x14,0x7D,0x13,0x74,0xD9,0x0F,0x14,0x6D,0x1F,0xDB,0x24,0x58,0x8D,
+	0x4A,0x0D,0xFF,0x8C,0xFD,0x14,0x5A,0x8E,0x04,0x92,0x33,0xE4,0xD7,0x4F,0xE4,0x40,0xE6,0xCC,0xA1,0x40,
+	0x64,0x5D,0x12,0x8B,0xAA,0x37,0x33,0x76,0x61,0xBC,0x13,0x50,0xC9,0xDE,0x82,0x9B,0xD2,0xEA,0xA2,0x90,
+	0xF0,0xC2,0xC5,0x85,0xC0,0xBF,0x4A,0x41,0x66,0xCE,0x24,0x41,0xC7,0x60,0xAE,0xD3,0xF9,0x37,0x69,0x11,
+	0xE9,0xB0,0x5D,0xB1,0xFC,0xDE,0xFA,0xC4,0x85,0xBC,0x9B,0x90,0x65,0x64,0xDE,0x99,0x95,0xD1,0x2D,0x7A,
+	0xC3,0xCF,0x34,0x03,0xB1,0x79,0xC0,0x40,0x6F,0x9F,0x04,0xE9,0x13,0xAE,0xF9,0x32,0x2F,0x78,0xA6,0xF7,
+	0x1D,0xD6,0x3C,0x57,0x01,0xDB,0x5A,0x25,0x33,0xF6,0x37,0x05,0x6B,0x70,0xE3,0x43,0x1D,0xB5,0xE9,0x23,
+	0xEF,0xD8,0xC6,0xB1,0x5C,0x14,0xF8,0x15,0x67,0x07,0x83,0x56,0x16,0x56,0x21,0x86,0xAC,0xC8,0x21,0x9B,
+	0x9D,0x47,0xCD,0x28,0xEC,0xC0,0x76,0x72,0x2F,0xBA,0x6A,0xDA,0x21,0x32,0x2C,0x1C,0xBD,0xFA,0x76,0x5C,
+	0x94,0xC9,0x6D,0x3A,0x56,0x0D,0x19,0x87,0x23,0x1C,0x0B,0x0A,0xB2,0xFC,0x0F,0x50,0x19,0xC1,0xB8,0x25,
+	0xFA,0x91,0xAE,0x1A,0x65,0x4B,0x97,0x6C,0x81,0xDE,0xC7,0x39,0x6D,0xA3,0x0F,0x3F,0x1C,0x98,0x06,0xC8,
+	0x59,0x91,0xE7,0xA8,0xD5,0x7F,0x2F,0x7D,0x8B,0x23,0xA4,0x1D,0x1C,0x77,0x78,0xB8,0x1C,0x4C,0xB6,0xDA,
+	0x77,0x36,0x99,0xBA,0x63,0x20,0x2A,0x6F,0x5D,0xF9,0x2D,0xD6,0xC6,0x93,0xE1,0x3E,0x57,0x15,0x2E,0x7B,
+	0x4B,0xB2,0xF3,0x5E,0xD0,0x51,0x97,0x59,0x2F,0x9B,0xD1,0x6B,0xD7,0xB2,0x3D,0x1D,0x98,0xC3,0x91,0xDB,
+	0xFF,0xFF,0x26,0x68,0x0D,0xA4,0x3A,0x64,0x0A,0x8D,0x8C,0x0D,0xA9,0x31,0xAE,0x09,0x98,0xA9,0xD1,0x3F,
+	0x7A,0x0A,0xB6,0xB5,0x3F,0xFE,0xD3,0x43,0x7D,0xE5,0xE0,0x47,0x78,0x3A,0x1C,0x51,0xBF,0x11,0x51,0x34,
+	0x31,0xDD,0xFD,0xB2,0xA1,0x48,0xE9,0x17,0x2F,0xB7,0x52,0x06,0xFE,0x15,0x25,0x6A,0xA2,0x07,0x83,0xD3,
+	0x21,0x96,0x99,0x08,0x3A,0x60,0xC2,0x53,0x68,0x27,0x77,0x31,0x14,0x7F,0x92,0x29,0xE3,0xBB,0xD2,0x16,
+	0x61,0x3E,0x9A,0x61,0x61,0xAA,0x64,0x27,0x32,0x83,0xD8,0x6F,0x33,0xCE,0xE0,0x26,0x10,0x95,0x67,0xF5,
+	0xA4,0xAB,0xDA,0x4C,0xBA,0x3C,0xBD,0xF2,0xB2,0x4E,0x29,0xE7,0x52,0xBE,0x1B,0x22,0xE9,0xA4,0x57,0xA6,
+	0xEB,0x3C,0xC4,0x40,0xFF,0x05,0xC9,0x17,0xD7,0x2B,0xD9,0x1A,0x0E,0x71,0x60,0x84,0xFD,0xA1,0x6A,0xD0,
+	0x48,0xE9,0x2B,0x90,0xB3,0x99,0x71,0x37,0x30,0x5C,0xAA,0x96,0x18,0xCA,0xC9,0xCB,0x35,0xED,0x89,0xFB,
+	0x93,0x20,0x9F,0xF5,0x76,0xF1,0xA3,0xE7,0x6D,0xA3,0x0F,0xDA,0xEA,0xD7,0xB5,0x4C,0xA8,0xC7,0x12,0xE0,
+	0x76,0x49,0x67,0x6E,0xBF,0x30,0x07,0x01,0x20,0xDA,0x93,0x39,0xD0,0x99,0x96,0xBB,0x24,0xAC,0x1E,0xC8,
+	0x54,0xA0,0x90,0x30,0xA3,0xDD,0x16,0xEE,0xDA,0x67,0x1A,0xB8,0x0F,0xAD,0x29,0xA2,0xE6,0x6F,0x83,0x00,
+	0x28,0x6A,0x90,0xC1,0x7B,0x60,0x50,0x58,0xA8,0xA3,0xF9,0xD2,0x65,0xA3,0x2B,0x56,0xF6,0x0C,0xEB,0x93,
+	0xD4,0x0C,0xDC,0x78,0x45,0xAF,0x0D,0x82,0xEE,0x39,0x4D,0x55,0xCD,0xAD,0x5B,0x3B,0x85,0x74,0x3A,0xE0,
+	0x03,0x50,0x04,0x44,0x74,0x33,0xA1,0x24,0x2A,0x1D,0xD7,0x54,0x1B,0xD1,0x53,0x3F,0x49,0x1C,0x1E,0xCB,
+	0x88,0xCD,0x4A,0x0C,0x96,0xAC,0xA4,0xC5,0x45,0x7A,0x19,0x89,0xD3,0x2E,0x44,0x80,0xB6,0x29,0x03,0x15,
+	0x1F,0xFF,0x06,0x21,0xBE,0xB9,0x1B,0xF3,0x1E,0xE8,0xAD,0x91,0xCE,0x63,0x0B,0x01,0x0A,0xD0,0x9E,0x45,
+	0x1D,0xD2,0x7C,0x3F,0xAD,0xB2,0x28,0x56,0x3E,0x3C,0x59,0x82,0x64,0x96,0x8C,0x60,0xFD,0xD9,0xDF,0xCB,
+	0x17,0xA8,0x49,0xDC,0x54,0x22,0x05,0xF6,0x84,0xF8,0xFC,0x1E,0x1A,0xCF,0xD6,0x81,0xE2,0xE2,0x42,0x2D,
+	0x7A,0xFD,0x9C,0xA1,0x94,0xDB,0x1E,0x76,0x83,0xFD,0x15,0xAF,0x4A,0x86,0x25,0x59,0x33,0xB7,0x4E,0x00,
+	0x40,0x17,0xBC,0xB5,0xBB,0xFA,0x46,0x74,0x94,0x5A,0x46,0x6C,0xD5,0x08,0xAD,0x19,0x46,0xF7,0x05,0x28,
+	0x3E,0x47,0x57,0x83,0xCC,0xE6,0xB3,0xDB,0xF3,0x30,0x0D,0xA9,0x4B,0xF4,0x9C,0xAD,0x0D,0x7D,0xD9,0xA7,
+	0x49,0x25,0x83,0x45,0x59,0x05,0xC3,0xB8,0x9C,0xFA,0xAF,0xBD,0x5B,0x7E,0x32,0xDE,0x77,0x13,0x87,0x99,
+	0x90,0x2B,0x4F,0x59,0x17,0xFB,0x74,0xCE,0x8D,0xC2,0xAA,0x5B,0x5B,0x14,0xFC,0x24,0xEE,0xF3,0x64,0xAF,
+	0xA0,0x4F,0x29,0x68,0x05,0x9B,0x14,0x29,0x43,0x4C,0xE3,0x21,0x85,0x46,0x27,0x8B,0xC8,0xD4,0x87,0xFA,
+	0x3F,0x79,0xC3,0xDA,0xDA,0xCF,0xD7,0x41,0xE6,0xE5,0x69,0x5C,0x8B,0x5A,0xE9,0x98,0xD9,0xDE,0x8F,0x4C,
+	0xCC,0x12,0xDE,0x24,0xB9,0xA4,0x7F,0x73,0xE8,0x0F,0xDD,0x8F,0xC8,0x3B,0x7A,0x6F,0x3B,0x63,0x84,0x90,
+	0x06,0x6D,0xDC,0xB1,0x61,0xCA,0xEA,0xDC,0x3C,0xE3,0x35,0x28,0x34,0x7A,0xFC,0x66,0x95,0xB7,0x62,0xB8,
+	0x39,0x6E,0xEE,0x0B,0xBE,0x85,0x7F,0xBE,0xAE,0x37,0xBB,0x05,0x27,0x0F,0xE2,0xA7,0x8A,0x6C,0xCF,0x21,
+	0xB7,0x15,0x78,0xEF,0x39,0xC1,0xA1,0x02,0xA6,0xA7,0x99,0xC3,0x05,0x81,0x81,0xC4,0xE1,0x6A,0xF5,0x63,
+	0x69,0x20,0xE8,0x7A,0xFF,0x4D,0xEB,0x11,0x32,0xCB,0x52,0x10,0x10,0xF6,0xB8,0xC0,0xF8,0x28,0xA2,0x96,
+	0x1D,0x08,0xED,0x90,0xC7,0xFF,0x5A,0x00,0x45,0x2D,0xB1,0x7B,0x09,0x2B,0xF3,0x46,0x90,0x64,0xB1,0xF6,
+	0xB1,0x6B,0xA9,0x66,0x90,0xFD,0x3D,0x23,0x07,0x01,0xF1,0xE5,0x9F,0xA6,0x47,0x4B,0x48,0x61,0xA1,0x43,
+	0x2A,0x85,0xBD,0x12,0x0A,0x6A,0x10,0xAF,0x0C,0x6D,0xF0,0xCE,0x4D,0x08,0x33,0x4E,0x7D,0x45,0x0B,0x6C,
+	0x3E,0x1D,0xC8,0x17,0x1C,0x19,0xE8,0x9E,0x2E,0xDA,0x80,0xCD,0x29,0x44,0xBB,0x4B,0xC8,0x91,0x73,0x7C,
+	0xE8,0xC4,0x15,0x9A,0xE6,0x6E,0x22,0xDD,0xFD,0xB9,0xD1,0x69,0x66,0x62,0xF2,0x04,0x78,0x2D,0xAC,0xC8,
+	0x49,0x40,0x28,0x78,0x07,0xE1,0x42,0x0A,0x02,0x27,0x82,0x4C,0x3D,0xA1,0x69,0xAA,0x0C,0xCD,0x36,0xBE,
+	0x20,0x8E,0xB6,0x28,0xE4,0x5C,0x2D,0x7E,0xBE,0x2F,0x6C,0x02,0xB0,0x40,0x1A,0xE3,0xDA,0xBF,0x70,0xB4,
+	0x77,0x87,0x27,0xCA,0x90,0x24,0xB2,0x36,0x27,0xB4,0x13,0xEA,0x2B,0x8C,0x2C,0xDF,0xC9,0x40,0xB2,0x41,
+	0xDB,0x62,0xAF,0x85,0xC9,0x0D,0x53,0xEB,0x36,0x06,0xA4,0xA3,0x63,0x1B,0xFA,0x64,0x74,0x8D,0xA3,0xA0,
+	0xDA,0x70,0xEC,0x26,0x17,0x5B,0xB7,0xE0,0x86,0xAC,0x0C,0xE5,0x96,0x32,0xEC,0x36,0x2B,0x2F,0x82,0x9A,
+	0xD6,0xB3,0x51,0xAA,0xA2,0x70,0x97,0xB7,0xB6,0x1D,0xA0,0xA2,0x60,0x7F,0xA2,0x23,0xBA,0x39,0x3B,0xF1,
+	0xCD,0x9E,0x18,0x13,0xF3,0xD2,0x23,0x12,0x77,0xDB,0x7F,0x41,0x96,0xD3,0x1A,0xEE,0x46,0xB3,0x51,0x42,
+	0x59,0xE1,0x4A,0xDA,0xEB,0x72,0x0E,0x62,0x38,0xBD,0x93,0xA1,0x53,0xFB,0x56,0xB6,0x3B,0x77,0xBD,0x7F,
+	0x61,0x17,0xEE,0xF2,0x71,0x37,0xA5,0x56,0xD3,0x9B,0xC1,0xCA,0x85,0x32,0xB8,0x23,0xEA,0xD7,0xFD,0xFA,
+	0x1F,0x1F,0x8A,0x13,0xA3,0xBE,0xCD,0xC3,0x56,0xAC,0x70,0x91,0x18,0xB9,0xB7,0xB7,0xB3,0xB9,0x34,0xB9,
+	0xC7,0xDC,0x66,0x1A,0xD1,0x07,0x79,0x6D,0x85,0x5B,0xCE,0xB7,0x7A,0x1A,0xEC,0xBF,0x2B,0x5B,0x3B,0x59,
+	0xF7,0x30,0x24,0xB8,0xAF,0xDD,0xC0,0xB8,0x1E,0x8C,0x1D,0x3B,0x3D,0xD8,0x81,0xEA,0x80,0x17,0x55,0xAB,
+	0x05,0xB9,0xD9,0x5F,0xCE,0x0B,0x91,0x68,0xD9,0x3F,0xA7,0x9B,0xB4,0xDA,0x37,0x7B,0xDE,0x5F,0x7F,0x2B,
+	0xDA,0xF3,0x60,0xD9,0x43,0xED,0xC6,0x38,0x2E,0x73,0x10,0xD2,0x6F,0x9C,0x34,0x06,0xBE,0x37,0xA8,0x26,
+	0x8E,0x32,0x11,0x8C,0x31,0xDF,0x68,0x8F,0x69,0x1F,0xA7,0xF9,0x9A,0xF4,0xD8,0xAB,0xBE,0xDC,0x87,0xCD,
+	0xE7,0xB3,0xD0,0xD3,0x8D,0xA7,0xB5,0xFC,0x93,0xF7,0xFA,0x4A,0xC2,0xDD,0xA5,0xDA,0x9F,0xB2,0x74,0x88,
+	0x9F,0xD0,0x7C,0x8E,0xDE,0xF6,0x81,0xE8,0x77,0xCD,0x7F,0x76,0xC6,0xFF,0x80,0x5F,0x98,0x4F,0xAD,0x15,
+	0xD4,0x7F,0x88,0x04,0x25,0x8C,0xB2,0x8F,0xEA,0xAC,0x3B,0xD2,0xA1,0x50,0x20,0x10,0xB8,0x05,0xAD,0x93,
+	0x8C,0x08,0x41,0x1D,0x1E,0x4E,0x23,0x0B,0x63,0xBE,0x29,0xD6,0x73,0x72,0x50,0xED,0x66,0x18,0xEA,0xEF,
+	0x11,0x43,0xB2,0x2A,0x62,0xC6,0x08,0xC6,0x5D,0x5E,0x38,0x7C,0xDB,0x37,0x04,0xBB,0x81,0x0B,0x6E,0x12,
+	0xF9,0x1B,0x74,0x16,0x7D,0xE9,0xF1,0x62,0x7B,0xD9,0xF3,0x72,0xFE,0x47,0xCF,0x8F,0xB6,0x26,0xF6,0x96,
+	0x9A,0x01,0xBA,0x33,0xF0,0x99,0x51,0x2F,0xB3,0x24,0xC1,0x89,0xD0,0xBB,0x35,0x42,0x1B,0x02,0x1F,0xB3,
+	0x78,0x8A,0xB2,0x2E,0x9D,0x98,0xA2,0x0A,0xED,0xF8,0xF0,0x26,0x57,0x7B,0x21,0x7E,0xF7,0x64,0x42,0x14,
+	0x96,0x2B,0x81,0xD6,0x6C,0xDF,0x76,0xDF,0xFB,0x0D,0x0F,0x67,0x84,0x8F,0x6D,0xE3,0xF8,0xFF,0x0F,0x47,
+	0x91,0x46,0x6F,0x3D,0x53,0xC4,0x5A,0x03,0x4E,0x00,0xED,0x18,0x15,0xA7,0x13,0x24,0x3E,0x4A,0xAE,0xAA,
+	0xFC,0x75,0x0A,0x59,0xF7,0x08,0x70,0x39,0x50,0x24,0x39,0xC6,0x31,0x44,0x3B,0x14,0x32,0x2F,0x11,0xB2,
+	0x2E,0xA7,0x79,0xC9,0xED,0xD1,0x69,0xCD,0xB9,0x70,0xAA,0x4B,0x93,0x08,0x4A,0x27,0x77,0xF2,0x5A,0x36,
+	0x3A,0xDD,0x5C,0xF7,0xF2,0x1B,0xF3,0x2F,0xDF,0x71,0x3B,0x41,0xE1,0x4A,0x07,0xB2,0x09,0x21,0x87,0x22,
+	0xC8,0xA0,0xFD,0x8F,0x13,0x0A,0xF0,0xFC,0x7C,0xB3,0x74,0x1A,0xB5,0xD0,0x53,0x6C,0x3A,0x39,0x4B,0x4F,
+	0xB3,0x2B,0xDB,0x0A,0x57,0x94,0x14,0x44,0x74,0xD4,0x6B,0x84,0x99,0x4F,0xEC,0xAC,0xD7,0x31,0x55,0x8A,
+	0xC6,0x0A,0x1C,0x3B,0xC6,0xD1,0x0C,0x76,0x33,0x8E,0xB7,0xBB,0xD2,0xF4,0xC5,0xFC,0xB5,0x9F,0xFD,0x8C,
+	0x5D,0x00,0x6B,0x43,0x15,0xD6,0xAC,0xBA,0x53,0xF7,0xAD,0xE7,0x2E,0x08,0x31,0x66,0x12,0x03,0x2A,0x53,
+	0x8A,0x5C,0x8E,0x4F,0x48,0xA7,0x2A,0x22,0xE5,0x99,0x70,0xA6,0xCD,0x75,0x14,0x37,0x2E,0x22,0xC3,0x1F,
+	0x83,0x17,0xB5,0xA2,0xF2,0x2A,0xC8,0x53,0xC8,0xBE,0x54,0xFC,0x9A,0x23,0x78,0xD3,0xDF,0x78,0xEE,0x2E,
+	0x43,0xAA,0xFF,0x42,0x41,0xBD,0x6E,0x6F,0x53,0x60,0xAE,0xFA,0x76,0xA2,0x7C,0xD7,0x87,0x00,0x4D,0x52,
+	0x44,0xBC,0x22,0x8B,0x75,0xC8,0x71,0x70,0x84,0x77,0xA3,0x1E,0x29,0xA8,0x3A,0x05,0x1C,0x0C,0x17,0xD7,
+	0x14,0xA7,0xEE,0x9E,0x08,0xE7,0xF1,0x1C,0x56,0xFE,0x6A,0x6F,0x9A,0xB2,0x98,0x32,0x6A,0x99,0x8D,0x46,
+	0xCC,0xAD,0x3D,0x61,0x2C,0xD5,0x27,0x83,0x34,0xB7,0x28,0x0C,0x13,0x52,0x36,0x4F,0x01,0xFF,0x2F,0x9C,
+	0x9A,0x8F,0x8B,0x1A,0x9D,0x4C,0x71,0x5B,0x4E,0x1A,0xE7,0x8F,0x20,0x6E,0x46,0x8B,0x90,0x1C,0x42,0x4B,
+	0xC5,0x7D,0x6F,0x63,0xD9,0xAC,0xC1,0x13,0x8F,0xEF,0x75,0xD7,0x88,0x99,0x34,0xD4,0xCE,0xF2,0x71,0x17,
+	0x8A,0xC1,0x84,0xE0,0x43,0x3F,0x0A,0x67,0xAA,0xAF,0xFC,0x3B,0xAA,0x83,0x39,0x0B,0x7D,0xD3,0xF8,0x92,
+	0x23,0xE1,0xE0,0x87,0x72,0x80,0xCE,0xA2,0x5C,0x7E,0xA6,0x8B,0x7A,0x60,0x15,0x32,0x5A,0xDE,0xE2,0xBA,
+	0x37,0x34,0xD9,0x21,0xB5,0xB1,0xA0,0x50,0x95,0xDF,0x8E,0x21,0x62,0x4F,0xF7,0x21,0x76,0xBD,0x96,0x10,
+	0x5F,0xE5,0xAF,0xCD,0xB0,0xA2,0xC0,0x11,0xF6,0xA0,0x93,0x76,0xF3,0x9E,0xD9,0x54,0x37,0xBD,0x6F,0xC1,
+	0xD4,0x3F,0x15,0x4D,0x77,0x4F,0x76,0xBC,0x6C,0x6A,0xF1,0x13,0xDF,0xC7,0xC2,0x49,0xEB,0x5C,0xF1,0x3E,
+	0x6C,0x42,0xB4,0x19,0xD7,0xE7,0x5B,0xE3,0xE1,0x19,0x0B,0x09,0xD0,0xFB,0x8E,0x60,0xBF,0xEB,0x46,0x54,
+	0x99,0x38,0x93,0x9C,0xBC,0xE4,0x55,0x9C,0xA6,0x59,0x68,0x3D,0xAA,0xD9,0x4A,0x10,0x02,0xE5,0x35,0xBC,
+	0x67,0xC5,0xF6,0xA9,0x67,0x4B,0xA7,0x60,0x3D,0x82,0x88,0x29,0x1D,0x2A,0x53,0xAD,0x87,0x6A,0x84,0x57,
+	0xAC,0xC8,0xC4,0x8F,0xD7,0x66,0x34,0x68,0x64,0x85,0x9A,0xA6,0xBF,0xE9,0x89,0xB1,0xBD,0xDE,0x12,0x64,
+	0xBB,0xF8,0x9F,0x73,0xB9,0x90,0x0A,0x10,0x91,0xA4,0x5D,0xC4,0x11,0x67,0x41,0x37,0xE4,0x48,0xDE,0x8F,
+	0xE3,0xDF,0x56,0x0E,0x88,0x9E,0x3B,0x3A,0x3F,0x17,0x01,0xCD,0xF8,0x9D,0x74,0xFB,0xFE,0x6F,0xD5,0xFD,
+	0x31,0xA6,0x43,0x50,0x2C,0x17,0x1B,0x75,0x7A,0x46,0xC2,0xC0,0x0F,0x1C,0x9D,0x46,0xFB,0x73,0x32,0x15,
+	0x32,0x33,0x4F,0x91,0xAF,0x6F,0x91,0x21,0x99,0x32,0xD2,0xA4,0xB3,0xA0,0xAE,0x81,0x9E,0xAE,0x84,0x79,
+	0xFE,0x81,0x1D,0x4D,0x7B,0xF8,0xE2,0x39,0x61,0xEF,0xC8,0xCE,0x39,0x73,0x59,0x91,0x02,0xAA,0x50,0xD0,
+	0x7C,0x7F,0x94,0x78,0x3E,0x70,0x50,0x31,0xE1,0xD3,0x3F,0x84,0x73,0xE2,0xA6,0x6A,0xB0,0x5D,0xA0,0x06,
+	0xDD,0xF4,0x98,0x28,0x9F,0x20,0xCC,0xA9,0xD7,0x75,0xD9,0x93,0x61,0xA5,0x08,0x3A,0xDE,0xD5,0x94,0x61,
+	0x94,0xD2,0xC4,0x4D,0xCC,0x05,0x3D,0x82,0xE2,0xD3,0xB0,0x74,0x30,0x1F,0x5B,0x41,0x51,0x93,0xA2,0xFD,
+	0xC6,0x53,0x8D,0x9D,0x29,0x9E,0x95,0x64,0x16,0xD6,0x83,0xBA,0x43,0x7D,0xC5,0x85,0x85,0x4F,0x5A,0x20,
+	0xBB,0xAB,0xDF,0x24,0x9A,0x09,0xE4,0x8D,0xB8,0x7B,0xCC,0x09,0x83,0x97,0x93,0xAC,0x09,0x4A,0x58,0xA9,
+	0x94,0xF4,0x04,0x99,0xBD,0x9D,0x57,0x1E,0x73,0x29,0x3C,0x4B,0x5B,0x67,0x9D,0xE0,0x43,0xB9,0x0D,0x8D,
+	0x30,0x9E,0x0C,0x9C,0x23,0x6B,0x52,0x76,0x5C,0x0A,0xDC,0xD1,0x7F,0xD3,0x05,0x99,0x35,0x7F,0x51,0x72,
+	0x22,0x95,0xB6,0x4A,0x28,0x75,0x9E,0xAA,0x3F,0x88,0x0C,0xED,0xB6,0x67,0xE0,0x4C,0x8F,0x85,0x92,0xBE,
+	0xB5,0xDD,0x0C,0x7C,0x2D,0x74,0x6E,0xCD,0x27,0x9E,0x8B,0x5C,0xC0,0x0D,0xB7,0x24,0x5B,0xDA,0x9A,0xBE,
+	0x38,0xA5,0x0D,0x31,0x1F,0x07,0x14,0x4D,0x1C,0x25,0x8E,0x9C,0x4C,0xFD,0x3F,0x30,0x4A,0xEB,0x51,0xC9,
+	0x60,0x2D,0xC7,0x8D,0x20,0x57,0xB2,0x30,0x93,0xFF,0x9E,0x0C,0xB2,0xB2,0x0E,0xCE,0xDF,0xD5,0x9F,0x05,
+	0x42,0x43,0x0B,0x9A,0x6F,0xE0,0x2E,0xC3,0xB3,0xFF,0x05,0x81,0x61,0x62,0x21,0x01,0x5B,0x01,0x9A,0x4B,
+	0x61,0xFE,0x47,0x4B,0xE2,0xDA,0xF0,0x91,0x63,0xBC,0x4C,0x43,0xDF,0x9E,0x0A,0x34,0xF3,0x81,0x68,0xD8,
+	0xB9,0x4F,0xC4,0x7E,0x18,0x22,0xC0,0xA0,0xDB,0xFF,0x3A,0xF3,0x70,0xAF,0xD5,0xA1,0x78,0x83,0xD0,0x88,
+	0x57,0x2E,0xDB,0xC4,0x4A,0x7B,0xDC,0x11,0x6A,0x82,0xF0,0x07,0x3F,0x42,0x7E,0x84,0x40,0x91,0xC1,0x3B,
+	0xF4,0x6A,0x96,0xF2,0xA2,0xA9,0xFC,0x76,0xF2,0x81,0x77,0x94,0x29,0x4D,0x37,0x53,0xF3,0xE0,0xFC,0xE0,
+	0xEB,0x01,0xF7,0xA5,0x09,0x80,0x43,0x41,0xA9,0x12,0x1E,0xDD,0xC6,0x2E,0x7E,0x31,0x62,0xDB,0xFE,0x29,
+	0x31,0x64,0x97,0xE4,0x70,0x54,0x80,0x23,0x5C,0xCB,0x33,0xD4,0x53,0x18,0xCC,0x4A,0x7D,0xD1,0x98,0x55,
+	0xBF,0x16,0x1C,0xA4,0x2D,0xCA,0x3E,0x33,0xE0,0xF9,0xF5,0x73,0x94,0xDD,0x91,0xC8,0x8C,0x45,0x81,0x16,
+	0xAE,0x04,0xE4,0x2E,0x1E,0x5B,0x98,0xA5,0x91,0xD6,0x82,0x71,0x1A,0x3A,0x8D,0x07,0x38,0x24,0x3C,0xC5,
+	0x60,0x91,0x84,0x20,0x10,0x91,0x6C,0x2E,0xA9,0xCB,0xCA,0x20,0xDD,0x8A,0x74,0xAC,0x8B,0x0D,0xC5,0x96,
+	0x1A,0x19,0x1E,0xDA,0x4F,0x5A,0x32,0x95,0xD9,0x6A,0x7D,0xBC,0x69,0x69,0x43,0xA5,0x0B,0x83,0xA0,0xDA,
+	0x44,0xC1,0x3B,0xA9,0x5D,0x18,0xD3,0x7B,0x48,0x81,0xB5,0x65,0x14,0x49,0xD2,0xD6,0x7D,0x44,0x8B,0x94,
+	0xEB,0xBE,0xF9,0x06,0xEB,0xA3,0xBC,0x4A,0x79,0x5B,0x7D,0x32,0xFF,0xD0,0xEC,0xC8,0xD7,0xEA,0xDB,0x59,
+	0xE2,0xA4,0xB4,0xE8,0xF2,0xE4,0x0F,0x50,0x69,0xAF,0xDA,0x8C,0xA4,0xC2,0x17,0xBA,0xAC,0xA5,0x10,0xBE,
+	0x16,0x23,0x93,0x71,0x42,0x0C,0xD2,0x2D,0xDE,0x47,0x09,0xA6,0x62,0x5E,0x36,0xB1,0x9B,0x90,0x1B,0x16,
+	0xA3,0x42,0x8E,0x8E,0xED,0xC2,0xF9,0x79,0x22,0x8B,0x42,0xF7,0x0C,0x72,0x45,0x6C,0xDF,0x05,0x69,0xE3,
+	0x76,0xA0,0x3F,0x14,0x4E,0x44,0x38,0xF6,0xCE,0x5D,0x18,0x4F,0x80,0xF2,0x55,0xD2,0x52,0x01,0xB0,0x7C,
+	0xA2,0xC9,0xD4,0x81,0x11,0xED,0x6D,0xD2,0xDA,0xD3,0xA9,0x65,0xF2,0x69,0xA1,0xE2,0x9B,0x95,0xEB,0x31,
+	0x44,0x95,0x4C,0x4F,0x19,0x29,0xFD,0xE6,0xD3,0x31,0x3A,0xFC,0xD3,0xC2,0x9B,0xD0,0x34,0x8E,0x0F,0xA7,
+	0x6C,0xFB,0xB4,0x97,0x1B,0xF6,0x8B,0x54,0x11,0x05,0xCF,0xBE,0xEF,0xC4,0x03,0x74,0x51,0x84,0xBB,0x34,
+	0x39,0xD8,0x3B,0xF8,0xA4,0x25,0x2B,0x3C,0xA2,0x74,0x0E,0x9E,0xEC,0xF9,0xAA,0x96,0x98,0x1A,0x75,0x2F,
+	0x0F,0x1A,0x96,0xD5,0xC8,0x57,0x9D,0x75,0x08,0xFA,0xC3,0xC5,0x04,0xC8,0x82,0xFB,0x1A,0x91,0xD2,0x4C,
+	0x6E,0x7A,0x4D,0xA8,0x6E,0x4B,0x11,0xD4,0x78,0x78,0x8C,0x69,0x1B,0x19,0x3A,0xE3,0x9A,0x92,0xD8,0xA9,
+	0x55,0x79,0xB0,0x1C,0x7F,0x89,0x27,0x1B,0x28,0x10,0xD6,0x8D,0x4D,0x35,0x2B,0xE9,0xEC,0x14,0x97,0xAD,
+	0xDC,0x7C,0x51,0x30,0xF5,0x6E,0xF7,0x99,0x50,0x4A,0x42,0x96,0xC7,0x0E,0x84,0xBD,0xF9,0x7B,0xB9,0x8F,
+	0xF0,0xB3,0xE6,0xD1,0x41,0xDC,0xC7,0x88,0x72,0xFE,0xE8,0x5D,0xF7,0xCA,0xD9,0x9F,0xC2,0xCC,0x0E,0xC4,
+	0x8A,0xC9,0x4B,0x62,0xEB,0x32,0xE0,0x54,0x07,0xD2,0x17,0xB7,0x78,0xB1,0x07,0x14,0x75,0x8E,0xC6,0xD6,
+	0xDE,0x1C,0xDF,0xE9,0x52,0xDE,0xAA,0xAA,0xD3,0x49,0x58,0x25,0xBB,0x84,0x9F,0x51,0x9F,0x1D,0x0E,0x83,
+	0x7B,0x3E,0xA7,0xF3,0x36,0x80,0xFE,0xFE,0x14,0x0F,0xDC,0xB1,0x66,0x9D,0xE4,0x19,0x72,0x7B,0xAF,0xE1,
+	0x33,0x80,0x96,0x3A,0x98,0x07,0x99,0x0F,0xD9,0xC2,0xBB,0x35,0xA8,0x40,0x5F,0xAA,0x25,0x08,0xFE,0x75,
+	0x7F,0xF3,0x57,0x1E,0xC5,0xD2,0xB1,0xDE,0x9C,0xA0,0xEE,0x17,0x8C,0x0C,0xB7,0xD7,0x80,0x0E,0x60,0xCE,
+	0x21,0x92,0x74,0xC8,0x24,0x30,0xCC,0xDD,0x07,0xC4,0xBB,0x46,0x10,0x34,0x8F,0x0C,0x68,0x1B,0x20,0xD4,
+	0x46,0xE4,0xE8,0x21,0x33,0x00,0x3E,0x69,0x25,0x19,0x7A,0x63,0x73,0xED,0x98,0xF3,0xA3,0x44,0x6D,0x78,
+	0xED,0x89,0xD8,0x58,0xFC,0x73,0xB1,0xCA,0xF6,0xC2,0xF9,0x63,0x7E,0x46,0x7B,0x4F,0x81,0x94,0x54,0x0C,
+	0xE4,0xA7,0xB8,0xB4,0x2E,0x84,0xC1,0x92,0xFE,0x30,0x18,0xF9,0x57,0x27,0x33,0x1E,0xF7,0xD9,0x85,0xE7,
+	0x3B,0xC8,0x49,0x5C,0xA7,0xEE,0xDF,0x9E,0x5C,0x87,0xB4,0xDE,0x2B,0xEB,0xFA,0x92,0xE4,0xC1,0x0E,0x5C,
+	0xE6,0x8C,0xE8,0xF6,0x8E,0x51,0x9D,0x22,0x11,0x0C,0x00,0x83,0x34,0xF9,0x9D,0x8F,0x7D,0xF5,0x15,0x6A,
+	0xE5,0x86,0xFA,0x1F,0x9B,0x98,0xBB,0xFD,0xCB,0x89,0x83,0xD1,0x71,0xE6,0x63,0x28,0xF9,0xE9,0x22,0x56,
+	0xAF,0x18,0x14,0x93,0xA7,0xEF,0xEE,0x08,0xD6,0xBC,0x6A,0x38,0xFC,0xE8,0xB3,0x45,0xFA,0xC1,0x44,0xDE,
+	0x27,0x76,0xDE,0x69,0xD7,0x4A,0x5B,0xB4,0x88,0x9D,0xB1,0xEF,0xD8,0xFC,0x15,0x93,0xCF,0xEC,0xD7,0x53,
+	0x56,0x76,0x53,0xA0,0x02,0x79,0x89,0x5B,0x9C,0xED,0x84,0x08,0xE5,0x6C,0xDF,0xA8,0xD9,0x55,0x3A,0xF0,
+	0xDF,0x6B,0x64,0x2E,0x7C,0x1D,0x66,0x89,0x0E,0x92,0xB4,0x57,0xD7,0xB0,0xF7,0xE1,0xC4,0x3E,0x7C,0x74,
+	0xDC,0xE0,0x59,0x72,0x39,0x93,0x3F,0x32,0x47,0xE1,0x3F,0x7F,0x50,0xD0,0xF1,0x65,0x18,0x1F,0x32,0x13,
+	0xE2,0xC1,0x8B,0xD6,0x14,0x73,0xBC,0xE0,0x91,0xFF,0xF5,0x92,0x7D,0xC2,0x6C,0x11,0x39,0x97,0x85,0x49,
+	0x59,0xFE,0x2C,0x97,0xAB,0x39,0xE2,0x99,0x8B,0x48,0xB4,0x11,0x8F,0x85,0xF2,0x42,0x9F,0x3D,0x8D,0x92,
+	0x51,0xD7,0xC8,0x2F,0x27,0xF7,0x79,0xCD,0x53,0x97,0xAE,0x09,0x71,0x4F,0x35,0x4C,0x4F,0x67,0x3E,0xC7,
+	0xB0,0x26,0xD9,0x70,0x8F,0xDC,0xE7,0x18,0x09,0x7B,0x3C,0xD3,0xA1,0xA4,0xEE,0xBD,0x6B,0xB4,0x68,0x69,
+	0xAF,0x86,0x59,0x73,0xAC,0x2B,0x40,0xFB,0x2D,0xD8,0xB5,0x9F,0x00,0xBC,0x48,0xAD,0x6A,0x68,0x49,0x2C,
+	0x8C,0xFA,0xBB,0xE9,0x11,0xF5,0xBF,0x8D,0x5B,0x9A,0x36,0xAB,0x4F,0x9B,0xC1,0xF9,0x80,0x4F,0x33,0x1B,
+	0x4D,0x35,0x50,0x9E,0x88,0x9B,0xF8,0x2F,0xDE,0xEC,0x8F,0x55,0x50,0xF7,0x49,0xEF,0xAE,0x21,0x89,0x2A,
+	0x9B,0x16,0xBF,0x7D,0xF3,0x99,0x40,0xC1,0x2F,0x24,0xA0,0x8D,0xD3,0x3A,0xBF,0xC5,0x9B,0xB7,0x56,0x08,
+	0xE9,0xEF,0xBE,0x7A,0x97,0x35,0xD5,0xAA,0xAF,0x8B,0x11,0xAD,0x60,0xD3,0x49,0x7E,0x12,0x85,0xAC,0xB9,
+	0xA1,0xF5,0x7C,0x3B,0x2E,0x81,0x66,0x27,0xD1,0xF3,0xE7,0x12,0xEC,0x45,0xE5,0x11,0x01,0x53,0x27,0xD2,
+	0xA9,0xAC,0x08,0x9F,0xFB,0x12,0x59,0xC3,0xDB,0x9E,0x7F,0xDC,0xB7,0xBD,0x4F,0x66,0x6A,0xE3,0x56,0xF7,
+	0x2E,0x24,0xF3,0xD3,0x7E,0x65,0x14,0x57,0x7E,0x2F,0x0E,0xB4,0xE8,0xC8,0xB0,0x64,0x19,0x2A,0x98,0x01,
+	0x73,0xEE,0xC6,0xB0,0x1B,0x84,0x7F,0xA8,0x28,0xA2,0x50,0x81,0xCB,0x89,0xC6,0x30,0xE6,0xC9,0x97,0xF8,
+	0xD6,0xD8,0x1B,0x10,0x7E,0x8E,0x09,0x36,0x35,0x61,0x48,0x43,0xAB,0xA0,0x2E,0x9D,0x25,0x80,0xFF,0x0F,
+	0x97,0xD9,0x50,0xBB,0x61,0x24,0x04,0x10,0xC2,0x5B,0xC6,0x48,0xB9,0x20,0xD8,0x23,0x77,0xAE,0xEC,0xAD,
+	0x5B,0x65,0x39,0x54,0xE2,0xC9,0x7C,0x50,0xBA,0x46,0xE8,0x33,0x39,0x19,0x9E,0x40,0x94,0xB6,0x6F,0xD0,
+	0xA3,0x42,0xEB,0xD5,0x4B,0xC9,0x31,0x55,0x63,0x86,0xCA,0xD2,0xAC,0x3C,0x13,0x6C,0xA8,0x48,0xA1,0x52,
+	0x3A,0x24,0xC2,0xD1,0x8C,0xA5,0xCD,0x36,0x19,0xD8,0x6C,0x9D,0x4E,0xF2,0x52,0xD4,0xF3,0x6C,0x68,0x19,
+	0x0A,0x49,0xB4,0xB9,0x96,0xDF,0x04,0xA8,0xB6,0xE4,0xFC,0x9D,0x58,0xA9,0x55,0x69,0xC2,0x64,0xDA,0xF5,
+	0x3D,0xD5,0xB8,0xE9,0x9A,0xE7,0x94,0x5E,0xF6,0x04,0x3F,0x08,0x60,0x18,0x83,0x18,0x70,0x48,0x4D,0x7E,
+	0x17,0x41,0x5B,0xE4,0xB2,0x29,0x58,0xBB,0x8E,0xA1,0xF8,0xB7,0x2D,0x2C,0x42,0x5A,0x6E,0x41,0xAA,0x48,
+	0xBB,0xF3,0x5C,0x3A,0x63,0x00,0x5A,0xAC,0xA8,0x8C,0xA5,0xBF,0xA2,0x0E,0xF0,0x1E,0x55,0x0F,0x3B,0xF9,
+	0x0C,0x4F,0x1C,0xAF,0xED,0x68,0x0D,0x8B,0xDE,0xCB,0xAC,0x93,0xDE,0xDE,0x59,0xF6,0x60,0x4B,0x5E,0xAE,
+	0x1F,0xA2,0xBC,0x0A,0x68,0xC6,0x1F,0xAD,0x85,0x20,0x00,0x40,0x24,0x35,0xCB,0x75,0x91,0xB9,0xB4,0xD3,
+	0x0A,0x59,0x01,0x18,0x9B,0x14,0x38,0x81,0x69,0x52,0xC3,0x2B,0x52,0x33,0x54,0xBD,0x67,0xEB,0x61,0x8B,
+	0x5B,0xAA,0x03,0x05,0xFB,0xE4,0x81,0xE5,0xAF,0x70,0x55,0x25,0xBB,0x8E,0xAD,0x4B,0x5C,0x7F,0x33,0xAC,
+	0x2C,0x71,0x9B,0x2D,0x5A,0x77,0xFA,0xC2,0xD3,0xE2,0x9D,0x8F,0x89,0xC6,0x22,0xA2,0xD1,0xE9,0x54,0x29,
+	0x36,0xAF,0x72,0x50,0xEE,0x15,0x80,0x17,0x58,0x35,0xDC,0x20,0x1E,0x24,0xCC,0xF0,0xDA,0x64,0x83,0xA5,
+	0x65,0xCE,0x23,0xB3,0x57,0x73,0x52,0x3E,0x57,0x85,0x70,0x3C,0xB0,0xCD,0x0A,0x4A,0x95,0x52,0x6D,0x1B,
+	0xE2,0x3B,0x33,0xD7,0x42,0x94,0xDB,0xB7,0xD3,0xCC,0xF3,0x8E,0xC7,0x51,0xFD,0x21,0x52,0xFD,0x78,0x29,
+	0xC1,0xE9,0xDC,0x23,0x52,0x4B,0x68,0x10,0x99,0x5C,0x05,0x28,0x28,0x5C,0xC9,0x67,0xA4,0xB4,0xB0,0x28,
+	0xB6,0xCF,0xE5,0x89,0x5B,0xF6,0x25,0x19,0x8E,0xD4,0xC3,0x0C,0xA6,0x90,0xF9,0x8A,0x19,0xE5,0x86,0xB8,
+	0xCE,0xD1,0x28,0x9C,0x59,0x85,0x98,0x06,0x42,0xEA,0x87,0xCD,0x50,0xF8,0x4E,0x49,0x16,0xF8,0x8C,0x80,
+	0x12,0x3F,0x6B,0x3B,0xA6,0x5D,0xB8,0xCA,0xDB,0xBF,0x7F,0x16,0xCB,0xF8,0x51,0xDC,0x32,0x83,0x70,0xE1,
+	0xA4,0xEB,0xD8,0xBE,0x5B,0x5B,0xA1,0x00,0x6B,0xE6,0xE6,0x03,0x92,0x8C,0xB8,0xBB,0x84,0xC1,0xEA,0xE9,
+	0x53,0x6F,0xCD,0x0B,0x0A,0x1F,0x47,0x9E,0xD8,0xDF,0xF4,0xA9,0x2B,0x00,0xB1,0xDB,0x5A,0xBC,0xDF,0xFD,
+	0xBB,0x42,0x0B,0x03,0xDF,0x11,0x46,0x76,0xEF,0xD3,0x58,0x25,0xD4,0x0D,0xF0,0xA6,0x1F,0x36,0xF6,0x11,
+	0x1C,0xA3,0x56,0xBB,0xAD,0x21,0xA0,0xFE,0xFC,0xF2,0xA2,0xC1,0x37,0x6C,0xBC,0xD4,0xA9,0xF2,0x1F,0xB6,
+	0x46,0x82,0x75,0xC0,0x5E,0x81,0x9D,0x50,0xF6,0x64,0xAD,0xA5,0xF0,0x69,0x2F,0xB7,0x6C,0x4A,0xD3,0xF7,
+	0x99,0x0E,0xEF,0xA1,0xC5,0x6C,0x0A,0x82,0xD3,0x5A,0x5A,0xF2,0x9F,0x2B,0xB2,0x11,0xFD,0xC0,0x50,0x88,
+	0xAF,0xE7,0xC8,0xB6,0x1A,0xA5,0x50,0xA9,0xAB,0x88,0x68,0x25,0x67,0x20,0x40,0x8D,0xA6,0x5A,0x80,0x44,
+	0x3F,0x74,0xC5,0x21,0x75,0xE3,0xD9,0x63,0xFD,0xA9,0x6B,0x61,0x54,0x87,0xCF,0x5E,0x1E,0x2F,0x92,0x74,
+	0x26,0x78,0x79,0xD5,0x17,0x1F,0x06,0x8D,0xF8,0xC9,0x87,0x4B,0xF3,0x58,0x30,0xF5,0xF3,0x05,0xF7,0xFC,
+	0x3D,0x98,0xE7,0x09,0x32,0x68,0x93,0x0A,0xAB,0x15,0x65,0x88,0xE4,0x0A,0x7E,0xD9,0xC3,0xA1,0x61,0x3A,
+	0x25,0xC4,0x6E,0xC0,0xB4,0x78,0x71,0xF4,0x7B,0xC8,0x63,0xD6,0x62,0x07,0xE3,0x58,0xA9,0x75,0xA5,0x4D,
+	0x23,0x37,0x33,0x03,0x02,0x0D,0xB5,0x3C,0x4F,0xE9,0xC4,0x41,0xCB,0x71,0x2C,0xCC,0x59,0x46,0xF2,0x75,
+	0x24,0x57,0xDA,0x9E,0x12,0x53,0xAB,0x7F,0xF5,0xD3,0xA9,0x6E,0xAA,0x4F,0xF9,0xDE,0x5F,0xA9,0xD2,0xA0,
+	0x9D,0xA9,0xEA,0x84,0x49,0x1D,0x1E,0x01,0x37,0xAE,0x63,0x71,0xF6,0x3B,0x73,0xCD,0x1E,0xB7,0xB3,0x72,
+	0x0F,0x13,0x44,0xDB,0xDA,0x7E,0x5C,0x66,0x76,0xEC,0x75,0x3D,0x64,0x72,0xF4,0x68,0xA5,0x8B,0x85,0xDB,
+	0x2A,0x4C,0xE4,0x5B,0xA6,0x3D,0x48,0x18,0x35,0x63,0xE2,0x51,0x0A,0x7D,0x8A,0x8B,0x02,0x5F,0x32,0x02,
+	0xDE,0x3C,0x00,0x13,0x41,0x1E,0x8C,0xC1,0x0F,0xDA,0x84,0x92,0xD0,0x0E,0x77,0xE3,0xF2,0x3F,0x1E,0x02,
+	0x43,0x4F,0x67,0x43,0xE0,0xF7,0x11,0xC5,0x03,0x97,0x7B,0xD4,0x7F,0x99,0x79,0x50,0x7F,0xB0,0xBD,0x90,
+	0x41,0x91,0x0E,0x9A,0xBD,0x82,0x3E,0xC0,0xB4,0xD5,0xC9,0xE2,0xB9,0x19,0x0A,0xE5,0xC7,0x4B,0x92,0x9E,
+	0x15,0xF0,0x7E,0x8D,0xCC,0xD1,0xCC,0x3C,0x5E,0x56,0x60,0x76,0x3B,0x5F,0x7C,0x85,0x43,0x70,0x5B,0xFB,
+	0xCE,0x9B,0xB4,0x54,0xA9,0x3D,0xC1,0x81,0xC2,0xCD,0x8C,0xC3,0x9D,0xF9,0x57,0x63,0x36,0x38,0x8C,0xF3,
+	0x5C,0xF3,0x47,0x00,0xCD,0x78,0x6D,0xC7,0xFF,0x08,0x64,0x0E,0x77,0xD5,0xAE,0x2E,0x3A,0x02,0x79,0xCC,
+	0x06,0x3B,0xEC,0xEE,0x08,0x57,0x82,0xE9,0x1F,0x6F,0xF5,0xF8,0xC2,0x14,0x00,0x12,0x05,0x10,0xC0,0xB9,
+	0x59,0x2C,0x71,0x3E,0x47,0xA9,0x94,0xCF,0xEA,0xA1,0x49,0x02,0x9B,0xDA,0x17,0xDD,0x9E,0xDE,0x51,0x23,
+	0x44,0x78,0x7B,0x58,0x63,0xB3,0x41,0x03,0x18,0x78,0x6F,0x80,0xD3,0x87,0xC2,0xEE,0x58,0x33,0xDC,0x7E,
+	0xA7,0x13,0xA6,0x19,0x40,0x73,0xCC,0x4B,0x89,0xBD,0xDA,0xB8,0xC4,0x5E,0xD4,0x6E,0xA6,0x12,0x69,0x09,
+	0xEB,0x50,0xC6,0x05,0xF2,0x00,0xC3,0xA9,0x45,0x3D,0x43,0xEB,0x55,0xFA,0x25,0xCF,0x8D,0x3B,0x0C,0x6D,
+	0x7E,0x95,0x83,0x48,0x89,0x32,0x4B,0xFB,0xDC,0xDD,0x2D,0xB0,0x04,0xBB,0x98,0xDB,0xFF,0xFF,0x3A,0xF3,
+	0x74,0xFF,0x3F,0xE2,0x32,0x41,0x49,0x9F,0xE7,0x52,0xA7,0x19,0x23,0x60,0x76,0x2D,0x32,0x95,0xC0,0x05,
+	0x17,0x59,0xEB,0x56,0xB6,0x2F,0xB8,0xDE,0x24,0x77,0x3F,0x79,0x0D,0x60,0x00,0x81,0x99,0xFD,0xE9,0x23,
+	0xCA,0x59,0x7D,0x5A,0x0A,0xE9,0xB1,0x71,0xC9,0xA8,0xCE,0x17,0xB1,0x38,0xFE,0x71,0x89,0x9E,0x91,0x39,
+	0xE2,0x4F,0x23,0x36,0x23,0x84,0x6C,0xC1,0xF9,0x55,0x90,0x2C,0xBA,0x4E,0xD6,0x16,0xB9,0x67,0x11,0xCA,
+	0xE6,0x0E,0x08,0xFC,0x92,0xBE,0x43,0xF4,0x56,0xCE,0x88,0x03,0x1B,0xE8,0xED,0xD2,0xF6,0xC9,0xC7,0x7C,
+	0x12,0xA9,0x14,0x26,0x23,0xE0,0xAF,0xC4,0x3B,0xB7,0xC9,0x97,0xF3,0x04,0x7C,0x6A,0xFD,0xF2,0x11,0xF1,
+	0xF0,0x0B,0xA7,0x49,0x38,0x96,0x91,0x09,0x77,0x48,0x2F,0xFC,0x1C,0x67,0xF5,0xCE,0xC8,0xC8,0x2A,0x15,
+	0xFF,0x7A,0x1C,0x04,0xE0,0xD8,0xCD,0xF4,0x84,0x64,0x43,0x86,0xEC,0x27,0x36,0x4E,0x93,0x98,0x53,0x21,
+	0x84,0x09,0xA3,0x90,0x9E,0x52,0x29,0xC1,0x3E,0x05,0x2B,0x95,0x58,0xE8,0x74,0x5E,0xBA,0xEC,0x9D,0x21,
+	0x3E,0x66,0x79,0x35,0xC8,0xCB,0x5B,0x71,0x3B,0x61,0x51,0x21,0x39,0xE8,0x10,0xC8,0x67,0x74,0xEA,0x59,
+	0x3E,0x03,0xEC,0xCD,0xAE,0x6F,0x83,0x3E,0x28,0xAD,0xCA,0x67,0x63,0xD6,0x52,0x70,0x20,0x86,0x58,0x22,
+	0xFF,0x80,0xF9,0xA9,0x9E,0x15,0xFD,0x39,0x25,0x75,0xEB,0x2E,0x08,0xEE,0xE2,0x54,0xCA,0x6A,0x8B,0x15,
+	0x3B,0x07,0x8B,0xA1,0x27,0x6D,0xDF,0x5D,0x2A,0x54,0x1F,0x23,0xD5,0x71,0x95,0x54,0x13,0x5A,0x0D,0xAE,
+	0x33,0xBB,0x4A,0x54,0x68,0x11,0xEB,0xE3,0x8D,0xC6,0x0A,0xA2,0x41,0xB1,0x48,0x44,0x4F,0xCE,0x89,0xB5,
+	0x41,0x30,0xFD,0x74,0x31,0x6A,0xBD,0x7F,0xCB,0x1D,0xDC,0x1E,0x55,0x50,0x05,0x95,0xA4,0x53,0xCF,0xA7,
+	0x43,0xAB,0x72,0x79,0xF2,0x5E,0xF2,0x52,0x58,0xE9,0x04,0x35,0xEE,0xC8,0xFE,0x41,0x37,0x70,0x84,0x8C,
+	0xEB,0x0F,0x68,0x57,0x57,0x3E,0x82,0xDE,0x04,0x16,0x53,0x9F,0x32,0xDB,0x59,0x17,0xDA,0xB3,0xDE,0x8D,
+	0x35,0x26,0x4A,0xDC,0x88,0x11,0x3B,0x34,0x13,0xFE,0x26,0x35,0x64,0x12,0x46,0x41,0x80,0x8E,0xCA,0xF9,
+	0x81,0x10,0x40,0x96,0xCE,0x18,0xDA,0x21,0x23,0x08,0x81,0xC5,0x10,0x97,0x67,0x41,0x57,0xF8,0xD6,0x71,
+	0xC1,0x8F,0x7D,0x4F,0xF2,0x10,0xE1,0x08,0x2D,0x8D,0x4F,0xBF,0x8D,0x53,0x02,0xBD,0x58,0xB9,0xE2,0x0A,
+	0x21,0x13,0x69,0x18,0x2C,0xB2,0xE5,0xB0,0xCC,0xA6,0xC7,0x26,0x9C,0xDF,0x04,0x61,0x56,0x57,0xCF,0x80,
+	0x35,0xB7,0x1B,0x41,0xC7,0x17,0x17,0xEC,0x5C,0x16,0x9F,0x69,0xA1,0x1F,0x87,0x98,0x99,0x0A,0xA4,0x19,
+	0x04,0xBB,0x0C,0x4B,0x05,0xE2,0x5D,0x42,0x2B,0x2C,0x53,0xCE,0x87,0x50,0xF2,0x8A,0x49,0x1C,0xA9,0x1C,
+	0x67,0x3E,0x2D,0x2C,0x7D,0x19,0x98,0xAE,0xF1,0x3E,0x8F,0xC3,0x41,0xC8,0x84,0xA5,0x7D,0x6E,0x87,0x85,
+	0x63,0x05,0xFD,0x5E,0x90,0x91,0x73,0xD0,0xEC,0x6D,0x86,0xB0,0x82,0xC1,0x09,0x31,0x2A,0x5D,0xB1,0x6D,
+	0x50,0x7C,0x0F,0x7D,0xB9,0x01,0x50,0xC4,0x10,0xEE,0x98,0x99,0xA3,0x92,0x4C,0x94,0x1C,0xA8,0xD8,0x0E,
+	0xA5,0x8F,0xF0,0x61,0x67,0xCC,0x71,0xA4,0xA0,0x91,0x3C,0x1B,0x13,0x89,0xCB,0x54,0x2D,0x10,0xF9,0x50,
+	0x97,0xE1,0x99,0x91,0x84,0xCD,0xE1,0x75,0x33,0xA1,0x61,0x0F,0x9E,0xD9,0x09,0xB4,0xA8,0xAD,0x79,0x64,
+	0x87,0x80,0x52,0xD7,0xD1,0x08,0xC1,0xDB,0x09,0x0E,0x41,0xDF,0x07,0x28,0xE0,0x40,0x1B,0x9F,0x7F,0x15,
+	0x10,0xB7,0xD8,0x84,0x62,0x6F,0x89,0x9D,0xBF,0x15,0xD0,0xA9,0x8A,0x28,0xA8,0xAA,0xAB,0xE7,0x38,0x00,
+	0xAC,0x94,0xF9,0x74,0x13,0x39,0x49,0x25,0x75,0x96,0xC9,0xBF,0x2A,0x5D,0xA3,0xCC,0xAD,0x25,0x42,0x5B,
+	0x66,0x57,0xA2,0xC8,0x7C,0x2A,0x72,0x0C,0xA8,0xEF,0x47,0x5F,0x4A,0x61,0x49,0x00,0xD9,0x3B,0x33,0x0E,
+	0x8B,0x69,0x78,0x1E,0x99,0x4B,0x2A,0x3A,0xAD,0xD3,0x71,0xC6,0x8E,0x25,0x70,0x1B,0xAA,0x99,0xBE,0x41,
+	0x3F,0x68,0x82,0xFD,0x8F,0xD9,0x7A,0x72,0xC9,0xF2,0xCB,0x23,0xBF,0x4D,0x33,0x2F,0xB0,0xEA,0xC0,0xCD,
+	0xFF,0x1D,0xEB,0xA6,0xD5,0x01,0x71,0x23,0x2A,0x8A,0x2B,0x3E,0x40,0xE9,0x33,0x2F,0x2C,0x84,0xDC,0x49,
+	0x50,0x89,0x2D,0xD0,0xFD,0xE2,0x3B,0x4E,0xFF,0x13,0x6C,0x2A,0x4A,0xE8,0x36,0xA4,0xED,0x13,0x4A,0xB0,
+	0xFE,0x04,0x2A,0xAE,0x22,0x20,0x21,0x7A,0x70,0x1C,0x7A,0x83,0x21,0x60,0x5C,0xD4,0x7B,0x07,0x3C,0x17,
+	0xE9,0xDB,0x83,0x18,0xAB,0x71,0x5F,0xFD,0xDF,0xE6,0x4B,0xD1,0x8E,0xBF,0x95,0x72,0x76,0xDE,0x25,0xC6,
+	0xED,0x3A,0x00,0x8E,0xA7,0x10,0xE6,0xF8,0x4F,0x9F,0x6A,0xC1,0x07,0x26,0x98,0xD0,0xBA,0x2F,0x6F,0xA6,
+	0xFB,0x5D,0x53,0xEC,0xAA,0x27,0xF4,0x92,0xB2,0x20,0x83,0x21,0x32,0x7C,0x8B,0x76,0x37,0x9D,0x23,0xB1,
+	0xC4,0x32,0x1F,0x14,0xC0,0x7D,0x0F,0x3D,0x13,0xBE,0x7E,0x38,0xF2,0xAA,0x25,0x1A,0x96,0x64,0xFD,0xAF,
+	0x94,0xF1,0x72,0x37,0xF0,0x64,0x87,0x24,0x84,0x4C,0xED,0xD8,0xAB,0x19,0xC2,0x77,0x18,0xAF,0xB4,0x4B,
+	0x7A,0x4F,0x18,0x78,0x77,0x14,0x1E,0x12,0x6B,0xD7,0x54,0x29,0x5F,0x16,0x7F,0x98,0x9A,0x55,0xBE,0x05,
+	0x0F,0x55,0x03,0xBB,0xA0,0xCE,0x95,0xA1,0x41,0xA6,0x75,0x1A,0xE7,0x94,0x46,0xDF,0x1F,0x87,0xE4,0x80,
+	0x94,0x01,0x93,0xEA,0x5E,0x34,0x03,0xCB,0x6A,0x51,0x68,0xF5,0x30,0x7A,0x9E,0xFA,0x24,0x91,0x2F,0x80,
+	0x0F,0xB4,0x7E,0xBA,0x98,0x62,0x8C,0x3C,0x7C,0x67,0x6F,0xFC,0x45,0x48,0xD1,0xD9,0xC0,0x0F,0xFE,0xF6,
+	0x52,0xD3,0xD9,0xC4,0x7B,0xA1,0xA6,0x7B,0xA8,0xD5,0x1F,0x75,0xAC,0xF7,0x80,0x77,0xDF,0x56,0x1B,0x47,
+	0x9F,0xB7,0xD7,0x99,0xB7,0x16,0x50,0xE1,0x6F,0x64,0xFF,0xC5,0x4A,0xCB,0x60,0x7F,0xE5,0xE0,0xBC,0xC6,
+	0x1D,0x0A,0x35,0x3D,0x4A,0xD0,0x74,0x2A,0x62,0x77,0x88,0x5E,0x95,0x5F,0xB4,0xDE,0x0B,0xF1,0xBA,0xAD,
+	0x5D,0x6B,0x69,0xE9,0x1F,0xAC,0xC0,0xD3,0xF2,0x5B,0xDD,0x2B,0xEE,0x35,0xD9,0x7E,0x60,0x11,0x64,0xFB,
+	0x0F,0x71,0x89,0xD7,0x15,0x8F,0x51,0x07,0x65,0x06,0x91,0x7F,0x9D,0x52,0x41,0xD6,0xCE,0xCF,0x65,0x3F,
+	0xAD,0xBD,0x51,0x59,0xFF,0x6C,0xBA,0xF7,0x3E,0x8F,0xA8,0xB3,0x6E,0x52,0x81,0xA0,0x16,0x50,0x36,0x29,
+	0x61,0x41,0x5A,0xE7,0x61,0x8C,0x9E,0x43,0x67,0x0E,0xB0,0x32,0xB8,0x02,0x67,0x38,0x81,0xF2,0xD3,0xF6,
+	0xFA,0x8D,0xA9,0xB2,0xE6,0x48,0xEF,0x22,0x51,0x06,0xF2,0x6E,0x0E,0xD5,0x9A,0x52,0x5B,0xEA,0x18,0x42,
+	0xEF,0x0C,0x59,0xA0,0x2D,0x0F,0xEB,0x51,0x7A,0x20,0x98,0x48,0x32,0x96,0x05,0xA0,0x48,0xB1,0x0E,0x94,
+	0x6E,0x6B,0xA0,0x71,0x68,0x94,0x32,0x04,0x53,0xEA,0x07,0x52,0x97,0x76,0x92,0x23,0x12,0x75,0xBD,0x61,
+	0xAA,0xE4,0x47,0x3A,0xD1,0xF9,0x01,0x5F,0xBE,0x04,0xB1,0x05,0xAE,0x6B,0xC8,0xD5,0xCD,0xC6,0x59,0xD7,
+	0x92,0x45,0xFE,0xDD,0x0B,0xB6,0xA1,0x17,0x90,0x78,0x4A,0x19,0x0E,0x1B,0xCA,0xD8,0x1E,0xCA,0x72,0x7E,
+	0x93,0x45,0x26,0x4E,0x86,0x97,0x9F,0x1A,0xD2,0xA4,0xF4,0x1B,0x98,0x4D,0xCB,0x03,0x23,0xDC,0x1A,0xAD,
+	0xD5,0xCB,0x5C,0x18,0xF8,0xAA,0xB1,0x89,0xDE,0x5A,0x11,0xCB,0xCE,0x79,0x95,0x2B,0x13,0x2E,0x18,0x79,
+	0xCD,0xB4,0xA3,0x1B,0x38,0xF4,0x49,0xBD,0x9B,0x15,0x3B,0x5F,0x0F,0x65,0x50,0x86,0x0C,0xCE,0xFA,0x9C,
+	0xE1,0x23,0x84,0x7B,0x68,0x5F,0xAA,0xEE,0x34,0x0F,0x8C,0x56,0xC0,0x9C,0xAA,0xFC,0xA7,0x20,0xF6,0xEA,
+	0x5B,0x45,0xBA,0x38,0x7A,0xE0,0x07,0xBA,0x06,0x4C,0xFB,0x9D,0x25,0x21,0x55,0x51,0x23,0xDF,0xEB,0xBD,
+	0x05,0x61,0x33,0x1A,0x3D,0x82,0xC1,0x4D,0x38,0x22,0x2A,0x47,0xA5,0xBA,0xA3,0x5A,0x78,0x69,0x24,0x66,
+	0xD8,0xD9,0xBC,0x77,0x4C,0x55,0xEF,0xA8,0xC5,0xAF,0x2F,0xBB,0xD3,0x32,0x5E,0x34,0xE9,0xB2,0x1B,0x34,
+	0xDC,0xB1,0xE3,0x38,0xC4,0x82,0xA8,0xD9,0x42,0x98,0xC5,0x29,0x03,0xB6,0xBD,0x76,0x92,0x9F,0x4C,0x9E,
+	0x45,0xA3,0x92,0x39,0xB8,0xE3,0xD9,0xE2,0x87,0x10,0x8B,0x25,0x31,0xB1,0xB1,0x34,0xDA,0x54,0x25,0x46,
+	0x81,0x75,0x57,0x72,0x3A,0xCA,0xC7,0x34,0x3E,0x3B,0x5C,0xFD,0x8B,0x5D,0xEC,0x34,0xAD,0x7B,0x8A,0xDE,
+	0x8F,0x18,0xC6,0xD5,0x90,0x33,0x4C,0x18,0xFB,0x98,0x96,0x1B,0xD0,0x78,0x25,0x47,0x17,0x54,0xA5,0x81,
+	0xED,0x3B,0x0D,0xC4,0xC2,0xE4,0xB5,0x50,0xDC,0x7B,0x33,0x70,0x0F,0x1A,0x9D,0xFA,0x12,0xBF,0x57,0xE0,
+	0x04,0x53,0xD7,0xF4,0x50,0x7A,0xB8,0x85,0xA5,0x95,0xB8,0x2C,0x71,0xC9,0xEA,0xD7,0x66,0x68,0xBB,0x35,
+	0xD9,0x87,0x34,0x0B,0x0F,0xB6,0x98,0x28,0xD2,0xFA,0xE6,0x9C,0xD5,0xBA,0xD6,0x89,0x81,0xE8,0x61,0x2C,
+	0x43,0x79,0x9F,0x91,0x51,0x39,0xEB,0xDB,0x4F,0x4A,0xA9,0x95,0x77,0x8C,0xDF,0xDE,0x9A,0xEE,0xB1,0xA0,
+	0xD3,0x98,0xAE,0x0D,0x15,0xB8,0x28,0x84,0xFF,0x80,0x38,0x6C,0xCB,0xB3,0xCE,0x2E,0xB8,0x3F,0xD5,0x6A,
+	0xEA,0xF9,0xDC,0xE8,0xD9,0x87,0x5C,0x02,0x2D,0xDF,0xB6,0xFB,0x58,0xCD,0x5D,0x10,0xF3,0x90,0xBE,0x49,
+	0x1B,0xF0,0x54,0x4D,0xE4,0xDF,0xC1,0xAF,0xFB,0x2E,0x97,0x7D,0x64,0x56,0x2E,0x69,0x89,0xDA,0x0B,0x5D,
+	0xE1,0x72,0xB7,0x5F,0x99,0x4F,0x0F,0x9B,0xFF,0xD2,0xA7,0xDA,0x98,0x80,0xE0,0xAA,0xA7,0xA4,0x14,0x64,
+	0xEB,0x0D,0xF0,0x8B,0x6A,0x15,0x10,0xE4,0xD8,0xEF,0x0E,0xB7,0x6F,0xA5,0x90,0xEC,0xB9,0xAC,0xEE,0x4C,
+	0x2F,0x02,0xFF,0x45,0x7B,0xA3,0xC3,0x10,0xA2,0x01,0xB6,0x83,0xD2,0x6B,0x49,0x12,0xAA,0x6D,0x05,0x58,
+	0x77,0xE6,0xCB,0x61,0x6E,0x00,0xD6,0x50,0x68,0x15,0x47,0x87,0x8D,0x92,0x7F,0x4C,0x5A,0x4E,0x1E,0x7A,
+	0x00,0x66,0xAA,0xA9,0xB5,0xA2,0x21,0xE6,0x00,0xFA,0x78,0xBA,0x16,0xEB,0xAA,0xD3,0x01,0x27,0x90,0xD4,
+	0x35,0xF0,0x62,0x70,0x85,0xC1,0x80,0xF4,0x52,0xBE,0xF3,0x73,0x51,0xC4,0xB1,0xC7,0xF5,0x56,0xB1,0xF6,
+	0x7C,0xAA,0x45,0x05,0x97,0xA6,0xD5,0xAC,0x81,0x65,0xD1,0x87,0x34,0x2F,0x31,0x67,0xAC,0xE4,0xA3,0x76,
+	0x74,0xE1,0x5C,0xBB,0xE7,0xF9,0x5D,0x70,0xCE,0xA6,0x3E,0x10,0xCE,0x04,0xE0,0xAA,0x1A,0x92,0xB0,0xDA,
+	0x41,0xCB,0x1E,0x61,0xBE,0xEB,0x13,0x7A,0x1B,0x44,0x7A,0xAB,0xA1,0xAB,0x1D,0x26,0x01,0x2C,0x03,0xCD,
+	0x10,0xA5,0x5C,0x49,0x43,0x4C,0xBB,0xAF,0x35,0x69,0x7A,0xE2,0xC5,0xFA,0x69,0x16,0x76,0xCF,0x43,0xD3,
+	0x6F,0x86,0x79,0x36,0x36,0x8F,0xF0,0x7A,0xDD,0xCE,0x64,0xAC,0x9C,0xAF,0xAD,0x9B,0x68,0x33,0x7A,0x87,
+	0xFD,0xEA,0xD1,0xB8,0xA3,0x70,0x8A,0xFE,0x11,0x26,0xBC,0x74,0xCD,0xC9,0x9A,0x3A,0x28,0x6D,0xA1,0xCA,
+	0x65,0xEA,0xA5,0xBF,0x96,0xA1,0x13,0xED,0x3B,0x8C,0x7B,0x92,0x3F,0xE1,0x13,0x4A,0xFF,0x22,0x6D,0xBD,
+	0x1D,0xAC,0x49,0xFF,0x89,0xA9,0x83,0xFD,0xDA,0xEB,0x9C,0x11,0x0A,0x82,0xDA,0x37,0x7C,0xD3,0x87,0x16,
+	0x62,0x09,0x67,0xB9,0x00,0x0D,0xBA,0x16,0x1F,0xE1,0x96,0x65,0x45,0x1C,0x68,0x41,0x43,0x7A,0xFA,0xD1,
+	0x8A,0x2C,0x9D,0x10,0x82,0x98,0xA3,0xBF,0x34,0xD7,0x12,0x87,0x05,0x7D,0x75,0x33,0xE8,0xB0,0x92,0x17,
+	0x97,0xCD,0xBE,0xD0,0x7F,0x7A,0x68,0x4E,0x8E,0x80,0xAD,0xC0,0xF9,0xB1,0xC8,0x51,0x00,0x6B,0xDC,0x16,
+	0x95,0xBB,0x2D,0x06,0xC1,0xD0,0x8C,0xC1,0x15,0x14,0x52,0xEA,0x47,0xB5,0xAB,0x34,0xB5,0xFD,0x84,0x70,
+	0xE7,0xE0,0x84,0x74,0x55,0xB4,0xDE,0x50,0x8C,0x49,0x85,0x67,0xBC,0x3D,0x77,0x91,0xD5,0xED,0x8D,0xC0,
+	0x95,0x09,0x12,0xA1,0x89,0x08,0x21,0xB5,0xF4,0x68,0x45,0x0C,0xD4,0x9C,0xC7,0x15,0x75,0xFF,0xBD,0x00,
+	0x2F,0x0A,0xEE,0x46,0x3A,0x5A,0xC9,0x59,0x14,0xDE,0x70,0x05,0x95,0xDB,0xD6,0x92,0xC4,0xFA,0x68,0xE5,
+	0xD4,0xDA,0x00,0x83,0xE0,0x2F,0xEA,0x43,0x16,0xBA,0x7E,0xB5,0x45,0xD9,0x95,0xFC,0xDE,0xF8,0x1E,0x55,
+	0x4D,0x25,0xE7,0xD8,0xB8,0x51,0xD7,0xDC,0x9E,0xBC,0x6F,0x0B,0xAA,0xB3,0x37,0xBF,0x64,0x7B,0x40,0xAE,
+	0x8D,0xFF,0xA6,0xD2,0x9F,0x48,0x9E,0xAC,0x7D,0x03,0xCE,0x2D,0xB0,0xD4,0xFF,0xFE,0xDD,0xBE,0x31,0xF8,
+	0xA2,0x60,0xD4,0x3C,0xBD,0xF5,0x5B,0x8C,0x90,0xDE,0x87,0x8C,0x88,0x01,0xF0,0xD4,0x8C,0xDC,0x9F,0x4D,
+	0xBB,0x74,0xB1,0x99,0x49,0xC5,0x2C,0x5E,0xFA,0x85,0x09,0x77,0x5A,0x39,0x26,0x3D,0x3D,0xF7,0x47,0xE7,
+	0x06,0xD6,0x44,0xA0,0xDB,0xFF,0xA8,0x3C,0x06,0xAB,0x00,0x44,0x08,0xDD,0x2E,0x08,0xA3,0x49,0xA8,0xDB,
+	0xB9,0x31,0x9F,0xF6,0x13,0x4C,0xB2,0xFC,0x1F,0x6E,0x41,0xA6,0xA4,0xEA,0x58,0xDC,0x51,0x7A,0x27,0xE9,
+	0x92,0x4F,0xE3,0xFB,0x93,0xA2,0x95,0x32,0xF0,0x73,0x7D,0xBA,0xD1,0x02,0xDA,0xF7,0x06,0xD2,0xE9,0x46,
+	0x18,0x8E,0x61,0x2C,0x21,0x58,0x19,0x53,0xF2,0x81,0x10,0x49,0xA3,0x1F,0x40,0x5B,0x38,0xA9,0xE8,0xE2,
+	0x60,0xB4,0x41,0x94,0xB3,0xC5,0x72,0xB8,0x37,0x4A,0x64,0xC7,0x31,0x2F,0xE2,0xE3,0x5F,0xEA,0xE0,0x14,
+	0x5C,0xEE,0x27,0xB7,0x07,0x86,0xBF,0x78,0x7B,0xD7,0x29,0x26,0xF1,0xE0,0x40,0xE1,0xE8,0x72,0x10,0x55,
+	0x24,0x1C,0xC0,0xD1,0xD4,0x03,0xCA,0x99,0x05,0x05,0xCB,0xF1,0xE9,0x5D,0xC2,0xF9,0xC0,0x13,0x97,0xEE,
+	0x73,0x27,0x70,0x1C,0xB7,0x0A,0xCB,0xA9,0xFD,0x63,0x4B,0x7E,0x7F,0x46,0xD3,0x8A,0x7C,0x20,0x8F,0xD0,
+	0x0F,0x04,0x3D,0x14,0x6A,0x0F,0xC2,0x6F,0xF4,0x45,0x04,0x1F,0x73,0x3B,0xC9,0x26,0x3D,0xE5,0x53,0xA9,
+	0xB3,0x70,0x52,0x29,0x2C,0x8B,0xC9,0x6E,0xA9,0x30,0xE4,0x4A,0xFD,0x27,0x21,0x4C,0xE9,0x62,0x85,0xAE,
+	0x28,0x9C,0xEA,0x4B,0x9B,0x68,0x98,0xDF,0x79,0xCA,0xEA,0x8C,0x47,0xE7,0x72,0x1F,0x38,0xAB,0xB7,0x7B,
+	0xBA,0x72,0x04,0xB0,0x78,0x2B,0x62,0x8F,0x2B,0x2F,0x57,0xCB,0xA8,0xFE,0xFB,0xA7,0x36,0x23,0x6D,0x8B,
+	0x2D,0x0C,0xCA,0x5C,0xEE,0x71,0xA9,0xB0,0xB7,0x60,0x7F,0x3F,0x24,0x32,0xE4,0x8F,0x2A,0x49,0x8E,0xF7,
+	0x7A,0x90,0x73,0x68,0x62,0x5D,0x68,0x1B,0x31,0x03,0xEC,0x32,0x68,0x58,0x92,0xD6,0xD7,0x32,0x04,0x81,
+	0x12,0x93,0x0A,0xF2,0x71,0x7E,0x99,0x4F,0x67,0x58,0xC5,0x8C,0xD6,0x1D,0xA9,0x69,0x6E,0xD4,0xDC,0x00,
+	0x15,0x39,0x51,0xD2,0xD8,0xF3,0xCA,0xF5,0xD4,0xFF,0x33,0x9C,0x06,0x9E,0xB7,0x7D,0xA1,0x7C,0x72,0x35,
+	0x9A,0xDB,0xC4,0x22,0x14,0xD5,0x46,0xB3,0x3E,0x94,0x4F,0x3A,0x8B,0x8C,0xF3,0x02,0xA2,0xFB,0x9E,0x06,
+	0x53,0xC4,0xB3,0x97,0x10,0xF3,0xA4,0xD2,0xB0,0x51,0x24,0xE2,0x8A,0x5A,0x86,0x86,0x1B,0x24,0xBF,0x29,
+	0x96,0x5B,0xBA,0xAF,0xE3,0xA9,0x05,0x92,0x87,0xA2,0xEF,0x16,0x82,0x89,0xF7,0x4E,0x5C,0x95,0x0D,0xC8,
+	0x92,0x97,0x45,0xF5,0xAB,0x54,0x1D,0x5C,0x63,0xFA,0x5F,0xB8,0x8F,0x03,0xDF,0x09,0x9D,0xB8,0x36,0xB8,
+	0x89,0x43,0x13,0x5F,0x0C,0x63,0x57,0x11,0x8E,0x09,0x86,0xB9,0xBB,0x3D,0xA6,0x47,0x5A,0xAB,0xB8,0x5E,
+	0x5B,0x62,0xC1,0x6F,0xB8,0x55,0x7F,0xCA,0x7A,0xBA,0x97,0x4F,0xDB,0xAB,0xF2,0x29,0xBF,0x9D,0xF7,0x1B,
+	0x74,0x96,0xD0,0xFF,0xFA,0x38,0xA7,0xA9,0x4E,0x35,0x38,0x49,0xA5,0xD6,0xBD,0x20,0xE0,0xD1,0x92,0xDD,
+	0x46,0x38,0x68,0x9C,0x02,0x5F,0xAE,0x1C,0x4B,0xDD,0xF1,0xE8,0xDC,0xD2,0xF2,0x5E,0xFE,0xF0,0x7C,0x10,
+	0x0F,0x12,0x26,0x78,0x41,0x6B,0xEB,0x57,0xAB,0x9E,0xB3,0xDC,0xCE,0x16,0x15,0xFA,0xC8,0x51,0x46,0x07,
+	0x13,0xEF,0x16,0x4A,0x4E,0xE0,0xF1,0xD0,0x18,0x24,0x65,0x0A,0xC1,0xF0,0x60,0x1F,0xB3,0x2E,0xD8,0xEA,
+	0x02,0xCD,0x44,0x72,0x35,0x10,0xD7,0xE2,0x40,0x34,0x32,0x10,0x64,0x6D,0x90,0x62,0x45,0x8A,0x50,0xFE,
+	0x9B,0x64,0xFC,0xE2,0x3B,0xAD,0x1E,0x40,0x74,0xD1,0x39,0xB6,0xB7,0x03,0xF8,0x82,0xF7,0x82,0xA0,0x50,
+	0xF8,0xA0,0xE8,0x2F,0x73,0xF9,0x79,0xFB,0xCB,0xCE,0xB8,0x65,0xA6,0xB3,0x5F,0x1F,0xC4,0x82,0xE0,0x2D,
+	0x70,0x1C,0x39,0x6F,0xA3,0x7B,0xC8,0x24,0xAF,0xA8,0x5E,0x94,0xE5,0xC2,0xCE,0x5E,0x75,0xB6,0x6A,0xB4,
+	0xA6,0x9E,0x13,0xAD,0xE4,0x2E,0xEA,0x94,0xE2,0xCE,0x78,0xFE,0xF2,0xEC,0x31,0x34,0x9E,0x09,0xD9,0x35,
+	0xE9,0x86,0x51,0x65,0x67,0xDD,0xA8,0x71,0x73,0xED,0x0F,0xA5,0x00,0x07,0x39,0x66,0xBD,0xB8,0xF9,0x63,
+	0x60,0xDC,0x7D,0x08,0xF6,0x07,0xD9,0x02,0xA9,0x77,0x5A,0xE6,0x68,0xE5,0xF2,0xFE,0xF4,0x67,0xEB,0x26,
+	0xF9,0x19,0x6F,0x7C,0xFA,0x99,0xCC,0x32,0x1E,0xE9,0x5C,0x12,0x4E,0x9B,0x82,0xC1,0x6E,0xF9,0xE3,0x73,
+	0x76,0x91,0xB5,0x23,0x63,0xC6,0x22,0x58,0xF4,0xA6,0x4B,0xAD,0x15,0x45,0x93,0xE4,0x8B,0x12,0x74,0xE0,
+	0x74,0xDA,0x62,0x3F,0x68,0x4B,0x03,0x78,0x03,0xE3,0x3B,0x67,0xAB,0x97,0x5A,0xA5,0xAD,0xEE,0xE0,0x0C,
+	0xC1,0x4A,0xAB,0x69,0xFB,0xA4,0xAC,0xB2,0xC5,0x40,0x97,0x9C,0xBE,0xB2,0xFD,0x9C,0x7C,0x0C,0xE9,0x7F,
+	0xBE,0x12,0xF2,0xAD,0x88,0x55,0x64,0xC6,0x1D,0xA3,0xF4,0x2B,0xC2,0x45,0xE0,0x6D,0xC8,0x45,0x87,0xC8,
+	0x93,0x85,0x56,0x02,0x60,0xF2,0xC3,0x84,0x26,0x06,0xDB,0xFA,0x36,0x7E,0xE4,0x56,0x89,0x3B,0x5B,0x39,
+	0x36,0x92,0xD3,0x62,0x60,0xF1,0xE4,0xC6,0x34,0x3F,0x96,0x6D,0x1A,0xC0,0xAA,0x7E,0xA5,0xFC,0x21,0xEA,
+	0xB9,0x80,0xD9,0xC0,0xFA,0x77,0xB4,0x7C,0x97,0xF4,0xFC,0x90,0x51,0xB9,0x90,0xD1,0x43,0x90,0xEC,0x2C,
+	0xB0,0xE9,0x72,0x12,0xA3,0x3B,0xB5,0x82,0x86,0xD1,0x9E,0x9A,0x04,0x2C,0x3C,0xF7,0xB1,0x38,0x3D,0x5A,
+	0x81,0x8F,0x02,0xB0,0x9A,0xBB,0xE7,0x0A,0x02,0x99,0xCA,0xCA,0x17,0xA4,0x2B,0x34,0x05,0x15,0x94,0x3E,
+	0x3D,0xF8,0x9B,0x32,0x12,0x97,0x6D,0x85,0x43,0x99,0xF0,0xA5,0xDA,0x8D,0xB8,0x47,0x1B,0xD3,0x8A,0x90,
+	0x92,0xBA,0xAD,0x68,0x17,0x59,0xEC,0xB5,0x94,0x05,0x59,0x35,0x1B,0x3C,0xB7,0xF0,0xE1,0x27,0x9B,0x2F,
+	0xF6,0xB7,0x55,0x95,0x14,0x83,0x1E,0x1E,0x9B,0xBC,0x6F,0x2F,0xC9,0xD1,0x37,0x46,0xA0,0x33,0xBF,0xE8,
+	0xD6,0xDB,0x2B,0x61,0x3B,0xB0,0x06,0xFD,0xA7,0xE8,0xE4,0xBF,0xDE,0xFF,0xC5,0xFD,0x53,0xE1,0xA6,0xFC,
+	0x84,0x1B,0x36,0x29,0x25,0xF6,0x30,0x2D,0xDE,0xEA,0x21,0x21,0x71,0x8A,0xC0,0x1D,0x74,0xB7,0xC0,0xC4,
+	0x62,0x5D,0xEF,0xA3,0x5E,0xFD,0x9E,0x22,0xE4,0x51,0xE2,0x2C,0x38,0x76,0x6D,0xEA,0x6E,0xDC,0xC2,0xCF,
+	0x78,0xCF,0x2D,0xBC,0xAD,0x9E,0x7C,0x5C,0xFA,0xC0,0x18,0x5A,0x90,0x70,0xCA,0x67,0x1C,0xB5,0x3E,0x52,
+	0x09,0x85,0xBD,0xAD,0x8D,0x38,0x77,0xAC,0x07,0x17,0x39,0x8D,0xDD,0xBE,0x6A,0x39,0x9C,0x2D,0x97,0xFB,
+	0x5E,0x10,0x2B,0x3C,0x31,0xD7,0x3F,0x56,0xE4,0xF2,0x7D,0xF2,0x23,0x40,0xF9,0x6E,0x91,0x2D,0x89,0x8D,
+	0x46,0x73,0x6F,0x4A,0x32,0x9F,0x1D,0xFA,0xA4,0xAE,0x30,0xEA,0xEC,0xF9,0x22,0x19,0x47,0x72,0x58,0xA0,
+	0xC2,0xB5,0x25,0x8B,0xE3,0x1B,0x39,0xFA,0xA3,0xC8,0xDF,0x43,0x3F,0xC9,0x6A,0xA1,0x9A,0xDE,0x1A,0xF9,
+	0x05,0x4E,0x76,0xD7,0x30,0x3C,0x38,0x4E,0x62,0xC8,0xCF,0x2A,0xB7,0x1E,0x5A,0x42,0x90,0x0E,0xDE,0x3B,
+	0xB1,0x41,0x46,0x02,0xBD,0xE9,0xAB,0x9F,0x6D,0x60,0x19,0x6F,0x25,0x47,0x5F,0xB6,0xBF,0x88,0xCF,0x8F,
+	0xB2,0x96,0xF0,0x16,0xAE,0x69,0x43,0x6F,0xEC,0x73,0xF9,0x78,0x1F,0x80,0x87,0xC4,0x35,0xFB,0x28,0xE1,
+	0x94,0x21,0x8B,0xF4,0x74,0x45,0x1D,0xB7,0x7A,0x64,0xF4,0x0E,0x5E,0x18,0xE1,0x4B,0xF1,0x92,0xFD,0x63,
+	0x85,0xFE,0x3D,0xEA,0x98,0x18,0x0B,0x01,0xFB,0xE5,0x80,0x2D,0xA7,0x35,0x40,0xFA,0x2A,0xF1,0x26,0x8E,
+	0x0D,0x21,0x40,0x7C,0x4F,0x7A,0xB5,0xB8,0x1F,0x77,0x0B,0xD8,0x61,0x9B,0x85,0x20,0x71,0x5B,0x00,0xCF,
+	0x60,0xF8,0x47,0xD3,0xDE,0xC8,0x75,0x34,0xBA,0x4F,0xEB,0x0C,0xAD,0x02,0x56,0x5B,0x2A,0x40,0x36,0x42,
+	0x44,0x37,0x04,0x9A,0xF5,0x60,0x76,0xAE,0x98,0x28,0x86,0xFB,0xEB,0x73,0x86,0xE8,0x10,0x93,0xA9,0xDC,
+	0x45,0x82,0xE2,0x3E,0xE6,0x21,0x9C,0xFE,0x78,0x7D,0xE2,0xF8,0x1D,0x5A,0xFE,0xD6,0x75,0x53,0x1A,0xC9,
+	0xDC,0x3B,0x2A,0x56,0xE8,0x0C,0xBB,0x0F,0x25,0x60,0x35,0xF1,0x7E,0x89,0xF3,0xD9,0xD1,0x50,0x9B,0x64,
+	0x83,0x33,0x6F,0x02,0x78,0xBA,0x3C,0x90,0x83,0xA5,0x46,0x25,0x36,0x92,0x41,0x6D,0x03,0x70,0xAB,0xDB,
+	0x19,0x21,0xD0,0x99,0x27,0x22,0x37,0x1A,0x37,0xD3,0x22,0x9C,0x67,0x62,0x9F,0xC7,0x43,0xD0,0x94,0xBE,
+	0x9C,0x50,0x75,0xC2,0x2E,0xCD,0x6D,0x50,0x43,0x12,0xCD,0xA4,0x05,0x79,0x80,0x15,0x9B,0x57,0xF7,0x66,
+	0xD7,0xEE,0x02,0x4E,0x08,0x22,0x4F,0x5A,0x18,0x90,0x9F,0xC0,0xD2,0xA5,0xAC,0xA6,0xC5,0x76,0x52,0x41,
+	0xEB,0xF7,0xA1,0xC3,0xDE,0x89,0x68,0x8A,0xD6,0x89,0x11,0xAB,0x90,0x38,0x64,0x0E,0xE1,0x51,0x58,0xC5,
+	0x19,0xDA,0x72,0xFD,0xA4,0x86,0xDA,0xC4,0x30,0x32,0xC5,0x63,0x62,0x32,0xAD,0xF4,0x86,0xFD,0x62,0xAE,
+	0x7A,0xAA,0x61,0x46,0xCF,0x59,0xFD,0x93,0x18,0x8A,0x8B,0x87,0x99,0xF4,0xB9,0x6A,0x4B,0x95,0xE4,0x8C,
+	0xD3,0x9B,0xD6,0x01,0xE5,0x85,0xC0,0x1D,0xCF,0x7C,0x34,0x7A,0x1A,0xFD,0xDC,0xEF,0x17,0xB0,0x40,0x5A,
+	0x6D,0xF4,0x31,0xCF,0x13,0x2A,0x12,0x0D,0x92,0x0E,0x6B,0xFE,0xDE,0x9C,0x6F,0x8E,0x15,0x55,0xD3,0xDE,
+	0x9E,0x0B,0x8D,0x69,0xAC,0x59,0xAF,0x77,0x50,0x98,0x8E,0x3B,0x55,0x02,0x30,0x8C,0xCB,0x04,0x50,0xAA,
+	0xD5,0x81,0xA4,0x5A,0x3B,0x9C,0x28,0x4C,0x93,0xF3,0xA8,0x5C,0xD3,0x35,0x70,0xA0,0xA6,0x7F,0xB6,0x2D,
+	0x59,0x39,0x66,0x0B,0x17,0x1F,0xDC,0x1E,0x9A,0x7B,0x87,0x58,0x31,0xE1,0xF9,0xF0,0xDA,0xF8,0x83,0x6B,
+	0x6A,0xF7,0xB7,0xEF,0x7E,0xF5,0xB2,0x1E,0x56,0x69,0x91,0x6C,0x3F,0xB2,0x99,0x48,0x00,0x5C,0xFF,0x7E,
+	0x58,0x79,0x98,0xFD,0xED,0xF1,0x9D,0x22,0xC8,0xF1,0x6B,0xA6,0x7E,0x2A,0x0B,0x68,0xA8,0xA3,0x1C,0x8B,
+	0x03,0xB2,0x09,0x2F,0x89,0x70,0x30,0xD7,0xA4,0x6E,0x7A,0xFC,0x81,0x02,0x8D,0x9C,0x85,0xC2,0x82,0x2A,
+	0x4C,0x33,0x09,0xE4,0x0E,0xB8,0x71,0xB6,0x49,0xA0,0x0B,0x71,0xA6,0x60,0xF7,0xB3,0x6A,0x2E,0xAC,0xB7,
+	0xFF,0x47,0x1E,0x9F,0x3C,0xA0,0x60,0xB1,0x68,0xEA,0x88,0x24,0xE9,0xAA,0xCF,0x2D,0xD3,0x19,0xA0,0x59,
+	0x7C,0xA6,0x56,0xE7,0x66,0x81,0xEC,0x49,0x6B,0xA3,0x83,0x0D,0x2F,0xC8,0x8F,0x51,0xFB,0xE8,0x5F,0xEB,
+	0x44,0x86,0xD9,0xB9,0x90,0x1F,0xD8,0xE7,0x80,0xE5,0xB7,0x98,0xD0,0x24,0x0B,0x51,0x84,0xC7,0xC9,0xBB,
+	0x7E,0x56,0x86,0x0D,0xE9,0x18,0x06,0xF3,0x99,0xA1,0x78,0x3A,0x34,0xCA,0xDC,0xAB,0xF7,0x2B,0x0A,0xCA,
+	0x65,0x8A,0xEA,0x22,0xB5,0xFB,0x52,0xEA,0x6D,0x28,0x94,0xBF,0x90,0x0F,0x9A,0x45,0xEE,0x42,0x6B,0xD0,
+	0xDD,0xB8,0x76,0xC6,0x2D,0x08,0x4B,0x33,0x77,0x89,0x66,0x66,0xCA,0xF9,0x26,0xC0,0x35,0x09,0xBE,0x9F,
+	0xB7,0xF1,0x3A,0xDF,0xB3,0xE9,0x29,0x0A,0xF1,0x89,0x85,0x9B,0xDB,0x09,0x4E,0x18,0xEF,0x23,0x9A,0x69,
+	0x18,0x6E,0x4C,0x52,0x32,0x63,0x49,0x2C,0xFF,0x11,0x0C,0x76,0x0E,0xCD,0xC2,0x3C,0x19,0x0F,0x04,0x7D,
+	0xFA,0xB9,0x07,0xBC,0xFE,0x12,0x37,0x38,0xA4,0xE2,0xD2,0x0D,0x3F,0x53,0xD3,0x18,0xF2,0x1D,0xDB,0x0D,
+	0xD8,0x4C,0x47,0x09,0x73,0xAC,0x16,0x9D,0x3E,0x50,0x03,0xFF,0x97,0x1D,0x93,0x1D,0xD9,0x2D,0x71,0x4B,
+	0x47,0x6F,0xBE,0x84,0xA6,0xB8,0xF4,0x0B,0x47,0x2F,0x0B,0x17,0x1A,0xAF,0xB9,0x91,0x73,0x3C,0x8A,0x22,
+	0x57,0x15,0x50,0xCC,0xC6,0xB4,0x10,0x33,0x1D,0xE2,0x5D,0xA0,0xFE,0x32,0xA0,0x94,0xDE,0xD1,0x0B,0x8E,
+	0xE2,0xE1,0x1D,0x9B,0x1D,0x88,0x3E,0x43,0xF9,0x9A,0xF9,0x33,0xFD,0x90,0x82,0x51,0x86,0x08,0xC3,0x1F,
+	0x14,0x50,0x3E,0xC0,0x95,0x49,0x9A,0xFA,0xDF,0x65,0x4B,0x11,0x4C,0xAB,0xD4,0xF9,0xD7,0xF2,0xA2,0xED,
+	0x5B,0x68,0x71,0x52,0x71,0x02,0xEB,0x76,0x29,0xB3,0xDC,0x0F,0xD6,0x7D,0x7F,0xC1,0x34,0x9E,0x49,0x55,
+	0xFE,0xBC,0xB5,0x77,0xE2,0x23,0xD5,0x61,0x55,0xF0,0xB9,0x40,0x06,0x48,0x59,0xB5,0x40,0xF5,0xC6,0xB1,
+	0x46,0x2A,0xF5,0x15,0x80,0xF3,0xA2,0x4F,0x5C,0x97,0x92,0x26,0xD5,0xFB,0xF6,0x03,0x77,0xD5,0x60,0x5D,
+	0x12,0xFB,0x73,0x07,0xF4,0xA4,0x84,0xED,0x1B,0xC6,0xAB,0x50,0x90,0x96,0xD8,0x16,0x94,0x1A,0x88,0xE0,
+	0x71,0xD8,0xDD,0x6F,0xB8,0x96,0xC8,0x5B,0x34,0x7B,0x24,0x2A,0x71,0x87,0x00,0xA4,0x99,0xD9,0x76,0x9F,
+	0xDD,0x44,0x65,0xD3,0x85,0xAA,0xA5,0xBD,0x4E,0xA6,0x59,0xF7,0xD1,0x01,0x24,0x75,0x9F,0x03,0x5E,0x88,
+	0x68,0x7E,0x29,0xBB,0x05,0xEB,0xC2,0x55,0xD4,0x40,0x90,0x7F,0xDE,0xB2,0x16,0x98,0x98,0x9F,0x84,0xEE,
+	0xFD,0xF9,0xB4,0x4F,0xE4,0xD9,0x5C,0x3C,0x9C,0x03,0x8A,0x29,0x4F,0x21,0x37,0x17,0x33,0x03,0x8E,0x21,
+	0x46,0x8C,0x5C,0x7B,0x43,0xDC,0xFC,0xA6,0x6D,0xDB,0x00,0x1D,0xDB,0xFF,0xA7,0x3C,0x87,0xD1,0x6C,0x6B,
+	0xCE,0x7D,0x72,0x31,0x43,0xA0,0x07,0x26,0xDB,0x95,0xB0,0xC0,0xA2,0x6F,0x5C,0x45,0x37,0x2A,0x1E,0x70,
+	0x15,0x2F,0xC2,0x35,0x26,0x61,0x5B,0x69,0xFC,0x1D,0x62,0x45,0x80,0x8F,0xD1,0x8D,0xEE,0xC4,0xC5,0xA1,
+	0xAF,0xB9,0x6B,0x91,0x80,0x43,0x09,0x34,0x0F,0x9E,0x40,0xE5,0x64,0x35,0xA8,0x09,0xC1,0x67,0xAB,0xC4,
+	0x30,0x26,0xD6,0x26,0xED,0x89,0x03,0x52,0x22,0x46,0x10,0x39,0x7F,0x69,0xB5,0xD4,0x39,0x2D,0xDA,0xD4,
+	0xAC,0xF8,0x0A,0x4B,0xA8,0x21,0x8E,0xF0,0x0E,0x64,0x79,0xBF,0x2E,0x0B,0xCD,0xE0,0x65,0xDB,0x2F,0x67,
+	0x2B,0x49,0x7D,0xE0,0x90,0xC9,0xFA,0xA9,0x7F,0xBC,0x9B,0xFA,0x24,0xDB,0x61,0x8F,0x6F,0x4A,0xE1,0x8B,
+	0x7F,0x6A,0x16,0x87,0xF4,0xD9,0x29,0x76,0xCD,0x33,0x53,0x4E,0xDE,0x40,0x94,0x6B,0x76,0xB4,0x0E,0xE4,
+	0x09,0x1C,0x5E,0x42,0x8A,0x16,0x19,0xFF,0x7A,0x73,0x5A,0x90,0x0D,0x28,0xC3,0x65,0x4F,0x81,0x03,0x4A,
+	0xB6,0xF6,0x53,0x6F,0xBC,0x4E,0x47,0x73,0x4B,0x55,0x98,0x11,0x09,0xAB,0x74,0xDA,0x24,0xDD,0xA3,0xB6,
+	0xDB,0x06,0x3C,0x90,0x38,0xC4,0xF9,0xED,0xC0,0x01,0x7F,0x13,0xED,0x6E,0x45,0x97,0xBF,0xDF,0x2D,0x57,
+	0x7C,0xF9,0x60,0x26,0x8A,0x00,0xF9,0xE1,0x1D,0xF4,0xDE,0xFC,0x1B,0x69,0x1F,0x0F,0x6F,0xCC,0x3C,0xB3,
+	0x8C,0xBE,0x96,0xE1,0x62,0x26,0xA8,0x91,0xCA,0xF5,0x87,0x84,0xD2,0x6A,0xF4,0x1B,0x2A,0xDA,0xEC,0x79,
+	0xA8,0xCB,0x65,0x3C,0xA3,0x42,0xE3,0x8E,0xEF,0xBB,0x3A,0x30,0x62,0xEF,0x7F,0x6C,0xF8,0x7D,0xEF,0xA9,
+	0xCD,0x4B,0xAA,0xE0,0x18,0x7D,0x04,0x94,0x09,0xD2,0x43,0x72,0x15,0x37,0xC8,0xEE,0xF2,0x6E,0xCD,0xF0,
+	0x77,0x62,0x3B,0xBC,0x2D,0xE4,0x4E,0x63,0xA0,0x7F,0x95,0xE6,0xCE,0x8E,0x6A,0xD6,0xF9,0x30,0x33,0xAC,
+	0xE1,0xBC,0x38,0x15,0x10,0x9C,0xE2,0x49,0xE1,0xE8,0xB5,0x4D,0x05,0x31,0x7C,0x3A,0x8E,0x19,0x04,0x99,
+	0xBF,0x39,0x36,0xE2,0x63,0x96,0xDC,0xED,0x8F,0xD2,0x72,0x68,0xAC,0x93,0x74,0x27,0x43,0x33,0x7C,0x1A,
+	0x96,0xDC,0xDC,0xF6,0x31,0xD8,0x3A,0x61,0xBC,0x07,0x9D,0x58,0x81,0xB2,0xEA,0x72,0xFD,0xDD,0xC6,0x1A,
+	0x07,0xF0,0xCD,0x91,0x8B,0xBA,0x60,0x8D,0x12,0x5B,0x7D,0x7B,0xE0,0x07,0xCE,0xC8,0x4C,0xFA,0x56,0xFB,
+	0x0A,0x74,0xD2,0x7D,0x44,0x18,0x92,0x2C,0x38,0x3E,0x09,0xE0,0x4B,0x83,0x1A,0x3C,0x4A,0x1B,0xDC,0x5C,
+	0x09,0xB2,0xFD,0xF8,0x66,0xF4,0x5E,0x40,0xB6,0x84,0x61,0x39,0xA9,0x5A,0xB9,0xB0,0x35,0x9C,0xFB,0xC6,
+	0x36,0x07,0x2D,0x56,0x04,0x09,0x19,0xA4,0xAF,0x28,0xCF,0xAC,0xC5,0x79,0xCB,0xE8,0xCF,0x50,0x73,0x2F,
+	0xB1,0x73,0xDC,0xF8,0xDD,0xE3,0xA4,0x24,0x39,0x1E,0xE9,0xD9,0x6B,0xF3,0x05,0x02,0xF7,0x01,0x06,0x4C,
+	0x48,0x94,0xE4,0x59,0x78,0xDD,0x20,0x45,0x23,0xCE,0x5F,0x8F,0x0B,0x8C,0x79,0x71,0x27,0xE8,0xA7,0xCF,
+	0xEF,0x33,0x5F,0x97,0x80,0xAD,0xB0,0x83,0x28,0x74,0x59,0x74,0x40,0x5B,0xDF,0xBF,0xFF,0xB4,0x4B,0x13,
+	0xED,0x4C,0x20,0x8F,0x8D,0xA0,0x8C,0xA7,0xD1,0xE3,0x19,0x98,0x15,0xF0,0xD1,0x62,0x40,0x8C,0x67,0xD5,
+	0x55,0x4D,0x71,0x01,0xA0,0x5B,0x96,0xCE,0x9A,0x57,0xB8,0xD2,0x54,0x34,0x8A,0x25,0xF6,0xC9,0x8A,0xC9,
+	0x3F,0x7D,0xF8,0x08,0x31,0x5D,0xA2,0x50,0xA6,0x4B,0x64,0x34,0xB1,0xED,0x57,0xB7,0x95,0xCE,0xE1,0x6E,
+	0xDD,0xA0,0x6D,0xB7,0xF2,0xD7,0xC7,0x73,0xBE,0x8B,0x37,0x7D,0x70,0xF8,0x5A,0x26,0x0E,0xA2,0x0F,0xE6,
+	0x16,0xD9,0xE7,0x79,0x22,0xA6,0x64,0x90,0xA6,0x7A,0x69,0xB4,0x97,0x05,0xC1,0xEC,0xC4,0x81,0xEF,0x14,
+	0xA0,0x80,0xDE,0x0C,0x80,0xB5,0x4C,0x1F,0x37,0x27,0xDD,0x0C,0x18,0x39,0x7E,0x22,0xD0,0x1E,0x01,0x31,
+	0x70,0xC5,0xD3,0xD5,0x0A,0x3F,0x11,0x74,0x64,0xA2,0xC1,0x88,0x27,0x84,0xED,0xF9,0x22,0x03,0xA6,0xCF,
+	0x54,0x59,0x8D,0x6D,0x8E,0x48,0x36,0xDF,0xFF,0xA8,0x7F,0xD7,0xAC,0x26,0x6A,0x6D,0x33,0x26,0xEE,0xA8,
+	0x0D,0xC1,0xE6,0x5C,0xB6,0x5A,0x31,0x3A,0xF8,0xC8,0xA7,0x4F,0xBE,0x7B,0x3B,0x13,0xCA,0x99,0x8D,0x82,
+	0xDA,0xF9,0x79,0x69,0x66,0x7A,0x54,0x6C,0xBB,0x24,0x2D,0xD2,0xFA,0xA6,0x0F,0x5D,0x36,0x38,0x7D,0x4B,
+	0xD7,0x71,0x9A,0xBF,0x22,0xFC,0xCD,0x88,0x48,0xDF,0xC5,0xDE,0xBF,0xD3,0xAA,0xF2,0x9E,0x87,0x5B,0xBE,
+	0x1B,0x89,0x42,0x85,0xC0,0x4B,0xC0,0xC6,0xE8,0x83,0x4C,0x11,0x7B,0x12,0xA5,0x62,0x98,0x56,0x37,0x09,
+	0x39,0xAB,0xCD,0x57,0xA6,0x91,0x6A,0xDF,0xBD,0xAD,0x8F,0x4C,0xAA,0x3E,0x7B,0x05,0xAE,0xCB,0x44,0xF0,
+	0x2A,0xB9,0xE9,0xE0,0xDB,0x1B,0xF1,0x4B,0x95,0x1F,0x3B,0x86,0xE9,0xCB,0xF6,0xD5,0x4A,0x76,0x79,0x5F,
+	0x84,0x2E,0x6C,0xE2,0x71,0x3A,0x84,0x3C,0x66,0x99,0xA2,0x86,0xCA,0x0E,0x65,0xB2,0x86,0xD0,0xF5,0x7C,
+	0x48,0x91,0xE8,0xC5,0x7A,0xC0,0xB7,0xE7,0xE8,0x5F,0xED,0xFB,0xEE,0xEF,0x25,0xA6,0x97,0xF1,0x03,0x16,
+	0xAC,0x90,0x83,0x1A,0x7A,0x05,0x5E,0x72,0xD2,0x3B,0xFF,0xF7,0x46,0x1B,0x5D,0x22,0x36,0x96,0x78,0xCA,
+	0x7E,0xC9,0xEA,0xA1,0x56,0x24,0xD4,0x25,0x1D,0xD0,0xA3,0x72,0x10,0x00,0x5F,0xCB,0xAB,0xF6,0xC1,0xA1,
+	0x44,0xB6,0xF6,0x43,0xEB,0xCF,0x24,0xA1,0x95,0x63,0xEF,0xE6,0xD7,0xD1,0x12,0xA1,0xD5,0x08,0xD5,0x24,
+	0x91,0xF5,0xFD,0x8E,0xF2,0x02,0xC3,0xDB,0xD4,0x27,0x99,0xC5,0xB9,0x45,0xF3,0x43,0x5F,0x47,0x6E,0x12,
+	0x48,0xC3,0xBE,0xAB,0x17,0x90,0x16,0xAB,0x8C,0x36,0x3D,0x1A,0x07,0xC3,0x86,0x41,0x05,0xD4,0x80,0x06,
+	0xF0,0x5F,0x8E,0xF8,0xD8,0x3B,0xDF,0x7F,0xDC,0x1B,0xEE,0xCD,0x1F,0xCA,0xB1,0xDD,0x17,0x69,0x7B,0x1F,
+	0x9B,0x78,0x97,0x0F,0x1E,0x1B,0xC0,0xC1,0xC3,0x04,0x25,0xFF,0xF9,0xD3,0xA6,0x62,0x24,0x90,0x69,0x27,
+	0x9F,0x13,0xA1,0xD5,0x6F,0x69,0xD0,0x4F,0x06,0x58,0x97,0xFD,0x8E,0xE2,0xBC,0xAC,0xD4,0xEC,0x7D,0x90,
+	0xBB,0x2E,0x69,0xED,0x1D,0xFE,0xC3,0x89,0x2A,0x93,0x33,0xE8,0x1F,0x11,0xED,0x13,0xEE,0x9C,0x27,0xD3,
+	0x36,0x9D,0x31,0x39,0xAB,0x32,0xB5,0x5F,0xD7,0xCE,0xD8,0xBB,0x06,0x97,0xDF,0x4B,0x16,0xAE,0x10,0x62,
+	0x0E,0x1B,0xD9,0x35,0xB5,0xFF,0xBC,0xA5,0xFF,0x02,0x11,0xC4,0x18,0xCB,0x5A,0x2A,0x2F,0xF4,0xA0,0x49,
+	0x50,0x22,0xAC,0xCF,0x22,0xF5,0xC6,0x68,0x59,0xCC,0xA0,0x67,0x3F,0xB7,0xAB,0xA0,0xBE,0xA8,0xC9,0x80,
+	0xC6,0xBA,0x1A,0x20,0x50,0x02,0x59,0x2F,0xFD,0x41,0x74,0x2E,0xF4,0xD6,0x0F,0x1C,0x72,0xBE,0x9C,0xA5,
+	0x2E,0x21,0x28,0x82,0x81,0x40,0x2C,0xD6,0x52,0x2C,0x14,0x13,0x27,0xDF,0x68,0x84,0x65,0x7F,0x20,0x32,
+	0x25,0x88,0x54,0x34,0x32,0x49,0x63,0xC1,0x3B,0x07,0x81,0xB8,0xF6,0x6E,0x29,0x46,0x01,0x09,0x43,0x36,
+	0xF3,0x8F,0x51,0x50,0xB6,0xF9,0x77,0x13,0xF1,0xCD,0x37,0x69,0x68,0x0E,0xF7,0x25,0x59,0x4E,0x96,0x15,
+	0xC0,0x07,0x81,0x9D,0x41,0x2A,0xDA,0xA9,0xDC,0xF9,0x03,0x88,0x67,0xE9,0xEA,0x5B,0x74,0x41,0x4B,0xA4,
+	0xA0,0xB0,0x1A,0x7B,0x07,0x12,0xD3,0x11,0xBC,0x96,0x32,0x5A,0xC8,0x46,0x15,0x4E,0xB0,0x59,0xA4,0xA9,
+	0x61,0x5B,0xDA,0x04,0x3D,0xD5,0x93,0x48,0xAA,0x0B,0x53,0xDD,0x23,0x28,0xAA,0x7F,0x36,0xBE,0xD5,0xD8,
+	0x99,0x5E,0x33,0x3E,0x48,0x0F,0x77,0xAE,0xCD,0x63,0x1B,0x84,0xAD,0xA3,0xC0,0xB2,0xE7,0xAC,0x6E,0x05,
+	0xA3,0x3D,0xAF,0x55,0xBB,0xFF,0x2C,0x29,0x0A,0x4D,0x93,0xA9,0xBE,0x92,0x4C,0x44,0xA0,0x09,0xF9,0x1A,
+	0xE4,0x76,0xD2,0x3A,0xBE,0x62,0x60,0xAF,0x7A,0xD1,0x4B,0xE8,0xA9,0xBE,0x83,0x1A,0x8C,0x75,0x77,0xA0,
+	0xE8,0x49,0x67,0x22,0x41,0xA2,0x01,0xD6,0xA1,0xFE,0xE8,0x1B,0xE7,0x20,0x88,0x04,0x7D,0xA1,0x04,0xAA,
+	0x68,0x2B,0x11,0xD0,0x68,0x59,0x43,0x4C,0x00,0xFB,0x32,0x30,0x82,0x53,0x73,0xE6,0x53,0xCE,0x0A,0xD6,
+	0x42,0xD3,0x5C,0x4D,0x53,0x75,0x3B,0xBC,0x03,0x77,0xE1,0xF3,0xD0,0xCD,0x95,0x82,0x9B,0x49,0x91,0x43,
+	0x75,0x32,0x82,0xFC,0x48,0xA2,0x76,0xAE,0xA5,0xA8,0xAA,0xA8,0xE7,0x88,0x49,0x31,0x8A,0x70,0xDE,0x80,
+	0x26,0x39,0xBA,0xC2,0xD3,0xB7,0x60,0x10,0x6A,0x5B,0x8E,0xE6,0xC1,0xAD,0x74,0xB0,0x27,0x38,0xB4,0x3C,
+	0x1A,0x77,0xC9,0x94,0xAB,0x04,0xCB,0x9A,0x01,0x76,0x18,0x45,0xFD,0x33,0xE8,0x36,0x3E,0xCB,0x73,0xCC,
+	0xCB,0xF2,0xB4,0x25,0xBE,0x0B,0xD0,0x21,0xA1,0xB6,0x4A,0xED,0xD0,0x40,0xC1,0xE2,0xD7,0xDE,0x63,0x71,
+	0xC0,0xE3,0x7E,0xAF,0xC1,0xC9,0x86,0x08,0x68,0x1C,0xE3,0x40,0x70,0xA5,0xCF,0x30,0xDD,0x87,0x30,0xA5,
+	0x8A,0x7C,0x5D,0x66,0x84,0x98,0x41,0xFF,0x5A,0x29,0x79,0x7C,0x21,0x3B,0x7F,0x0D,0xF5,0x21,0x38,0xA1,
+	0x43,0xA7,0xEF,0x96,0xBC,0x18,0xCE,0x95,0x5D,0x16,0x31,0x39,0x0A,0x90,0xB7,0x8E,0xAD,0x34,0xA0,0x5F,
+	0x69,0x19,0x44,0xF6,0xFF,0x52,0xD5,0x3B,0xAE,0x97,0xD0,0xF4,0xD1,0x78,0x28,0x35,0x59,0xC7,0x6E,0x03,
+	0x49,0xC9,0xEA,0xBA,0xD4,0x71,0x6A,0x58,0x67,0x34,0xC3,0xC7,0x1F,0x88,0x32,0x6E,0x2D,0x75,0xB2,0x78,
+	0xD2,0xB1,0xFD,0x7D,0x23,0x91,0xE8,0x0F,0x0B,0xF1,0x6F,0xC0,0x5D,0x33,0x29,0xA1,0xA8,0x5F,0x95,0xCD,
+	0xD3,0xAE,0x48,0x7D,0x98,0x70,0xCF,0xBB,0x95,0x3E,0xF0,0x38,0x2E,0x75,0x3A,0x82,0x6B,0xE3,0x18,0xE0,
+	0x2F,0xCE,0x7F,0xA2,0x23,0x43,0xF0,0xB3,0xD1,0x30,0x96,0x1A,0x89,0xAE,0xD0,0x37,0x43,0x9A,0x3B,0xF0,
+	0x51,0xFA,0xB2,0x3D,0xFC,0xC0,0xF8,0x85,0x71,0xDD,0x71,0x83,0x88,0xC0,0xEF,0x2E,0xD4,0xAC,0x8E,0x2F,
+	0x83,0x7B,0x9B,0x04,0xF0,0xAC,0x78,0xCA,0x45,0x4E,0xD9,0x23,0xEE,0xE5,0x76,0x6E,0xED,0xC0,0x82,0x46,
+	0x17,0xF4,0xB0,0xBF,0x7B,0xCE,0x48,0xA1,0x94,0x44,0xCC,0x30,0x24,0xC5,0x10,0xBE,0x8F,0x2E,0xE9,0x12,
+	0x49,0x68,0xA1,0xF8,0xF2,0xFE,0x5B,0xF3,0x32,0x29,0xB8,0x8B,0xF5,0x86,0xF1,0x00,0xFB,0x6B,0xF9,0xB2,
+	0x53,0x05,0x55,0xBA,0x6E,0xD6,0xAB,0xB1,0x7E,0x5D,0xE3,0x88,0x4A,0x6A,0xC9,0x91,0xD1,0xFD,0x8E,0xFA,
+	0x04,0x87,0x90,0xF1,0x2F,0x38,0xCD,0xAE,0x2F,0x77,0x0C,0x69,0x6F,0xCE,0x3D,0xF8,0xA1,0x24,0x15,0xF8,
+	0xA9,0x79,0x63,0x02,0xE8,0xC0,0xDA,0xCA,0x5D,0xF2,0xE3,0x56,0xAC,0x27,0x9D,0xED,0x3B,0xBA,0xDB,0x2F,
+	0x45,0xCA,0x51,0x6F,0xC5,0xF1,0xB8,0xF9,0x8B,0x73,0xF2,0x2E,0x38,0xA0,0xBB,0x18,0x14,0x66,0xDA,0x2B,
+	0xFF,0xBB,0x44,0x3E,0xAD,0x09,0x0E,0xA6,0x8A,0x6A,0xE1,0xF1,0xB5,0x61,0x56,0xEA,0x4D,0x9E,0xF9,0x28,
+	0xE4,0xFC,0xB3,0xA6,0xBA,0x52,0xB5,0x1E,0x4C,0x8D,0xB0,0xC3,0xE0,0xB6,0x45,0xA9,0xF6,0x21,0xEB,0x4B,
+	0x7A,0x54,0x64,0xF9,0xCE,0x8C,0x63,0x04,0xD0,0x8C,0x55,0x76,0x02,0x29,0xB1,0x32,0xF7,0xA6,0x47,0x16,
+	0xC9,0x35,0xFB,0xB8,0x22,0x99,0x03,0xB3,0x18,0x8F,0x96,0x79,0xB9,0x0D,0x83,0xBE,0x62,0x0B,0x40,0x4E,
+	0x04,0xBD,0xEC,0xCF,0x91,0xFD,0xD4,0x68,0xCD,0x78,0xC4,0x8D,0x3D,0x93,0xE5,0x8E,0x94,0xBE,0x9D,0xC4,
+	0xAA,0x6D,0x42,0x78,0x45,0x14,0xC0,0x4B,0xF8,0x2F,0xB7,0x41,0x74,0xC2,0xE9,0xAE,0x5A,0xD1,0xF6,0x97,
+	0xB3,0x23,0x62,0xF4,0xD6,0xE3,0x55,0xB3,0xF3,0xE8,0x58,0xAF,0xCF,0x5D,0x9A,0xFE,0x7E,0xBD,0xB4,0x67,
+	0x66,0xCF,0x58,0x99,0xAC,0x0B,0x28,0x22,0x2D,0x34,0x6D,0x16,0x31,0x15,0x40,0x9F,0x8E,0x9C,0x9D,0x90,
+	0xFA,0x97,0x27,0xB2,0x9A,0x9F,0xDB,0xA7,0x3B,0x30,0x2E,0x85,0xC5,0x96,0x4E,0x7D,0x01,0xED,0xFE,0x20,
+	0x23,0x1C,0x78,0xC6,0xC3,0x1A,0x63,0x92,0xC4,0x87,0x82,0xB0,0x0A,0x41,0xA9,0xAD,0xD3,0x43,0x82,0x66,
+	0x68,0x65,0x89,0x4C,0x6A,0xB3,0x5B,0x2A,0x37,0xC6,0xBB,0x70,0x88,0x26,0xF0,0xC2,0x3D,0xBD,0xEA,0x45,
+	0xEF,0x75,0x38,0x56,0x3F,0xB4,0x27,0x7B,0x74,0x3B,0x5F,0x87,0x41,0xF5,0xE4,0x8D,0xEE,0x57,0xEE,0x97,
+	0x59,0xF1,0x74,0x9B,0x44,0xC2,0x2C,0xEC,0xA5,0x12,0x4D,0xD9,0xB0,0x24,0x40,0x3B,0xD2,0x7E,0x93,0x7B,
+	0x56,0xDE,0x75,0xAE,0x3A,0x90,0xDA,0x99,0x0F,0x7A,0xAC,0xEC,0xCD,0x25,0x52,0xB7,0xC6,0x34,0xBD,0xCF,
+	0x0B,0x91,0x36,0x1B,0xE2,0x70,0xA7,0xC4,0xD8,0xED,0xA8,0xA6,0xAD,0xDE,0xB4,0xDE,0xC6,0x92,0xEB,0x2C,
+	0x2C,0x5E,0x96,0x2F,0xBA,0x73,0x2D,0xAA,0x9B,0x96,0xA9,0xFB,0x8C,0xCA,0xE7,0x68,0xC6,0x20,0x07,0xDB,
+	0xFF,0xFF,0x3A,0xF3,0x34,0x8B,0x54,0x2F,0x72,0xD4,0xEF,0x1E,0xE3,0x46,0x7C,0x26,0x58,0x0C,0xB0,0xF0,
+	0x05,0x20,0x8F,0xC9,0xEE,0xF4,0xD7,0xCB,0xB1,0x4E,0xCA,0xDC,0x51,0x2C,0x4E,0x30,0xB4,0x1D,0x21,0x1B,
+	0x1C,0x60,0x11,0x25,0xC6,0xF2,0x99,0xA1,0xD6,0x39,0x42,0x95,0xDC,0xE7,0xF1,0xE4,0x32,0x63,0xD9,0xDC,
+	0x98,0x2F,0x8B,0x30,0x62,0x9E,0x19,0x83,0xA7,0x82,0x95,0x89,0xB3,0x8B,0xE8,0xC0,0x3E,0xC4,0xD3,0x17,
+	0x26,0xE2,0xDB,0x96,0x7F,0x01,0xD4,0x2F,0x70,0x3C,0x26,0x76,0x97,0x21,0x5C,0x34,0x57,0x61,0x61,0x81,
+	0xC6,0x4A,0xD2,0xB7,0xB1,0x66,0x4B,0x64,0x42,0x46,0xF9,0x16,0xAA,0xE0,0x4B,0x17,0xF7,0x4B,0xDF,0x6D,
+	0x20,0x6A,0x61,0x8E,0xF0,0xBB,0x0D,0xB2,0x3A,0xB6,0x3A,0xF6,0xA4,0x05,0xBC,0x21,0xF8,0x87,0xA9,0xBA,
+	0x4C,0x40,0x6A,0xC4,0x58,0x25,0x32,0xEB,0x7D,0x6C,0x31,0x03,0xBA,0x6B,0x0E,0x6C,0xB1,0xF8,0xC3,0x3C,
+	0xFC,0x96,0xFC,0x8D,0xD5,0xAC,0x23,0x1E,0x3B,0x4E,0x15,0xD8,0xB8,0x2A,0x91,0xCB,0x58,0x27,0x33,0xEA,
+	0xF5,0xA6,0x8C,0x8A,0xD1,0x5A,0xAC,0x98,0x3D,0x48,0x83,0x8C,0xEA,0x0B,0xD5,0xE8,0x28,0x26,0xBC,0x61,
+	0x79,0xCF,0xED,0x8E,0xCA,0xFC,0x35,0x1F,0x22,0xBA,0xB1,0x38,0x3B,0x8D,0xA9,0x3E,0xA0,0x98,0xE0,0x90,
+	0x96,0x02,0xF5,0x26,0xAE,0xF1,0x1A,0x8B,0x2F,0x8F,0xD5,0x75,0x9C,0x1D,0x0A,0x79,0x6F,0x51,0xDB,0x75,
+	0x03,0x93,0x13,0xF8,0xA9,0xDE,0xD8,0x62,0xAF,0x6D,0x7B,0x7C,0xCD,0xF4,0x6C,0x41,0x2F,0xDE,0xF9,0xBA,
+	0x02,0x52,0x44,0xD9,0x5E,0xBB,0xD4,0xD4,0x45,0xA4,0xB4,0xBD,0x07,0x30,0xAA,0xEE,0x82,0x74,0x92,0xAD,
+	0x10,0xF1,0x7A,0x89,0x62,0x6B,0x9E,0x48,0x31,0x75,0x48,0x0A,0xA6,0xEA,0x81,0x67,0x59,0xA3,0x06,0xD2,
+	0x90,0x3E,0xB5,0xAC,0xD2,0x71,0xB2,0x73,0x51,0x70,0x4D,0xC8,0xDF,0xB8,0x43,0x9C,0xE9,0xFE,0x1D,0x49,
+	0xFD,0x68,0x3C,0xC2,0x7E,0x0F,0xC4,0x04,0x22,0xC9,0x0D,0xD5,0xC5,0x5A,0x8E,0xD4,0x1A,0xE5,0xF4,0x3A,
+	0xE6,0xE8,0xCC,0x94,0x37,0x7B,0x0C,0x7C,0x2D,0x4E,0x9E,0x16,0x10,0x3D,0x43,0xA7,0x5D,0x04,0xA7,0x27,
+	0x47,0xB0,0x3D,0x67,0x1E,0x17,0x15,0x4C,0xED,0x7B,0xE7,0xD3,0xAF,0x55,0x88,0xA6,0x8F,0xBD,0xFC,0x87,
+	0x6C,0xD1,0xCB,0xD9,0xF5,0x44,0x31,0x38,0x94,0xA9,0x82,0x6E,0x5B,0x3A,0x83,0x98,0x60,0xA7,0x00,0xD2,
+	0xDF,0x63,0xCE,0x51,0xB3,0x5B,0x12,0xEF,0x49,0x36,0x08,0xDA,0x96,0x84,0x32,0x22,0x7A,0x39,0xB0,0xB4,
+	0x5C,0xCB,0x91,0xA1,0xBE,0xC2,0x2D,0x0C,0x1F,0xA7,0x01,0xCB,0x0F,0x87,0x80,0x0A,0x5C,0x14,0x89,0xB1,
+	0x50,0x6A,0xCB,0x47,0x00,0x78,0x93,0xFA,0x0C,0x70,0x19,0x00,0x55,0xC3,0xBE,0x37,0x1B,0xDE,0x53,0xA8,
+	0x36,0x5A,0x1B,0x1C,0x85,0x73,0xFD,0xA7,0x0A,0xD2,0xF6,0x26,0xC2,0x51,0x9A,0x7D,0x65,0xD7,0xDD,0x1C,
+	0x7D,0x02,0x9C,0x96,0xAC,0x15,0x9E,0x18,0x1F,0xBF,0x77,0xB0,0x4B,0xD2,0xF7,0x78,0x43,0xF4,0x90,0xC4,
+	0xAD,0xF4,0xAC,0x9D,0xEB,0xC2,0x5B,0xD9,0x4A,0x1F,0xE8,0xC5,0x07,0x2E,0xB1,0x86,0x59,0x7C,0x9E,0x2B,
+	0xF6,0x60,0xF0,0xCA,0xAA,0x1D,0x08,0xD8,0x95,0x82,0x16,0x3E,0x03,0x79,0xCE,0x2F,0x14,0x23,0x00,0x0C,
+	0x6B,0x34,0xAA,0xC9,0xD3,0xE2,0x5F,0xA3,0x5C,0xA1,0x10,0x74,0xE4,0xCC,0x19,0x41,0x39,0xCE,0x75,0xA2,
+	0x97,0xC2,0x27,0x38,0x01,0x28,0x69,0x4A,0xFB,0xAE,0x6B,0x08,0xBD,0x81,0xE0,0x02,0x70,0xE8,0x65,0xAA,
+	0x42,0xC9,0xB8,0x46,0xC2,0x15,0x39,0x9F,0xB1,0x1F,0xD0,0x76,0xAE,0x35,0x48,0x7A,0x34,0x45,0x7B,0xC4,
+	0x16,0x08,0xC7,0x12,0xA0,0x3E,0xE9,0x69,0x2B,0xD8,0x1E,0xC7,0x86,0x56,0x46,0x7B,0x1B,0x0B,0xDE,0xE7,
+	0xE5,0x13,0xC2,0x5E,0xD0,0x7D,0xD1,0xAC,0xB4,0xA9,0xFE,0xC5,0x97,0xAD,0x7D,0xF7,0xA8,0xF7,0xB3,0x6F,
+	0xF4,0xD7,0xF2,0x0B,0xE7,0xEB,0xA0,0xEC,0x1A,0x50,0x6B,0x9D,0x9D,0x15,0x22,0x50,0x1F,0x13,0x3C,0x36,
+	0x0B,0x71,0xAC,0xDE,0x01,0x0D,0x52,0x58,0xB2,0xC7,0x49,0x3A,0x41,0xEA,0x06,0xBB,0xEF,0x88,0x75,0x6D,
+	0x11,0x2C,0x18,0x70,0x31,0x76,0x48,0xC7,0x5F,0xA5,0xB7,0x79,0x66,0x3A,0xBC,0x27,0x1D,0x6B,0x03,0xC5,
+	0x71,0x7A,0xEB,0x2F,0xAA,0x8B,0xDA,0xB0,0x1E,0xC1,0x62,0x2F,0xD9,0x59,0x2B,0x35,0xEB,0x33,0xCC,0x53,
+	0xD1,0x6A,0xEE,0x58,0x0F,0x22,0x06,0x2D,0x6B,0x2B,0xD5,0x84,0xAE,0xC2,0x7C,0x0D,0x23,0x83,0x33,0x76,
+	0xCE,0x07,0xF0,0xCB,0xB5,0xAF,0xB3,0x9E,0xD6,0xC8,0xE1,0x2F,0x80,0xEA,0xCB,0x41,0x03,0x72,0x93,0x2C,
+	0xE7,0x29,0x41,0x93,0xCF,0x80,0x99,0xFD,0xDE,0x2D,0x90,0xFD,0x87,0xD2,0x08,0x14,0x20,0xBA,0xA3,0x51,
+	0xE0,0x7D,0x34,0xE7,0xF9,0xEB,0x98,0xF0,0xDA,0xD3,0x40,0x16,0xC9,0x91,0x04,0x48,0xC9,0xDC,0x04,0x49,
+	0xCA,0x8C,0xAA,0x58,0x05,0x4D,0x25,0x86,0xB8,0xF3,0x65,0x1F,0x0F,0xB6,0xB7,0xC1,0x07,0xE2,0xA2,0x48,
+	0xA3,0xE8,0x01,0xD5,0x36,0xFF,0x42,0x37,0xB8,0x6D,0xC2,0x5F,0x7E,0x6E,0x61,0x3F,0x31,0x90,0x86,0x5E,
+	0xC3,0x32,0x50,0xD3,0x59,0x84,0x34,0x27,0x09,0xFC,0x7E,0x2C,0x06,0x84,0xEC,0x2B,0x65,0xDB,0xA3,0xF8,
+	0x10,0xA0,0x4B,0xDA,0x71,0xDF,0xEA,0x2B,0x25,0xDB,0xE5,0x07,0xF6,0x6D,0x2A,0xD3,0x95,0xA3,0xF4,0xEA,
+	0x0E,0x67,0x6F,0x33,0xDB,0x94,0xD3,0xEB,0x75,0xBF,0xBD,0x06,0x53,0x5A,0x22,0xE6,0xC3,0xDF,0xAC,0xCD,
+	0xD9,0x1E,0xF6,0x0C,0x1D,0x48,0x68,0x48,0x68,0x75,0x4E,0xA6,0x85,0xB7,0xFE,0xB4,0x03,0xAC,0xF1,0x56,
+	0xBF,0xB0,0x05,0x58,0xC1,0x64,0x3C,0x78,0x09,0xB5,0xA7,0x4B,0xFA,0xEF,0x9F,0xEF,0xB0,0xF8,0xA2,0x2F,
+	0xB0,0x6C,0x8C,0x3D,0x03,0xF2,0x7D,0x1F,0xF5,0x18,0xB9,0xFD,0x9E,0xDB,0x47,0x94,0xCB,0x8E,0x28,0xBD,
+	0xFB,0x97,0xF5,0xC3,0x1D,0x3C,0xD8,0xF7,0xFC,0xFC,0x08,0xC6,0x87,0x8D,0x0E,0x9C,0x95,0xAD,0x13,0xD8,
+	0x21,0x86,0x42,0xA1,0xFD,0xB8,0xFE,0x9B,0xC4,0x56,0x3E,0x57,0x60,0xF0,0xDF,0x34,0xA8,0x6C,0xEF,0xCB,
+	0x3E,0xA6,0xDB,0x78,0xBD,0xD6,0xAD,0xE5,0x96,0xAF,0x03,0xBD,0x58,0x8F,0x54,0x4D,0xBF,0xB5,0xF7,0xCA,
+	0xDB,0x9D,0xE7,0xDF,0x9C,0x7E,0x16,0x2C,0x06,0x33,0xE7,0x7A,0xD2,0x20,0xB3,0x19,0x9C,0x91,0x3A,0xA0,
+	0x0C,0xF9,0x52,0x78,0x69,0x50,0x48,0x81,0x04,0x8E,0xD8,0x70,0x41,0x95,0xF8,0x62,0xC4,0x23,0xCC,0x63,
+	0xA3,0xC0,0x89,0x89,0x17,0xA0,0x4E,0x20,0x3C,0x13,0x91,0x25,0xD0,0x62,0x70,0x77,0x6A,0x72,0x2D,0x66,
+	0xE9,0x2C,0x8E,0x2E,0xE3,0xC8,0x1E,0x4D,0xD1,0x63,0x18,0xEC,0xEB,0xCD,0x9E,0xA6,0x16,0xA1,0x09,0x62,
+	0xE7,0xC5,0xD2,0x43,0xF3,0x6D,0xE4,0xCF,0x00,0x95,0xB6,0x7D,0xE6,0xA6,0x0A,0x8F,0x9E,0x29,0x83,0xDB,
+	0x28,0x67,0x03,0xBE,0x6B,0x4F,0x72,0xA7,0xF2,0x30,0xAE,0x9E,0xD0,0x0B,0x55,0xE1,0xF3,0x9F,0x6F,0x35,
+	0xF6,0x7C,0x6C,0xA6,0xA3,0x65,0x3F,0x94,0x28,0x2C,0x76,0x0E,0x0E,0xBB,0x48,0xEA,0x2B,0x58,0x36,0x7F,
+	0x6C,0x27,0x5D,0x19,0x7C,0x57,0x92,0x2C,0xDA,0xA4,0xCA,0xB4,0x4D,0x82,0x2E,0x6F,0x65,0x26,0x0A,0x29,
+	0x39,0xBC,0x9A,0x3C,0x59,0x69,0x59,0x57,0xE0,0x5B,0x43,0x98,0xDF,0x85,0xAB,0xC9,0xCC,0x6F,0x3B,0xA9,
+	0x84,0xF3,0x0F,0xFB,0xC1,0x5A,0x3F,0x6E,0xBB,0x24,0x8E,0x28,0xF5,0xC0,0xBD,0x58,0xA0,0xC6,0x46,0x3A,
+	0xF1,0xF7,0x00,0x13,0xA5,0x79,0xED,0xFB,0x6D,0xE3,0xE9,0x32,0xE6,0x55,0x4C,0x21,0xA3,0xFB,0xAA,0x63,
+	0x23,0xF8,0x9A,0xA5,0x44,0x4B,0xF5,0x5C,0x03,0x0D,0x47,0xCD,0xA9,0x5D,0xBB,0xB4,0x5A,0xB5,0x8B,0xED,
+	0xB3,0x32,0x62,0x05,0xDC,0xB7,0x2B,0x0F,0x4E,0x4D,0xDA,0xD9,0xE6,0x77,0x75,0xD9,0xCD,0xB5,0x1B,0x90,
+	0xAB,0xB4,0x5D,0x4C,0x85,0x1B,0x8E,0x86,0xDB,0x61,0xAB,0x42,0x03,0xEA,0x8A,0xD4,0x53,0x01,0x54,0x95,
+	0x25,0xCA,0x1D,0x14,0x02,0x05,0x5A,0xDE,0x9C,0x5E,0xE2,0xCD,0x98,0xB8,0x41,0x69,0xD8,0x5F,0x3A,0xE5,
+	0xBC,0x5A,0x03,0x8D,0x53,0x10,0xAB,0xC0,0xD1,0xA2,0xC1,0x57,0xE3,0x08,0x37,0x45,0xBB,0x3A,0x1B,0x9C,
+	0xA9,0x22,0xE7,0xA5,0x0E,0xFE,0x84,0x1D,0x65,0x0F,0x54,0x83,0xB0,0x28,0x0A,0x9D,0x9D,0x15,0xEC,0x60,
+	0x52,0x36,0x8C,0x0D,0x55,0x13,0xAC,0x9E,0xEA,0x38,0x5E,0x74,0x37,0x1A,0x85,0x08,0x96,0x7C,0x40,0x45,
+	0xFE,0x24,0x6E,0xA7,0x70,0xC9,0x95,0x3C,0xED,0x4D,0x52,0x61,0xE2,0x76,0xE7,0x9F,0xA5,0xED,0xAF,0xD5,
+	0xB2,0x97,0xFA,0x8C,0xAB,0xAE,0x59,0xD5,0xAB,0x86,0x11,0xEE,0x6A,0x57,0x80,0x4A,0x7A,0x93,0xD6,0x3D,
+	0x7D,0x1A,0x6B,0x55,0x87,0x3A,0x54,0x9D,0x8E,0xB2,0x36,0xFC,0x35,0x51,0x8D,0x86,0x11,0x1B,0xDC,0x43,
+	0x90,0xF0,0x27,0x98,0x9B,0xAB,0x16,0xAF,0x8B,0x60,0xD5,0xCB,0x13,0xAF,0xCF,0x01,0x11,0xD3,0x9A,0x84,
+	0x48,0xB4,0x1E,0xDD,0x3B,0x27,0xC6,0xBD,0x6B,0x5F,0x33,0x22,0xFA,0xEB,0x8C,0x4C,0x7E,0xE4,0x06,0x0C,
+	0xFB,0x38,0xC6,0xC8,0x62,0x3C,0x8F,0xEB,0x9E,0x75,0xF5,0x68,0x23,0xB2,0xF6,0xCC,0x98,0x36,0x5A,0x05,
+	0x63,0x1F,0x14,0x83,0x7D,0x15,0x7D,0xF4,0x41,0x75,0x44,0x4F,0x2B,0xE2,0x97,0x84,0x17,0x12,0x17,0x89,
+	0xA8,0x3C,0x97,0x5B,0x2B,0x18,0x4D,0x5F,0x2A,0x83,0x85,0x4A,0xED,0x74,0x61,0x79,0xC7,0xAD,0x1E,0x2E,
+	0xE6,0xD0,0xA6,0x2A,0x9C,0xC9,0x38,0x1F,0x42,0x62,0xAF,0xE1,0x9E,0x69,0xA3,0x70,0x24,0xC1,0x11,0x69,
+	0xB6,0xA7,0xF8,0xA3,0xB4,0x6C,0x23,0x45,0x20,0x8F,0x8E,0x27,0x06,0xA6,0xF8,0x0D,0x92,0x00,0xCD,0x50,
+	0xF0,0xCD,0xF9,0xD3,0x1C,0xCB,0x1D,0xE3,0x00,0x01,0x89,0xCE,0x34,0xA2,0xAA,0xD1,0x2C,0x72,0xDF,0x53,
+	0xD6,0x8B,0xAF,0x96,0x35,0xB4,0xB0,0x5F,0x1A,0xE6,0xFE,0x25,0x40,0x14,0x07,0x9B,0xA5,0x91,0xC2,0x04,
+	0x01,0x7F,0xE9,0xD2,0x40,0x19,0xB7,0xB7,0xC5,0x69,0x87,0xF2,0x34,0x9C,0xA1,0x5E,0x9C,0x80,0xBA,0x07,
+	0x90,0x2D,0x4D,0xA3,0xDE,0x84,0xEC,0x49,0xE7,0x6B,0x65,0x74,0x81,0x7D,0x36,0x53,0x91,0x6C,0x29,0xF7,
+	0x9B,0xCE,0x39,0x4B,0xCB,0xE4,0x7B,0x01,0xE9,0x89,0x1C,0x16,0x9E,0xB4,0xF2,0xBB,0xF1,0x35,0x85,0x52,
+	0xA0,0x51,0x90,0xFA,0x13,0x92,0x2E,0x5E,0x11,0x24,0x04,0x9A,0xEE,0x64,0x75,0x34,0xA2,0xAB,0x9B,0x2B,
+	0xBF,0x6E,0xDC,0x6D,0x11,0x2C,0x4B,0xAF,0x86,0x57,0x73,0xD2,0xAA,0xA8,0x0A,0x7D,0xAE,0x49,0xD5,0x27,
+	0x74,0x3A,0xAC,0xBF,0x87,0xB6,0x25,0x46,0x34,0x52,0xA8,0xCE,0x5A,0x74,0x94,0xCC,0x9E,0x16,0x48,0x97,
+	0xEF,0x17,0x31,0x6B,0x58,0xBF,0xD1,0xEA,0x07,0x22,0x8A,0x15,0x39,0xA0,0xB5,0x2A,0xC2,0x8F,0xC2,0x81,
+	0x51,0x8F,0x59,0x76,0x65,0xA5,0xDB,0x6F,0x73,0xDF,0xF4,0x90,0x3D,0x8C,0x55,0xED,0x5E,0x36,0x33,0xD9,
+	0x4A,0xD3,0x47,0xCD,0x93,0xA5,0xF8,0x18,0xCE,0x4F,0x3F,0xAF,0x81,0xEE,0x37,0x71,0x10,0x8B,0x96,0xE4,
+	0x5D,0xE1,0xFA,0xC0,0x9F,0xBC,0x92,0xD6,0x0D,0x7D,0xBD,0xD5,0xFB,0x99,0xD4,0x50,0x77,0xB2,0x3C,0x72,
+	0x7B,0x93,0x26,0x32,0x56,0xA2,0x85,0xE5,0x5B,0x3F,0xBD,0x96,0x5D,0xE3,0x8A,0x38,0x11,0x54,0x48,0x5E,
+	0xFC,0x07,0xAD,0xB0,0xC5,0x18,0xEF,0x83,0x37,0x97,0xFB,0x67,0xE3,0x11,0x9B,0xC7,0x8C,0x53,0x5C,0x3D,
+	0x04,0x99,0xDC,0xD6,0x95,0xF6,0x89,0x1E,0xEE,0x2F,0x34,0x46,0x76,0xF7,0x7E,0x2D,0xDC,0x87,0x09,0x52,
+	0x40,0xFC,0x3C,0xE1,0x56,0xBD,0xB7,0x72,0x08,0x7E,0x23,0x2B,0xD1,0xDB,0xA5,0xC7,0xB0,0x2D,0x5D,0x0F,
+	0x58,0xAD,0x36,0xE2,0xF0,0x2E,0xD5,0x63,0x58,0x2B,0x36,0x78,0xC8,0xB5,0x5B,0x9A,0xA6,0x6C,0xAD,0x7F,
+	0xAF,0xEC,0x69,0xBB,0x18,0x87,0x2D,0xFD,0x08,0xB7,0x0E,0x51,0x90,0xDB,0x2D,0xAC,0x9A,0x55,0x3E,0xE8,
+	0xD6,0x6C,0xEC,0x9B,0x3B,0x62,0xBE,0x38,0xED,0xC3,0x25,0x53,0x82,0x74,0x9F,0x6B,0xA8,0xBF,0xF7,0x96,
+	0xF8,0xB9,0x84,0x96,0xEA,0x81,0xAB,0xCF,0xE0,0x55,0xBE,0x1F,0xAC,0x9B,0xF3,0xBB,0x3F,0x77,0x07,0x40,
+	0x60,0x26,0xC0,0x42,0x02,0xB9,0xCA,0x59,0x05,0x33,0x53,0xA7,0x8A,0xA5,0x17,0x12,0xF2,0x9E,0x2C,0x88,
+	0x3C,0xB3,0x10,0x3A,0xD2,0xF1,0x2E,0xA3,0x2A,0xBB,0xE8,0x12,0x70,0x90,0xBF,0x7A,0x14,0xBA,0x3B,0xB0,
+	0x64,0x95,0xB8,0x45,0xCD,0x3A,0xEA,0x8E,0xCC,0x0C,0x4F,0x0F,0xB6,0xB2,0xAB,0x7B,0x0E,0x3D,0xCF,0x2F,
+	0x1E,0xB4,0x59,0x8F,0x4C,0x5A,0x3F,0x17,0x08,0xBE,0x3E,0x2C,0x6B,0x0F,0x34,0x66,0x9F,0xA6,0x36,0x94,
+	0xCC,0xEB,0x17,0xBF,0xF1,0x9F,0x76,0x16,0xE8,0x0E,0xEA,0x16,0x35,0x4D,0xD8,0x2D,0x9B,0x4C,0xE6,0x32,
+	0xB0,0xE2,0x81,0x33,0xE0,0x00,0x80,0x7F,0xF1,0x26,0x69,0x25,0x29,0x33,0xCB,0x57,0xB8,0x13,0x5B,0x2B,
+	0x6A,0x67,0xB7,0x28,0x5B,0x00,0xE2,0x16,0x60,0xE2,0xB4,0xC6,0x5D,0x22,0x3E,0x47,0x26,0x8F,0x27,0xBB,
+	0xE3,0xF2,0x8D,0x06,0x9C,0x56,0x12,0xE5,0xB9,0x00,0x72,0xE0,0xC6,0xAA,0xDA,0xB6,0x15,0xE7,0x7D,0x06,
+	0x00,0x2A,0xE0,0x9A,0xFF,0x68,0xEA,0x68,0x69,0x42,0x3A,0xC1,0xDC,0xEB,0xE9,0xFF,0xE6,0x5D,0xF9,0x62,
+	0x53,0x22,0xED,0x75,0x7C,0x1C,0x8D,0xA6,0x1F,0xFA,0xA3,0x99,0xE4,0x0A,0x24,0x9D,0xB8,0x2A,0x92,0xF4,
+	0x08,0xA5,0x7D,0x7F,0x6C,0x8E,0x44,0xDB,0x22,0x95,0x2F,0xDD,0xFB,0x28,0xB1,0xA9,0x00,0xD6,0xF4,0xBD,
+	0xB5,0x24,0x8A,0xC3,0xB9,0x46,0xC0,0x89,0x31,0x38,0x8B,0x38,0xFA,0xF5,0xD3,0xF3,0xBC,0x27,0x45,0x99,
+	0x23,0xC9,0xF3,0x02,0xED,0x2B,0xB4,0x28,0x28,0xF4,0xF5,0xB9,0xBD,0x86,0x25,0xF4,0xA2,0x44,0xE5,0x3B,
+	0x38,0xE8,0x64,0x2E,0x5F,0x43,0x65,0xAE,0x1C,0x9C,0x50,0x8E,0x79,0x77,0xAD,0x94,0x5A,0x90,0xDA,0x3A,
+	0xF8,0x68,0xFE,0xB4,0x83,0xE0,0x2A,0xFC,0x0D,0xB1,0x71,0xF8,0x0B,0x0B,0x42,0x2F,0xD7,0x41,0x00,0x5C,
+	0xAE,0x06,0xEB,0x09,0xCE,0x67,0x6E,0x32,0x0F,0x33,0x73,0xA2,0x8D,0x54,0xDB,0x3A,0x85,0x82,0x25,0x54,
+	0x2A,0xE0,0x77,0x12,0x05,0x90,0xFB,0xFE,0x0E,0xCF,0x14,0xCA,0xC5,0x6C,0x2A,0xD4,0xDF,0x0B,0x14,0xB9,
+	0xAA,0xDB,0xB7,0x20,0x9F,0xCE,0xF1,0x7E,0x15,0x84,0xF0,0xC3,0x17,0xF7,0xE4,0x47,0xF5,0xFC,0xBA,0xB1,
+	0xA2,0xED,0x3C,0x20,0x7A,0x3F,0x15,0x58,0xE2,0x13,0xED,0xB9,0x10,0xF3,0x9D,0x61,0xA3,0xB2,0x18,0xAA,
+	0x85,0x71,0x42,0xC2,0x92,0xDA,0xCF,0xFE,0x1A,0x17,0xC4,0x42,0x9E,0x4D,0xE4,0xF2,0x93,0xCB,0xB7,0x20,
+	0x46,0x4F,0x5C,0xE7,0xD3,0xFE,0x5E,0x03,0xC8,0x51,0x55,0xA7,0x0F,0x94,0x24,0xC2,0x0B,0x04,0x69,0x96,
+	0x30,0x82,0xD5,0xBE,0xCA,0x1B,0x7D,0x82,0x6C,0x3E,0x98,0x87,0x2A,0x9F,0xAA,0x07,0x70,0x75,0x77,0x61,
+	0x32,0xB8,0xF5,0x3A,0xC8,0x38,0x4F,0x71,0x08,0x13,0xA5,0x77,0xF6,0x7E,0x93,0x7B,0xAC,0x95,0x1F,0x21,
+	0xC4,0x49,0x36,0x42,0x81,0xEB,0x06,0x5D,0xDB,0xA8,0x36,0xBC,0x95,0x7A,0x4F,0xAD,0x0D,0x96,0x20,0x64,
+	0xE4,0xFF,0x3E,0xCE,0x1B,0x25,0x55,0xA6,0x43,0x7E,0x47,0x64,0xE6,0xB1,0x0D,0xAB,0x7A,0x1B,0xA5,0x9D,
+	0x8B,0xD5,0xBE,0x29,0x11,0xB8,0x2F,0xEF,0xDB,0x4E,0x04,0x49,0x69,0x44,0xE1,0xBA,0xDD,0x74,0xE2,0xEC,
+	0xD7,0xBD,0x9D,0x4A,0x45,0xB7,0x6C,0x58,0xD4,0xF3,0x8C,0xAC,0xD9,0x19,0xEE,0xAA,0x49,0x01,0x7F,0xFC,
+	0x71,0xED,0x93,0xB8,0x7F,0x46,0x56,0x30,0x9A,0x72,0x7F,0xF9,0x13,0xB1,0x1C,0x4E,0xBC,0xD5,0xF3,0x8B,
+	0x65,0xF8,0x8D,0xE8,0x59,0x78,0x31,0xDE,0x8F,0xB0,0x27,0x4C,0x84,0xAC,0x7A,0x8F,0xAA,0xEF,0xBF,0xB9,
+	0xBC,0x70,0x9B,0xA7,0xF3,0x0B,0x31,0xF7,0xB7,0xE0,0xB0,0x10,0xBB,0xAE,0x9D,0xD5,0xD8,0xA1,0x72,0xBD,
+	0x73,0x2E,0x17,0x27,0x33,0x0E,0x22,0x30,0xF6,0x5C,0x18,0x44,0x37,0xFD,0x61,0x3E,0x6F,0xC6,0x93,0x37,
+	0x92,0xE3,0x0E,0xBC,0x2D,0xCD,0xEB,0xD8,0xE8,0x4D,0x8D,0x37,0x79,0x12,0x79,0x69,0xFF,0x80,0x23,0x31,
+	0x57,0x82,0xC7,0x30,0xF1,0x68,0xE0,0x85,0xFB,0x02,0xF8,0xA6,0x1A,0xA7,0xE1,0x11,0x72,0xA8,0x49,0xF8,
+	0xD5,0xA0,0xF8,0x30,0xFC,0xC7,0xB6,0xB0,0x92,0x84,0x46,0x5E,0x8F,0x0C,0x47,0x94,0x1F,0xB4,0x61,0x3D,
+	0x44,0xC6,0xA6,0xD7,0x77,0xBD,0x17,0x4E,0xC5,0xED,0x99,0x60,0x75,0x83,0xB2,0x84,0x7A,0x28,0xB0,0xB3,
+	0x30,0xBC,0x01,0x61,0x3B,0xC8,0xD9,0x24,0xE4,0x4C,0xF9,0x0A,0xE5,0x41,0xDC,0xAF,0x38,0x05,0x0C,0x5E,
+	0x2C,0x37,0xB7,0x03,0xB7,0xAC,0x71,0x1A,0x0B,0x19,0x98,0x3A,0x76,0xF1,0xC1,0x45,0x25,0xC4,0x1E,0x1A,
+	0x36,0xE6,0xDE,0xE7,0x8C,0x35,0x39,0xFE,0x3F,0xEA,0xCC,0x59,0xAE,0x35,0x89,0x9F,0x45,0x45,0x0F,0x64,
+	0xE5,0x86,0xAB,0x0C,0xF8,0xD3,0xC4,0x45,0xE3,0x8A,0x3B,0xBD,0x61,0x21,0x1A,0x78,0x2A,0x21,0xBF,0xBE,
+	0x56,0xE3,0x2B,0x1F,0xEB,0x13,0x4A,0xFE,0xF9,0xAD,0xAA,0xB6,0x9F,0x70,0xB0,0x33,0x2C,0x06,0x69,0xF8,
+	0xD6,0x7F,0x82,0xFC,0x5A,0xD4,0x37,0x7B,0x8A,0x71,0x23,0xDA,0xCA,0xEE,0xCC,0x2C,0x18,0xC6,0x93,0x2B,
+	0xAF,0x63,0xC7,0x7F,0xE4,0x80,0x53,0x4F,0x38,0xA9,0x43,0x85,0x32,0xA1,0x3B,0x8A,0xC0,0xE9,0x7A,0x60,
+	0x20,0x3D,0xDA,0x81,0x10,0x2C,0xA4,0x26,0x34,0xF4,0x8B,0x57,0xD7,0xB0,0x0A,0x70,0xA9,0xD1,0x01,0xF9,
+	0x5E,0xBE,0x26,0xB0,0xD6,0x8C,0xC2,0xB1,0x1E,0xFE,0xB0,0xB1,0x4F,0xD6,0x9A,0xDD,0x29,0x4F,0xD9,0xCC,
+	0x3A,0x0F,0xD5,0x88,0xC1,0xB3,0x2A,0x4E,0xCE,0x9C,0x2D,0x15,0x09,0x79,0x27,0xB1,0x77,0x92,0x3D,0xC4,
+	0x85,0xB1,0xC4,0xB0,0x44,0xA8,0xBB,0x3C,0x45,0xB2,0x8E,0x90,0x55,0x9F,0x94,0xA2,0xF6,0xF9,0xCC,0xA0,
+	0x45,0xA9,0x73,0x9A,0x31,0x1F,0x44,0x0C,0xE5,0xD1,0xC4,0x26,0x80,0xFA,0x1B,0xC4,0x82,0x39,0x25,0x52,
+	0xB0,0xF4,0x8D,0x61,0x66,0xC3,0xBF,0x1A,0x55,0x93,0x13,0xD4,0x83,0x02,0xE6,0x53,0xE5,0x7A,0xCB,0x91,
+	0x1C,0x6A,0x9D,0xB7,0xF1,0xFA,0xA6,0xB8,0x4C,0x9A,0x66,0x93,0xE6,0xB5,0x85,0x1A,0x90,0x7B,0x31,0x35,
+	0xDD,0x67,0x7C,0xB5,0xC6,0xFD,0x11,0x6F,0x9E,0xF9,0x07,0xA4,0x0F,0x2D,0xE4,0x11,0x01,0x56,0x59,0x8D,
+	0x45,0x95,0x5C,0xA8,0x1D,0xFB,0x6C,0xAB,0xEA,0x4A,0x03,0xCD,0x07,0xBB,0xBF,0x88,0xC3,0xDF,0xCF,0xB0,
+	0xC9,0xFB,0x69,0x9F,0x4C,0x44,0x1F,0xCD,0x9F,0xC7,0x1E,0x39,0x8D,0x19,0xDC,0x3D,0x0A,0x11,0x89,0x6E,
+	0x20,0x11,0xBC,0x01,0xDD,0xF1,0x3D,0x24,0x0B,0xDF,0xA6,0x6E,0x39,0x5F,0x40,0x18,0x0D,0xDB,0xC6,0x2E,
+	0x81,0xF2,0x70,0x34,0x47,0x91,0x76,0x88,0x74,0xCF,0x65,0xF9,0x05,0x9A,0xBD,0x14,0x5D,0x9B,0x76,0x0A,
+	0x20,0x84,0x55,0xEF,0x1C,0xFD,0xBF,0x6F,0x4E,0xB3,0xC7,0x2F,0x20,0xF0,0x60,0x40,0x06,0x0D,0x10,0x24,
+	0x76,0x83,0x5A,0xDB,0xE3,0x46,0x9A,0x64,0x5C,0x9B,0x30,0xC0,0xBE,0x0E,0x0F,0xEB,0x66,0x21,0x01,0xB2,
+	0x44,0xE1,0xA7,0x46,0xBA,0x62,0x4B,0xFF,0x23,0x67,0xD8,0x9A,0x35,0xA8,0x99,0x20,0xC6,0xA9,0x6A,0x01,
+	0x82,0x66,0x31,0xC1,0x7A,0x0C,0x49,0x0D,0x19,0xFE,0xD9,0xC4,0xF0,0x45,0xE7,0x94,0x3A,0x20,0x0A,0xBB,
+	0xA1,0x02,0xBE,0xD2,0xF9,0xC2,0x42,0x90,0x4A,0x4B,0x78,0xEE,0xC6,0xF0,0x37,0xB2,0x81,0x2D,0xAA,0x4A,
+	0xC5,0xD1,0x38,0x30,0xEF,0xC8,0x5C,0xB2,0xC1,0x66,0x4D,0xB7,0x23,0x8C,0x9F,0xD6,0x82,0x89,0x31,0x21,
+	0x6F,0x49,0x74,0x7E,0xB9,0x12,0xB2,0x33,0xC0,0xB8,0x2E,0xA6,0x49,0x8C,0x21,0xF3,0xC2,0x20,0x3A,0x8E,
+	0x1B,0x90,0x62,0x4C,0x68,0x85,0xA8,0xE6,0x5B,0x27,0x9A,0x21,0x4E,0xA3,0xEC,0x89,0xA8,0x99,0x02,0x3F,
+	0x49,0x06,0x0D,0x54,0xF2,0xF8,0xDA,0xCD,0x78,0xB2,0x8C,0xB8,0x4A,0x08,0x7B,0x2E,0x2B,0x0C,0xAA,0x72,
+	0x59,0xA0,0x0A,0xAB,0xCD,0xFA,0xA8,0xEA,0x02,0x60,0x6B,0x5D,0xBC,0x86,0xD2,0x2E,0x3C,0xD4,0x01,0xBD,
+	0xBA,0xEF,0xA3,0xCE,0xAD,0xCA,0x3A,0xCA,0x8A,0x07,0xA1,0x48,0xE6,0x68,0x2A,0xEA,0x4B,0x0B,0x5A,0x7F,
+	0xAC,0x44,0xCC,0xDA,0x02,0xB0,0x6D,0x6B,0x70,0x88,0x4A,0x9A,0xC9,0x45,0xA9,0xC1,0x93,0xDE,0x7B,0x1B,
+	0x84,0x84,0x70,0x4A,0x4E,0xEB,0x6B,0xB9,0x96,0xC6,0xF5,0xD6,0xDB,0xCA,0x5B,0x3B,0xC3,0x4D,0x4B,0xAC,
+	0x7B,0x6F,0x2B,0x03,0x68,0x2A,0x39,0x6E,0xAD,0x89,0x8C,0x97,0x43,0x30,0xFB,0x00,0x63,0xF4,0xD4,0x55,
+	0x4B,0x56,0x23,0x01,0x91,0xEF,0x36,0x72,0xA3,0x12,0x51,0x95,0x4A,0x81,0x4C,0xD2,0x25,0x57,0x1B,0x3D,
+	0x84,0x7D,0x7D,0x03,0x82,0xB2,0x22,0xB8,0x15,0xCD,0x9D,0x35,0x41,0xAD,0xEA,0x4D,0xFC,0x30,0x58,0x73,
+	0x23,0x10,0x4D,0x4D,0x75,0x8F,0x95,0xB8,0xE7,0xB8,0xA5,0xCA,0x70,0x7E,0x3B,0x44,0x4D,0xEE,0x63,0x5B,
+	0x59,0x82,0xDC,0x80,0x01,0xAF,0x75,0xFE,0xEE,0xC0,0x46,0xD4,0x80,0x98,0x6F,0xE2,0xEF,0xD0,0x24,0x72,
+	0x41,0x20,0xBD,0x54,0xA5,0xCA,0x25,0x80,0x26,0x1B,0x45,0x34,0x60,0x76,0x2D,0xC6,0x81,0xA9,0x8B,0xEA,
+	0xB4,0x38,0x8D,0x24,0x94,0x9D,0x93,0xE6,0xB7,0x9C,0x65,0x21,0x1D,0x58,0xE3,0xB1,0x9B,0x80,0x41,0x6A,
+	0xAA,0x1B,0x39,0xD7,0xB5,0x85,0x4A,0xD7,0xE5,0x3A,0x25,0x0C,0x84,0x5B,0x98,0x7A,0xAB,0x31,0x0A,0xDC,
+	0x35,0xC2,0x96,0xA1,0x6F,0xB2,0x25,0xF2,0x98,0x46,0x82,0x6B,0x2A,0x19,0xE1,0xB0,0x37,0xBC,0x47,0xCB,
+	0xAC,0x5C,0x3A,0xD2,0x65,0x26,0xB6,0xFB,0xEA,0xA4,0x74,0xB9,0x58,0xA4,0x43,0x9D,0xDA,0x4D,0xE6,0x7F,
+	0x58,0x84,0x39,0x2A,0xA8,0x54,0xF4,0xC8,0xBF,0x2A,0x36,0xAC,0x65,0x51,0xA8,0xA8,0x93,0x54,0x2E,0x98,
+	0x25,0x10,0x90,0xD3,0x75,0x73,0x54,0xF9,0xC8,0x5B,0xE0,0xBC,0x11,0xCA,0xDE,0x39,0xA2,0x11,0x66,0xD7,
+	0x26,0x8A,0x5D,0xED,0x49,0x53,0x81,0x53,0x11,0x56,0x45,0xDD,0x08,0x12,0xAE,0x7D,0x6D,0x80,0xD7,0x90,
+	0x88,0x7F,0xA1,0xBD,0x12,0x8C,0x58,0x80,0x0D,0xC4,0x4C,0x95,0x60,0xAA,0x50,0x66,0x0A,0xCD,0xE4,0xD5,
+	0x7E,0x6D,0x72,0x13,0x03,0x6A,0xA0,0x13,0x6A,0x7E,0x72,0x37,0x67,0xCC,0x83,0x26,0xEE,0x4C,0x19,0x53,
+	0x80,0x8D,0xA7,0x83,0x87,0x6A,0xCE,0x71,0xCA,0xA0,0xE7,0x87,0x3F,0xE1,0xF0,0xC3,0x7E,0x8C,0x39,0x93,
+	0x86,0x23,0xBB,0xB1,0xC0,0xE3,0x2A,0x3C,0x76,0x66,0xBE,0x2A,0x86,0x54,0x48,0xCC,0x82,0x30,0x4F,0x80,
+	0xC4,0xCC,0xCA,0x95,0x9C,0x4F,0x50,0x82,0xFC,0x8A,0xAC,0x90,0x85,0xA6,0xF0,0x71,0xE6,0x4D,0x4B,0x71,
+	0x83,0x33,0x59,0x13,0x8E,0x89,0x44,0x5C,0xFD,0xD2,0xB7,0x1C,0x65,0xC0,0x93,0x63,0x2A,0xA2,0x09,0x13,
+	0x87,0x0C,0x0A,0xAC,0x5F,0x14,0x7D,0x91,0x45,0x8F,0x5E,0xE8,0xBC,0x51,0x42,0xAA,0xB0,0x85,0xA3,0x68,
+	0x5C,0x03,0xF2,0xDF,0x67,0x35,0x01,0xCC,0x34,0x8B,0x20,0x5A,0xAE,0x84,0x3A,0xF6,0xFD,0xE4,0x70,0x3B,
+	0x6F,0xC4,0x6A,0xCD,0x7B,0x79,0x29,0x1B,0x2F,0x87,0xDB,0x07,0x7C,0x55,0x19,0xAE,0xC2,0xA8,0xCD,0x8A,
+	0x29,0x49,0x61,0xF4,0x2E,0x8D,0x54,0xF2,0x62,0x26,0xB9,0xB9,0xC8,0x6B,0x9B,0xE9,0x29,0xA8,0x66,0xA8,
+	0x8C,0xA4,0x00,0x5D,0x68,0x4A,0x52,0x08,0x0F,0xC8,0x72,0x9F,0x8C,0xAC,0x0A,0x1B,0xE4,0xCF,0x88,0x5A,
+	0xE3,0xE9,0x20,0x7F,0xEC,0xCB,0xA4,0x4D,0x5B,0x46,0x1F,0xCF,0xE1,0x74,0xD9,0xBC,0x54,0x05,0x0B,0xE9,
+	0xCB,0x04,0x50,0x59,0x02,0x0B,0xB5,0x86,0x0D,0xA7,0x58,0x58,0x4B,0x79,0xF3,0xB7,0x6C,0xC9,0xC9,0x7B,
+	0x5A,0xF9,0x5C,0x00,0x2D,0xAD,0x9F,0xC1,0xFE,0x41,0x8C,0x5D,0x57,0x95,0xDC,0xC4,0x83,0xB2,0xA4,0x96,
+	0x84,0x1B,0x38,0x12,0x26,0x39,0x43,0xF5,0x63,0xCB,0x1B,0x13,0x73,0xEB,0xE5,0x76,0xFB,0x94,0xED,0x9B,
+	0xB2,0xA8,0x8D,0x59,0xF4,0x9F,0x36,0xFA,0x20,0xB1,0x52,0x71,0x27,0xDB,0xA5,0x92,0xCA,0x6C,0xF0,0xF3,
+	0xB9,0xC8,0xBF,0x88,0xDB,0xB2,0x6E,0xD2,0x85,0x92,0xDE,0x35,0xF0,0x1B,0x0C,0x60,0x63,0x4D,0xA2,0x5C,
+	0x9D,0x07,0x68,0x30,0x8B,0x98,0x92,0x44,0xCB,0xF1,0x7E,0x10,0xE5,0x9D,0xCB,0xB6,0x84,0xFB,0x6D,0x47,
+	0x07,0x1E,0x03,0x36,0x7C,0xA6,0x0D,0x61,0xEF,0x30,0x42,0xA3,0x02,0xDE,0x67,0xF3,0x04,0x9A,0x5E,0xD0,
+	0x63,0x61,0xE8,0x63,0x44,0x96,0x95,0x71,0x0B,0xB6,0xA4,0xE8,0x6F,0x27,0x36,0x96,0xBC,0x25,0xD3,0xCC,
+	0x93,0x65,0xD6,0xEA,0xB0,0x75,0x16,0x4A,0xD6,0x96,0xC9,0xDE,0x69,0xFB,0x3F,0x52,0xD1,0x94,0x86,0x6E,
+	0x86,0xF6,0x5F,0x09,0xA9,0xCA,0xFC,0x96,0x4D,0xD4,0xF7,0x63,0xF3,0xD0,0xCF,0x2D,0xF5,0x27,0x4F,0xDF,
+	0xF9,0x96,0xE6,0xBA,0xBB,0xA1,0x67,0xBE,0x92,0x24,0xDF,0xFE,0x5A,0xF6,0x6C,0x8A,0x8D,0x9A,0x41,0x51,
+	0xD5,0x0A,0x9A,0x6A,0x92,0xFC,0x96,0xAA,0x21,0x77,0xEE,0x38,0x8E,0x15,0x5C,0xC1,0xD3,0x12,0x29,0xE5,
+	0x19,0x69,0xB5,0x7C,0x7A,0x99,0x6F,0x4F,0x0F,0x16,0xB9,0x55,0xBA,0x6A,0xDB,0xA9,0x6D,0x0A,0x73,0x0D,
+	0xF8,0x24,0x6D,0x39,0x2D,0xD7,0xD9,0x2E,0x5F,0xFF,0xDF,0xE1,0x63,0x52,0xA5,0xEF,0x5C,0xBE,0x27,0xA1,
+	0x99,0xFD,0x13,0x1F,0x6C,0xAD,0x2E,0x90,0x8A,0x03,0xAE,0x84,0x31,0x64,0x76,0xA4,0x11,0x4C,0xF6,0xB0,
+	0xFA,0x42,0x31,0xDF,0xA0,0x92,0xF9,0x74,0x41,0xF5,0x2C,0xE9,0x83,0x4F,0xFF,0xA5,0x7B,0x01,0x6F,0x91,
+	0x3D,0xC3,0xE8,0x5F,0xB1,0x66,0x77,0xA4,0x03,0x07,0xB7,0x7C,0xF9,0x2E,0xE0,0x76,0x7C,0xF5,0xC9,0x2E,
+	0xFB,0x78,0x19,0x43,0xA7,0xAB,0x82,0xB7,0x38,0x89,0xE4,0x02,0xFD,0x28,0xAE,0xDC,0xBB,0x17,0x76,0xF0,
+	0x8E,0xA3,0xF6,0x20,0x78,0x2A,0xE3,0xFE,0xA8,0x26,0x8B,0xF1,0xEC,0xDE,0x11,0xB1,0x7D,0x49,0xDF,0xD5,
+	0x79,0x65,0xEE,0xEE,0x29,0xC5,0x7D,0xE0,0x65,0xCB,0x57,0x11,0x8B,0x46,0x49,0x67,0xAF,0x98,0x09,0x06,
+	0xDF,0x2B,0xE0,0x8D,0x31,0x9C,0x49,0x8C,0x4E,0x5C,0x7D,0x7F,0x29,0x4B,0xAB,0xB2,0x49,0x4A,0xF1,0x47,
+	0xFF,0x04,0xCA,0x8C,0xD9,0xAD,0xF4,0xAD,0xEC,0xAA,0xE7,0x4A,0x23,0xCA,0x4A,0x4C,0xD9,0x76,0x7C,0x33,
+	0x2B,0x07,0x78,0x72,0xF8,0x3C,0x2D,0x98,0xA8,0x56,0xAC,0xBE,0xF6,0xC7,0x73,0xBD,0x62,0x68,0x2E,0xEE,
+	0xFB,0xA0,0xE2,0xFE,0x34,0x3D,0xA0,0x4D,0x59,0x7D,0x78,0xBB,0x20,0xA3,0xFC,0xAE,0x2C,0xB3,0x68,0xFB,
+	0x28,0xE3,0x92,0x90,0xE6,0x2E,0x14,0xEC,0x09,0xB6,0xB2,0x6E,0xD3,0x22,0x24,0xDD,0xA2,0xCE,0x7D,0xD4,
+	0x93,0x8E,0x93,0xB8,0xE0,0x9B,0xFD,0xE9,0x52,0xE7,0x01,0x1B,0x00,0x2D,0x00,0x8F,0x0E,0x8D,0x0B,0xA1,
+	0x37,0xFA,0x47,0xAE,0xDA,0xD3,0x4D,0xDD,0x20,0x0C,0x8E,0x6E,0xE9,0x3C,0x12,0xE2,0x40,0xBE,0x44,0x4C,
+	0x44,0x9F,0xAF,0x3A,0x63,0x90,0x96,0xFA,0xD4,0x9D,0x25,0x14,0x6B,0x7C,0xF4,0xB5,0xEE,0x95,0x23,0xEF,
+	0xEC,0xAC,0xE5,0x4F,0xA0,0xAC,0x7B,0x87,0x41,0x91,0x21,0xF7,0x13,0x57,0xBE,0xDB,0x35,0xAE,0x51,0xFB,
+	0xFE,0x6C,0xF2,0x79,0xDA,0x5E,0xDB,0x93,0x79,0xB0,0x7A,0x4E,0x14,0xC5,0xB6,0xCF,0xD3,0x9E,0xFB,0xF1,
+	0x83,0xEB,0x16,0xF4,0x36,0x8B,0xB7,0x20,0x66,0x1A,0x8B,0x8E,0x01,0xF3,0x9E,0xED,0xC8,0x51,0x92,0x91,
+	0x33,0x91,0x8C,0x03,0x01,0xC8,0xCA,0x5C,0x98,0x66,0xFE,0x64,0x55,0xBB,0xFF,0x74,0xD8,0xA9,0xC2,0xA6,
+	0x1B,0xF0,0x15,0x59,0x51,0x8B,0x73,0x60,0xD5,0xB8,0x99,0x85,0x0F,0xB4,0x3B,0x50,0x08,0x34,0x66,0x44,
+	0x9D,0xD8,0x78,0x38,0x38,0x55,0x22,0x7D,0x9B,0x78,0xED,0xEF,0x81,0xFB,0x94,0xDE,0xC7,0x7C,0x01,0xFA,
+	0x27,0x7B,0xB6,0x62,0x95,0x34,0x4C,0x22,0x82,0xDA,0x43,0x43,0xF9,0x19,0x79,0x38,0x2A,0x1E,0x3E,0x09,
+	0xE4,0x8C,0x70,0x5A,0x82,0xF7,0x16,0xD7,0xD9,0xFA,0xCB,0x49,0xA1,0xB2,0x70,0x8E,0xD7,0x7F,0xDF,0x28,
+	0x16,0x8E,0x32,0xC6,0x64,0xD6,0xE2,0xAA,0xDD,0x79,0x77,0x69,0xC6,0xFF,0xBA,0x9B,0x08,0xFA,0x00,0xAB,
+	0x93,0x6F,0xEE,0xCB,0x41,0x79,0x52,0xAF,0x11,0x7F,0x40,0x5D,0xF9,0x55,0xB8,0x55,0x78,0xBD,0x7F,0x36,
+	0x62,0xDD,0x74,0x7C,0xBC,0x47,0x4C,0x19,0x6A,0x41,0xB1,0x41,0x13,0x9D,0x11,0x3B,0xAF,0xA2,0x46,0x1E,
+	0xD3,0xBC,0xDF,0x3F,0x97,0x5C,0x85,0x02,0x10,0x9C,0x1E,0xA3,0x25,0xF2,0x88,0x3B,0xFF,0xE4,0x8B,0xAC,
+	0x45,0x00,0xF8,0x2E,0x84,0xA3,0xFA,0x1A,0xA0,0x2E,0x08,0xE5,0x73,0x55,0x02,0xD4,0xC8,0x3C,0x85,0xD0,
+	0x75,0x22,0x78,0xC6,0x21,0x2D,0xFB,0x04,0xE2,0x57,0x6B,0xFA,0xFC,0xDD,0x96,0x82,0xE7,0xB4,0xFF,0x91,
+	0x05,0xF9,0x7F,0x65,0x22,0x5F,0x5F,0x82,0x30,0x65,0xA9,0xC7,0xA2,0xD2,0x30,0xC6,0x75,0xA3,0x5D,0x19,
+	0xC3,0xF9,0x4E,0xC7,0x2C,0xE7,0xCE,0xCB,0xDB,0x86,0xDB,0xE3,0x01,0xCE,0x5D,0xD2,0x2A,0xCC,0xDA,0x01,
+	0x65,0x87,0x87,0x47,0xF6,0x1A,0x56,0xE3,0x7A,0x45,0x4A,0xAA,0x94,0xFD,0x0F,0xC2,0x9E,0xC2,0x8A,0x14,
+	0xA4,0x84,0x0E,0x21,0x7C,0x2A,0xB7,0xF2,0x2B,0x0C,0xF0,0x9D,0x66,0x58,0xC2,0xD2,0x20,0x1A,0xE2,0x9E,
+	0x98,0x1D,0x1B,0x51,0x1A,0x71,0x60,0x6A,0x58,0x65,0xCC,0x28,0xBD,0x6B,0xE8,0x00,0xC5,0x86,0x97,0xD9,
+	0xDF,0xC9,0x04,0x8A,0x2F,0x36,0x45,0xC2,0x5D,0xAB,0x5B,0xF0,0x2D,0xC8,0xA4,0x44,0x61,0x96,0x65,0x1B,
+	0x33,0x35,0x19,0xDC,0x50,0xE7,0xFB,0xE8,0xA3,0xB6,0xA3,0x06,0x7C,0xD4,0xC0,0x7C,0x30,0x7D,0xB8,0x3C,
+	0x20,0xF0,0xF8,0x7A,0xF9,0x73,0xB0,0xCE,0x75,0x0F,0xC6,0x08,0xB5,0x51,0xE0,0xEE,0xA1,0x31,0x32,0x21,
+	0x6F,0xCD,0xCC,0xFA,0x3D,0x00,0xBE,0x85,0xC2,0x60,0xC4,0xC6,0x85,0x92,0x5C,0x0C,0x50,0x84,0x56,0xBE,
+	0xF8,0xAC,0xDF,0xEE,0x39,0x73,0xA1,0x40,0x29,0x82,0x94,0x29,0xA1,0x50,0xBB,0x3F,0xAD,0x02,0xAB,0xE4,
+	0x26,0xEC,0xC5,0xD2,0x0D,0xB0,0x70,0xE2,0x62,0xAD,0x82,0x32,0xB8,0x1B,0xE6,0x9D,0x0A,0x4F,0x69,0x8A,
+	0x72,0xEA,0x52,0x94,0xC4,0x12,0x2B,0x0D,0x94,0x2E,0x87,0xF0,0xC4,0x2C,0x05,0xC6,0x21,0xF8,0x33,0xE1,
+	0xC4,0xAF,0xDD,0x83,0x01,0xF0,0x4A,0x27,0xBC,0x5E,0x27,0xC8,0x57,0xA2,0x04,0x17,0xEF,0xFE,0x19,0xF5,
+	0x38,0x45,0x15,0xD1,0x11,0x50,0x3D,0x96,0x89,0xE6,0xA4,0xDF,0xFC,0x99,0x9A,0x76,0xC3,0x17,0xE3,0x77,
+	0x46,0xE5,0x8A,0x4E,0x82,0x17,0xC0,0xAD,0xB9,0x6A,0x65,0x89,0x5F,0x76,0x87,0xFA,0xC2,0x2A,0x82,0xDA,
+	0x9E,0xA4,0x9C,0xE4,0x07,0xE9,0x31,0x34,0x98,0xF4,0xB5,0x0B,0x54,0x9B,0x42,0x4F,0xD2,0x7B,0xD6,0x5D,
+	0x50,0x3C,0x93,0x63,0x42,0x14,0x91,0x1B,0x59,0x9A,0x3D,0xAA,0x2A,0x68,0xD9,0x82,0x89,0x37,0x59,0xF4,
+	0xEA,0x04,0x81,0x1B,0x6A,0x7A,0x25,0x98,0x5E,0xE8,0x78,0xDD,0xC4,0x3A,0xE7,0xA2,0x3B,0xA3,0x56,0xD8,
+	0x9A,0x9B,0x0C,0x1A,0x6D,0x3C,0x75,0x83,0x09,0x35,0x18,0xD4,0x4F,0xF8,0xC8,0x69,0x4D,0x25,0x05,0x0E,
+	0x4C,0x0B,0x49,0x3E,0x46,0x38,0x6A,0x58,0x77,0x98,0xBC,0xE6,0xC9,0x2F,0x6B,0x9B,0x78,0x0A,0x1E,0xCE,
+	0xD7,0x19,0xB0,0x3D,0x54,0x1E,0x91,0x62,0xCB,0x0A,0xC8,0xC2,0x78,0x04,0x50,0x38,0x4D,0xE8,0xBA,0xCD,
+	0x19,0xB2,0xEE,0xBD,0x4B,0x9F,0x6D,0xE1,0x03,0x76,0x75,0x4B,0x45,0xDA,0xB7,0xCD,0x7F,0x13,0x7F,0xEA,
+	0xCA,0xB0,0xF9,0xD0,0x7A,0x51,0x11,0xDC,0x0E,0xC0,0xDD,0xCC,0x1C,0xCC,0xF2,0xCB,0x06,0x16,0xB0,0xCE,
+	0xCB,0xE0,0xB8,0xE0,0x38,0xB4,0x04,0xC3,0x90,0x00,0x06,0x0C,0x46,0xB8,0xF0,0x64,0xB2,0x6D,0xF3,0x37,
+	0xA0,0x8E,0x7D,0x52,0x45,0x3A,0x89,0xB4,0x1C,0xF8,0x7F,0xCB,0xA0,0xB7,0xA1,0x1B,0x0C,0x0F,0x2D,0x45,
+	0x94,0x07,0xBF,0x53,0x63,0xEF,0xEA,0x02,0x71,0x0E,0x51,0x15,0x74,0x8C,0xE8,0x63,0xB2,0x63,0xA2,0xD3,
+	0x6D,0xBE,0x62,0x4A,0xE2,0x23,0xBD,0x0E,0xF7,0x58,0x98,0xE4,0x6D,0xA6,0xBC,0xFF,0x43,0x84,0xE9,0x22,
+	0x3E,0xC9,0x76,0xF0,0x8E,0xF3,0xDD,0xAD,0x57,0xA8,0x0E,0x92,0xF3,0x94,0xD9,0xF0,0x62,0x65,0x18,0x69,
+	0x27,0xF9,0x01,0xBC,0xE1,0x22,0x91,0xB5,0x48,0xEB,0x8F,0x34,0xB1,0x6D,0x41,0x5C,0xA3,0xF7,0x36,0xD1,
+	0x80,0x14,0xE3,0x8E,0x2A,0xE4,0x19,0x8C,0x07,0x4A,0x5A,0x0C,0x80,0xC4,0xB6,0x33,0x3A,0x78,0x6A,0x5B,
+	0x7C,0x0A,0x39,0x6B,0x56,0xB4,0x85,0xD9,0x6A,0xF6,0xC9,0x7A,0x9B,0x2A,0x62,0x1F,0xA0,0xF8,0xFA,0x7C,
+	0xBB,0xB4,0x5D,0x24,0xC4,0x48,0xC3,0xCB,0x84,0x31,0x9C,0xC4,0x21,0xDB,0x57,0xE7,0x63,0x95,0x73,0x3E,
+	0x2A,0xA6,0x8E,0xFF,0xAA,0x99,0x63,0xC9,0xCC,0xEA,0xE3,0x1A,0x24,0x64,0x43,0xA0,0x7E,0x41,0xFA,0xB2,
+	0x3B,0x7E,0xBE,0xF7,0x4B,0x2C,0xAD,0x84,0x8B,0x21,0xB3,0x67,0x69,0xAD,0x71,0x9B,0xC9,0x25,0x0C,0x47,
+	0x6D,0x0C,0xF1,0x02,0x8A,0xD0,0xD6,0xA6,0x6B,0x5D,0x6F,0x37,0x4C,0x51,0x8C,0x96,0xEE,0x8B,0x28,0x65,
+	0x7F,0xD1,0x19,0xDD,0xB8,0x69,0x4F,0x23,0x49,0x50,0x70,0x06,0x1A,0x54,0x9C,0x9D,0xD3,0xFD,0x7A,0xB9,
+	0xF8,0x54,0xBC,0xD4,0x38,0x3F,0x03,0x9E,0x10,0x12,0x31,0x98,0x13,0xB7,0xB8,0xF2,0xC2,0x1A,0x86,0x14,
+	0x92,0x37,0x22,0x9C,0xEC,0xD7,0xA4,0x47,0x13,0x1D,0x26,0x86,0x01,0x4D,0xE5,0xC4,0x3C,0x3F,0xDD,0x6B,
+	0xA8,0x03,0x02,0x21,0xB7,0x49,0x8D,0xFF,0x42,0x18,0x85,0x10,0x10,0xBB,0x9C,0x71,0xE5,0x7A,0xFB,0xB8,
+	0x1A,0x70,0xFF,0xA0,0x2E,0xBF,0x3C,0xE0,0x01,0x41,0xF4,0x92,0x00,0x98,0x5D,0x6B,0xC7,0x00,0x2B,0xB2,
+	0xDC,0xB8,0xCE,0x94,0x73,0xB8,0xE8,0x92,0x5F,0x2A,0xE3,0xAC,0x50,0x89,0x91,0x3E,0xA4,0xDC,0x7D,0x3A,
+	0x3D,0xB0,0x2B,0xE6,0x43,0x89,0xAD,0x61,0xAA,0xA4,0x99,0x16,0x7D,0x1F,0x8C,0x33,0x97,0xCA,0xE6,0x5D,
+	0x54,0x51,0x1D,0xB8,0xCF,0x7F,0xCD,0x79,0x14,0xF8,0x06,0x6E,0x99,0xB0,0xAF,0x8C,0x48,0x18,0xC8,0x0D,
+	0x24,0x63,0x76,0xBF,0xD4,0x16,0x9E,0x7E,0x98,0xB1,0x98,0x2C,0x4B,0x39,0x8D,0x5C,0x31,0x62,0xC7,0xD4,
+	0xA3,0xC7,0x85,0x6F,0x19,0xB2,0x97,0x8A,0x56,0x59,0xF2,0xDB,0xBA,0xD3,0x29,0xA4,0x2D,0xBF,0x87,0x7F,
+	0x3B,0x73,0xDB,0x3B,0x34,0x54,0x38,0xCB,0x12,0x58,0xC4,0x4C,0x6D,0xAA,0x9E,0xDC,0x09,0x49,0x76,0x2C,
+	0xCB,0xD6,0xC5,0x04,0xA0,0xB1,0x1E,0xB8,0x39,0x71,0x76,0xA5,0x1A,0x2D,0x6C,0x07,0xE6,0x20,0x1E,0xB0,
+	0xF3,0x77,0x79,0x6C,0x09,0xB3,0xF8,0x2B,0x89,0x4B,0xD0,0x18,0x49,0x1E,0x28,0x69,0xE7,0xDD,0x29,0x6D,
+	0xA8,0x7D,0xF5,0x55,0x1C,0x2F,0xB8,0x8A,0x48,0x1D,0xCF,0x79,0xE6,0xBF,0xB5,0xE2,0xE7,0x0B,0x18,0x84,
+	0x36,0x50,0xA1,0xA6,0x19,0xB3,0xD0,0x66,0xBA,0x6B,0x12,0xF4,0x8D,0x4D,0x28,0x94,0x10,0x6B,0xB7,0xEF,
+	0x26,0xA1,0x47,0xB2,0x7E,0xFB,0x06,0x32,0xB0,0x9D,0xD9,0xC1,0x94,0xEE,0x6B,0x22,0x67,0x80,0xB5,0xC5,
+	0x35,0x5D,0x17,0x3F,0x83,0x7B,0xF3,0x12,0x36,0xA5,0x41,0x31,0x8B,0x81,0x11,0xB6,0xF1,0x4E,0xC7,0xE7,
+	0xE7,0xBB,0xB9,0xCD,0xB3,0x7B,0x17,0x04,0xFD,0xCF,0xCF,0x57,0xF7,0x1B,0xA8,0x4B,0xC6,0x9E,0xEE,0x29,
+	0x57,0x1A,0x87,0xFA,0xE2,0x1A,0x6F,0x4B,0xBC,0xA1,0x18,0xB9,0x7D,0x59,0x5C,0x80,0x40,0xAC,0xFD,0x8B,
+	0x6E,0x8B,0xCA,0xC2,0x21,0x4B,0xEF,0xD7,0xD3,0xC8,0xC9,0x47,0xCB,0x50,0xE6,0x93,0xB9,0x1A,0xC7,0x4B,
+	0xA1,0x48,0x07,0x68,0xFB,0xED,0x2A,0xC2,0xBF,0xAE,0xBD,0xF7,0xED,0x67,0xB7,0xCE,0x50,0xAA,0xEA,0x47,
+	0xC3,0x84,0xD2,0x39,0x7E,0x56,0x53,0x15,0x71,0x7C,0x80,0x78,0x59,0xA8,0x1B,0xF4,0x65,0xDB,0x2B,0x6F,
+	0xFF,0x51,0xA6,0xC4,0xCA,0x80,0x64,0xCD,0xDA,0x12,0x55,0x23,0x21,0x86,0xD3,0x9D,0x98,0xC1,0xAC,0x01,
+	0xB9,0x3E,0x1C,0x07,0x05,0x5A,0xCB,0x34,0x9B,0xF0,0xE0,0x81,0xE7,0xA5,0xB2,0xA2,0xC2,0x63,0x56,0x0C,
+	0xFA,0x01,0x70,0x34,0xAC,0xE8,0xE2,0x56,0xFE,0xB6,0x42,0x95,0xB2,0x6C,0x3E,0x91,0xA6,0x4C,0xDC,0x04,
+	0x88,0x44,0xE5,0x88,0x5C,0x2E,0xD7,0x09,0x79,0xAB,0x37,0x81,0x72,0xE3,0xD6,0xB9,0x64,0xEC,0x5A,0xB9,
+	0x8F,0x12,0x43,0x4B,0xF9,0x60,0xC3,0x80,0x2E,0xAD,0xB7,0x85,0x22,0x68,0x80,0xE4,0x75,0x90,0x0C,0x10,
+	0x68,0xB0,0x18,0x22,0x33,0xC5,0x98,0xE1,0x5D,0x9E,0x94,0xC6,0xB5,0xBE,0x34,0xB6,0xCD,0xA6,0xEA,0x49,
+	0x1E,0xB2,0xEB,0xF0,0xD4,0x9D,0xDD,0x05,0xB1,0xB6,0xD9,0xA1,0xEC,0xBE,0xF7,0x54,0x92,0x59,0x13,0xBE,
+	0x86,0x1E,0xF4,0x06,0x10,0x3A,0x95,0xA6,0x60,0xB3,0x42,0xC5,0x1E,0x02,0xD3,0x62,0x20,0x5F,0xBE,0xD2,
+	0x91,0xF5,0x3D,0x02,0x65,0x84,0x34,0xAA,0xFA,0xFE,0xC0,0x41,0x4D,0x9F,0x52,0xD3,0x92,0x35,0xD3,0x99,
+	0xBA,0x97,0x50,0x64,0x7B,0xFF,0xC0,0xBD,0x4D,0xF5,0xBC,0xE9,0x13,0xB7,0xAA,0x73,0x66,0xB6,0xB4,0x0F,
+	0x68,0x3B,0xEF,0xC0,0x89,0x34,0x15,0x3F,0x03,0xFA,0x22,0x0B,0x15,0x28,0x79,0xE3,0x77,0x47,0x7C,0x53,
+	0x44,0xC9,0xA2,0x6E,0x06,0xBE,0x6F,0x92,0xC9,0xD1,0x88,0x93,0xF1,0x5E,0x09,0xAB,0x19,0x86,0x1A,0xFC,
+	0xC2,0xBF,0xBD,0x3B,0xEF,0x25,0xE3,0x3A,0x3A,0x70,0x5E,0xED,0x57,0x11,0xAF,0xCD,0x1D,0x65,0xB7,0x88,
+	0x52,0xD9,0xE3,0xEF,0xF8,0xD6,0x10,0x7D,0xCE,0x5B,0xA7,0x28,0x5C,0xB4,0x47,0xD9,0x0F,0xBB,0x87,0x41,
+	0x51,0xF6,0x40,0x6A,0x08,0x3C,0x19,0x09,0xFC,0xFC,0xF0,0x98,0x95,0xC7,0x36,0xA2,0xED,0x90,0x16,0x5E,
+	0x68,0xBB,0xCE,0x38,0x1B,0x16,0x0D,0x04,0x3B,0x66,0xB6,0xFB,0x79,0xA5,0xF0,0xDA,0x8C,0xBB,0xEF,0xDF,
+	0x43,0x36,0x42,0x0D,0x6E,0x8D,0xC9,0x1F,0x3C,0xDE,0x57,0x24,0x46,0x3C,0x7C,0x6D,0xD4,0x4E,0x79,0x13,
+	0x35,0x92,0x44,0xFB,0xB3,0x86,0xA8,0x3C,0xE9,0x90,0x00,0xE6,0x7B,0x31,0xA8,0xE7,0x82,0xC9,0x14,0x5B,
+	0x73,0x80,0xB0,0x70,0x50,0x02,0x98,0x76,0x15,0x81,0x7B,0xD6,0x72,0xD5,0x92,0x30,0xF2,0xBC,0x59,0xD5,
+	0xB3,0xA0,0x00,0x81,0x89,0x74,0x19,0x3D,0x65,0xC3,0xF1,0x64,0x6B,0x6F,0x09,0x58,0xA1,0xD2,0x9C,0x6A,
+	0x50,0x41,0x43,0x30,0x66,0x58,0xE3,0x55,0x9D,0x65,0x16,0x80,0x46,0xD0,0xFA,0xF4,0xA6,0x8B,0x70,0x93,
+	0xE1,0x56,0xA9,0x0A,0x33,0x60,0x98,0x59,0xB9,0x55,0x0C,0x84,0x6D,0xDA,0x20,0x54,0x70,0x2E,0x4C,0xE0,
+	0xD4,0xA4,0x17,0x5E,0xE4,0x32,0x65,0x61,0x6F,0x44,0xE9,0x11,0x42,0xE0,0xB0,0x25,0x9E,0x65,0xBB,0x96,
+	0x6A,0x84,0x65,0xBD,0x56,0x6A,0xE1,0x8F,0xD3,0x0A,0xF9,0xF1,0x2E,0x0B,0x88,0xCE,0x7C,0x4A,0xC8,0x19,
+	0x38,0x25,0x16,0x4E,0x08,0x07,0x9E,0xD7,0xF9,0xE0,0xD1,0x1B,0x76,0x05,0x9B,0x73,0x9B,0x01,0x9E,0x98,
+	0x13,0x6B,0x65,0x18,0x26,0xE0,0x9E,0x76,0x0F,0x2A,0x03,0x1C,0xAC,0x84,0xD3,0xD4,0x9C,0x40,0x13,0xCF,
+	0x2D,0x9B,0xD2,0xB6,0xB6,0x09,0xF6,0x7F,0xDA,0x94,0x21,0xD1,0xC1,0x04,0x5B,0xC5,0x11,0x6D,0x20,0x68,
+	0xE3,0x6F,0x25,0x68,0x6D,0x5B,0xAD,0x2F,0xA3,0x96,0x16,0x93,0xD5,0x11,0x74,0xEC,0xC9,0x0C,0x13,0x55,
+	0xFA,0x92,0xB9,0x86,0x6F,0x2E,0x43,0xF6,0x5A,0x2D,0x21,0x48,0x89,0x74,0x1C,0xCD,0xA5,0x30,0xB4,0x96,
+	0x23,0xF4,0x34,0x9D,0x5A,0x71,0x75,0xE8,0x49,0x2F,0x5B,0x2F,0xA8,0x43,0xA0,0x89,0xC9,0xBE,0x33,0x50,
+	0x5C,0x0E,0xC4,0xC0,0xDF,0x0B,0xD4,0xE6,0x34,0x90,0xAC,0x67,0xAA,0x41,0x46,0xD6,0xCB,0xFB,0x32,0xBC,
+	0xFF,0x9A,0xEC,0xD5,0x8A,0x3C,0x1A,0x4D,0x69,0x13,0xBD,0xD6,0x50,0xC2,0x64,0xE7,0x5F,0x7C,0x96,0x56,
+	0x80,0x4F,0x1D,0xA9,0xC0,0x80,0xAF,0x8C,0xF6,0x41,0x2D,0x7B,0xC8,0x22,0xC7,0x6B,0x12,0x35,0x47,0x1D,
+	0xC1,0xE3,0x5D,0x19,0xFD,0x7E,0x52,0x74,0xD9,0xB9,0x50,0x82,0x56,0x78,0xEF,0x90,0xE2,0x42,0x54,0xE6,
+	0x0A,0x6F,0x73,0x4F,0xD2,0xC3,0xD6,0x4C,0x35,0x2C,0x13,0x16,0x73,0xF8,0x5C,0x34,0x4B,0xBE,0x13,0x79,
+	0x51,0x78,0xD3,0x83,0x8E,0x74,0xC5,0x09,0x63,0xFB,0x30,0x93,0x7F,0xF0,0x45,0xC8,0x6B,0x14,0xCD,0x51,
+	0xB0,0x37,0x96,0x17,0xC7,0xFA,0x5D,0xF7,0x9B,0x6C,0x67,0xC8,0x68,0x56,0x8A,0x77,0x99,0xB2,0x14,0xDA,
+	0x5B,0x78,0xCE,0x19,0x1B,0xF9,0x51,0x3E,0xA9,0xDC,0xB0,0xB5,0x7A,0x26,0x0B,0x4B,0x5D,0xF6,0xA6,0x5C,
+	0x0D,0xC5,0x40,0x8B,0xE0,0x58,0x7C,0x6F,0xC7,0xC5,0xEF,0x8D,0x09,0xF5,0x82,0x29,0xC2,0x00,0x51,0xB1,
+	0x99,0x00,0x97,0x9C,0xE5,0x96,0x8A,0x4A,0x99,0x5D,0xA2,0xE6,0x05,0x8A,0x93,0xE7,0x00,0xA9,0xF8,0x38,
+	0xB7,0xBA,0xCC,0x19,0xC9,0x1C,0xB1,0x9A,0x85,0x10,0xD9,0xDA,0x37,0xB9,0x58,0xD5,0x1B,0x0C,0xB6,0xDD,
+	0xEC,0x6C,0x57,0xFF,0x78,0x6F,0x15,0xF3,0x84,0xEB,0x43,0x0D,0xEA,0x3D,0x65,0xD7,0x49,0x1F,0x17,0xA0,
+	0x90,0x3C,0xD8,0x74,0x17,0x5C,0x4D,0xFD,0xFF,0x5F,0x65,0x11,0x75,0x90,0x1F,0xB0,0xBF,0x3D,0x06,0x6A,
+	0x09,0x24,0xD8,0x64,0x55,0x80,0x69,0xAC,0xA1,0x7F,0x38,0xB3,0xF5,0x1F,0x73,0x1D,0x03,0xF8,0x90,0xC6,
+	0xEE,0xAE,0x71,0x40,0xBA,0xC5,0x1F,0x0A,0x53,0xB8,0x3C,0x53,0xFF,0x94,0xD9,0x85,0x9D,0x1D,0xEE,0x22,
+	0xC2,0xE9,0x9B,0xF7,0x88,0xA3,0xB5,0xEF,0x3B,0x78,0x91,0x47,0x9D,0xAC,0xFA,0xB1,0x45,0x69,0x53,0xB5,
+	0x69,0xE1,0x28,0x83,0x6D,0x8B,0x18,0x4E,0xB1,0xE5,0x0E,0x64,0x25,0xB1,0x30,0x2B,0x6A,0xEC,0xDD,0x6E,
+	0x01,0xB6,0x53,0x18,0x33,0xC9,0xD4,0x01,0x10,0x63,0xA8,0x5E,0x37,0xFE,0xE1,0x30,0xA4,0x80,0x4C,0x38,
+	0x0B,0xFA,0xA2,0x90,0x4A,0x87,0x7C,0x47,0xEE,0x7E,0x31,0x62,0xE5,0x78,0xD7,0xA6,0x55,0x07,0xB4,0x83,
+	0x47,0xD8,0x9E,0x01,0xBC,0xE8,0x62,0x8E,0x5D,0x86,0xFC,0x26,0x08,0xEA,0x0A,0xFA,0x10,0x63,0x8A,0xDD,
+	0x20,0x8D,0xBE,0xBA,0x3F,0xFB,0x2A,0x0F,0x21,0x54,0x2B,0xD2,0x07,0x84,0x45,0xCD,0x73,0x46,0xE3,0xF6,
+	0xD8,0x80,0xAE,0x81,0xBE,0xA7,0x4B,0x27,0x2C,0x65,0x8B,0xDC,0xFE,0x61,0xF4,0x32,0xF6,0xFA,0x81,0x9A,
+	0xDE,0x4B,0x63,0xBB,0xFE,0xEB,0xE9,0xCC,0xB7,0x44,0x5C,0xEF,0x78,0x53,0xDC,0xBE,0xDC,0xAC,0x6C,0xB3,
+	0xDC,0x8D,0x76,0x5C,0xD3,0x8E,0xFD,0xDE,0x35,0x16,0xB3,0x10,0xBA,0x1B,0x01,0x3D,0xB2,0x7B,0x42,0xE1,
+	0x3C,0xE9,0x3D,0xA9,0x8A,0x23,0x73,0xCA,0x65,0xC2,0x0C,0x19,0x0C,0xCE,0x0C,0xA8,0xED,0xB2,0x53,0xA1,
+	0x23,0x82,0xB1,0x5D,0xBB,0xE3,0x40,0x0B,0x4F,0xD0,0x3B,0x33,0x57,0xE7,0x62,0xE4,0x07,0x30,0x31,0x56,
+	0x87,0xB9,0xBC,0xE7,0xC5,0x5A,0x74,0x7F,0xC1,0x9C,0x3D,0xE1,0x75,0x35,0x3D,0x46,0x86,0xB8,0xC5,0xD0,
+	0x26,0x6E,0xDA,0x13,0x76,0x31,0x7C,0xA6,0x01,0x3D,0x25,0x9A,0xE8,0x1F,0xCE,0x41,0x66,0xFA,0x0A,0x34,
+	0x96,0x2F,0x3C,0x71,0x45,0x6C,0xAE,0xE5,0x42,0x1E,0x45,0x31,0xEC,0xEC,0x1E,0x12,0x29,0x70,0x53,0x76,
+	0xD6,0x37,0x24,0x93,0x09,0xDA,0xE4,0x9C,0xC1,0xC4,0x7D,0xE1,0x75,0xF6,0xA4,0x22,0x47,0x34,0xD2,0x26,
+	0xF5,0xB5,0xC7,0x14,0x77,0x28,0xF8,0xB6,0x6F,0xB7,0xD2,0x63,0xA0,0xFF,0xDB,0x36,0x74,0x96,0xCA,0x05,
+	0xD5,0xC1,0x59,0x94,0x95,0x70,0xFE,0x57,0x9D,0xED,0xA5,0xD3,0x9E,0x38,0x85,0xD7,0x06,0x76,0x74,0x3D,
+	0x77,0x77,0x7F,0x9F,0x8B,0x83,0xB5,0x5E,0x8F,0xB1,0x0E,0xFA,0x68,0xD7,0x93,0x0F,0xA5,0xC5,0x14,0x69,
+	0x7D,0x82,0x2A,0x63,0xC2,0xF8,0x74,0x41,0xCE,0xDF,0xF1,0xD0,0xF0,0x04,0xA6,0xED,0xD0,0xD5,0x21,0x73,
+	0xB0,0xBE,0x57,0xEA,0x1B,0xD7,0x98,0x90,0xDE,0xB8,0x0C,0x7D,0x9E,0xCB,0x10,0xEF,0xB9,0xB2,0x33,0x40,
+	0x4C,0x53,0xD9,0x0B,0x08,0x5D,0x3C,0xCB,0x8D,0xDD,0xBF,0x55,0xDB,0x43,0x28,0x19,0x05,0x57,0xAF,0x61,
+	0x19,0xDC,0x95,0x32,0x4C,0xF1,0x17,0xD6,0x9A,0xC2,0x24,0xDE,0x07,0xD0,0xFA,0xBE,0x37,0xE6,0x98,0xB9,
+	0x6C,0x9E,0x98,0x27,0x27,0xF3,0x73,0x5A,0x8D,0x71,0x5B,0x9C,0x9D,0x78,0xD7,0x44,0x5A,0x16,0x03,0x44,
+	0xDC,0xBB,0x6D,0x41,0x04,0x9B,0x1A,0x89,0xDE,0xBF,0xE8,0x31,0x06,0x78,0xE6,0xBD,0xFB,0x93,0x30,0xAF,
+	0xE1,0xCA,0xE8,0x03,0xB9,0x68,0xD3,0x4E,0x7E,0x44,0x80,0x67,0x6F,0xA8,0x3C,0xD2,0xA0,0xBE,0x2B,0xD6,
+	0x39,0xF2,0xC1,0x05,0xE3,0x7B,0x6D,0x76,0xE6,0x84,0x96,0x31,0x42,0x8E,0xE9,0xA1,0xEA,0x01,0xD4,0x09,
+	0x60,0xBC,0xA9,0xFF,0x78,0x90,0xA6,0xC9,0xC1,0x38,0xE7,0x8D,0x24,0xC0,0xD3,0x4D,0x82,0x18,0xA0,0x0E,
+	0xAB,0x98,0xEA,0x40,0xA3,0x84,0x70,0x16,0x30,0x18,0x5B,0xD2,0xCA,0x49,0x91,0x8D,0x70,0x66,0x5A,0x92,
+	0xA2,0x43,0x49,0x45,0xF2,0xE4,0x7B,0xBE,0x75,0x7D,0xB9,0x62,0x6B,0x29,0x31,0x2A,0xCB,0xCD,0xAF,0x62,
+	0xF6,0xCB,0x13,0xAE,0x20,0x62,0x31,0x2A,0xD2,0xA7,0x74,0x35,0x60,0x5C,0xB7,0x86,0x57,0xEA,0xC2,0xF4,
+	0xE1,0x44,0x98,0x0E,0x8A,0x20,0x16,0x18,0xC6,0x77,0x47,0xDF,0x66,0xC8,0x5C,0x6A,0x3A,0xDF,0xAC,0xA0,
+	0x18,0x45,0xDA,0x20,0x78,0xE6,0xA0,0xD4,0x31,0x26,0xD5,0x4F,0xEE,0x46,0x01,0x1E,0xE2,0xD9,0x28,0x99,
+	0x48,0x15,0x9F,0x2E,0x17,0x2B,0xF3,0x9D,0xFE,0xEB,0xB5,0x5D,0x53,0x51,0x88,0xE9,0x85,0x42,0xCB,0x25,
+	0x89,0x6D,0xAF,0xB2,0x71,0x7D,0x9B,0x47,0xFD,0x6D,0x77,0x1E,0x68,0xC1,0x80,0x26,0xB1,0x08,0x0C,0x2A,
+	0xB4,0x16,0x17,0x50,0xFA,0x92,0x10,0x07,0xAC,0x49,0xE2,0x4C,0xE2,0xC2,0x13,0x51,0x8E,0xB5,0x18,0x13,
+	0xE5,0x94,0xD9,0x39,0x8A,0x81,0x43,0x1E,0xEE,0xCF,0x8E,0x3F,0x78,0x72,0x0B,0xA1,0x72,0x6E,0x88,0x06,
+	0x29,0x6F,0x7B,0x0F,0xB9,0x73,0x3C,0xD2,0x63,0xE0,0x20,0xE6,0xC3,0x55,0x26,0x90,0x93,0xFF,0x13,0xF4,
+	0xAC,0x53,0x55,0x0B,0x86,0x17,0xB7,0x28,0xDA,0x82,0x64,0x8F,0xE5,0xFE,0xBF,0x88,0x90,0x0E,0x5B,0x63,
+	0xB4,0x97,0xBD,0xB8,0x5B,0xE1,0xB5,0x51,0x1E,0xF1,0x36,0x05,0x28,0x83,0x2D,0x0B,0x00,0x08,0x61,0xE6,
+	0xC7,0x95,0xC4,0xAE,0xDE,0x12,0x20,0xF2,0x3B,0x23,0x64,0x44,0x97,0x78,0xBA,0xC3,0x16,0x99,0x2C,0xC7,
+	0x9F,0x5B,0x7B,0x0E,0x56,0xFF,0x67,0xAE,0xF2,0xC5,0xFE,0xE4,0x04,0x9A,0xF0,0x62,0x94,0x5F,0x7C,0x86,
+	0x11,0x09,0x27,0xEC,0xA1,0x14,0x50,0x34,0x11,0xE6,0x35,0xAA,0xE7,0x5B,0x57,0xD4,0xCE,0xD9,0x17,0x1B,
+	0xD3,0xB8,0x6D,0xA7,0xD1,0x6B,0xDE,0x93,0xA3,0x58,0xA3,0xF2,0xD7,0xDC,0xE1,0x6E,0x8D,0xE7,0x9D,0x7C,
+	0xB8,0x91,0xB5,0x05,0xB4,0xCB,0xDE,0x08,0x91,0x5B,0xB1,0xC8,0x08,0x56,0xD7,0x44,0xB9,0x6B,0x12,0xFF,
+	0xA3,0xF0,0x9C,0x52,0x1A,0x59,0x4D,0x6B,0x8B,0x9A,0xD0,0x07,0xB9,0xBA,0x2D,0x5A,0xE1,0xF7,0xDD,0xAC,
+	0x07,0x87,0x6F,0x9B,0x3F,0x16,0x23,0xEF,0x73,0xA2,0x17,0xBD,0x41,0xBD,0x0A,0x39,0xC2,0x46,0xE6,0xBA,
+	0x48,0xB0,0x56,0x5D,0x06,0x88,0x76,0xE1,0x59,0x68,0xAE,0xF0,0x9A,0xFD,0xCB,0xDA,0xAA,0x5C,0x5B,0x2D,
+	0x98,0x7D,0x54,0x68,0x8C,0x46,0x8C,0xB7,0x83,0x39,0x39,0xCE,0x1F,0x11,0x67,0xD7,0x36,0x93,0xED,0xC9,
+	0x0B,0x3E,0x6C,0x1E,0x7E,0xF3,0x16,0xCE,0x4E,0xE0,0x4F,0xC0,0x61,0xB4,0x7A,0x8F,0x14,0x5C,0x4F,0xEE,
+	0xD1,0x3B,0x40,0x00,0x51,0x8D,0xFA,0x04,0xA7,0x09,0xB6,0x51,0x30,0x4F,0x1E,0x74,0xF5,0x8C,0x79,0x16,
+	0x8D,0x7D,0x68,0xBE,0xB7,0x7E,0xF8,0xFA,0x7F,0x6C,0xE2,0x37,0xF2,0xE2,0xE5,0x85,0xB6,0x83,0x76,0x8D,
+	0x97,0x88,0x29,0x27,0x43,0x01,0xD3,0xB6,0xD5,0x82,0x49,0x11,0x17,0x8E,0x97,0xAF,0xE9,0x0C,0xAA,0xD1,
+	0x99,0x34,0xF9,0xE3,0xD3,0x58,0xCC,0xD8,0x05,0x67,0xDE,0x6B,0x7D,0xAB,0x24,0x8A,0x1D,0x89,0x8E,0x61,
+	0x72,0x6F,0xC8,0x20,0x65,0x69,0x96,0x50,0xF6,0x26,0x16,0x10,0xB8,0xA0,0x47,0x90,0x34,0x5F,0x3B,0x11,
+	0xBA,0x29,0x62,0x75,0xF6,0x7B,0x69,0x5B,0x44,0xDA,0xBE,0x56,0xEA,0xF9,0x17,0x54,0x26,0xD8,0xC4,0xA4,
+	0x1B,0x0A,0x41,0xF1,0x5E,0xA4,0xEF,0x5A,0x64,0xAA,0x7B,0x85,0xAB,0xED,0x02,0x7D,0x22,0x7B,0x30,0xE4,
+	0x6C,0x0B,0x8C,0x51,0x34,0xE5,0x4A,0x18,0xC3,0x84,0x1E,0x7C,0xE2,0x0D,0xC2,0xAB,0x24,0x64,0xC4,0x38,
+	0xBC,0x6A,0x1B,0xE3,0x1E,0xC5,0xDD,0x08,0x3D,0x75,0x31,0x59,0xFF,0xFC,0xA5,0x4D,0xBC,0xE7,0x61,0x06,
+	0x9D,0xC4,0xF8,0x19,0x55,0xD8,0x25,0x28,0xA8,0xC4,0x75,0xCC,0x51,0xA9,0xCE,0xD1,0x0D,0x5C,0xB4,0xBF,
+	0xBD,0xEC,0xDD,0x88,0xE2,0x31,0x62,0x11,0x36,0xE1,0x30,0x1C,0x7F,0x22,0x62,0x6F,0x2B,0x02,0x42,0x85,
+	0xE3,0xC0,0x81,0x76,0xFA,0x52,0x48,0x34,0x5F,0x7E,0x63,0x52,0x44,0x25,0x0B,0xE9,0x5F,0xF3,0xE1,0x30,
+	0x6D,0xA3,0xCB,0x29,0xED,0x23,0x4B,0x2D,0xFD,0xD3,0x1B,0x30,0xA5,0x33,0x40,0x4E,0x7E,0x6E,0x0E,0x52,
+	0x78,0x10,0x5B,0xF4,0xF6,0xB0,0x0A,0xD6,0x9F,0x4B,0x0D,0x44,0x9D,0xA0,0x4C,0x90,0xB3,0x9C,0x4B,0xE8,
+	0x54,0xB5,0xB2,0x0B,0x0E,0xC9,0xE1,0xDD,0xC0,0xFE,0x45,0xD5,0xD3,0x9D,0x5E,0xC0,0x5D,0x61,0x35,0x4E,
+	0x9A,0x79,0x20,0x97,0xFC,0xB0,0x67,0x8E,0xE5,0x95,0xD4,0xE4,0xCF,0x3A,0xBD,0x8C,0x97,0x06,0x0A,0x16,
+	0x01,0xF0,0x3C,0x6F,0x15,0xCE,0xA4,0xF7,0x02,0x1B,0xCA,0x5B,0xE4,0xE8,0xD2,0x46,0xFA,0xB5,0x4C,0xF0,
+	0x86,0x4A,0x92,0xD1,0x13,0x18,0x3E,0x10,0xE5,0xE9,0x7D,0xB6,0x7B,0xF6,0xDD,0x23,0xC0,0x90,0x45,0xB5,
+	0xD4,0xCA,0x79,0x81,0xC7,0x47,0xCB,0xEE,0x7B,0x50,0x0D,0x98,0xA2,0x9A,0x78,0xE6,0x16,0x36,0xA9,0x91,
+	0x1C,0xB2,0x7B,0xEF,0xF1,0x8C,0x8C,0x77,0x8F,0x9E,0x86,0x04,0x3F,0x18,0xE3,0x2E,0x49,0x7C,0x81,0x93,
+	0x8C,0x29,0x64,0x87,0x6D,0x9F,0x56,0xED,0x34,0xFB,0xAE,0xFD,0x8C,0x7F,0x46,0xA1,0x57,0x2D,0x07,0x04,
+	0x0D,0x16,0xFE,0x4B,0x19,0x3A,0x09,0x12,0xCE,0x37,0xEE,0xAE,0xFA,0x2A,0x85,0x99,0x0E,0x9D,0xFE,0xE3,
+	0x54,0x48,0xEC,0x48,0x9B,0x56,0xEF,0xA4,0x81,0x6F,0x19,0x8D,0xF8,0x96,0x27,0x3D,0xBA,0x31,0x4E,0x68,
+	0xFF,0x72,0x94,0x6A,0x09,0xC0,0x56,0x24,0xD6,0x4B,0x7E,0xAD,0x03,0x1C,0x06,0x78,0xF6,0x7E,0x25,0xCA,
+	0x5F,0x1D,0x21,0x49,0x2E,0x68,0xB5,0x80,0x55,0xDA,0x58,0x09,0x42,0x63,0x37,0x86,0x0F,0xBC,0x67,0xC3,
+	0x9C,0xAB,0xD7,0xEF,0xCB,0x10,0x47,0x00,0x43,0xD2,0x7F,0xEE,0xE7,0xBE,0x3A,0xF3,0x22,0xAF,0x11,0x36,
+	0x70,0x2C,0x58,0x35,0xA9,0x03,0xC0,0x4B,0x73,0x01,0x09,0xF6,0x76,0x54,0xDA,0x17,0x17,0xE3,0xE0,0x43,
+	0x3D,0xE0,0x58,0x9D,0x28,0x7A,0x55,0xE9,0x19,0x4D,0xFF,0x03,0x79,0x2D,0xE9,0x29,0x29,0x21,0xCF,0xC7,
+	0xD4,0x9F,0xD6,0xAB,0xBE,0x89,0xB1,0xD2,0x4F,0xBE,0x4D,0xC2,0xEB,0xCE,0x1F,0x6B,0x5C,0x01,0x84,0x8A,
+	0xF1,0xFB,0x10,0x84,0x72,0x66,0x70,0xA5,0xE3,0xB5,0x10,0x89,0x73,0x9F,0xF2,0x44,0xDE,0x8D,0xC9,0x32,
+	0xAC,0x49,0x01,0x12,0xBC,0x43,0x50,0x9B,0x60,0x32,0x11,0x7D,0xDE,0x07,0x4E,0xE6,0x37,0x79,0x2F,0xAC,
+	0x40,0x42,0x91,0x99,0x6E,0x24,0x41,0x0E,0x03,0x57,0xAE,0x3B,0x41,0x2D,0x79,0xA1,0x62,0xB6,0x62,0x93,
+	0xC3,0x9A,0xFB,0xF3,0x0E,0x83,0x61,0xCC,0x1C,0x88,0x44,0x88,0xA3,0x4B,0x39,0xA9,0xCB,0x57,0x74,0x5D,
+	0x19,0x44,0x71,0x98,0x12,0x70,0xC1,0x16,0x36,0xDE,0x5A,0x95,0xB5,0x64,0x9E,0xE1,0x59,0x47,0x16,0x7E,
+	0xF1,0xAB,0x15,0x15,0x48,0x9C,0xEE,0xDD,0x27,0xDB,0x75,0x49,0xB6,0x16,0x4B,0x8C,0x3C,0x69,0x2C,0x48,
+	0xBA,0x4B,0xE0,0xCD,0x8F,0xDA,0xED,0x18,0x4A,0xF0,0x06,0xC8,0x47,0x0B,0x2C,0x10,0xC8,0x48,0x2A,0xEE,
+	0x9F,0x72,0xBD,0x07,0xDE,0x70,0x32,0x23,0x73,0x20,0x22,0x1A,0x0A,0x0D,0x92,0xDD,0xFA,0xED,0x63,0x59,
+	0x57,0x84,0xF8,0xAB,0x8A,0x93,0xC0,0x0B,0x8B,0x6E,0xEB,0x2A,0x18,0x6C,0xE0,0x26,0x1A,0xD2,0xD9,0x02,
+	0x28,0x72,0x7B,0xED,0x4E,0xBF,0xA3,0x5A,0x7A,0x70,0x3C,0x7F,0xC9,0x13,0x82,0xBC,0x78,0x61,0x15,0xDF,
+	0xC7,0x11,0xEF,0x54,0x40,0xC1,0x35,0x6F,0xD4,0x92,0x9A,0xF6,0x59,0x3C,0x01,0x90,0x4D,0x11,0xB1,0x47,
+	0xFD,0x7C,0xD1,0x7F,0x5D,0x93,0x81,0x4B,0x59,0xFB,0x05,0x91,0xE4,0x73,0xEB,0xA3,0x11,0xF1,0x7F,0x6F,
+	0x48,0xE2,0xD3,0x77,0xF9,0xB7,0x09,0xD8,0xC3,0x92,0x64,0xF3,0x85,0xEE,0x8C,0x91,0x4A,0x19,0xD6,0x07,
+	0x81,0x79,0x26,0xE8,0x20,0x52,0x81,0x1F,0x83,0x67,0x85,0x91,0x34,0x3D,0xF2,0x70,0x5B,0x38,0x24,0x82,
+	0xE1,0x51,0x5C,0xE9,0x52,0x73,0x99,0x80,0xED,0x3E,0x3E,0xCD,0x17,0xC9,0x75,0xA1,0x81,0xA9,0xAE,0x67,
+	0x37,0x48,0x02,0x90,0xCE,0x3F,0xDF,0x17,0x00,0x7A,0xD7,0x13,0x61,0x5D,0x77,0x3E,0x52,0xE8,0xFB,0x64,
+	0x28,0xA3,0x79,0xFF,0x04,0x54,0x96,0x89,0x51,0xD5,0x84,0xA9,0x87,0x45,0xDD,0x7A,0xC0,0xC8,0x9D,0xDB,
+	0xE7,0x31,0x60,0x94,0x80,0x08,0x27,0x8C,0x75,0xA6,0x2F,0x71,0x5E,0x58,0x60,0x4D,0xFC,0x97,0x69,0x84,
+	0x03,0xCB,0x7B,0x32,0xF9,0x4A,0xCF,0xD5,0x1E,0xC6,0x0D,0x1F,0x28,0x84,0xB3,0x2A,0x8C,0x51,0xA4,0x7A,
+	0x2F,0x71,0xDF,0x89,0x4D,0x34,0x51,0x33,0x28,0x71,0xB0,0x18,0x7A,0x53,0x62,0x8E,0x81,0x19,0x49,0xFC,
+	0xAE,0xAD,0xD8,0xBE,0x5B,0xB3,0x7D,0x58,0xB3,0x7E,0x21,0x14,0x3B,0x3F,0xA4,0x88,0x58,0x50,0x14,0x33,
+	0x53,0x7D,0x97,0x98,0xAF,0x1F,0xEF,0x13,0x56,0x73,0xDF,0xAB,0x54,0x5D,0xB6,0xBB,0xC7,0xC0,0xFA,0x5D,
+	0xD8,0xA3,0x5C,0x1B,0xC8,0xE8,0xF9,0xB0,0x7F,0x82,0x66,0x07,0xE1,0xAC,0xF0,0xC6,0xCB,0x34,0xCE,0x20,
+	0xB5,0x63,0xF3,0xA0,0x03,0xF8,0x96,0x67,0x57,0xE3,0x6E,0x28,0x27,0x14,0xE8,0xB2,0x63,0x32,0x7A,0x2C,
+	0xFB,0x9F,0x99,0x78,0x15,0xAF,0xE7,0x3D,0xA2,0x76,0x9C,0x25,0xF0,0x4F,0xB5,0x60,0xE0,0x02,0xE5,0x7B,
+	0xE3,0xE1,0x20,0x0C,0xFC,0x81,0x79,0x9E,0xF6,0xF8,0x49,0x4A,0x86,0xC4,0x18,0x4E,0xAB,0xEB,0x10,0x60,
+	0x49,0xC9,0x44,0x04,0xED,0x81,0x97,0xA2,0x69,0x34,0xC8,0x18,0xFE,0xE6,0x06,0x0A,0xC5,0xC1,0x05,0x1C,
+	0xD6,0xE8,0xCD,0xE6,0x15,0x19,0x62,0x45,0x51,0x56,0x0F,0xAE,0x6A,0xCB,0xC9,0x89,0x7A,0xEB,0xA9,0xFA,
+	0x55,0x7A,0x45,0xD2,0xD5,0x08,0xEA,0x11,0x84,0x18,0xA0,0xD9,0x72,0x38,0xD9,0xF9,0x70,0x05,0x60,0x6C,
+	0xE7,0xA6,0xBF,0x1A,0xAD,0xF7,0x34,0x70,0xD1,0x8A,0x86,0x89,0x64,0x83,0x51,0xD9,0xE4,0x5F,0xE8,0xBE,
+	0x19,0x31,0xC7,0xCE,0x45,0x58,0x5D,0x37,0x65,0x5B,0x9B,0xF0,0x1F,0xA7,0x4A,0x14,0xA2,0x1F,0x18,0xAA,
+	0x4F,0xD5,0xE6,0x68,0xA7,0x2A,0x90,0x81,0x9E,0xEB,0x62,0x68,0x38,0x84,0x7B,0x96,0x7B,0xE6,0x1A,0x6C,
+	0x7A,0xCD,0x32,0xAE,0x06,0xB7,0x0A,0x08,0x0D,0x73,0xF3,0x08,0xA1,0x61,0x18,0x53,0x0F,0x85,0x52,0xA1,
+	0x9F,0x5C,0x5A,0x47,0xEC,0x8C,0x83,0x11,0x23,0x12,0x03,0x49,0x8F,0x83,0x8F,0x29,0x69,0xBE,0x0B,0x09,
+	0x2D,0xC8,0x88,0x94,0x5D,0xE3,0xEB,0x1A,0x40,0x89,0xD5,0xFB,0xF7,0xA2,0x1B,0x79,0x8A,0xC2,0x42,0xC3,
+	0x28,0x52,0x5C,0xA5,0xD9,0x9F,0x9C,0x96,0x97,0xB6,0x2A,0x99,0x50,0x2B,0x37,0xCD,0x14,0x90,0x2C,0x7F,
+	0x03,0x3A,0xD4,0xB2,0xCA,0x04,0x83,0x83,0xC4,0x2E,0xB4,0xA3,0xC0,0x9F,0x1B,0xBE,0x5F,0x09,0x88,0x23,
+	0x15,0x32,0x31,0x27,0x9B,0x01,0x4E,0xDD,0x7B,0x24,0xFA,0x3B,0xDA,0x9F,0x3C,0x13,0xCA,0x60,0x86,0x16,
+	0x12,0x58,0x5A,0xF7,0xF1,0xBD,0xBB,0x75,0xC7,0x6B,0xA5,0xA0,0x40,0x6B,0xCF,0x04,0x76,0x29,0x4F,0x00,
+	0xC1,0xE4,0xB1,0x3E,0x21,0x3C,0x2C,0xCE,0xB9,0x11,0x10,0x81,0x41,0x57,0x56,0x3D,0x71,0x05,0xE5,0x3E,
+	0x36,0xD6,0xBE,0xC7,0xCD,0xD6,0x8D,0x1F,0x33,0x2D,0x4A,0x01,0x49,0xF0,0x5C,0x2A,0xA7,0x0C,0xB9,0xD1,
+	0x7F,0xB4,0x6B,0x91,0x58,0x95,0xE6,0xF7,0xF7,0xF7,0xFD,0x34,0x2A,0x61,0x19,0xBF,0x9D,0x47,0x1E,0x97,
+	0x87,0x9C,0x25,0x5E,0x12,0x49,0x96,0x09,0x03,0x34,0x86,0xA3,0xD6,0xFD,0x86,0x3E,0x23,0xF9,0x41,0xF4,
+	0xC0,0xE5,0x24,0xCC,0x9F,0xC6,0x1C,0x2A,0x4B,0x31,0x6D,0xA8,0xEA,0x78,0x77,0x06,0x2E,0xF7,0xFF,0x1F,
+	0xB8,0x60,0xF5,0x9C,0x99,0x4F,0x61,0x59,0xE9,0x76,0xBE,0xBD,0xF9,0x97,0x7E,0x37,0x26,0xDC,0x42,0xBD,
+	0x18,0xFE,0xA8,0xC4,0x8F,0x23,0xF6,0x9C,0xFC,0x30,0x86,0xCE,0xAD,0x99,0x5A,0xA1,0x9C,0xFC,0x36,0x5A,
+	0x92,0x5D,0xD7,0x98,0xE1,0xEF,0x30,0x29,0x29,0x6E,0x68,0x6E,0x4B,0xB1,0xC8,0xAC,0x24,0x9D,0x9E,0x0D,
+	0x71,0xE5,0x36,0xB9,0x50,0x99,0x30,0x5F,0xC8,0xCA,0x84,0x85,0x62,0x79,0x47,0x71,0xFE,0x4F,0x59,0xBA,
+	0xA5,0xFF,0x79,0xC3,0xE9,0x56,0x2E,0x0C,0x46,0x73,0x3C,0xB7,0x35,0x6A,0xA7,0xF6,0x11,0xFC,0xD2,0x50,
+	0x6D,0x63,0x10,0x28,0x3A,0x61,0x8A,0x30,0xBA,0xB0,0x00,0x67,0xB3,0xEE,0xBA,0x8B,0x91,0x40,0x7D,0xA5,
+	0xF6,0x70,0x05,0x56,0xA4,0xDD,0xF1,0x95,0xB8,0x95,0xDC,0xD8,0xF2,0xDC,0xAE,0x1D,0xC7,0xBA,0xA7,0x0C,
+	0x22,0xE0,0x7E,0x1D,0x04,0xCE,0x1B,0x37,0x21,0x50,0xC0,0x13,0x36,0xE5,0x2F,0x65,0x52,0x64,0x70,0x17,
+	0xDD,0x98,0xD0,0x50,0x96,0xC7,0x0A,0x83,0xC7,0xC8,0xD8,0x74,0xAC,0x65,0x58,0x23,0x71,0x63,0x79,0xBA,
+	0xFB,0xBC,0x69,0x50,0x63,0xC7,0xD1,0x64,0x2D,0x99,0xAA,0x91,0x97,0xAA,0xF7,0x8D,0xB0,0xD7,0x0B,0x22,
+	0x28,0x23,0x26,0x8A,0x24,0x98,0x4A,0x19,0x63,0xC3,0xFA,0xFC,0x78,0x89,0x33,0xC0,0x84,0x88,0x92,0xDF,
+	0x20,0xDC,0x30,0xEB,0x3D,0x82,0xB2,0x8C,0xBA,0xD9,0x8F,0xBC,0x73,0x33,0xE1,0x1B,0xF8,0xD6,0x81,0x4F,
+	0xE6,0x4B,0x12,0x89,0xA2,0x50,0x33,0x20,0xAB,0x02,0x33,0x37,0x54,0x67,0x12,0x28,0xBD,0x14,0xAB,0xA2,
+	0xFA,0xAA,0x25,0x15,0x6A,0xC0,0x5B,0xA9,0xB8,0xF6,0xCD,0xCC,0x4D,0x15,0x9B,0x5B,0xFF,0x27,0xC2,0x98,
+	0xA5,0xED,0xD6,0x6C,0xA5,0x93,0x32,0x2B,0x08,0xAC,0x93,0x4F,0xBC,0x3D,0x08,0x2B,0xA0,0x29,0x25,0x83,
+	0x5B,0x92,0xF8,0xAB,0x26,0xF3,0x42,0x32,0xB9,0xCE,0x40,0x9A,0x4E,0xC3,0xD3,0x6C,0xDA,0x91,0x73,0x69,
+	0xAA,0xA0,0x33,0x1B,0xC9,0xA2,0xCB,0x89,0x3A,0xEE,0x24,0x7D,0x24,0x6F,0xD2,0xB1,0x14,0x52,0x82,0xA8,
+	0xD9,0x61,0x10,0xE0,0x1B,0xA5,0xEC,0x83,0x8D,0x7F,0x28,0x0F,0xC8,0x60,0x0C,0x97,0xD7,0x70,0xBB,0x9D,
+	0x67,0x62,0x5C,0x20,0xAC,0xD0,0x50,0x1B,0x41,0x1D,0x29,0x17,0xA4,0x38,0x84,0x25,0xD5,0x9C,0x93,0x9D,
+	0x70,0xF7,0x47,0x73,0x80,0xEB,0xD3,0xAC,0x37,0x98,0x44,0xD3,0x0A,0xC2,0xA5,0x5A,0x8A,0xFA,0x23,0xBE,
+	0xE8,0x1B,0x9E,0x40,0x2D,0xD6,0xD3,0xF2,0x46,0xFB,0xD4,0x1B,0x72,0x74,0xE3,0xAE,0xFF,0x1A,0x92,0x0A,
+	0x35,0x76,0x64,0x0F,0x8A,0x5F,0xDC,0xF4,0x8C,0x75,0x4D,0xC8,0xA4,0xDC,0x05,0x15,0x1C,0x74,0xF1,0x83,
+	0x15,0x33,0xD5,0x1A,0x0D,0x76,0x8D,0xC8,0x6D,0xB7,0xE4,0x51,0x88,0xE0,0x4B,0x93,0xC7,0xFC,0x22,0x0A,
+	0xBC,0x2C,0xB1,0xA4,0x2E,0x41,0x15,0xFC,0x3E,0xFA,0xA2,0xCA,0x83,0xE9,0xCD,0x2A,0x07,0xE5,0x54,0xDC,
+	0x15,0x5B,0xF0,0xCC,0x85,0xE8,0xDE,0x71,0x67,0xD4,0x2F,0xCE,0x92,0x81,0xED,0xC6,0x55,0x66,0x28,0x9E,
+	0x1B,0x52,0x20,0x84,0x14,0x0B,0x4C,0x2E,0xFC,0x91,0x5A,0x54,0xCA,0xE4,0x3E,0xA4,0xC2,0x34,0xE0,0xC6,
+	0x64,0xFD,0xB9,0xE0,0xFA,0x78,0xC9,0xBB,0x77,0x70,0x06,0x14,0xC5,0xB1,0x2E,0xEC,0x83,0xA4,0x18,0x15,
+	0x35,0x58,0xDE,0x2B,0xA7,0x10,0x0E,0x75,0xAB,0x30,0x26,0xFF,0x4F,0xF2,0x10,0x6A,0x34,0x58,0x25,0xD4,
+	0xAB,0x9A,0x38,0x3D,0x5B,0xCF,0x65,0x1A,0x6E,0xFA,0x19,0xFB,0xB5,0xCA,0x34,0xFE,0x0A,0xA0,0x97,0xD5,
+	0xD8,0xE3,0xFF,0x8B,0x89,0x43,0x11,0xC3,0xB4,0xC8,0x98,0xF1,0x38,0x0A,0xB6,0x2A,0x12,0x93,0x29,0x13,
+	0x70,0xDF,0x97,0xC4,0x52,0x50,0xBD,0x61,0x39,0x0B,0xAC,0x56,0x5D,0x54,0xA9,0x41,0x71,0xAD,0x78,0xA2,
+	0x34,0xED,0xA6,0x63,0xA8,0x20,0x6C,0x65,0x1B,0x24,0x0F,0x0E,0x63,0x62,0x72,0x3A,0x54,0x0C,0xAE,0x73,
+	0xC9,0x82,0x38,0x93,0xA5,0xA3,0x5B,0x3F,0xC6,0x83,0x1D,0x75,0x51,0xEE,0xC0,0x30,0x64,0xB1,0xB9,0x51,
+	0xF1,0xDF,0x20,0x91,0xC2,0x49,0xF0,0x99,0xA9,0x1B,0x48,0xA1,0x83,0x08,0x33,0x79,0x11,0x7E,0xE8,0x9A,
+	0x89,0x08,0xF8,0x76,0x57,0x1A,0xA1,0x97,0x0B,0x07,0x60,0xBC,0xE9,0x27,0x23,0x35,0x2D,0xA2,0x0E,0x67,
+	0xD6,0x19,0x3B,0x78,0x81,0x4D,0xD7,0x24,0xC4,0xAE,0x1F,0x7E,0x38,0xDC,0xF9,0x77,0x28,0x18,0xE3,0x73,
+	0xED,0x37,0xF8,0x3E,0x74,0xF9,0x16,0xA7,0x68,0x45,0x49,0x09,0xFD,0x17,0x3C,0x36,0x0B,0xBA,0xD8,0x1A,
+	0x55,0x5C,0x2C,0x16,0x4B,0xFA,0x7A,0x26,0xEC,0xE7,0x07,0x11,0xEF,0x07,0x63,0xA6,0x83,0xA7,0x4D,0x07,
+	0xAF,0x4B,0x84,0x5B,0xAF,0xEA,0x0A,0x69,0x2E,0x00,0x3A,0x9B,0x84,0xBE,0xF6,0x59,0x42,0x4D,0x1B,0xFD,
+	0x51,0x36,0x2F,0xA7,0x06,0xD7,0x72,0xB6,0x87,0x17,0xE3,0x0C,0xB9,0xA0,0xF2,0x6E,0x5E,0x13,0xA0,0x05,
+	0x09,0x3D,0x2B,0xA2,0xA3,0xEF,0x02,0x67,0x8F,0x02,0xFA,0x81,0x5F,0x12,0x4D,0xA2,0x08,0xCC,0x7E,0xA2,
+	0x8A,0x55,0xCC,0xF5,0xEA,0x65,0xF3,0x6F,0x21,0x11,0xA4,0xA0,0x00,0x72,0x35,0x71,0x99,0xA4,0x45,0x47,
+	0xA4,0xC0,0x04,0x7F,0x20,0x10,0x5C,0x72,0x87,0x31,0xFF,0x00,0x4B,0x2F,0x7F,0x62,0x5A,0x5B,0xB1,0xB2,
+	0x17,0xF8,0x54,0x72,0x47,0xD3,0x30,0xE4,0xDE,0x20,0xF1,0xD0,0x0C,0x80,0x82,0x76,0x1D,0xFC,0xB0,0x70,
+	0x98,0x18,0x7E,0x05,0xB2,0xCB,0xBD,0x9E,0xE2,0xE1,0xA3,0x67,0x1F,0xF8,0x78,0xFA,0x5A,0x3E,0xCD,0xDD,
+	0x42,0xBE,0x65,0x8A,0xE3,0xE0,0xAF,0x97,0x1E,0xB7,0xA4,0x1F,0xD2,0xD5,0x73,0x42,0x00,0x74,0x0A,0xE5,
+	0x42,0xCF,0xF4,0xE6,0x76,0x54,0x7A,0xB0,0x47,0x9E,0x6D,0xB9,0x31,0xD4,0xC4,0xAD,0xC4,0xB0,0xFC,0xF6,
+	0x77,0x57,0x5B,0xFA,0xCE,0x67,0xDF,0x25,0xEA,0x41,0x35,0x85,0x19,0xC6,0xF5,0xE7,0xF6,0x16,0x13,0xD5,
+	0x46,0x14,0x36,0x53,0xF4,0xA5,0xC2,0x11,0xC3,0x73,0xFD,0xF7,0xF7,0x66,0xB7,0x0E,0x16,0xF4,0x59,0xFD,
+	0x4C,0xD4,0x6F,0xC8,0x9F,0xBD,0x8C,0x1E,0xC4,0xBA,0x6A,0x1E,0x17,0x9F,0x6C,0xEE,0xDC,0xB6,0x86,0x8B,
+	0x15,0xA6,0xC0,0xB8,0x9C,0x7A,0xE7,0x27,0xB6,0x90,0x40,0x4F,0xB7,0xF8,0x0F,0x50,0xDF,0x10,0x7D,0xE8,
+	0x9C,0xF2,0xEF,0x32,0x8E,0x64,0x1B,0x7D,0x42,0x46,0x7E,0xDD,0x87,0x4A,0x8A,0x3B,0xBA,0xC1,0x48,0x39,
+	0xA2,0xDD,0x26,0x27,0x1F,0xA7,0x6E,0x32,0x5D,0x3A,0xF6,0xEE,0x76,0xE5,0x9C,0x29,0xAB,0x10,0x16,0xFA,
+	0x37,0xBD,0xD5,0x07,0x34,0xA6,0xFE,0xFE,0x69,0xFA,0x3E,0x5D,0x4B,0x1F,0x01,0xA9,0x8D,0xCA,0x49,0x8B,
+	0x49,0x05,0xF7,0xEF,0xBA,0xD8,0x3D,0x88,0x44,0xFB,0xEB,0xDE,0xB7,0x9F,0xFE,0x89,0x14,0x9D,0xFF,0xFF,
+	0xBD,0x61,0x00,0x00,0x53,0x1D,0x68,0x8C,0x23,0xEB,0x42,0x76,0x64,0xE1,0x3B,0xEE,0xEB,0x22,0x51,0x33,
+	0xA6,0x11,0x57,0xC5,0xF0,0x27,0xB8,0x42,0x23,0x8D,0x8E,0x08,0x57,0x52,0x58,0x9B,0x25,0xFD,0xDB,0x95,
+	0x37,0x60,0x29,0x11,0xE6,0xED,0x40,0x39,0xB3,0xE3,0xB1,0xEB,0x91,0x4E,0xA9,0x29,0x32,0x61,0x89,0xB5,
+	0x8F,0x6B,0x54,0x57,0x93,0x6C,0x15,0x70,0x0E,0xFB,0x9A,0xC0,0x20,0xFB,0x90,0xC9,0xC9,0xD9,0xA8,0x17,
+	0x66,0x26,0xE5,0xBE,0xE2,0x3A,0x5F,0xA7,0x97,0xA8,0x02,0x8C,0x3F,0x07,0xA0,0x53,0xBA,0xD4,0x7B,0xE4,
+	0x1F,0xFB,0xC9,0x5C,0xF1,0x40,0x29,0x46,0x3B,0x49,0x84,0x8C,0x3B,0xF7,0x30,0x6E,0xF9,0xD2,0x9B,0x7B,
+	0x78,0x43,0x0C,0xBC,0x62,0xB8,0xA1,0x64,0xE7,0x4E,0x7D,0x77,0x60,0x05,0x02,0x49,0x3C,0xDC,0xC9,0x4A,
+	0x4E,0x68,0x94,0x8D,0xD8,0x4D,0x30,0xA8,0xCC,0xA6,0xF4,0xBC,0xF0,0xB3,0x5A,0xC4,0xF5,0x0B,0x0A,0x22,
+	0x33,0x9D,0x11,0xA5,0x63,0x4E,0x10,0x16,0xE4,0xA7,0x2A,0xD0,0x72,0xB1,0x95,0x8D,0xF0,0x38,0xAF,0x63,
+	0x2A,0x6E,0xC9,0xE2,0x70,0x28,0x40,0x6E,0x34,0x40,0x49,0x27,0xB7,0xDF,0x11,0x73,0x34,0x99,0x98,0x4D,
+	0xB9,0xDC,0x08,0x73,0x22,0x3D,0xC4,0x48,0xBB,0xC3,0xDA,0x47,0x37,0x86,0x4B,0xA5,0xE4,0xD6,0x81,0x56,
+	0x34,0x0B,0x4B,0x0F,0x6F,0x01,0x92,0xCD,0xDE,0xF6,0xCF,0x67,0xBE,0x55,0x2A,0x16,0x6D,0x0F,0x83,0x9E,
+	0xF0,0xC1,0x59,0x64,0x8D,0x3C,0x43,0xA1,0x27,0x6D,0x65,0x08,0x74,0x14,0xBD,0x0C,0xD8,0x95,0xAE,0x73,
+	0xAC,0x51,0x44,0x2D,0x2F,0x3D,0x6C,0xA2,0x38,0x56,0xD9,0xC6,0x87,0x15,0xB4,0x6E,0xDC,0x7D,0xBB,0x35,
+	0xCD,0x32,0x7C,0xB2,0x2C,0x5C,0xE3,0xC7,0x0B,0x80,0x3D,0x7E,0x93,0x64,0x9B,0xB9,0x93,0x2A,0xA0,0x21,
+	0x41,0xAD,0xAD,0x5A,0x11,0xED,0xEE,0xB5,0x1C,0xAC,0x4D,0x39,0x8E,0x3B,0xB1,0x2E,0xE0,0x32,0xE3,0x0C,
+	0x18,0xE0,0x1E,0x3F,0x81,0x9F,0x9E,0xB6,0x0A,0x76,0x6F,0x90,0xE2,0x42,0x84,0x23,0x9B,0xC5,0x19,0x1D,
+	0x82,0x97,0x8B,0x50,0x05,0x55,0xCB,0x03,0xE7,0xD8,0xC6,0xF6,0xC0,0xD8,0x57,0xF0,0x9E,0x54,0x90,0xCF,
+	0x13,0x3F,0x5D,0xB8,0x81,0x10,0xB3,0x39,0x1B,0xCC,0x35,0xCD,0x23,0x29,0xF5,0x35,0xFD,0x8B,0x0F,0xDF,
+	0x08,0x33,0xCE,0x85,0x73,0x61,0xD2,0x1B,0x89,0x87,0x51,0xB7,0x12,0xCD,0x2C,0x57,0x0B,0x5A,0x45,0x5F,
+	0x0A,0xC5,0x5D,0x62,0x0D,0xEF,0xD4,0xD8,0x51,0x1A,0x4C,0x97,0x82,0x3D,0xA5,0x0D,0x4F,0xD6,0xB8,0xB0,
+	0x53,0x97,0xD7,0x09,0xDD,0xFA,0x80,0x5A,0x6C,0xD7,0xC1,0x00,0x13,0x09,0x55,0x9B,0x1A,0x86,0x4F,0x34,
+	0xA6,0xB0,0x27,0x47,0x8A,0xB3,0x4E,0xB1,0x79,0x35,0x1C,0xA0,0x42,0x6D,0xFB,0x97,0xC6,0x6D,0x0C,0xE9,
+	0xC9,0xA1,0xDE,0xE1,0xB2,0xED,0xB5,0x30,0x64,0x50,0x71,0x4F,0x43,0xE0,0xDE,0xCA,0x0B,0x8D,0x87,0xFF,
+	0x92,0x2C,0x3E,0xAF,0xE9,0x11,0x07,0x14,0x0F,0x52,0x4F,0x64,0x81,0x51,0x98,0xFE,0x82,0xA4,0x5D,0x3B,
+	0xDE,0x14,0xA9,0xE5,0xB8,0xFF,0x9F,0x51,0x88,0x1D,0x27,0x3A,0xC8,0xF4,0x1F,0xE0,0x20,0x2D,0x0C,0x99,
+	0x17,0x2B,0xFF,0xA0,0xC4,0x7B,0xE1,0x49,0xD9,0x82,0x12,0xA3,0x32,0x2E,0x68,0xBF,0x0A,0xAC,0xCF,0x30,
+	0x1D,0xC7,0xC6,0x8F,0xBE,0x72,0xFC,0x3B,0x6F,0xC6,0xFB,0x43,0xFC,0xA1,0x09,0xF3,0x45,0x3D,0xF3,0xD4,
+	0xEE,0x6F,0x8D,0x37,0x30,0x22,0xB7,0x2B,0xB6,0x2A,0x8C,0x67,0x64,0x49,0xC7,0x9A,0x3E,0xB0,0xAD,0x20,
+	0xED,0x15,0x3B,0x35,0xF7,0x0B,0x70,0x10,0xBD,0x86,0xCE,0xC7,0x3E,0xE9,0x93,0x2C,0x8A,0x23,0x8E,0x8E,
+	0x14,0x0C,0xC7,0x35,0x8D,0x6C,0xA9,0x32,0xAF,0x2C,0xA1,0x2F,0x41,0x0B,0x70,0x34,0xA2,0xCA,0x2B,0x0E,
+	0x27,0x39,0x0E,0x14,0xF4,0xA4,0x7A,0x93,0xAF,0x0C,0xB3,0xDB,0xFF,0xF6,0x31,0x1B,0x3A,0x85,0xA2,0x77,
+	0xE8,0x76,0x1A,0x3A,0x09,0x27,0x9C,0xAE,0x5C,0x07,0x1A,0xD5,0xB2,0xC4,0x03,0x87,0xE9,0x84,0xBA,0xEA,
+	0xFB,0x78,0xCC,0xC6,0x1E,0xB3,0x5A,0x38,0x00,0xC4,0xEB,0x38,0x95,0x0A,0x83,0x79,0xEE,0x46,0xF7,0x7C,
+	0xB6,0xC6,0xB7,0xAF,0xA8,0x66,0x56,0xEF,0xE4,0x4E,0x55,0x1D,0x6C,0x08,0xF1,0x5B,0xF5,0x88,0x63,0x2A,
+	0xAE,0xE3,0x1F,0x51,0xDB,0x13,0x22,0x76,0x08,0xBF,0x22,0xE7,0x01,0xA1,0x23,0x16,0xEF,0x53,0xAC,0xD3,
+	0x2A,0xAE,0x72,0xDF,0x6C,0xC5,0x94,0x66,0xF4,0x1C,0x61,0x95,0xC0,0x70,0xEC,0xDF,0xB4,0xCE,0xAE,0x29,
+	0x75,0x77,0xFB,0x9A,0xFD,0x51,0xC7,0x09,0x35,0x63,0x6C,0x77,0x37,0x27,0x7C,0xDF,0xB5,0xF5,0x95,0x72,
+	0x7E,0x90,0x9E,0x8B,0x4F,0xD0,0xC1,0xCE,0xFD,0x40,0x3E,0x80,0xB6,0xD1,0x5B,0x64,0xC8,0xB3,0xA3,0x51,
+	0xE0,0x5D,0x8A,0x0E,0x14,0xB0,0x8C,0xE1,0x12,0x02,0xFC,0xE7,0x49,0xB8,0x04,0xCE,0x46,0x51,0x47,0x8C,
+	0x1B,0x44,0x1B,0x6E,0xDC,0x3D,0x65,0x7A,0xC3,0x1F,0x67,0xA1,0x0F,0xB6,0x4A,0xD5,0x9E,0x11,0x53,0x94,
+	0x04,0xD2,0x2F,0xE4,0x9F,0x1A,0xBA,0x0C,0x57,0x9E,0xEC,0x5A,0xA5,0xB1,0xB6,0xBD,0x20,0xA7,0x47,0xFE,
+	0xEA,0x05,0x25,0x1C,0x67,0x64,0x4C,0x75,0x0A,0x59,0x54,0x29,0xCE,0xE4,0x6D,0x00,0xDE,0xC4,0xDC,0x80,
+	0x05,0x80,0x84,0x7E,0xD2,0x7C,0x94,0xA1,0x55,0xF3,0xC0,0xEA,0xAE,0x81,0x2F,0x60,0x9A,0x79,0x66,0x97,
+	0x76,0x59,0xAD,0x7A,0x2A,0x0A,0x97,0xB7,0x93,0x3C,0x03,0xF4,0x84,0xF7,0xDD,0x64,0x54,0xFF,0x3C,0x88,
+	0x9F,0xC5,0x31,0x6E,0x32,0x33,0xC1,0x00,0x34,0x03,0x68,0x80,0xB4,0xEB,0x91,0xAB,0x8C,0x18,0x3D,0x96,
+	0xBD,0x19,0x4B,0x43,0x6F,0x42,0x80,0x0F,0xDE,0x9C,0x3D,0x89,0x3E,0xDB,0xA3,0x73,0xBC,0xAF,0x17,0x56,
+	0xA1,0xA1,0x17,0xBC,0x92,0x9E,0x8F,0x68,0x29,0x16,0x03,0x3A,0x68,0xD8,0x8A,0xBF,0x82,0x8E,0x81,0x0B,
+	0x5E,0x56,0x1E,0xED,0xD7,0x93,0x6E,0xFF,0x0A,0xFE,0x0E,0x99,0x07,0x5E,0x77,0x9D,0x0A,0xB3,0x0E,0xF5,
+	0x1A,0xDF,0x96,0xEE,0x5F,0xFF,0x36,0x73,0x92,0x9F,0xD8,0xD2,0x43,0x5D,0x39,0x29,0xAA,0x63,0xB2,0x02,
+	0x57,0xCF,0x8C,0x94,0x63,0x08,0xF6,0x9C,0x82,0xB1,0x3A,0xA4,0x46,0xEE,0xBA,0x12,0x1E,0x3F,0x2A,0xDA,
+	0xE9,0xCC,0x6E,0xFD,0x69,0xBD,0x51,0xCA,0x69,0xBA,0xFE,0x28,0xF9,0x71,0x1B,0x40,0x44,0x44,0x34,0x00,
+	0x7E,0xBF,0x2C,0x63,0x3D,0x4E,0x15,0xE4,0x07,0x80,0xA5,0x95,0xC7,0x90,0xE6,0x9C,0xB8,0x82,0x60,0xC1,
+	0xC8,0x19,0x2D,0x96,0xC3,0x28,0xEA,0x05,0x18,0xC1,0x3D,0x56,0xE2,0x94,0x99,0xFC,0x89,0x41,0x18,0x91,
+	0xAB,0x59,0xA6,0x40,0xA3,0x4A,0x7A,0xC6,0xBF,0x22,0xD5,0xC4,0x34,0xFE,0xF7,0x7D,0xE2,0xB5,0xD7,0x82,
+	0xC0,0x47,0x2B,0x1F,0x68,0xDB,0xB7,0x2A,0x75,0xDA,0x08,0x69,0x64,0x67,0x59,0x0F,0xE4,0x43,0x82,0xF4,
+	0x2F,0xCA,0x79,0xB9,0x82,0xF7,0x76,0x68,0x66,0x77,0x56,0x13,0x61,0x42,0xEA,0xCD,0x21,0x27,0x89,0xF8,
+	0x63,0x45,0xD0,0x7E,0x95,0xB4,0x09,0x68,0xA0,0x67,0x79,0x85,0x6D,0xB4,0xC4,0x4D,0x7F,0x06,0xBA,0x6C,
+	0x43,0xA3,0x0D,0x5B,0x77,0xB9,0x25,0x58,0x2F,0x68,0xEB,0xEC,0x18,0x0F,0xDF,0xD1,0xB8,0xA6,0x67,0xBD,
+	0x47,0x2B,0xCB,0x42,0x33,0x8A,0xC3,0x08,0x39,0x11,0x0B,0x3C,0xAC,0x68,0xD3,0xE1,0xAC,0x47,0x2C,0x1C,
+	0xEA,0xC5,0xBE,0x99,0x28,0xF4,0xD3,0xD9,0x72,0x5A,0x51,0xA4,0x22,0xE8,0xE5,0x88,0xFD,0xC6,0x1F,0xA7,
+	0xDE,0xEF,0x29,0xC8,0x5F,0xBA,0x2A,0xEA,0xCA,0x35,0xAC,0x6B,0xFB,0x2D,0x1F,0xDB,0x0D,0x3E,0x93,0x72,
+	0xBE,0xD2,0x9E,0xA8,0x47,0x4B,0xDA,0xF8,0x0B,0x49,0xE4,0xE1,0x3F,0x4C,0xF9,0xA5,0x0A,0x61,0x6B,0x96,
+	0xC4,0x2C,0x28,0x0B,0x21,0xF5,0x13,0xB1,0xC7,0xD3,0xD9,0xA2,0x1D,0x9D,0xD3,0xB4,0x68,0xB2,0x82,0xCE,
+	0x7E,0xD0,0xFF,0xFF,0x55,0xEF,0xB3,0xA8,0xCC,0x41,0x11,0x80,0x14,0x01,0xD4,0x95,0x46,0xDF,0x93,0x70,
+	0x17,0x0A,0x19,0x10,0x4E,0xEA,0x54,0x80,0xD8,0x3F,0xC9,0x47,0xFD,0x7C,0x65,0xAE,0xEA,0x1F,0x45,0xF1,
+	0xF4,0xC7,0xAA,0x66,0x22,0x22,0x35,0x55,0x4E,0xD1,0xEC,0xEF,0x46,0xAC,0xD7,0xD1,0xD9,0x42,0x7B,0x05,
+	0xE0,0x82,0x62,0x91,0x18,0xBA,0x6F,0x44,0x72,0x30,0x6D,0x40,0x6E,0x3D,0xE0,0x02,0xE0,0x50,0x29,0xF4,
+	0x19,0x0B,0xF3,0x9F,0xD3,0xF6,0xB5,0xF3,0x92,0x0A,0x3C,0xB4,0x46,0x5A,0x82,0x1B,0x23,0x76,0xEC,0xBF,
+	0x37,0x6A,0xA5,0x93,0x37,0x3B,0x4E,0x83,0xA1,0xB6,0x15,0x14,0x4D,0xD4,0x7A,0x79,0x57,0xF4,0x79,0xB7,
+	0x04,0x52,0xCD,0x51,0xD1,0xEE,0xA4,0x0E,0x98,0x08,0xD9,0x89,0x2E,0x33,0x46,0x25,0x27,0x35,0xD6,0x60,
+	0x3D,0x25,0xD4,0x53,0x91,0xFB,0x36,0x2A,0x13,0x1B,0xD4,0x9D,0x4E,0x39,0x26,0x4B,0xE5,0xE4,0x4C,0x53,
+	0x0A,0x79,0x4E,0x0B,0x14,0x48,0x78,0x7F,0x99,0xB8,0x69,0xAF,0xC6,0xFC,0x3B,0x32,0xDC,0xD7,0xBB,0xFB,
+	0x4B,0x38,0xA6,0xE2,0x28,0x2B,0x09,0xBF,0x12,0xC6,0x60,0x41,0xF9,0x3B,0xF1,0x60,0x2C,0x8C,0xFE,0x23,
+	0x1E,0x3A,0x89,0xC4,0x11,0xCD,0x17,0xF6,0x8D,0xC8,0xF5,0x74,0xDC,0x5C,0x7A,0xBE,0xC0,0x58,0x39,0x9E,
+	0x48,0xDC,0x8E,0x02,0x77,0xD6,0x63,0xB6,0x96,0xE1,0x6D,0x8B,0x1B,0xA1,0x97,0xA9,0x15,0x45,0x28,0x1C,
+	0x45,0x4D,0x2F,0xDB,0xD2,0x12,0xF7,0x23,0x17,0x32,0x4F,0x48,0xED,0x84,0x22,0xED,0x90,0x00,0x3A,0x56,
+	0x27,0xA9,0x9E,0x2B,0x99,0x06,0x9C,0x49,0x8E,0x63,0xE1,0x16,0xAB,0x4F,0xD3,0x6D,0x70,0x7E,0x39,0x67,
+	0x29,0xA8,0x72,0x8F,0xAE,0x02,0x47,0xC5,0x6F,0xA0,0x41,0x2C,0x82,0x8F,0xEA,0xC7,0x8D,0x0F,0x4F,0x92,
+	0xCA,0xA0,0x60,0x54,0xBA,0x61,0x49,0x3C,0xC7,0x8E,0x7E,0xE7,0x83,0x02,0xF9,0xFB,0x90,0x81,0xE3,0xB7,
+	0xBD,0xF0,0xCC,0xC7,0xD3,0xE6,0x5F,0xE6,0xFB,0x96,0x3A,0x77,0xC4,0xC7,0x60,0x96,0xA5,0x45,0x79,0x7F,
+	0x01,0xD6,0xAA,0xBE,0xAB,0xE8,0x34,0x82,0x4B,0xCA,0x0F,0xC7,0x2F,0x4A,0x08,0xA8,0x79,0x0D,0xB8,0x8B,
+	0x33,0xAD,0x32,0x81,0x44,0x8E,0x62,0x94,0x52,0x6D,0xF7,0x31,0xF4,0x87,0xAB,0xA8,0xF4,0x87,0x19,0x71,
+	0xB6,0xCA,0x5D,0x53,0x58,0xE5,0xBD,0xEA,0x0B,0x8E,0x37,0x8A,0x26,0xD2,0x7B,0x5A,0xF7,0xA4,0xCC,0x28,
+	0x3F,0x9F,0x30,0x5F,0x2E,0xB1,0x3F,0x21,0x29,0xEB,0x6A,0x06,0x09,0x34,0x82,0xCD,0x73,0x87,0x96,0x8A,
+	0x2D,0x75,0x9B,0x6F,0xF6,0x1F,0x55,0x9A,0xCF,0xE2,0xE5,0x9A,0x37,0x8E,0x4B,0x34,0x83,0x86,0x7A,0xF2,
+	0x9C,0x3A,0x97,0xA9,0xC9,0xC1,0xDD,0x02,0xF9,0x60,0xF5,0xB5,0xFF,0x5F,0xCB,0x31,0x8F,0xBC,0x8D,0x38,
+	0x40,0xAE,0x45,0x6F,0xD3,0xE0,0xAA,0xB3,0xB0,0x31,0x83,0xA4,0x2C,0xB9,0xF2,0xA2,0xEC,0x30,0x05,0x8F,
+	0xE0,0xDE,0x98,0xCF,0xB4,0x7B,0xC3,0x4B,0x13,0xCD,0xB7,0xBB,0xC6,0xC8,0x9B,0x71,0x29,0x1A,0xD4,0x00,
+	0x5E,0x52,0x13,0x7B,0x1D,0x63,0x51,0xFE,0x8C,0xAF,0xAB,0x81,0xD3,0x44,0xA1,0xA5,0x85,0x17,0x84,0x97,
+	0xB9,0xD3,0x62,0xA5,0x97,0x92,0xB7,0xA5,0x9D,0xE3,0x36,0xCA,0x04,0xA3,0xD1,0x12,0x03,0x61,0xD0,0x2C,
+	0x64,0x93,0x86,0x92,0xE8,0x4C,0x73,0x97,0x08,0x9F,0x0E,0x22,0x61,0xAC,0x7C,0xD3,0x13,0xEF,0xA7,0xA6,
+	0x1F,0xA1,0x4D,0xBC,0xF7,0x9E,0xAB,0xBA,0x35,0xB4,0x1D,0xA7,0x5C,0xBD,0x10,0xF9,0x08,0xAF,0x2E,0xDF,
+	0xA4,0x97,0x1B,0xE2,0xC5,0x3F,0xDE,0x1F,0xE2,0x4F,0x34,0x17,0xC9,0x56,0xD4,0x2C,0x37,0xD8,0xB6,0x79,
+	0x45,0x1A,0x3F,0x76,0x08,0x80,0x85,0x0D,0x1C,0x8A,0xA0,0x21,0x95,0x94,0xA5,0xFE,0x5D,0xF2,0xDF,0x1A,
+	0xE3,0xAD,0xAB,0x08,0xA2,0xF5,0x92,0x57,0x9C,0x9F,0x49,0xB5,0x40,0x4A,0x95,0x42,0xE1,0x0C,0xBE,0x06,
+	0x48,0x97,0x54,0x23,0x2E,0xFD,0xA0,0xA2,0x94,0xF8,0x50,0x1E,0x6D,0x88,0x0F,0x2A,0x46,0xA1,0x9A,0xF8,
+	0xCF,0x3A,0xFF,0x6D,0xB9,0x32,0x38,0xD5,0x11,0x26,0x7A,0xE0,0x73,0xE7,0x1F,0x39,0x86,0xEA,0x37,0x7F,
+	0x4F,0x1B,0x8A,0x96,0x13,0xDE,0xEE,0xBA,0x29,0x96,0xAD,0xBC,0x0C,0x12,0x58,0x2E,0xD3,0x14,0x1B,0xA1,
+	0xC9,0x56,0xC2,0x40,0x9E,0x29,0x3F,0x52,0x8B,0x63,0x4A,0x50,0x1A,0x11,0xF0,0x02,0xB8,0x91,0xA8,0x01,
+	0x5C,0xFF,0x37,0x43,0x0D,0x0D,0x95,0x25,0x82,0x4C,0xF8,0x7E,0x02,0xCF,0x49,0x01,0xFC,0xF3,0x07,0x6B,
+	0xB6,0x91,0x36,0xFD,0x41,0x33,0x75,0x0D,0x0C,0x5E,0x8E,0x14,0x0A,0x21,0x6C,0xBD,0x2D,0x9C,0x10,0xB1,
+	0xD5,0xB0,0x45,0x13,0x39,0x90,0x1F,0xC0,0xDB,0xFF,0xDB,0x02,0x7F,0x44,0x93,0xE2,0x92,0x23,0x4E,0xC2,
+	0x44,0xC5,0xAE,0x8C,0x9A,0xF3,0x28,0xF2,0x83,0xAD,0xB6,0x2D,0xB6,0x27,0x60,0x80,0xFF,0xDE,0x90,0x1C,
+	0xB8,0x72,0x61,0x57,0xBC,0x89,0x84,0xE7,0xA3,0x90,0x03,0xA1,0x3B,0xEF,0xAF,0x90,0x1A,0x11,0xB2,0x62,
+	0x9D,0x0C,0xD9,0x08,0x32,0x38,0x27,0x45,0x22,0xC3,0xFF,0x8D,0x2E,0xCE,0xE7,0xA2,0xC2,0xA9,0x47,0x94,
+	0x71,0x5D,0x56,0x4C,0xC2,0xE3,0xF8,0x17,0xDE,0xE2,0x70,0xAA,0xAF,0x08,0xC3,0x36,0x30,0xA5,0x5C,0x37,
+	0xC2,0x4B,0x50,0x45,0x6D,0x27,0x39,0xC5,0xC5,0x62,0xD7,0x7D,0x94,0xE4,0xC1,0xA6,0xC0,0xB3,0xD1,0xA5,
+	0xC0,0xED,0x36,0x76,0x22,0xD8,0xCF,0x6D,0x13,0x0A,0xFA,0x35,0x1F,0x2F,0x8C,0xB8,0xB0,0x98,0x5D,0x09,
+	0xF1,0x64,0xC2,0x6A,0xEF,0x38,0x6C,0x15,0x4E,0x41,0x44,0xBF,0x66,0xB7,0xAD,0x1E,0xDD,0x6D,0x82,0x98,
+	0x31,0xC5,0x5A,0x4B,0x2C,0x36,0xC9,0x01,0xA6,0xC4,0x61,0x1C,0x8B,0x62,0x3B,0xF2,0x9E,0x11,0x3C,0xD1,
+	0x76,0xF1,0x53,0x5D,0x75,0xC7,0xBF,0x7B,0x7A,0x80,0xEB,0x1F,0xBB,0x69,0xC2,0x39,0xA2,0xBA,0x4E,0x81,
+	0x2E,0x07,0xF6,0x2A,0xF5,0x0A,0x75,0x74,0x1C,0xD7,0x71,0x38,0x92,0xE4,0xAA,0x9D,0xF9,0x2C,0x52,0x5C,
+	0x7C,0xCC,0xF4,0x65,0x94,0x8B,0xDA,0x4A,0x23,0x25,0x81,0x8C,0xA4,0x62,0x93,0x19,0x8C,0xFE,0x23,0xC9,
+	0xA9,0xEF,0x6D,0x21,0xA1,0x41,0xED,0xC0,0xDC,0x5D,0x12,0xCE,0x62,0x06,0x53,0x9D,0xEF,0x82,0xA4,0x0A,
+	0x68,0xEC,0x6F,0x9F,0xFF,0xE4,0xF9,0xC7,0xD1,0x66,0x5B,0x80,0x36,0xCB,0x83,0x5F,0xE2,0x54,0xAC,0x26,
+	0x52,0x80,0x72,0x96,0xC0,0x92,0x2F,0x21,0xED,0x22,0xAB,0xC1,0x65,0xF0,0xA4,0x84,0x75,0x77,0x7E,0x71,
+	0x55,0xA3,0xA4,0x81,0xCF,0x6A,0x4F,0xC3,0x0B,0x51,0xED,0x27,0x70,0xCB,0x23,0x62,0x2D,0x8E,0xAE,0x3C,
+	0x69,0x60,0x8D,0x33,0x61,0xF8,0xCD,0x38,0x52,0x75,0x1E,0xAD,0x4A,0x45,0x9E,0xA9,0x5A,0xA5,0x35,0xA7,
+	0x8B,0xFC,0xDC,0x43,0x11,0x54,0x54,0x64,0xDF,0x44,0xB4,0x27,0x43,0x31,0x62,0xA0,0xA1,0x55,0xE4,0x24,
+	0x88,0x7A,0x85,0x55,0xF3,0x1B,0x05,0x51,0xE3,0xBB,0x33,0xA9,0x09,0xE2,0xAD,0x67,0xFB,0xAB,0x8D,0x2C,
+	0x25,0x7B,0xFF,0xC4,0xC3,0x33,0x23,0xEB,0x88,0x23,0xBD,0xB4,0x0A,0x7A,0x7E,0x91,0x4B,0x78,0xBC,0xBD,
+	0x0E,0x97,0x2E,0x5B,0x4A,0x23,0xB8,0x5A,0xD9,0xF8,0xF5,0x9A,0xC7,0x02,0xF5,0x6F,0x07,0x55,0x84,0x3C,
+	0x01,0x18,0x61,0x4E,0x58,0xEB,0x90,0x76,0x49,0xC9,0xD4,0xFE,0x82,0xB9,0x13,0x45,0xE8,0xAF,0xEF,0x45,
+	0x7E,0xB7,0xE9,0xEF,0x2B,0xB7,0xB1,0x28,0x7B,0xBB,0x8F,0xA6,0x99,0x19,0xC6,0x89,0x5C,0xA4,0x78,0xAC,
+	0xE0,0x35,0xF6,0xE8,0x51,0x33,0xD2,0x2E,0xF8,0x5F,0xDC,0xE8,0xD9,0x87,0x54,0x4B,0x06,0x9D,0x9B,0x24,
+	0x9A,0x22,0x77,0xCE,0x89,0x4D,0x1E,0x01,0x4E,0x7B,0x45,0x36,0x27,0xB3,0x47,0xBE,0x84,0x7C,0xB4,0x12,
+	0x7B,0x23,0x07,0x69,0x89,0xDA,0x30,0xA6,0x26,0x99,0x7B,0xBF,0x50,0x7B,0xED,0x4A,0x5B,0xB7,0x57,0x68,
+	0x5A,0x80,0xB5,0x3B,0xEF,0xC4,0x6A,0x61,0xB8,0x0D,0x34,0xA0,0xC4,0x4B,0x0F,0xB5,0x62,0x3D,0x8C,0x68,
+	0xA6,0x75,0xBF,0xF4,0x13,0x6A,0x26,0xB6,0x2D,0x80,0x86,0x9A,0x35,0x1E,0x1B,0xB3,0x41,0x2D,0xB2,0xE5,
+	0x38,0x0F,0x09,0xD0,0xE6,0x37,0xD7,0x8E,0xD5,0xB2,0x89,0x0D,0x09,0xE6,0xB1,0x93,0xEE,0x63,0x07,0x47,
+	0xAE,0xCC,0x46,0x44,0xEF,0x60,0x98,0xAA,0x9E,0xC9,0x73,0x01,0xDC,0x8D,0xF8,0x91,0x80,0x30,0x78,0x5B,
+	0x50,0xD7,0x69,0x34,0x45,0xCA,0x04,0xC5,0x76,0xAF,0x26,0xE0,0x43,0x61,0xEA,0xF2,0x6D,0x9F,0x8D,0xD1,
+	0x86,0x8E,0xE9,0x72,0x7F,0x57,0x97,0x11,0x2D,0x60,0x3C,0x08,0x75,0x67,0x57,0x33,0xA4,0xA7,0xF9,0x24,
+	0xB5,0xCB,0xF1,0xED,0x0F,0xAF,0xA3,0x76,0x74,0xA5,0x96,0x68,0x64,0x85,0xEA,0x0A,0x99,0x99,0xB2,0x18,
+	0x2C,0x18,0x4D,0xD0,0x78,0xAA,0x54,0x1C,0xEC,0x0A,0xBA,0x6D,0x09,0x52,0xCF,0xC0,0xA4,0x00,0xEA,0x37,
+	0xFE,0xF2,0x58,0xFB,0x75,0x3B,0xC3,0x0D,0xE7,0xA7,0x4C,0x58,0x6F,0x49,0x79,0xDF,0x7D,0xEC,0x05,0xE8,
+	0x01,0x86,0x2B,0x9B,0xE2,0x4C,0xC6,0xD7,0xCD,0x60,0x5F,0xBB,0x9A,0x20,0x9A,0xA2,0x19,0xC1,0x84,0x2B,
+	0x1F,0x9E,0x95,0x99,0x94,0x67,0xA7,0x86,0xAF,0xE3,0xFB,0x29,0x3B,0xE1,0xF1,0x65,0x6F,0x58,0x04,0x4D,
+	0x24,0x68,0x25,0x7E,0x28,0x6D,0x7B,0x17,0x6F,0x21,0x54,0x77,0x98,0xF5,0x10,0x6F,0x25,0x0B,0x47,0x14,
+	0x7D,0xAF,0x0D,0x3B,0x8C,0x07,0x7E,0xDB,0xFA,0x6F,0x7A,0x88,0x2F,0x83,0x3B,0x93,0x40,0xE9,0x5E,0x60,
+	0x17,0x36,0xEC,0x1F,0xB9,0x3D,0x6D,0x25,0xE6,0x7C,0x8A,0xD2,0xA0,0xFF,0xC8,0x10,0xEC,0x36,0xAE,0x05,
+	0x5B,0x6E,0x2F,0x8B,0x47,0x41,0x1F,0x54,0xB5,0x5C,0x9F,0x7C,0xA2,0x89,0xC3,0x2F,0x4B,0x39,0x43,0xDC,
+	0x47,0x76,0x97,0x5C,0x1D,0x3B,0x92,0x71,0x81,0x08,0x6D,0xE7,0x18,0xDF,0x7D,0x5B,0xD9,0x9E,0xC5,0xD7,
+	0xFD,0x43,0x65,0x02,0x34,0x29,0xC5,0xC1,0xBB,0x32,0xC6,0xD8,0x76,0x11,0x58,0x63,0x56,0xF9,0xAC,0x2E,
+	0x27,0x0E,0xEC,0x96,0x55,0x08,0x14,0x74,0x9B,0x94,0xC4,0x26,0x8C,0xFA,0xC9,0x51,0xB6,0x9C,0x85,0xB4,
+	0x3A,0x30,0x42,0x1E,0xE6,0xD8,0xCD,0x65,0xFF,0x4B,0x6D,0x57,0xF7,0xB3,0x8F,0x55,0x46,0x31,0xDA,0xDE,
+	0x2F,0xA6,0x3D,0xBF,0x30,0x0A,0xD3,0x73,0x2E,0x3C,0x9C,0x11,0xC3,0x33,0x20,0x92,0x87,0x69,0x09,0xB5,
+	0xDF,0x7C,0x01,0xE9,0x44,0x1B,0x10,0x36,0xDC,0x66,0x2D,0x49,0x1D,0x2D,0xE7,0x8A,0xD8,0x06,0xBD,0xB6,
+	0xAA,0x93,0xA5,0x11,0x4B,0xB9,0x67,0xBB,0xA8,0x2F,0xD7,0xFC,0x1B,0xF5,0x09,0xEF,0x0E,0x1E,0x50,0x9D,
+	0x93,0xD5,0x28,0x53,0xBF,0x76,0xDF,0xEC,0x1A,0xF6,0x3F,0x3F,0x8B,0x23,0xE6,0x8E,0x4E,0xFE,0x65,0x99,
+	0x1E,0xB0,0x8C,0x8E,0xC5,0xFA,0x0D,0x9A,0x67,0x68,0x5A,0xBC,0xD4,0xF9,0x40,0xD7,0x69,0x1F,0x3E,0x93,
+	0x25,0xBF,0xCB,0xB4,0x74,0x43,0xB2,0x27,0x1F,0xA1,0x11,0x8B,0xED,0xE4,0xD3,0xA3,0x03,0xF1,0xFE,0x5F,
+	0x8A,0x02,0xCE,0xD8,0x30,0x39,0x3E,0x13,0x97,0x9D,0xA4,0xBF,0xDF,0xFF,0x81,0x84,0x7B,0x47,0x40,0x1C,
+	0x9E,0x5D,0x49,0x00,0xE5,0x9F,0x0A,0x9A,0xAD,0xB8,0x89,0x50,0xAE,0x43,0x71,0xEC,0x15,0x9A,0x63,0xCB,
+	0x7E,0x5C,0x26,0xC4,0xA2,0x6E,0x3F,0x19,0x0D,0x84,0x16,0xEA,0x25,0xF1,0x10,0x47,0x3F,0xCF,0x89,0x2D,
+	0x52,0x4A,0xD6,0x7D,0x87,0xD8,0x89,0xD2,0x68,0xA5,0xC0,0x34,0x7A,0x5C,0xB9,0xCB,0xD7,0x98,0xE4,0x22,
+	0x41,0xF9,0xB2,0xA4,0x56,0xAF,0x32,0xE8,0xB7,0xC2,0xD7,0xE6,0xD2,0x2E,0xF0,0xC0,0xA4,0x8E,0xCA,0x7A,
+	0xE5,0x50,0x67,0xE2,0x51,0xD8,0x74,0x07,0x65,0x93,0x39,0x65,0xB1,0xE0,0xEA,0xAB,0x2D,0x22,0x51,0xA1,
+	0xDE,0x2A,0xE9,0xB5,0x8E,0x99,0x88,0x68,0x85,0x34,0x3E,0x0A,0x2E,0xDB,0x3B,0x71,0xC0,0x07,0xA7,0xD9,
+	0x51,0xAB,0x35,0x8C,0x67,0xE7,0x82,0x76,0xDA,0x08,0xD2,0x31,0x89,0x33,0x53,0xAE,0x59,0x0A,0x03,0x18,
+	0x89,0x44,0x75,0x66,0x7B,0xD6,0x1E,0xD0,0x49,0x0B,0xA2,0xEC,0x86,0x66,0xC3,0x09,0xCC,0x48,0x8B,0x85,
+	0x79,0x9B,0x13,0xC5,0x4D,0x71,0xAB,0xFD,0x26,0x65,0x52,0x43,0x2C,0xA4,0xD2,0xBA,0x9F,0xD1,0x98,0x64,
+	0x15,0x3A,0xFB,0x7C,0x55,0x66,0x8F,0x2A,0xFD,0x87,0x69,0x22,0xCF,0x22,0x8F,0x7D,0xC5,0xB1,0x78,0xE8,
+	0x05,0x84,0x87,0x3A,0x86,0xDB,0xF0,0xA3,0xE6,0x6F,0x5A,0xB8,0x5B,0xF0,0x15,0x99,0xD9,0xA1,0x82,0x74,
+	0x8C,0x3D,0xAB,0xCB,0x66,0x6F,0x31,0xA9,0x3F,0xC8,0xF5,0x11,0x79,0x2C,0x03,0x51,0xE8,0x5D,0x82,0x60,
+	0x70,0x4B,0x39,0xB9,0x3A,0xC9,0x71,0xF9,0x87,0x66,0x5F,0xAF,0x5F,0x10,0x55,0x7A,0xED,0x4D,0xA7,0x8C,
+	0x98,0x61,0x54,0x48,0x97,0x76,0x35,0xE3,0x5D,0xB0,0xEC,0xD5,0xBD,0x3C,0xDC,0xAC,0xC6,0xA5,0xE4,0x36,
+	0x74,0x1B,0xDE,0x63,0xA6,0x32,0x2A,0xA1,0x35,0xC7,0x26,0x89,0xD3,0x72,0x9D,0x12,0x93,0x52,0x35,0x6E,
+	0x48,0xC2,0x87,0x9D,0x12,0x35,0x88,0xAF,0xD5,0xE7,0xA5,0x65,0x06,0x7C,0x11,0x2F,0x83,0x8B,0x04,0x0C,
+	0x11,0x3C,0xE3,0xE1,0xEF,0x58,0x53,0x84,0xF0,0x70,0xA0,0x4A,0x22,0x95,0x20,0xAF,0xF9,0x71,0xBA,0x01,
+	0xA9,0x15,0xC4,0xF0,0xFE,0x34,0x85,0x68,0x11,0x1B,0x05,0xBB,0x59,0x72,0x3D,0xFF,0x24,0xA2,0x87,0x87,
+	0x93,0x23,0x90,0xD0,0x23,0x57,0x0D,0x1D,0xE0,0x3F,0x03,0x63,0xE7,0xDA,0x02,0xFD,0xAD,0xFC,0xC6,0xC4,
+	0xB6,0x15,0x8E,0xC4,0xD9,0x37,0x03,0xB2,0x58,0x43,0xF6,0xE8,0x59,0xF5,0x70,0x69,0xC0,0xE8,0xEE,0xDC,
+	0x24,0xB2,0x3E,0x7A,0x5A,0x7A,0x16,0x70,0xDA,0x7F,0x79,0x79,0x04,0x17,0xE7,0xCD,0x16,0x35,0x47,0xCF,
+	0xA8,0x15,0xEF,0x8A,0x5B,0x7C,0x1D,0x9D,0x52,0x96,0x0F,0x7F,0x3B,0x33,0x21,0x94,0x4E,0x16,0x17,0x69,
+	0x5A,0x7D,0x9B,0xC8,0xDF,0x96,0x80,0x8A,0x54,0x70,0x28,0x76,0x81,0xAA,0x87,0xD1,0x91,0x38,0x8E,0x71,
+	0x98,0x80,0x73,0x47,0xCA,0x7F,0x3D,0x0B,0x8F,0xF2,0x7A,0x9E,0x8C,0xF6,0x43,0xA4,0x8B,0xBE,0x91,0xCF,
+	0xE6,0x52,0x09,0x72,0xFA,0xF1,0xED,0x5D,0x7A,0xD1,0x37,0xC4,0xF3,0xC1,0x86,0x3D,0xB8,0xFF,0xE9,0x08,
+	0x03,0x0F,0x8F,0xC0,0x10,0x3B,0xB3,0x0A,0xA1,0x2F,0xC2,0x82,0x44,0xC6,0x93,0x0E,0x9C,0xF1,0xFA,0xD1,
+	0xF7,0xED,0x16,0x2E,0x2B,0x5E,0x79,0xF8,0x66,0x81,0x68,0xD4,0xA4,0x3E,0xA8,0xB7,0x42,0xAF,0xB6,0x32,
+	0x25,0x7D,0x1E,0x2A,0x2B,0x7F,0x12,0x0B,0x25,0xD9,0xBB,0x37,0x77,0xA3,0x96,0x23,0x09,0x7C,0xF6,0x17,
+	0xA6,0xE4,0xE2,0x32,0x3E,0x5C,0xFD,0xDF,0x9F,0xAE,0xF7,0xC6,0x3C,0xFE,0xD8,0xBC,0xBA,0xA9,0x70,0x22,
+	0x08,0xBF,0x90,0x30,0xC3,0xA6,0x7F,0xD6,0x3D,0xFF,0x96,0x51,0xB6,0xFA,0xC7,0xE0,0x65,0x18,0x80,0xF2,
+	0x08,0x8E,0xDA,0xA1,0xE5,0xD4,0x9E,0xC3,0x85,0xBD,0xF5,0x61,0xC8,0xA8,0x3E,0x32,0x1E,0x5F,0x53,0xB1,
+	0x7A,0x26,0x5D,0x35,0x28,0xBC,0x1B,0x73,0xC4,0xD7,0x39,0xAA,0xA1,0x6A,0x18,0xB6,0xFB,0x75,0x1A,0xF1,
+	0x6B,0xA8,0x87,0x07,0xF8,0x99,0xC0,0x2F,0x1A,0xF3,0xEE,0x44,0x03,0x97,0xAA,0x9A,0x4D,0xCF,0x96,0xBE,
+	0x19,0xE4,0xBE,0xBA,0x76,0xF3,0x7A,0x1E,0x59,0xE6,0x63,0xD2,0x06,0x31,0x06,0x02,0x7C,0xDB,0x52,0x59,
+	0x27,0x11,0x56,0xF4,0xF6,0x89,0x14,0x32,0x22,0x76,0x33,0xA3,0x31,0xBA,0x64,0xF5,0xAA,0xDB,0x5A,0x7B,
+	0xAF,0x73,0x07,0x28,0xE9,0x1D,0x4D,0xF8,0x6C,0x51,0x89,0x95,0xA9,0x91,0x52,0xA1,0x78,0x0D,0x94,0x59,
+	0x90,0xD0,0xA7,0x6B,0x92,0xB0,0x2B,0xFA,0x00,0xE9,0x5C,0x7A,0x2F,0x2F,0x9D,0x49,0x7F,0x3D,0x11,0x6B,
+	0xCF,0x8E,0xE5,0xC3,0x21,0x33,0x31,0xF4,0xF7,0xCD,0x8D,0x59,0x76,0xCB,0xD4,0x5F,0x40,0xCD,0x9B,0x29,
+	0x5A,0xAF,0x72,0xBE,0xD7,0x6B,0x2D,0x16,0x97,0xB6,0x76,0x44,0x40,0x6C,0x3C,0xA4,0xD5,0x7A,0xF4,0x55,
+	0xD8,0x49,0x24,0xAA,0xD4,0xBE,0x17,0xC0,0xDA,0x8E,0xF6,0x48,0xD6,0xF7,0x65,0x7F,0x18,0xD0,0x2D,0xBA,
+	0x17,0xB4,0x8A,0xF8,0x35,0x0F,0x6A,0x45,0x58,0xFF,0x75,0x9F,0x28,0x3E,0x70,0x17,0x4E,0x28,0xD1,0xC8,
+	0x27,0xD3,0xB5,0x32,0x54,0x79,0x89,0xE6,0x98,0xF4,0x24,0x0E,0x05,0xF6,0x0A,0xD0,0xE3,0xC2,0xCE,0x56,
+	0xF6,0x5B,0x3C,0xAC,0xE5,0x95,0xF6,0xCA,0x14,0x60,0x25,0xE6,0xEA,0xB6,0x7C,0xB1,0x53,0x08,0xA7,0x84,
+	0x5B,0x10,0xAC,0x4A,0xEA,0x4B,0x4A,0xBD,0x17,0x0A,0x51,0x85,0x83,0xFF,0x25,0x8B,0x2A,0x2A,0x7D,0xC8,
+	0x81,0xB1,0xD6,0x56,0x32,0xC9,0xA5,0x95,0x80,0xF3,0x7C,0x18,0x24,0x90,0x8E,0x71,0x4B,0xAE,0x0D,0x38,
+	0x68,0xD0,0x41,0x4C,0xDD,0x72,0x14,0x69,0x4E,0x36,0xEE,0x66,0x3D,0x42,0x05,0x0A,0x9A,0xC2,0x43,0x5C,
+	0xDC,0x73,0xA6,0x4D,0x80,0xDB,0x67,0x8E,0x0D,0x01,0x76,0xD9,0x94,0x25,0x58,0x4D,0x5D,0x70,0x71,0xDD,
+	0x81,0xDA,0xAF,0x63,0x3C,0xF9,0x4D,0x3F,0xB2,0x5D,0xC0,0x5D,0x7F,0xD3,0x04,0x6A,0xDF,0x1A,0xC6,0x0A,
+	0x9F,0x36,0x0B,0x19,0xB6,0x08,0x29,0x4E,0x05,0x7C,0x68,0xD8,0x51,0xEA,0x42,0x41,0x3C,0x1D,0x96,0x70,
+	0x4D,0x0B,0x41,0xA2,0x5E,0xBD,0x67,0x0B,0xA3,0xE5,0x60,0x30,0x57,0xED,0x54,0x1A,0x72,0x9E,0x8C,0x6B,
+	0xD9,0x90,0x69,0xF2,0x22,0x62,0xD5,0x2C,0x89,0xBB,0x00,0x88,0x05,0x77,0x53,0xDB,0x70,0xBE,0x5E,0xA0,
+	0x88,0xAB,0xF8,0x86,0x31,0x20,0x45,0xC0,0x73,0xA0,0x2F,0xB7,0x72,0xBD,0x7A,0xE1,0x2F,0x1C,0x37,0xF6,
+	0x93,0x28,0xDC,0xFA,0xFA,0x3E,0x3B,0x09,0x8D,0x62,0x55,0x43,0xEB,0x41,0xF9,0x87,0xB1,0x42,0xBA,0x66,
+	0xCE,0x9E,0xF7,0x18,0xD3,0x82,0x37,0x65,0xE1,0xDC,0x09,0x6E,0x32,0x25,0x22,0xB5,0xFB,0x6E,0xBF,0x0D,
+	0xA5,0xC3,0x10,0x58,0x6C,0xDF,0x95,0xAD,0xB3,0x7B,0xF0,0x12,0x20,0x78,0x8E,0xFE,0x56,0xB8,0x5E,0x36,
+	0x62,0x25,0x2F,0x3A,0xC5,0x2F,0x40,0xF2,0xC3,0x4D,0x77,0x6A,0xB7,0x91,0x6F,0xBC,0x11,0x1D,0x75,0x27,
+	0x2D,0x4A,0x2F,0x66,0xC6,0xB6,0x68,0x3B,0x0F,0x1B,0x5B,0xAE,0x05,0x64,0xCC,0x0B,0x26,0xFB,0x61,0x83,
+	0xE2,0x97,0x6F,0x86,0x3B,0xCC,0x7C,0xB9,0xE9,0xA7,0x9A,0x19,0x7B,0x68,0xD2,0x81,0x6B,0x53,0x81,0x2E,
+	0xF9,0xC5,0x6C,0x69,0x0A,0x1A,0xC8,0xFE,0x9B,0x20,0xB1,0xBD,0xDA,0x76,0x65,0x46,0xAE,0x28,0x51,0x7A,
+	0xEA,0x66,0xFB,0x8F,0xB9,0xEA,0x95,0x77,0x45,0x28,0x00,0xD7,0x31,0x9B,0x35,0xB8,0xE9,0x8B,0x4B,0xED,
+	0x40,0x24,0x64,0x66,0x74,0xB7,0xC2,0x97,0x7C,0xF4,0xC2,0x31,0x43,0xA1,0x6D,0x23,0xC7,0x90,0x92,0xAC,
+	0x28,0x4A,0xE0,0x68,0xDF,0x7A,0x02,0x51,0x7C,0xA1,0x63,0x03,0xE2,0xD1,0xEB,0x18,0x47,0xC6,0xD0,0x67,
+	0x30,0x19,0x46,0x0E,0x40,0xBE,0xF8,0x16,0xCA,0x2A,0x73,0x29,0x6B,0xC7,0xF5,0x28,0x0A,0xCA,0x94,0x1F,
+	0x8D,0x84,0x5B,0x2F,0x70,0x3E,0xA4,0x9B,0x49,0x6B,0x5F,0xBB,0x49,0x6C,0x52,0x24,0xCB,0x53,0x91,0x62,
+	0xB2,0x39,0xB8,0x48,0xCC,0x1D,0x04,0x4C,0xBD,0x3D,0x58,0x63,0x0B,0xCC,0x94,0x94,0x92,0x70,0x64,0x38,
+	0xC4,0xD8,0xC5,0x0E,0xD4,0xEE,0xC5,0xCD,0x7D,0xB3,0x81,0x95,0x13,0x34,0x72,0x51,0x60,0xFD,0x6E,0xAD,
+	0x55,0x8D,0x5B,0x31,0x4A,0x10,0xD3,0xA9,0xB9,0xB8,0x3D,0x22,0x42,0x59,0x9C,0xD3,0x0A,0x31,0x6B,0x31,
+	0x81,0x54,0x1B,0xA8,0xDB,0x25,0x08,0xB3,0xE7,0x86,0x73,0x7B,0x19,0xC2,0x15,0xC5,0xF6,0x79,0xCE,0xC5,
+	0x03,0x31,0x9C,0x65,0xFE,0x17,0x77,0x9A,0xA6,0x89,0x7A,0x45,0x98,0xAF,0x69,0x57,0xB6,0x3C,0x6F,0x09,
+	0x7A,0x99,0x50,0x97,0x19,0xE0,0x89,0x8F,0xAD,0x09,0xA0,0x51,0x86,0x03,0x80,0xA7,0x61,0x53,0x60,0xAA,
+	0x27,0xB2,0x00,0x38,0xA8,0x34,0x79,0x7F,0x44,0x97,0x52,0xA0,0xCD,0x43,0x4F,0xA8,0xF5,0x85,0x57,0x8D,
+	0xFC,0x75,0xD0,0x7E,0x65,0xBC,0x47,0x8E,0xCE,0x42,0x9A,0x7C,0x25,0x62,0x97,0x0D,0x92,0x73,0xD7,0x65,
+	0x22,0xF7,0x21,0x4F,0xFA,0x17,0xF5,0x95,0x0D,0xFC,0xCB,0xC7,0xA7,0x05,0xD6,0x82,0xDD,0xBA,0xAF,0xC3,
+	0x4E,0x4B,0x39,0xCB,0x3B,0x5B,0x3B,0x37,0x2C,0x2F,0xE6,0xA2,0x4D,0x38,0x1A,0x8A,0x59,0xB7,0x71,0xDB,
+	0x11,0xD9,0xA1,0x5C,0x11,0x16,0x91,0x5C,0x04,0x0A,0x73,0x08,0x94,0xA2,0x76,0x76,0xB3,0xFE,0x75,0xB6,
+	0xAC,0x2D,0x18,0x98,0xC9,0x4B,0xAF,0xCD,0x73,0xA3,0xF7,0x1C,0x1A,0xFE,0x16,0xCC,0x7E,0x73,0x0F,0x28,
+	0x0F,0x7D,0xA4,0xC2,0xB8,0xD2,0xFC,0xEE,0x91,0xCB,0xDF,0x70,0x6E,0x83,0x14,0xF6,0x95,0xAF,0xF0,0x8E,
+	0x78,0x7F,0xB1,0x40,0xAF,0xFB,0x0E,0xA3,0x44,0xF4,0x87,0xF4,0xB9,0x2A,0xA8,0x40,0x76,0x84,0x00,0xC9,
+	0xD8,0x57,0xDA,0xF2,0x89,0x82,0xC1,0x67,0xB0,0x29,0x0C,0xA7,0xF2,0x3B,0xC2,0x41,0x23,0xF2,0xFD,0x3D,
+	0xA3,0x36,0x99,0xF5,0x17,0xAA,0xC1,0x3B,0x62,0xD3,0x02,0xAD,0xD6,0xC1,0x4F,0x40,0x42,0x87,0x80,0x44,
+	0x17,0x2F,0x70,0x00,0xA4,0xE4,0x13,0x9D,0x29,0xE4,0x3E,0xF2,0x57,0x55,0xE4,0xAA,0xB6,0xE7,0xBA,0x20,
+	0x64,0xF4,0x68,0xB1,0x55,0x10,0xE7,0x46,0x80,0x5D,0x1E,0xA5,0x90,0x44,0xF0,0x11,0x65,0x84,0x99,0xA5,
+	0x50,0x13,0x57,0x5A,0x0A,0x21,0xED,0x3D,0x12,0xB7,0xF9,0xBB,0x1F,0xC1,0xFD,0x30,0x56,0xE9,0x76,0x30,
+	0x2E,0xCA,0xE2,0x7C,0xBF,0xCD,0xCA,0x22,0xEB,0xD8,0x72,0xC2,0x58,0x86,0xEA,0x56,0x86,0x28,0xD2,0x39,
+	0xBE,0xAF,0xAD,0xBE,0x5E,0x08,0xD8,0x3A,0x5C,0x49,0xBE,0x6E,0x65,0x29,0xDB,0x8D,0xBD,0xAB,0xCB,0xD4,
+	0x25,0xB1,0x0C,0xBD,0xCF,0x37,0xFF,0xE8,0xA3,0x56,0x04,0xE4,0x3E,0xB0,0x03,0xC0,0xBE,0xCB,0xAB,0xB3,
+	0xD9,0x85,0xE1,0x8A,0x42,0x57,0x39,0x61,0x61,0xAE,0x52,0x2E,0xEF,0x33,0x51,0xF8,0x82,0x0A,0x30,0x01,
+	0x2B,0xF1,0x44,0x21,0x3E,0x6F,0xE5,0x1A,0x59,0x30,0x98,0x7A,0x82,0x50,0x4D,0xB6,0x1D,0xCC,0xBC,0xE4,
+	0x98,0x35,0x13,0x20,0x63,0xC3,0xAD,0xFC,0xDA,0x45,0x54,0x14,0x56,0x72,0xFB,0x57,0xB3,0xED,0x03,0x1B,
+	0xC3,0x8F,0x54,0x8E,0x09,0xEF,0x59,0x6C,0x4F,0x9F,0xDC,0x75,0x4C,0xB3,0x14,0x22,0x57,0x75,0xFC,0xB2,
+	0x47,0xAA,0x33,0x7A,0x69,0x4D,0x14,0x69,0xB8,0x1C,0xD9,0x42,0xE5,0xCE,0x50,0x92,0xF8,0xB0,0xA5,0xF9,
+	0xA2,0xA1,0xA6,0x8B,0x87,0xE3,0x8D,0x4C,0x6B,0x6F,0x0D,0x15,0xFC,0xB2,0x81,0x16,0x70,0xF1,0xBA,0x08,
+	0x5E,0x02,0x26,0x39,0xE4,0x33,0xED,0x37,0x95,0xF2,0xA0,0x9C,0x28,0x8A,0x64,0x83,0x12,0xDA,0x0F,0x11,
+	0x08,0x49,0xAA,0xE9,0x32,0xBA,0xDB,0xAD,0x84,0x28,0xC4,0x14,0xE3,0x73,0x2C,0x02,0x62,0x44,0x23,0xF6,
+	0xF4,0xFB,0x18,0x3C,0xA0,0xA5,0xA5,0xF8,0xBE,0xDA,0xD9,0x70,0xB5,0xDC,0x94,0x47,0x20,0x49,0x7B,0xB1,
+	0xCF,0x9A,0x4A,0x40,0x56,0x18,0xBD,0x5A,0xF8,0xDA,0x1D,0xC8,0xD3,0xF4,0x4F,0x61,0xD7,0x64,0xF8,0xB6,
+	0x34,0x15,0x6F,0x99,0x95,0x97,0x30,0x8F,0x0B,0x54,0xC0,0xD1,0xD0,0xA5,0xE6,0x17,0xC1,0x28,0xC9,0xA6,
+	0xD3,0x98,0x06,0x8E,0x82,0xBF,0x9E,0xD4,0xAA,0x41,0xB4,0xC8,0x76,0x0B,0x36,0xD4,0x4B,0x2A,0x68,0xE9,
+	0xCF,0x5B,0xEF,0x32,0x2F,0xD9,0x6F,0x6B,0x21,0xD7,0x5F,0xDB,0xE5,0x56,0x6B,0x3B,0x84,0x53,0x74,0x65,
+	0x28,0xAF,0x80,0x3F,0xFC,0xFC,0x6B,0x0A,0x42,0xA9,0x77,0xAF,0xFC,0x50,0xD3,0xEB,0x8E,0x3C,0xD1,0x81,
+	0xEB,0x6B,0x3E,0xD7,0x69,0xEE,0x2F,0x16,0x61,0xB0,0x9A,0x4F,0xF2,0x8D,0x4C,0xB5,0x6B,0x42,0xA1,0xFA,
+	0x80,0x55,0x81,0x8D,0x05,0xF7,0x57,0xEB,0xA2,0x30,0x48,0x40,0x54,0x09,0xB2,0x81,0x4C,0x9D,0x00,0x8C,
+	0x9A,0x0B,0x78,0x32,0xC8,0x0F,0x10,0x42,0xDB,0x3D,0x68,0xA0,0xA0,0xBF,0xCF,0xD2,0x4A,0xF0,0xBD,0xFD,
+	0x03,0xA5,0xE6,0x66,0x9C,0x57,0xE1,0x17,0xE0,0xCB,0x35,0x4B,0xCC,0x3D,0x16,0xF2,0xF4,0x59,0xD1,0x72,
+	0xCC,0x65,0x71,0x65,0x40,0x4F,0x12,0x27,0x4F,0x23,0x1E,0xA1,0x6A,0xA0,0x74,0x67,0x07,0x7C,0xB6,0xDE,
+	0x74,0xEB,0x22,0x7B,0x38,0xAA,0x3F,0x7F,0x2D,0xD1,0x28,0xCE,0x30,0xF2,0x00,0xEC,0x0E,0x5F,0xAF,0x99,
+	0x52,0x6A,0xEB,0xB4,0xDF,0x6E,0xA0,0xD2,0xEF,0x64,0x82,0x71,0xC6,0x04,0xFF,0x4C,0xAE,0xCE,0x99,0xC5,
+	0xAB,0x1E,0xBE,0xB8,0x92,0x28,0x77,0x95,0xC2,0x56,0xB9,0xE3,0x2E,0x27,0xD9,0x23,0x74,0x8C,0x25,0xD5,
+	0x6F,0x07,0xC9,0xB6,0xC1,0xB2,0xA1,0x69,0x33,0xE6,0xDD,0x82,0x7F,0x7C,0xB8,0x87,0xA3,0xA5,0x6A,0xD6,
+	0xF5,0xB0,0xED,0xD4,0x58,0x2A,0xBF,0xE5,0x0B,0x7C,0x34,0x89,0xBF,0x87,0xA1,0xDA,0xE5,0xB4,0xFC,0x4C,
+	0x58,0xE9,0xC3,0x64,0x30,0xD1,0xE2,0xE7,0x69,0x29,0xEC,0xAB,0xCD,0x4E,0x90,0xAA,0x25,0x04,0x98,0x37,
+	0xF1,0xB0,0x4B,0x64,0xF7,0x69,0x63,0x42,0xC7,0x29,0x3C,0x4D,0x59,0x7B,0xB1,0x74,0x0C,0x16,0x6E,0x0E,
+	0x99,0xF8,0x56,0x2F,0xCB,0x42,0x69,0x9F,0xDE,0xE1,0x58,0xA2,0xF8,0x0E,0xB4,0xCF,0x70,0xAB,0x60,0x8B,
+	0x81,0xE6,0xE3,0xF8,0x6D,0xC5,0x10,0x2B,0xAB,0xBF,0x21,0x52,0x54,0xA3,0xF0,0xFF,0x16,0xA8,0x81,0x26,
+	0xDC,0x5D,0xF5,0x5D,0x6A,0x90,0x4B,0xAE,0x7F,0x80,0x39,0x7D,0x1B,0x99,0xE0,0x9F,0x77,0xD2,0x3E,0x3C,
+	0xCB,0xD6,0xFB,0xF6,0xE2,0xAF,0x03,0x48,0x22,0x1D,0x0C,0x80,0x8D,0x1C,0x6E,0x80,0xC0,0xBE,0xC0,0xB4,
+	0x1F,0x91,0x0E,0xAC,0x67,0x9B,0x3B,0xD5,0x55,0x77,0x5B,0x12,0xA4,0xB9,0x15,0x9B,0xB3,0xC6,0xB9,0x32,
+	0xFC,0x2D,0xF3,0xC4,0xF3,0x32,0xEE,0x62,0x7F,0xB8,0xD4,0x17,0x54,0x37,0xF0,0xD3,0x56,0x48,0xBD,0xEC,
+	0x50,0xFF,0x45,0xBF,0x5B,0x1D,0xC5,0xF2,0xCA,0xCF,0xD0,0x26,0xF0,0x57,0x43,0x0E,0x87,0x3B,0xE6,0x8F,
+	0xD6,0xE9,0x7B,0xF0,0xBC,0x37,0x34,0x32,0xE5,0xA0,0xD8,0xB3,0xF2,0x7B,0x47,0xDD,0x54,0x96,0xC5,0x07,
+	0x31,0x70,0xB6,0x1A,0x9D,0x56,0x45,0x22,0xF0,0x83,0xDD,0xA2,0xC4,0x1E,0x7A,0xD4,0x3E,0x3B,0xCD,0x36,
+	0xE1,0xA2,0x7A,0xF3,0x27,0x13,0x61,0x80,0xC3,0x8E,0x87,0xCB,0x03,0x1E,0xD6,0xCE,0x03,0x57,0xDC,0xA9,
+	0xF7,0xFE,0x31,0xC7,0xFD,0xDC,0xCC,0x8F,0x2D,0x36,0x66,0x87,0x11,0x1B,0x6E,0x4C,0x37,0x36,0xAC,0xF3,
+	0x7D,0xE6,0x39,0x65,0x3A,0xFC,0x15,0x9B,0x13,0xCF,0x17,0x6D,0xF2,0x61,0xA8,0xAE,0xC2,0xBE,0xBD,0x67,
+	0x4D,0x0B,0x1C,0x3E,0x5C,0xAA,0x9E,0x4D,0xE3,0x34,0x93,0x0F,0xE8,0xFC,0xAE,0xD2,0xFC,0xC8,0x52,0xAF,
+	0xEB,0x52,0xF0,0xEB,0xBC,0xD8,0x8E,0x5C,0x48,0x64,0x90,0x4E,0x3F,0x92,0x64,0x0B,0xA1,0xF6,0x94,0x1E,
+	0x3A,0x3D,0x4F,0xC0,0xAC,0x66,0x21,0xBF,0x51,0x98,0xF4,0x7F,0x36,0xB8,0x77,0x7A,0x03,0xF2,0x09,0x2D,
+	0x8F,0xC4,0x2C,0x2E,0x65,0x94,0x3D,0xFD,0x00,0x89,0xA1,0x6E,0x90,0xF9,0xA6,0x86,0x67,0x16,0x23,0x5B,
+	0xF5,0xCC,0x7A,0x9F,0xC6,0x88,0x0F,0x61,0x9E,0x89,0x9D,0x2E,0xB1,0x30,0x51,0x64,0x8F,0x9E,0x1E,0x50,
+	0xBA,0xAD,0x86,0x42,0xAE,0x7A,0xFA,0x2C,0xFB,0x80,0x44,0xE8,0x75,0xF4,0xAC,0xC1,0x46,0xC6,0xF9,0x23,
+	0x08,0x8B,0x76,0x99,0xF6,0xF7,0x93,0x9D,0x26,0xA7,0x5B,0x3A,0xC4,0x03,0xB9,0x69,0x60,0x3F,0x5B,0xC7,
+	0x08,0xE6,0x56,0xB7,0xFE,0xB4,0x57,0xFD,0x2D,0x72,0x88,0x19,0x3D,0xEB,0xBA,0xC7,0xF4,0xE9,0xCB,0x4C,
+	0xCF,0x11,0xC1,0x2C,0x9A,0xB8,0x86,0x70,0xB6,0x66,0x2B,0xDE,0x7D,0x85,0x9F,0x75,0x13,0xB0,0x70,0x90,
+	0x14,0x1A,0x72,0x55,0xB6,0xBD,0x0B,0x4A,0x84,0xA7,0xB7,0x58,0x85,0xE9,0xD6,0x6D,0x23,0x33,0x50,0xF3,
+	0xED,0xFA,0xE2,0x72,0x6E,0xC9,0x26,0x8A,0x48,0x50,0x8D,0xED,0x8E,0xD7,0x1D,0x41,0x81,0xAA,0x86,0x58,
+	0x8E,0x74,0x06,0x81,0xE2,0x24,0xA7,0x58,0x31,0xC6,0x15,0x41,0xD2,0x4F,0xCF,0x8B,0x70,0xAA,0xF3,0xDC,
+	0xC4,0x27,0x3B,0x3F,0x4E,0x82,0xB0,0xA8,0x01,0x57,0x39,0x1F,0x66,0x6D,0x48,0xE1,0x7C,0x1D,0xAB,0x25,
+	0xBD,0x3F,0x23,0x7F,0xD1,0x1F,0x61,0x31,0x2F,0xAC,0x83,0xEE,0xC8,0x13,0xC4,0x99,0xA6,0x67,0x32,0xC2,
+	0x59,0x71,0x62,0x57,0xF2,0xE3,0x98,0x56,0xFB,0x0A,0x5C,0x36,0x9F,0x69,0xA0,0x65,0x23,0xF2,0x24,0x34,
+	0x03,0x38,0xCA,0x20,0x0F,0x6B,0x41,0x6F,0x4B,0xD8,0x8B,0x48,0x27,0xE1,0x08,0x9B,0xCB,0x8B,0xDA,0xE2,
+	0x7B,0x3A,0xF6,0x60,0xA4,0xBB,0x43,0x81,0xBC,0x55,0xA4,0x73,0xC4,0xD0,0x91,0x8A,0x8D,0xB9,0xCB,0xD0,
+	0x12,0xBC,0xB5,0x56,0x26,0xBF,0x89,0x89,0x4E,0xE5,0xD2,0x90,0xD4,0x12,0xC3,0xCC,0x44,0x51,0xE5,0x4F,
+	0xD0,0x6E,0x8D,0x09,0x30,0x06,0x35,0xF4,0xBF,0x23,0xF1,0x5D,0x19,0xB0,0xB4,0x57,0xB6,0xBD,0xAD,0x55,
+	0x37,0x90,0xE5,0x64,0x39,0xBE,0xE4,0x4C,0x65,0xB3,0xBC,0xD1,0x0E,0x06,0x40,0x3F,0xA7,0xD6,0x83,0xCE,
+	0xDD,0x22,0x0A,0x7D,0x0D,0x62,0x74,0xF8,0x92,0x00,0xB3,0x90,0x21,0xDD,0xD3,0x89,0xE3,0x70,0x47,0xAC,
+	0xBA,0x68,0xA2,0xC4,0x73,0xB9,0xB8,0xA3,0xD1,0xB2,0x4E,0xBD,0x63,0x4A,0x74,0x10,0x34,0x0A,0x43,0x16,
+	0x1E,0xB6,0x90,0x3B,0x11,0xD5,0x4A,0xE0,0x5C,0x12,0xD2,0xED,0x03,0x23,0x9C,0xF9,0x27,0x83,0xC5,0x71,
+	0x53,0x98,0x5B,0x7C,0x1D,0xDA,0x9F,0xD5,0xF9,0x53,0xEA,0x90,0x5F,0xBA,0xBE,0xC1,0xD0,0x25,0xAA,0xA2,
+	0x3B,0x82,0xD3,0xD4,0xCE,0xC2,0x19,0x5F,0x4E,0x02,0x4F,0x49,0x2A,0x6F,0x08,0xE0,0x61,0x31,0xB4,0x86,
+	0xEA,0x10,0xAB,0xE7,0x28,0xF1,0x10,0x4B,0xA1,0x30,0x92,0xFD,0x46,0xF9,0x7D,0xDD,0xAD,0x94,0x07,0x45,
+	0xED,0xB6,0xEF,0xA9,0x28,0xE4,0xB8,0xFC,0x3A,0xF0,0xC0,0x1B,0x86,0xBC,0xD1,0x1F,0xE2,0xEE,0x86,0xFE,
+	0x0D,0xFC,0xC9,0x2F,0xA3,0xFD,0x1F,0xF4,0xBF,0xA9,0x81,0x03,0x7F,0xF3,0xB0,0x4F,0xDD,0x47,0x86,0xC1,
+	0x6E,0xCA,0x29,0xD9,0xE6,0x92,0x1F,0x65,0xDC,0x28,0xE8,0xFB,0xCB,0x0F,0x07,0x55,0x9D,0x69,0x58,0x0A,
+	0x73,0x9F,0x97,0x79,0x03,0xBE,0xC0,0xA9,0x2D,0x1B,0x35,0x65,0xAD,0x4E,0x6E,0x0C,0xA9,0x11,0x4E,0xE9,
+	0x8D,0xBD,0xA3,0x95,0x92,0x3E,0xD2,0xEE,0x6D,0x8E,0xDE,0xC0,0x57,0xE0,0xF8,0x74,0x7F,0xEA,0x87,0x5F,
+	0x0D,0x60,0xE7,0x61,0x93,0xA0,0xBD,0xB2,0xE1,0x48,0x3E,0xA1,0xA1,0x59,0xF6,0xE1,0x7E,0x92,0x29,0xE5,
+	0x6F,0xF0,0x88,0xC2,0x45,0xCE,0x9D,0xD7,0xF5,0x21,0xD7,0x33,0x3B,0xA5,0xF7,0xFF,0xE2,0xB3,0xB5,0x96,
+	0x71,0xF2,0x8A,0x3C,0xF1,0x01,0x9C,0xAA,0x60,0x09,0x58,0xA5,0xB0,0x65,0xC3,0x03,0x26,0xC4,0x82,0xF4,
+	0xF0,0x9E,0x79,0xBA,0x6B,0x1F,0xA9,0x87,0x14,0xD3,0xE3,0x19,0xC4,0xDD,0x8B,0xC5,0x71,0x03,0x5E,0xA2,
+	0x07,0x8C,0xF6,0xD1,0xA9,0x90,0xA2,0x8E,0x2A,0xEE,0x19,0xE8,0x2E,0x61,0xC2,0xA1,0xE4,0x05,0xFC,0x0B,
+	0xE1,0x27,0x40,0x07,0xA3,0x2C,0xCD,0x5F,0xA5,0xC9,0xA3,0x67,0x9C,0x4B,0x8E,0x00,0x99,0xE4,0x8B,0xBC,
+	0x36,0x92,0x3A,0x4E,0x3B,0x83,0x7C,0x8D,0xFF,0xE4,0x06,0x10,0x66,0x2A,0x2B,0x49,0x80,0xBF,0xAB,0x1D,
+	0x0D,0xC5,0x5E,0x9B,0x8F,0x38,0x88,0x1F,0x40,0x6A,0x1D,0x15,0x49,0x06,0xE5,0x3A,0x38,0x0D,0x66,0xF0,
+	0xF6,0x48,0xFA,0xA2,0xB6,0x21,0xF5,0x8A,0xAA,0xB3,0x89,0xB6,0xD4,0xB3,0x35,0x22,0x69,0x79,0x73,0xBE,
+	0xB7,0x50,0xA2,0x70,0xB6,0x02,0x7A,0x0E,0x39,0x69,0xB8,0x32,0xEA,0x18,0x3E,0xC9,0xAC,0x86,0x0A,0x33,
+	0x23,0x41,0x89,0x6D,0xA6,0xC1,0x30,0xB4,0xD9,0x4D,0x0B,0xF4,0x44,0x6D,0xCB,0x67,0xA5,0xBB,0xA5,0x7A,
+	0x2E,0x60,0x33,0xFC,0xDC,0xA9,0x7B,0x74,0x28,0xE1,0x01,0xA6,0xA8,0x41,0xE8,0xBD,0xF0,0x1D,0xC3,0x9A,
+	0xAC,0x73,0x5D,0xBD,0x8E,0x64,0xF0,0xB2,0x69,0x3D,0x5C,0x44,0x4C,0x8A,0xC5,0x7C,0xD6,0x50,0x45,0x2C,
+	0x16,0x70,0xB1,0xC3,0xC3,0x32,0x05,0x21,0xBE,0xA2,0x72,0xE2,0xCF,0x6C,0xF5,0xEF,0x5A,0x3C,0xFD,0x10,
+	0xC3,0x70,0x9B,0x31,0xCE,0xBF,0xE0,0x5E,0x23,0x84,0x7C,0x83,0x3C,0x32,0xF4,0x1E,0x09,0x3C,0x4E,0xDF,
+	0x66,0x81,0xAB,0x2F,0xCA,0x71,0xC8,0xAB,0xBE,0x93,0xE9,0x58,0xD7,0xB6,0xBC,0x54,0x6B,0xD8,0xF8,0x3E,
+	0x4B,0x52,0x74,0x35,0x11,0xCD,0x55,0xF2,0x87,0xDE,0x54,0x61,0x8D,0x35,0x2F,0xD1,0x54,0x56,0x57,0x15,
+	0x9B,0xBC,0x6A,0x5D,0x13,0x64,0x52,0x17,0xB3,0x71,0xD2,0x1B,0x89,0x47,0xB4,0xA1,0xC7,0x95,0x13,0xBB,
+	0x50,0x1C,0xAC,0x44,0x13,0x37,0xDD,0x66,0x2F,0xE3,0x25,0xE7,0xEC,0xC4,0x1A,0x5A,0x6F,0xA2,0x66,0xFA,
+	0x51,0x62,0xBA,0xB4,0x57,0x47,0xFF,0x21,0x4F,0x7B,0x31,0x81,0x64,0xD1,0x3F,0x3C,0xCB,0x31,0x2E,0x66,
+	0x26,0xAD,0xCD,0xFD,0xA1,0xBB,0x6B,0x9F,0xC3,0xD6,0xC2,0x5B,0xCA,0x4F,0xFB,0xF9,0xAE,0xE3,0x92,0xF1,
+	0x89,0x71,0xD6,0x85,0x47,0x32,0x86,0xF1,0xD9,0x3C,0xE2,0xA7,0xF1,0xC0,0xB7,0xBA,0xB6,0xEB,0x76,0x3A,
+	0xBF,0x9B,0x79,0x54,0xAB,0x4E,0x7D,0x78,0x26,0xC1,0x3C,0x3D,0x9C,0xCF,0x17,0xD6,0xE2,0x32,0x58,0x9F,
+	0x2E,0x9D,0x2C,0x19,0xA3,0x5E,0x34,0xFB,0x56,0x5D,0xF8,0x6E,0x80,0xF9,0xF8,0x51,0xFD,0xC4,0x78,0xEA,
+	0x48,0x5C,0x0B,0x79,0xC1,0x2B,0x69,0xA4,0x23,0x3F,0x4B,0xD6,0x5C,0x86,0x41,0xF9,0xFA,0x0A,0x67,0x74,
+	0xEA,0x2A,0x06,0xD2,0xC8,0xA3,0x14,0xA5,0x41,0xEB,0x8D,0x86,0x51,0xE0,0x62,0x3B,0x92,0xF1,0x0F,0x43,
+	0xE5,0x62,0x4E,0x55,0x2F,0x5F,0x2C,0x2B,0x83,0xB0,0x56,0x2B,0x93,0x90,0xC3,0x17,0x4A,0xC1,0x7F,0xB3,
+	0xEE,0x5D,0xBE,0x6C,0x35,0x91,0x67,0xDD,0xB7,0xFB,0x21,0x11,0x23,0x70,0x4F,0x86,0xE3,0xA5,0x80,0xE7,
+	0x23,0x9E,0x39,0x92,0xA2,0xAA,0x87,0x01,0xE4,0xA6,0x50,0x72,0x64,0x44,0xD9,0xF1,0x96,0xE6,0x55,0x25,
+	0x29,0xE4,0x09,0x51,0xAE,0xCB,0x56,0x3A,0x51,0x06,0x58,0x35,0xC7,0xC8,0x5D,0x38,0x34,0x2C,0x82,0x0C,
+	0xA7,0xC5,0x41,0x25,0xF9,0x84,0xD2,0x8E,0x3A,0xB9,0x14,0x6C,0xE7,0xEA,0x85,0x2B,0xC1,0xC4,0xE8,0x0E,
+	0x24,0xAA,0xB5,0x3E,0xD1,0x6A,0x81,0xEE,0x2D,0x78,0x2F,0xBE,0x76,0xCD,0xD5,0x4D,0x49,0x58,0x5C,0x65,
+	0x8A,0xD9,0x78,0xD8,0x4D,0x57,0x5B,0x35,0xFC,0x3E,0xEE,0xCC,0xDA,0xD1,0x0C,0xB3,0x11,0xB8,0x6B,0xB3,
+	0xF0,0xA6,0x84,0x5B,0x7A,0x6F,0xA9,0x1F,0xDB,0xD0,0xF2,0x55,0x8A,0x58,0x39,0x77,0x18,0x9F,0x0C,0xC6,
+	0xBB,0x4F,0xB8,0x2C,0x1F,0xEB,0x50,0xE2,0xF8,0xE3,0xA5,0x63,0xAC,0x70,0x52,0x47,0xA4,0x89,0x7B,0xFA,
+	0x20,0x2C,0xC7,0x24,0xF6,0x71,0x2E,0x2D,0x69,0x25,0x86,0x98,0xF4,0x45,0x0E,0x54,0xBB,0x1B,0x55,0x5D,
+	0x51,0x22,0x13,0x7B,0xAC,0xEC,0x21,0x78,0xB9,0x3A,0xC1,0x8C,0xD0,0x9A,0x2C,0x87,0xF9,0x2D,0xFC,0xBE,
+	0xB6,0xB8,0xE0,0x5D,0xE7,0xDE,0x4E,0x24,0xF4,0xF5,0x33,0x61,0x5C,0x3C,0xCC,0xD2,0x3A,0xBC,0x83,0xE9,
+	0x95,0xB8,0x9C,0x34,0xF5,0xD4,0x8A,0xF0,0x96,0x33,0x71,0xF5,0x17,0xF3,0xD5,0x9C,0xC0,0x6E,0x8D,0xC7,
+	0xF0,0x39,0x78,0xA2,0xD0,0x3C,0xE7,0x48,0x16,0xB5,0x06,0x74,0x2F,0x5A,0x85,0x5F,0x9A,0xBC,0xCF,0xB8,
+	0xF3,0x68,0x9B,0x36,0x55,0x45,0xF4,0x13,0xA4,0x94,0x2C,0x1B,0x72,0xB6,0x7E,0x94,0x1F,0xD9,0x5D,0x25,
+	0xBB,0x08,0xCA,0x03,0x8F,0x85,0x3C,0xF2,0x11,0x00,0x5A,0x9C,0x82,0xDA,0x9B,0xC1,0x57,0x35,0x4F,0x10,
+	0x02,0x79,0x75,0x46,0x0A,0xC5,0x7C,0x95,0xCB,0xD5,0x95,0xCA,0x37,0x89,0x03,0xC1,0x62,0xC1,0x2C,0x73,
+	0xF3,0x34,0xBD,0x8E,0x41,0x21,0x2E,0x6B,0x5F,0x98,0x7E,0x93,0x9D,0x7C,0x0E,0x4E,0x34,0xFE,0xF1,0x66,
+	0x5A,0xEC,0x94,0x7C,0xBF,0xF1,0x3E,0x8B,0x44,0x26,0x56,0x22,0x59,0xFA,0xFA,0x87,0x4D,0x25,0xDF,0x0D,
+	0xB9,0x23,0xAD,0x49,0x0C,0x81,0x97,0x6E,0x5D,0xB5,0xEF,0x67,0x44,0x16,0xB2,0x7D,0x11,0xF9,0x86,0x0A,
+	0x4E,0x04,0xEE,0x1B,0xDD,0x18,0xEB,0x53,0x1D,0x40,0x76,0x4C,0xB6,0xB4,0x55,0xF0,0xB6,0x68,0xD0,0x46,
+	0xFA,0x58,0xEE,0x3C,0x3F,0x16,0xB4,0x7F,0x9C,0xD8,0x1F,0x5A,0xB9,0x62,0x01,0x7A,0x7B,0x3E,0x9F,0x23,
+	0x48,0x15,0xBD,0x66,0x1D,0xDB,0x29,0xE4,0xFC,0x90,0x21,0xE8,0x5F,0x9B,0x26,0x3D,0x4E,0x84,0xB5,0x6E,
+	0x1C,0xDA,0xC8,0x44,0x1B,0x08,0x12,0x15,0x7A,0xF8,0xE8,0xA3,0x06,0x7B,0xDA,0x05,0xB3,0x26,0xA6,0xD1,
+	0xA8,0x20,0xFB,0x7B,0xA5,0x9C,0x58,0xB8,0x75,0x1A,0xF0,0x96,0xCC,0xEE,0x79,0x3E,0x91,0x35,0xE7,0x94,
+	0x25,0xC1,0x45,0x05,0xFF,0x67,0x2E,0xF7,0xF3,0xBC,0x4F,0x13,0xC8,0x0E,0x01,0x57,0x2F,0xBD,0x28,0x77,
+	0xA2,0x32,0xB7,0xC4,0x32,0x46,0x3E,0xC0,0x5D,0x51,0xC0,0xB1,0x74,0xD2,0xF7,0x6C,0x06,0xCF,0xC0,0x44,
+	0x12,0xA9,0x8F,0xC8,0x31,0x40,0x70,0x06,0x76,0x68,0xA3,0x74,0xE2,0x03,0x58,0xD6,0x32,0x87,0xD8,0x85,
+	0xF7,0xB1,0x7C,0x36,0xD7,0x69,0x17,0x50,0xB6,0x02,0xA1,0x13,0x01,0x29,0x0E,0xC1,0xFD,0x56,0xE9,0x27,
+	0x71,0x6A,0x69,0x15,0x20,0x01,0xF1,0x12,0x51,0x2F,0x8F,0xF5,0x9F,0x72,0xB1,0x84,0x50,0x75,0x5B,0x1F,
+	0xED,0x03,0xBC,0xD8,0xBB,0x55,0xFA,0xA2,0x6A,0x9E,0xED,0xC4,0x5E,0x25,0x12,0x08,0xE8,0x12,0xA2,0x45,
+	0xEE,0x84,0x72,0xBE,0xB5,0x08,0xF9,0xFC,0x1F,0x15,0x05,0xE1,0x9F,0x47,0xA9,0xA8,0xB6,0xA0,0x6C,0xD4,
+	0xC8,0x44,0x84,0xD7,0x21,0x06,0xBD,0xFF,0xBA,0xFD,0x43,0x4F,0xB7,0xA1,0xF7,0xB9,0x35,0x6B,0xA4,0x72,
+	0x81,0xE0,0x6F,0x2F,0xA9,0x17,0x8A,0xBB,0x98,0xD0,0xF5,0xC0,0xB7,0xB7,0x12,0x91,0x6F,0x6A,0x2A,0x5A,
+	0xAF,0x16,0xB4,0x5A,0xFA,0xAE,0x9F,0x90,0x7F,0x00,0xBA,0x3D,0xD7,0x60,0x66,0xBF,0x0F,0xDC,0xBC,0x2F,
+	0xFA,0x22,0x53,0x97,0xE8,0xDE,0xDB,0xCA,0x3B,0x61,0x86,0xDD,0xC5,0x39,0xE4,0xAE,0x17,0xD2,0x4D,0xCC,
+	0x34,0x0D,0xD1,0x7C,0x78,0x61,0x13,0xE0,0x4C,0xBD,0xD4,0x18,0xD1,0x3F,0x57,0x66,0xF2,0x53,0xD4,0x5C,
+	0xF0,0xCB,0x98,0xF6,0x4A,0x1E,0x08,0x76,0x37,0xEA,0x74,0x72,0xE7,0xA4,0x42,0x9A,0x0E,0x71,0x12,0x61,
+	0xF0,0x09,0xE5,0xC1,0xF7,0xB9,0xF6,0x5A,0x9F,0x52,0x1B,0x48,0x4A,0x30,0xDA,0xA3,0x5E,0xC6,0xDB,0x68,
+	0xF0,0x35,0x8D,0xFE,0x1C,0x2F,0x46,0xD7,0xF7,0x28,0x1C,0x22,0x8E,0xB9,0x57,0x40,0x75,0x92,0x4C,0x69,
+	0x02,0xD4,0xEC,0x1B,0x9B,0x87,0x8C,0x7C,0x55,0x57,0x5B,0x2B,0x67,0xE2,0xC2,0xD0,0x03,0x17,0x8A,0x48,
+	0x98,0x11,0x19,0x23,0x4B,0xD5,0xFF,0x27,0xD1,0xC6,0x0D,0x69,0xE6,0x1D,0x40,0x16,0x76,0xFB,0xCA,0x4A,
+	0x4A,0x5C,0x4C,0xBF,0xC4,0xFB,0xDD,0x1C,0x3C,0x54,0x62,0x17,0x73,0x3A,0x7E,0x8A,0x30,0xB5,0xA8,0x6C,
+	0xD9,0x37,0xBF,0xD6,0xFD,0xF5,0xDE,0x50,0xC4,0x83,0xD1,0x9A,0x5E,0x59,0x51,0x63,0xD8,0xE6,0xE1,0x47,
+	0x88,0xDA,0x9E,0x44,0xD8,0x39,0x10,0x3B,0xA0,0xAA,0x33,0x52,0x4B,0x7B,0x12,0xC9,0xAE,0xDB,0xD7,0x40,
+	0x4E,0xC1,0xCF,0x75,0x4E,0x1D,0xF0,0x75,0x23,0xF6,0xE0,0x47,0x54,0xAA,0x43,0x6B,0xCA,0x9D,0x3E,0xEF,
+	0xC3,0x77,0x19,0xB6,0x05,0xFA,0x44,0xF0,0x6C,0x4E,0x46,0x6E,0xA7,0x03,0x9C,0x5C,0x11,0x67,0x4E,0x2C,
+	0x06,0x32,0xDE,0x15,0x5C,0x1F,0x27,0x87,0xD8,0x7B,0x3F,0x39,0xDD,0xBF,0x1E,0xCD,0x5B,0x81,0x57,0xED,
+	0x9F,0xE6,0x68,0x0F,0x78,0x82,0x71,0xA4,0x08,0x5E,0xAF,0x99,0xB4,0x32,0x84,0x67,0xCF,0x84,0x70,0x16,
+	0x46,0x70,0x98,0x50,0x47,0x70,0x98,0x5A,0xEF,0x04,0x9C,0x60,0xC7,0x7D,0xB0,0x0B,0xBF,0xA4,0x84,0x8D,
+	0x06,0x31,0x28,0xE3,0x9E,0xA7,0x39,0xC1,0x8F,0x6A,0x1C,0x54,0x29,0x1E,0xDE,0xEB,0x68,0xCF,0xEB,0xCB,
+	0x28,0xC8,0x1B,0xF3,0x67,0x4A,0x8B,0x97,0x45,0x4D,0x70,0x09,0x20,0x7C,0xF9,0x8A,0x34,0x2B,0x5E,0x3B,
+	0x11,0x06,0x83,0x8B,0x22,0xE7,0x62,0xC0,0x97,0x5B,0x98,0xC4,0xCB,0x1B,0xF7,0x49,0x9F,0x39,0x98,0xA4,
+	0xD2,0xEA,0x31,0x27,0x01,0x67,0xA2,0xEB,0xB4,0xA3,0x29,0x9D,0xFA,0x3A,0xC0,0xD2,0x83,0x36,0x19,0xC1,
+	0x06,0xE3,0xD9,0x57,0x35,0xAB,0x5E,0x18,0x31,0x6B,0x55,0xA5,0x75,0xE8,0x0C,0xAC,0x22,0x76,0xF1,0xDA,
+	0xF4,0x87,0x95,0xE8,0xC6,0x47,0x5E,0xCA,0x07,0xEF,0x7B,0x3D,0xA9,0x79,0x22,0xEC,0x9E,0xAB,0x95,0x1D,
+	0x27,0x6D,0x8C,0x0A,0x27,0xFF,0xD2,0x3E,0xD1,0x38,0xCA,0xBE,0x43,0xA4,0x92,0xB0,0xD9,0x5D,0xB8,0xBC,
+	0xDD,0x16,0xDB,0x79,0xBF,0xDF,0xE4,0xFF,0x94,0xA5,0x93,0xDA,0x2C,0x4A,0x73,0xBB,0x19,0x65,0x72,0x8A,
+	0x28,0x22,0xA1,0x1E,0x3E,0xAD,0x9E,0x20,0xA6,0xBF,0xC3,0xC3,0x61,0x10,0x02,0x01,0x54,0x83,0x9A,0x6A,
+	0xE2,0xDC,0xCF,0x94,0xB7,0x33,0xD5,0x2F,0xE3,0xE5,0x3C,0xA6,0xE6,0x4E,0x79,0xDA,0x58,0x96,0x3A,0xEA,
+	0x6E,0xAF,0x6F,0x8D,0xDB,0x60,0xF3,0x54,0xE8,0xCC,0xD9,0xB1,0xFD,0x69,0xE3,0x14,0x8C,0xC7,0x36,0xE2,
+	0x37,0xC6,0xAB,0xF2,0x39,0x22,0x54,0xBD,0xFC,0x40,0x39,0x1B,0xD5,0x4D,0xAD,0x3F,0x34,0x8B,0x2C,0x35,
+	0x47,0xB0,0xDF,0xFD,0xB9,0x26,0x4A,0xA4,0xD1,0x03,0x0C,0xD6,0x7C,0xFB,0x3B,0x74,0x01,0xFF,0x16,0xEF,
+	0x14,0xF3,0x06,0x49,0x63,0x6A,0x2D,0xF1,0xBF,0x6B,0x5D,0x6B,0xEE,0x3F,0xED,0x0A,0x87,0x74,0x4B,0xA4,
+	0x45,0x2D,0xA7,0x54,0xC0,0x5F,0x6D,0xAC,0xAD,0xFF,0xF7,0x60,0xCD,0xF1,0xC7,0xDC,0x8D,0xE3,0xF5,0x3A,
+	0x96,0xA1,0x04,0xC0,0x44,0x1F,0xAE,0x38,0x95,0xB9,0x50,0x1F,0xE7,0x96,0x94,0xB9,0xC5,0x59,0xB3,0x72,
+	0x5C,0xF5,0xD4,0x06,0xC0,0xBA,0xC7,0x14,0x77,0x28,0x41,0x06,0x7F,0xFA,0xD4,0x21,0xD1,0x92,0xAF,0x3C,
+	0x15,0xF7,0xFD,0x0C,0xD5,0x81,0x3C,0x05,0x74,0xFE,0x36,0xD3,0xA1,0xDC,0xD5,0x87,0xB3,0xB8,0x85,0x1B,
+	0x2A,0x95,0xAD,0x08,0x0C,0xF1,0x0E,0x48,0x47,0x5E,0x6C,0x1D,0x9D,0x27,0x48,0xAC,0x8D,0x8B,0xA0,0x82,
+	0x7A,0xCB,0x48,0x97,0xCC,0x36,0x01,0xE4,0xE0,0x65,0x61,0xBE,0x69,0x62,0x09,0x92,0x7B,0x02,0x27,0x90,
+	0x62,0x31,0x0B,0x10,0xBF,0x7A,0x49,0xAC,0x4D,0x25,0x7A,0xCD,0xDD,0x4A,0x4D,0x85,0x49,0x6F,0x90,0xC1,
+	0xE5,0xBF,0xC5,0x39,0x30,0xD4,0x5F,0x3B,0xCE,0x3A,0x8A,0x8D,0xCF,0x6A,0x76,0xAC,0x7D,0x03,0xFF,0x89,
+	0x5D,0x4B,0xFE,0x11,0xDF,0xFD,0x4E,0x6E,0x8C,0xF8,0x96,0xFA,0xBD,0xB5,0x86,0x78,0xAA,0xE3,0x7B,0xEF,
+	0xFA,0x8D,0x98,0xB9,0x78,0x98,0x9F,0xAD,0xFF,0x9E,0xCC,0x0D,0xFE,0x23,0xCF,0x04,0xDA,0xFD,0xD0,0x39,
+	0xD8,0x9B,0x3B,0x3D,0x3D,0x97,0xBF,0xE6,0x9E,0xDF,0x3F,0xDF,0xFF,0xBE,0x3A,0xFB,0x63,0x9D,0xAA,0x64,
+	0x5E,0x3B,0x30,0xAA,0x41,0x20,0x7C,0xA4,0xAC,0x40,0x30,0xE1,0xA2,0xE1,0x2E,0x72,0x6D,0x6E,0xB4,0xAB,
+	0x40,0xC1,0x90,0xEB,0x32,0xF1,0x16,0x85,0xC7,0x27,0xA2,0x63,0x6F,0x39,0xA6,0x2D,0xE4,0xBF,0x3D,0x67,
+	0x53,0x64,0x3B,0x2F,0x22,0x18,0x31,0xD2,0x53,0xA1,0xA6,0xAA,0x3E,0x02,0xE1,0xB7,0xD0,0xDC,0x94,0xBA,
+	0x8D,0xF9,0x3B,0xA6,0xB3,0xAE,0x2E,0x67,0x44,0xB4,0x54,0xE0,0x47,0xB9,0xCE,0x2F,0xD9,0xFA,0xA8,0x14,
+	0xF1,0xF8,0x02,0x35,0x3F,0xEA,0x18,0x38,0xC0,0x27,0x26,0x3F,0x50,0x0E,0x46,0x15,0x93,0x29,0x49,0x70,
+	0xAF,0x07,0x79,0x51,0x57,0xC7,0xF2,0xCB,0x74,0x46,0xB1,0x72,0x6E,0x28,0xF9,0x03,0xA1,0x7B,0xC0,0x75,
+	0xD5,0xDC,0x86,0x56,0x85,0x6A,0x8A,0x14,0x9A,0x00,0xCD,0x28,0x6C,0x93,0xAA,0x9E,0x08,0xE8,0xF5,0xE8,
+	0xF8,0xB8,0xF2,0x38,0xF8,0x32,0x64,0x3E,0xA8,0xCA,0x45,0x3C,0xDA,0x67,0xA8,0x8C,0x1B,0x35,0x27,0x6F,
+	0xD9,0x0A,0x17,0xD9,0x3D,0x9B,0x4C,0x2C,0x58,0x2A,0xCB,0xCD,0x21,0xF6,0x2D,0xFB,0xBD,0xA0,0x35,0xCA,
+	0x45,0x46,0x7B,0x02,0xFD,0x6D,0xEE,0x33,0xD4,0xF3,0x52,0x0A,0xB0,0xD7,0x2C,0x6F,0xEB,0x93,0x71,0x68,
+	0x16,0x15,0xFA,0x51,0xA5,0x80,0x15,0x49,0x9C,0x2A,0xFA,0x0A,0x29,0x71,0xDF,0x75,0x38,0x58,0x78,0xD7,
+	0x7D,0x4F,0xC5,0xC9,0x9E,0xED,0x09,0x39,0xB6,0xE1,0xB3,0xCD,0xC8,0x6D,0x9F,0xB6,0xE0,0x45,0x63,0xFF,
+	0x44,0x70,0x25,0x7E,0x6A,0x23,0xA3,0x5A,0xB8,0x6A,0x46,0x7F,0xC9,0x99,0xBE,0x7E,0xCB,0x4B,0x4A,0x42,
+	0x64,0xD5,0x05,0x54,0x10,0xD1,0x0A,0xE0,0x05,0x3D,0xF5,0x10,0x69,0xBD,0xCD,0x5E,0xFD,0x15,0xA4,0x73,
+	0xB3,0x51,0xA9,0x1E,0xA3,0x52,0xC5,0x69,0xDC,0x0D,0x80,0x4E,0x09,0x5D,0x04,0x21,0xCA,0x08,0x08,0xD2,
+	0xB1,0x3F,0x50,0xAC,0x86,0x44,0x63,0xB6,0x40,0x8C,0x95,0xA4,0x0D,0x22,0x7C,0x3F,0x87,0x94,0xF7,0x28,
+	0x34,0xDF,0x7C,0x82,0xE3,0x5B,0x6F,0x06,0xDE,0x89,0xB4,0x52,0x02,0x64,0xF4,0x2E,0x9F,0x38,0x74,0x32,
+	0x08,0x5B,0x63,0x12,0xD6,0x6E,0xBD,0xA7,0xE1,0xE4,0x74,0xE1,0x1E,0x53,0x7D,0xE6,0x63,0x12,0xAD,0xC1,
+	0xC1,0x17,0x17,0xD0,0x00,0x56,0xB2,0x92,0x4E,0x81,0x1D,0x75,0xA2,0x19,0x5B,0x13,0x98,0x78,0x86,0x8E,
+	0x08,0x45,0xDB,0x84,0x0B,0x38,0xA2,0xCA,0x97,0x2C,0x56,0x60,0x62,0xD8,0x22,0x0D,0xA0,0x6B,0xDE,0x08,
+	0xD8,0x36,0xC3,0xEC,0x4D,0x5F,0xFC,0xB0,0x78,0xD4,0x1F,0x8A,0xBF,0x1A,0x47,0xF4,0xB0,0x3C,0xB7,0xA7,
+	0x64,0x18,0x06,0xDE,0xCC,0x16,0x23,0x1D,0x20,0x09,0x3B,0xE2,0x1A,0x7A,0x4F,0x24,0x48,0xD1,0x0F,0xC2,
+	0x81,0xD4,0xE5,0x7D,0xF6,0x0F,0x39,0xB2,0xE8,0xE3,0x3E,0x2A,0xE9,0x18,0x01,0xDE,0x85,0xA9,0x5E,0x5C,
+	0x2F,0x3E,0xF4,0x43,0xC4,0xB0,0x36,0x9A,0x4D,0x5B,0xBE,0xBC,0x95,0xF6,0x87,0x30,0x8D,0xE5,0x97,0xBA,
+	0xAA,0x52,0x3F,0xEE,0x69,0x51,0xAF,0x69,0xCD,0xB1,0xF8,0x6C,0xAD,0x5F,0x2C,0x23,0x9F,0x7E,0x57,0x5E,
+	0x0A,0x50,0xDB,0x1F,0xDF,0x64,0x58,0x1B,0xFE,0x46,0x5F,0x3B,0x12,0x93,0x4F,0x5D,0xC9,0x76,0x94,0x7A,
+	0xF5,0x68,0x30,0x16,0x4F,0xA8,0x6B,0x2B,0x13,0xF2,0xBA,0x5D,0x26,0xB0,0xE4,0xB4,0xDD,0x39,0x4E,0x27,
+	0x6D,0xAB,0x17,0x65,0x63,0x29,0x39,0x33,0x90,0x15,0x91,0xC5,0xD2,0x39,0x17,0x67,0xC7,0x7C,0x66,0x69,
+	0x36,0x28,0xAA,0xC0,0x41,0x4E,0x81,0x57,0x85,0x4E,0x60,0xAA,0x56,0xC9,0x08,0xE4,0xB2,0x23,0x93,0x72,
+	0xB9,0x85,0x88,0x64,0x1A,0x6F,0x16,0x82,0x34,0x55,0xF8,0x6B,0xF2,0xE4,0xD4,0x30,0xC4,0x38,0xE8,0x94,
+	0xF1,0xD5,0x1F,0x86,0x96,0xCB,0x01,0x7A,0x13,0xA1,0x9D,0xE3,0x3A,0xE6,0xC4,0x85,0x7A,0x6D,0xD1,0xA0,
+	0xCC,0x97,0xB9,0xFF,0xD1,0x2C,0x33,0x76,0xE6,0xB7,0x69,0xF5,0xD6,0x90,0x1C,0x6E,0x81,0x7E,0xA7,0x33,
+	0x1A,0x9B,0x60,0x7C,0xA7,0xAC,0xB1,0xE9,0x9E,0x61,0x14,0x7F,0x2C,0xC9,0xBB,0x23,0x1B,0xFA,0x85,0x75,
+	0xD8,0x14,0x23,0x3C,0xA8,0xA9,0x6B,0x0F,0xC4,0xC3,0x53,0x6D,0x6B,0x21,0x0B,0xD4,0xE8,0xB6,0xFB,0x3E,
+	0xDA,0x11,0x6D,0x7E,0x64,0x22,0x35,0x61,0x3E,0xEA,0x92,0x40,0x40,0xA9,0xE0,0x7F,0x3C,0x44,0xDA,0xB9,
+	0x49,0xCD,0xA2,0x7F,0x27,0x03,0x28,0x6F,0x32,0x33,0xC8,0x8C,0xDC,0xE4,0x5A,0xA9,0x8B,0x00,0xF3,0x61,
+	0x9B,0x72,0x30,0x80,0x92,0xC3,0x82,0x1C,0x1C,0x1D,0x3A,0x62,0x2B,0x0F,0x43,0xBF,0x20,0x0D,0x49,0xD7,
+	0x39,0x32,0x02,0x0D,0x9D,0x31,0x39,0x00,0x64,0xEB,0x36,0x43,0x67,0xD4,0x13,0xFD,0x33,0x8E,0x83,0xFD,
+	0xDE,0xF8,0x84,0x20,0x24,0x90,0x9E,0x7C,0xC5,0xDC,0xCF,0x40,0xE6,0x98,0x14,0xD4,0x02,0x5F,0x20,0xC4,
+	0xFE,0x91,0xF6,0xD2,0x45,0xF3,0x6C,0x2F,0xC4,0x5B,0x2C,0x45,0xF1,0x7C,0x85,0xBD,0xA4,0x92,0xC3,0x5F,
+	0xB7,0x50,0xFF,0xD1,0x47,0xD4,0x11,0xD5,0x7A,0x6D,0x01,0x3A,0xA5,0x3E,0xF8,0x5A,0x14,0x4C,0x42,0x51,
+	0x67,0xD0,0xEF,0xE1,0x1E,0x97,0xB6,0xFD,0x14,0xD6,0x24,0x8B,0x56,0x1F,0x14,0xA2,0xC0,0xD9,0x5F,0x80,
+	0x36,0xBB,0x28,0xD6,0x58,0xF0,0xC4,0x2F,0x35,0x2E,0x36,0xEF,0x26,0xD0,0x57,0x90,0xF8,0x73,0x3A,0xAF,
+	0xA0,0xED,0xB5,0xC4,0xDD,0x95,0x7F,0xE2,0x45,0xDB,0x35,0x1B,0x2A,0xED,0xC0,0xAC,0x3A,0x8C,0x18,0xC4,
+	0x86,0xDF,0x05,0x71,0xE6,0xD0,0xFC,0xB7,0xE7,0xB5,0xA7,0x65,0xD5,0xE9,0xDC,0xEE,0x24,0x04,0x71,0xD8,
+	0xCF,0xDE,0x26,0x5D,0xF8,0x75,0x91,0xDD,0xB3,0xC4,0xAB,0x76,0xF1,0x79,0x6E,0x37,0xCE,0x99,0x85,0x5C,
+	0x59,0xF4,0xDA,0xF9,0x82,0xC5,0x9C,0xD4,0xBA,0xD1,0x17,0xD2,0x4D,0xDC,0xE5,0x81,0x17,0x9E,0x35,0x99,
+	0x1E,0x10,0xAC,0x9D,0x10,0xFA,0x60,0x69,0xEB,0x19,0xA9,0xDD,0x06,0x76,0x7A,0x4E,0x72,0x0D,0xC0,0xA7,
+	0x7F,0x49,0xCD,0x08,0xC2,0x21,0x7B,0x53,0x78,0x37,0x56,0xEA,0x91,0x32,0x73,0xBB,0xB2,0x10,0x88,0x88,
+	0xCC,0xDB,0xC4,0x01,0x82,0x7C,0xDA,0xFA,0x0F,0x3F,0xB3,0xF1,0x9C,0xFE,0x0F,0xCF,0x6C,0xD6,0x18,0x29,
+	0x9E,0xBF,0xCF,0xA9,0xCD,0xA3,0xB5,0x4D,0xB7,0xB5,0x77,0x4D,0x4E,0x55,0xEC,0x04,0x1E,0x7C,0xD0,0xFA,
+	0xF9,0x89,0x3B,0xE6,0xBC,0xDD,0x49,0xBA,0x27,0x86,0xC9,0x0F,0xF5,0xB1,0xAC,0x62,0xA2,0xF1,0xC8,0xD3,
+	0x22,0xC6,0x20,0xCE,0xC3,0x49,0x90,0x31,0x57,0xBA,0x85,0xF2,0x04,0x96,0xF9,0x21,0xB0,0x33,0x81,0xA3,
+	0xC1,0xA7,0x69,0x43,0x5D,0x94,0xFE,0x91,0x3C,0x42,0x31,0x87,0xE1,0x31,0xAF,0x53,0x4C,0x95,0x65,0x11,
+	0xE2,0xFF,0xE7,0x46,0xE9,0x60,0x46,0xD5,0x2F,0x89,0x0E,0x82,0x46,0xC1,0x10,0x99,0xD4,0x91,0xA9,0xA0,
+	0xFC,0x4A,0xF0,0xAA,0xBF,0x28,0x66,0x92,0x21,0x12,0x70,0xC1,0xDE,0xEE,0x7E,0xA3,0xA6,0x1D,0x5C,0xC1,
+	0xE5,0x22,0x43,0x49,0x29,0x02,0x87,0x61,0xB5,0xC5,0x10,0x73,0x24,0x8A,0x36,0x71,0x1C,0x8A,0x27,0x76,
+	0xE7,0xDC,0xD8,0xEA,0xE0,0x72,0x62,0x49,0xF1,0x05,0x3A,0x7C,0x98,0xAE,0xBE,0xB7,0x49,0x28,0x2A,0xC2,
+	0x48,0x25,0x32,0xC8,0xFE,0x06,0x1A,0x5B,0x3D,0x47,0x52,0xDA,0x6D,0x0B,0x2F,0xC1,0xE8,0xB2,0x49,0xF7,
+	0x2B,0x6F,0xA7,0x4D,0x9C,0x44,0xFF,0x2B,0xC0,0x26,0x6E,0xD4,0xDA,0xF1,0xBF,0xE9,0xD5,0x04,0xCB,0x22,
+	0x91,0x47,0x40,0xEC,0xB6,0x49,0xE9,0x39,0xA4,0x33,0x1B,0xD2,0xAD,0x17,0x09,0xDF,0x6B,0xA7,0x76,0x91,
+	0xCB,0x39,0x2A,0x48,0xA7,0x2E,0x34,0x51,0x38,0x0B,0xAB,0x78,0x99,0x25,0x3B,0x84,0xD7,0x0D,0x5A,0x61,
+	0x18,0x21,0x77,0xAF,0xAE,0x83,0xE3,0xA7,0xF3,0x94,0x4E,0x47,0xFB,0xB5,0x11,0xE5,0xE9,0x47,0xB1,0xDB,
+	0x8A,0x78,0x46,0xAD,0x97,0x20,0xC4,0x35,0xB4,0x4F,0xAF,0x80,0x9F,0x2D,0xC4,0xF1,0x90,0x9D,0x44,0xE5,
+	0x9E,0x71,0x6C,0x5E,0x5F,0x70,0x74,0x9B,0x54,0x1C,0xF6,0xD6,0x39,0x5D,0x1B,0x10,0x76,0x97,0x67,0x29,
+	0x9C,0xE0,0xFC,0x22,0x33,0xD5,0x7B,0x88,0x93,0x14,0xBF,0x7A,0xD3,0xDD,0x95,0xA0,0x51,0xDF,0xC8,0x26,
+	0x1D,0x69,0x8E,0xD7,0xED,0x08,0xB5,0x6B,0x3C,0x51,0x63,0xB7,0x00,0x80,0x1C,0x57,0x11,0xCC,0xB7,0xED,
+	0xC1,0x55,0x5E,0x26,0xD2,0x85,0xD5,0xFE,0xC1,0xD1,0x2B,0x1B,0x8D,0x8B,0x06,0x2B,0x80,0x13,0x37,0xF0,
+	0xD2,0x2E,0xCC,0x72,0x66,0x11,0x23,0x0B,0x8C,0x8A,0x25,0x80,0x57,0x1B,0x3A,0xB7,0xD8,0x39,0x2A,0x65,
+	0xD1,0xAF,0x2A,0x1A,0x0D,0x89,0x41,0xAA,0x02,0x9F,0x09,0x33,0x80,0x77,0x67,0x13,0x61,0x14,0x22,0x0A,
+	0x0C,0x88,0x67,0x7E,0xAD,0x18,0xFE,0x91,0xC6,0x68,0x68,0xAF,0xC9,0xC9,0x56,0x44,0x05,0x39,0x41,0x9A,
+	0x42,0xC3,0xD7,0x3C,0x9C,0xC6,0xB1,0xC2,0xB4,0x18,0x1E,0x5E,0xFB,0x3A,0xEF,0x8D,0x8C,0xB1,0xFB,0x89,
+	0x8B,0x3A,0x6C,0xD2,0xCB,0x75,0xF7,0xE9,0x83,0xF1,0x0F,0x71,0x86,0x90,0x8E,0xFB,0x42,0x79,0x91,0xE4,
+	0xB4,0xD3,0x95,0x39,0xA5,0xE2,0x42,0x2A,0x0E,0x5E,0x3E,0x24,0x64,0x73,0xDE,0x0A,0xC6,0x53,0x29,0x13,
+	0x85,0x83,0xB9,0xDD,0x27,0x5D,0x9E,0x31,0x2B,0x86,0xB2,0x63,0x6A,0xDD,0x21,0x03,0x84,0x82,0x81,0xF0,
+	0x8B,0x7E,0x57,0x31,0x3A,0xC5,0xD7,0x10,0x29,0xA3,0x28,0x12,0x05,0x81,0x14,0x59,0xAD,0xC4,0x81,0xD9,
+	0xCC,0x92,0xE0,0x62,0x14,0x1E,0x20,0x02,0x04,0x80,0x40,0x43,0xF1,0x8D,0x88,0xC4,0xE9,0xA3,0xEB,0x8D,
+	0x42,0x58,0x1C,0x58,0x35,0xE4,0x97,0x4E,0x26,0xE1,0xA8,0x17,0x41,0xAF,0x68,0xB7,0x49,0x83,0x98,0x23,
+	0xD8,0x6C,0x2B,0x07,0x27,0xC3,0x99,0x16,0xC8,0x55,0x59,0xA7,0xD3,0xD4,0xD3,0x25,0xD5,0xA2,0xD2,0xEE,
+	0x8D,0x3E,0xC1,0x91,0x69,0xE2,0xF8,0x14,0xC1,0xB9,0x5E,0xC8,0x34,0x35,0x18,0x52,0xA5,0xCA,0x80,0x06,
+	0x03,0x29,0xAB,0x80,0x40,0x9F,0xAF,0x0A,0x72,0xA8,0xEC,0x20,0xA4,0x86,0x92,0x24,0xB4,0xD1,0x06,0x83,
+	0xC2,0xA4,0xA7,0x1A,0x73,0xE3,0xD0,0x67,0x04,0x85,0x99,0x63,0x14,0x5A,0x39,0x11,0x2D,0x4D,0x85,0x9A,
+	0x96,0xA4,0x96,0xA8,0x05,0x84,0x20,0xBA,0x9F,0xE7,0xE9,0xF7,0xF2,0xF3,0xF1,0x10,0x2A,0xE8,0x29,0xEA,
+	0x00,0x17,0x62,0xE3,0xDE,0x05,0xD2,0x59,0x29,0x49,0x49,0x0A,0xD3,0xEA,0xCE,0x64,0x2C,0xE9,0xAF,0xE1,
+	0x1B,0x02,0x42,0x08,0x2D,0xC9,0xD2,0x3E,0x36,0x0D,0x7C,0x0A,0x8A,0x1A,0xA6,0xEF,0xCC,0x01,0xC8,0x1A,
+	0x6D,0x3E,0x04,0x2E,0x51,0xE6,0xF4,0xE4,0xA9,0xCA,0x3E,0x9B,0xEA,0x97,0xC4,0x48,0x6E,0x48,0xBF,0x3F,
+	0x5E,0xE5,0xE6,0xBA,0x06,0x83,0x3C,0x8D,0x9C,0x50,0x12,0x68,0x4F,0xC1,0x62,0xEC,0x5F,0x12,0xD1,0x05,
+	0xEE,0x32,0xCC,0x9B,0x08,0xED,0x85,0x98,0x6B,0xD6,0xE8,0x6B,0xB4,0x26,0xF3,0x39,0x79,0x72,0x99,0xBF,
+	0x96,0xA1,0x01,0x45,0xC2,0x45,0xC9,0x8D,0xFA,0x13,0xAB,0xA2,0x68,0x5F,0x35,0x9C,0x62,0x0B,0x1B,0x0D,
+	0x38,0x62,0x6B,0x80,0x20,0x10,0xFB,0x64,0x34,0x1B,0xBD,0x7C,0xD5,0xAB,0x39,0x6A,0x3B,0x38,0xF2,0x77,
+	0x3F,0x5A,0x67,0x74,0x16,0xDB,0x54,0xB2,0x33,0xF1,0xF3,0x13,0x47,0xB2,0xC3,0x49,0x9C,0xA1,0xDA,0x65,
+	0x45,0x89,0xA5,0x61,0x87,0x53,0x7F,0x0A,0xC6,0xD1,0x25,0xD4,0xE0,0x73,0xD5,0xB7,0x44,0x3C,0x7F,0xD1,
+	0x17,0xFD,0x6D,0xB3,0x92,0x89,0x51,0x25,0xB5,0xFB,0x6E,0xE6,0x20,0x76,0x24,0x5B,0x6E,0x4F,0xD8,0x99,
+	0xB8,0x2B,0x0B,0x19,0x89,0x0B,0x37,0x52,0xD9,0xB5,0x31,0xED,0xB5,0xBD,0xD8,0x9D,0x46,0x15,0x03,0x09,
+	0x88,0x0A,0x72,0x23,0xAA,0xD6,0x3F,0x3B,0xB2,0xF6,0xE5,0xFC,0x62,0x02,0x0A,0x18,0x09,0x09,0xE9,0x57,
+	0xD0,0x1F,0x19,0xB5,0x48,0x3A,0xB8,0x88,0x44,0xB2,0x02,0x08,0x08,0x08,0xFC,0x62,0xDA,0xD7,0xD2,0xAA,
+	0xBB,0x1F,0xE4,0xD9,0x51,0xB4,0xB4,0xD1,0x72,0x78,0x2F,0x7C,0x3D,0xD6,0x4B,0xD8,0x97,0xF8,0x09,0xD7,
+	0x25,0xA0,0x3A,0xE1,0x9C,0x08,0x8F,0xA7,0xBC,0xD5,0x0F,0x29,0xBA,0x41,0x55,0x37,0xEF,0x6A,0x48,0x8B,
+	0x21,0x73,0x2E,0x7D,0x28,0x0A,0xF6,0x85,0x18,0x64,0x00,0x3F,0x9A,0xDF,0x40,0xCD,0x9F,0xB8,0xF6,0x4E,
+	0x60,0x2D,0x9E,0xB1,0x9D,0xFD,0x56,0x1D,0x4A,0x51,0x09,0x11,0x81,0x03,0xEA,0xDE,0x58,0x15,0xE9,0xDB,
+	0x39,0x86,0x86,0x12,0xD7,0x92,0x01,0x01,0x80,0x02,0x7F,0xCE,0x50,0xFE,0x27,0x7F,0xDA,0xBF,0x2E,0xC5,
+	0x49,0xCE,0x08,0x10,0x01,0x01,0xAF,0x23,0xAD,0xDE,0x08,0xFB,0x63,0x1C,0xD7,0x4E,0xEB,0x04,0x00,0x00,
+	0x8A,0xE1,0x80,0x19,0x0D,0x40,0xD0,0x08,0x50,0xDB,0x16,0x7E,0xCD,0x22,0x2B,0x94,0xCC,0xCF,0xBF,0x11,
+	0x8C,0x0D,0x8C,0x0B,0x7D,0x8A,0x0E,0x88,0xAA,0xD2,0x0C,0xC8,0x51,0xD4,0x04,0x2D,0x0F,0x00,0x01,0x07,
+	0x94,0xD9,0xBA,0xA4,0x53,0x7D,0x86,0x27,0x82,0x97,0x61,0x6E,0xC2,0x63,0x9F,0x11,0x78,0x82,0xA2,0x80,
+	0xFF,0xEC,0x17,0xCD,0xD1,0x21,0x78,0xBF,0xF7,0x67,0x10,0x03,0x71,0x64,0x7D,0x8D,0x4A,0x40,0xC5,0x62,
+	0x9A,0x75,0x36,0x6C,0xF6,0x86,0xDE,0x36,0x73,0x6D,0xE9,0x99,0x20,0x31,0xE0,0x33,0x99,0xC6,0xBA,0x3E,
+	0xE2,0x10,0xA7,0x74,0x79,0x75,0xD3,0x8C,0xCA,0x1D,0x75,0x07,0x25,0x03,0xEC,0xA2,0xFB,0x03,0xB0,0x23,
+	0x60,0x37,0x0E,0x7F,0xB5,0x73,0x26,0x0B,0x19,0xE4,0x1A,0x05,0x6B,0x68,0x6E,0x9F,0x7C,0x22,0xC7,0x7A,
+	0xFB,0xC2,0x91,0xA3,0xA5,0xC9,0xF1,0x47,0x4A,0x96,0xB4,0xCD,0x38,0x89,0x49,0x6A,0x0A,0xB9,0x61,0x43,
+	0x39,0x7F,0x94,0xF6,0x69,0xD9,0x07,0x09,0xD8,0xA3,0x6B,0x63,0xF9,0xE7,0xAB,0xD2,0x2D,0x09,0xA4,0xDB,
+	0x0A,0x4D,0xD5,0x20,0x91,0x2F,0x12,0xCA,0xFF,0xE6,0xE5,0x01,0x2C,0xE8,0x52,0x3B,0x26,0xAD,0x78,0xB7,
+	0x25,0xBC,0x85,0x47,0x30,0x19,0x29,0x43,0x6E,0x39,0xB1,0x63,0x46,0x96,0x0A,0x45,0xD4,0xF0,0x59,0x7E,
+	0xB4,0x2E,0xD9,0x3B,0xD6,0xCB,0x8B,0xB6,0x6B,0x6D,0x74,0xE8,0x6E,0x6D,0x80,0x42,0xB4,0x0C,0x46,0x46,
+	0xAA,0x2C,0x4B,0xDD,0xDB,0x79,0xE3,0x3F,0x66,0x23,0x3D,0x1B,0x3C,0xB2,0x0D,0x86,0x32,0x60,0x16,0x73,
+	0xA4,0x9D,0x91,0xA6,0x5B,0x61,0x91,0x87,0x89,0xD1,0x38,0x37,0x7F,0x78,0x36,0x72,0x69,0x90,0xD2,0xAC,
+	0xB0,0x35,0x65,0xE6,0x94,0x9D,0xA2,0x64,0x53,0x7C,0x57,0xCB,0x4B,0x76,0x81,0x74,0x8C,0x07,0x03,0xC3,
+	0x80,0xC8,0x11,0xA1,0xB0,0xFB,0x33,0xA1,0x43,0xC3,0x0A,0x64,0x81,0x06,0x1C,0xE7,0x1C,0x9F,0xD9,0x44,
+	0xC1,0x46,0x52,0xFC,0xC9,0xC5,0x68,0xBF,0xEC,0x9B,0x6E,0x13,0x02,0xF9,0x85,0x04,0x76,0xD4,0x5B,0xF0,
+	0x7B,0xCC,0x9E,0xA7,0x05,0x94,0x54,0xF5,0x67,0xD5,0xFF,0xF3,0x9A,0xE6,0xFE,0x70,0xDA,0xB9,0x93,0xBF,
+	0x64,0x99,0x47,0xA6,0x20,0xB6,0x84,0x75,0x19,0x32,0x73,0x00,0x81,0x1A,0xF5,0xE5,0xE0,0x28,0x92,0x01,
+	0x50,0xF6,0xA5,0xE4,0x93,0xFC,0x39,0xFA,0xC3,0x99,0xD8,0xA5,0x18,0x93,0xCD,0xA4,0x17,0x3D,0xC8,0x85,
+	0xD9,0xD3,0x8E,0xAA,0x49,0x49,0xBB,0x6D,0x49,0x31,0xDE,0xB5,0xC5,0xF4,0x2F,0x4D,0x09,0x79,0x39,0xB9,
+	0xC3,0x15,0x16,0x8C,0xD3,0x4B,0xA2,0x9C,0x10,0x09,0x06,0xAC,0x93,0x0B,0xF0,0xEA,0x0A,0x98,0xDF,0x84,
+	0xB5,0x7B,0x0D,0x88,0x48,0xDA,0xBF,0xA0,0x92,0x6A,0x52,0x68,0x7A,0x0C,0x7C,0x36,0x2A,0xF1,0x44,0x1B,
+	0xEE,0xD1,0x56,0xDD,0x42,0xD3,0x13,0x28,0xAB,0xCD,0x1E,0x58,0x63,0xD3,0x66,0x98,0x67,0x1D,0xA0,0xD4,
+	0x18,0x3D,0x9A,0xC8,0x9D,0x4B,0xB8,0xF2,0x94,0xEB,0x05,0xBE,0x01,0x3A,0xC2,0x9F,0x90,0x6F,0x71,0x85,
+	0xCB,0x94,0x74,0x9F,0x1A,0xC2,0xDB,0xA2,0x02,0x6E,0xC9,0xC5,0x10,0xEE,0x97,0x26,0x22,0xC0,0x24,0x74,
+	0xFF,0x51,0x63,0xF2,0x18,0x6F,0x15,0xD5,0x2C,0x15,0x9F,0x13,0x88,0x8D,0xB0,0x13,0x11,0x81,0x5A,0x8F,
+	0x44,0xB1,0x80,0xC8,0xA8,0x40,0x21,0x27,0x0B,0x80,0x9F,0x36,0xF5,0xE2,0xA7,0x50,0xF2,0xAC,0x26,0x58,
+	0xFA,0x44,0x41,0x0C,0xA9,0x82,0x5A,0x64,0xB9,0xCF,0x60,0x58,0xA6,0x3C,0x81,0xC8,0x20,0x80,0xDF,0x73,
+	0xA7,0x7B,0xD8,0x35,0x20,0x05,0x66,0x00,0xB9,0x19,0x96,0xD2,0xA5,0xA6,0x7A,0xD8,0xEC,0x54,0x52,0xAC,
+	0x07,0x68,0x6D,0x81,0x7F,0x18,0x5F,0xCE,0xD8,0x48,0xDA,0xE6,0x71,0x7B,0xD9,0x77,0xC5,0xB9,0xA5,0x9D,
+	0x3B,0x67,0x72,0xF8,0x02,0x95,0xD2,0xE3,0x1B,0x28,0x96,0x68,0xBD,0x72,0x2F,0x5B,0x2C,0xD6,0xAA,0xE5,
+	0x28,0x4A,0x25,0x0F,0x08,0x88,0xC4,0xCA,0x1D,0xC8,0xCA,0xC2,0xA9,0x87,0x49,0x51,0x34,0x39,0x74,0xB3,
+	0x0D,0x04,0xE0,0xBE,0xBC,0x8B,0xBF,0xC7,0x61,0xBC,0xAD,0xCD,0x25,0xA9,0x5D,0xFA,0xBE,0x96,0x23,0x1F,
+	0xC3,0x07,0xB3,0x3B,0xAD,0x11,0xCD,0x13,0x29,0x49,0x55,0x2B,0x6C,0x2A,0xF5,0x37,0x25,0x00,0xAD,0x00,
+	0xFB,0x89,0x3B,0x76,0x34,0x8A,0x75,0x75,0x72,0x71,0xB2,0xCA,0x46,0x42,0xCD,0x5B,0x3E,0x63,0x27,0xFC,
+	0x5E,0xE4,0xD5,0x6B,0xAE,0x72,0x55,0x05,0x9C,0xA0,0x04,0x57,0x6F,0x7D,0xA4,0xC6,0xA0,0x4D,0xB7,0xD8,
+	0x2F,0x51,0xC8,0x31,0x4F,0x12,0x60,0x15,0xA4,0xBF,0x71,0x9E,0xE0,0xEE,0xD0,0xFE,0x78,0x72,0x14,0x9D,
+	0x3E,0x70,0xFF,0x7F,0xC3,0xD2,0xAE,0x0C,0xE5,0x7A,0x74,0x7C,0xD9,0x19,0x24,0xCF,0x16,0xC0,0xBC,0x48,
+	0xA1,0x0D,0x81,0x57,0x4C,0xF9,0x88,0xF0,0xDE,0x0A,0x60,0x69,0xD4,0xD2,0x96,0xA3,0x05,0x7C,0x29,0x9D,
+	0x1E,0x60,0xA1,0x70,0x20,0x46,0x35,0xF4,0x98,0x13,0x9F,0xAB,0x21,0x2F,0xEB,0x8B,0xFC,0x59,0x2D,0x7B,
+	0x44,0xDE,0x56,0xAC,0xF8,0x28,0x2F,0xF4,0x27,0x93,0x9D,0x97,0xAD,0xC9,0x9B,0xB0,0x44,0xC1,0xCC,0xA4,
+	0xDF,0xE7,0x66,0xFE,0x8D,0x90,0xCE,0x57,0x4A,0x5B,0xB1,0xD3,0xBB,0x26,0x95,0xA0,0xC4,0xA5,0xD8,0x90,
+	0x8C,0xD6,0xDA,0xAF,0x17,0x58,0x9C,0x88,0x5B,0xAA,0xF3,0xA5,0xD6,0xFE,0x4F,0x52,0xD6,0x79,0x60,0xE3,
+	0xF2,0x9A,0xCC,0x6F,0x3F,0x64,0x57,0x2C,0x4B,0x94,0xC9,0x91,0x0C,0xF4,0xEF,0x30,0x35,0xF7,0xDD,0x82,
+	0x89,0x67,0xA6,0x0A,0x6C,0xCE,0x7E,0xAF,0x68,0xD8,0xE6,0xA3,0x2A,0x0D,0xC0,0x84,0x13,0x6D,0x15,0x3B,
+	0xCA,0x44,0xE1,0xBA,0xED,0x99,0x30,0x46,0x7D,0xBB,0xFA,0x87,0xAA,0x2A,0x18,0xBE,0x1D,0x45,0x7D,0x0B,
+	0xFC,0x5A,0x23,0x53,0xFC,0x4F,0x7C,0xE8,0xDF,0x80,0xBD,0x15,0x56,0x6A,0xE0,0xBA,0x31,0x1A,0xBC,0x30,
+	0x00,0x5A,0x46,0x57,0x0C,0x0C,0x55,0x6E,0x38,0x0C,0xC3,0xC6,0xDA,0xAD,0xFE,0x97,0xB6,0xCD,0x34,0x25,
+	0xCE,0x1E,0x90,0x6B,0xBC,0xB0,0xFD,0x7E,0x3F,0x00,0xC6,0x00,0xD3,0xF0,0x27,0xB8,0xFB,0x1F,0x09,0x0D,
+	0x1F,0x4F,0x42,0xD3,0x6C,0xDE,0x57,0xFC,0xCE,0x9A,0xDE,0x35,0x36,0x62,0x3C,0x2C,0xD9,0x1B,0x01,0x5E,
+	0x27,0xD0,0x00,0xD0,0xCB,0xAA,0x95,0x2B,0x70,0x42,0x00,0x06,0x14,0xDB,0xCB,0x20,0xB8,0x58,0x27,0x68,
+	0x27,0x60,0x70,0x94,0x55,0xF7,0x08,0x7B,0x9E,0x87,0xFD,0x4F,0x29,0x4C,0x58,0x2C,0xCF,0x9C,0x02,0x46,
+	0x7B,0x97,0x85,0x1A,0xBC,0x59,0x4A,0x21,0xC6,0xD2,0xA6,0x6D,0xA3,0x62,0x2F,0x2D,0x05,0xA7,0x9A,0xD5,
+	0x9D,0x63,0xE6,0x4F,0xEF,0xFF,0xC0,0x31,0x5C,0x00,0x00,0x33,0x3E,0x0F,0xE6,0xFE,0xE3,0x8F,0x31,0xC0,
+	0x40,0x3D,0xEE,0xB4,0x70,0x69,0xFF,0x69,0xFE,0x66,0x4A,0x3C,0x09,0x65,0x58,0x30,0x6D,0x46,0xE8,0x76,
+	0x13,0xBE,0xC5,0x45,0xCE,0xA5,0x3C,0xCD,0x84,0x66,0x6F,0x4D,0x4D,0xC0,0x53,0x99,0x6A,0x9D,0x2F,0x33,
+	0x74,0xFA,0x4B,0x35,0x7A,0x76,0x5E,0xF1,0x0B,0xE6,0xEC,0x88,0xF3,0xB3,0x15,0x0F,0xFD,0x07,0x04,0xA5,
+	0xF1,0x82,0xAD,0x73,0xBB,0x4B,0x39,0x89,0x8D,0x76,0x0E,0x29,0x77,0xA6,0x9D,0x1D,0x99,0x49,0x22,0xC3,
+	0xB8,0x2A,0x8F,0x42,0x33,0x78,0xB7,0x76,0x2B,0x81,0xD3,0x6F,0xD0,0x81,0x12,0x3C,0x31,0xEB,0xEE,0x1C,
+	0xE0,0xC5,0xDC,0x6B,0xE3,0xD8,0xB1,0xEE,0xE1,0x56,0x60,0x4A,0xCA,0xC7,0xE5,0x15,0x11,0x01,0x54,0x2A,
+	0xF5,0xD1,0x2E,0xDE,0x1A,0x24,0xF2,0x7B,0x2A,0x28,0x44,0x73,0x6A,0xC7,0x5C,0xAB,0x63,0xD0,0xEC,0x6D,
+	0x9F,0x89,0x22,0xFC,0x1B,0xF8,0x82,0x7E,0x30,0xDA,0x97,0xB7,0x77,0xAF,0xD3,0xED,0xC2,0x2C,0x6D,0x17,
+	0x02,0xB3,0xC6,0xFE,0xB1,0x3F,0x1D,0x69,0x60,0x8E,0xD9,0x5A,0x72,0xF2,0x7B,0x60,0x03,0xEE,0x5F,0xF0,
+	0x32,0xE5,0xBB,0xB1,0x50,0xBF,0x92,0xE6,0xCF,0xED,0x44,0x3E,0x9B,0xFB,0x71,0xDB,0x18,0x7D,0x72,0xBD,
+	0xC8,0xF0,0x1A,0x67,0x5D,0xEC,0xC4,0xC2,0x8A,0xF7,0x23,0x85,0x1D,0xDE,0x16,0xFF,0xCA,0x63,0x51,0x7B,
+	0x4D,0x93,0xF7,0x32,0x8B,0xB4,0x6A,0xDB,0xDE,0xAD,0x53,0x73,0xA5,0x96,0xDB,0xA1,0x5A,0xF2,0x43,0x23,
+	0xA1,0xFC,0x0B,0xCB,0x9B,0xB2,0x45,0x33,0xC2,0x58,0x73,0xC5,0xBF,0x38,0x5D,0x00,0x12,0xF0,0x56,0x18,
+	0xCA,0x8F,0x6B,0xD4,0x48,0x61,0xDE,0xAB,0x53,0x34,0x02,0x12,0x67,0xD0,0xE9,0x09,0x52,0xA1,0x24,0x32,
+	0x72,0xBD,0xAD,0xDA,0x9E,0x82,0x5A,0xCD,0x0B,0xBE,0xED,0xE7,0xB2,0xAD,0xCF,0x17,0x31,0x14,0xB3,0xED,
+	0x52,0xB4,0xEE,0x13,0x8B,0xB6,0x4B,0xEA,0xC3,0xDA,0xB5,0x6A,0x40,0xC9,0xA6,0x09,0xD1,0x22,0xF5,0x5B,
+	0xB6,0xF3,0xE8,0x98,0xF8,0x1A,0x19,0x6B,0x51,0xBB,0x40,0x39,0xCE,0xC4,0x40,0x8E,0xA3,0xF2,0x61,0xCF,
+	0x36,0x1A,0x79,0xB5,0x5D,0xB9,0x91,0xEF,0x47,0x97,0x70,0xA1,0x03,0xCC,0xA9,0x65,0x90,0x77,0x1D,0x9B,
+	0x79,0xB9,0x99,0xA8,0x52,0xDA,0xA9,0x59,0x02,0xFE,0x64,0xC2,0x91,0x9A,0xA5,0x33,0xE2,0xEB,0x77,0x3F,
+	0x06,0x3F,0x28,0xDD,0x9F,0xFF,0x41,0xD2,0x0E,0x67,0x68,0x63,0xD0,0xB9,0xEE,0xD8,0x44,0x7D,0x49,0x87,
+	0x45,0xFB,0x0A,0xA2,0xE8,0x42,0xB8,0xDA,0x5C,0xC1,0xC6,0xDD,0xC5,0x3E,0xC5,0x1A,0x8E,0xAB,0x57,0xAA,
+	0xD4,0xA2,0x3C,0x23,0x13,0x6E,0x68,0xE4,0x47,0x67,0x67,0x07,0x16,0xFE,0xCD,0x1D,0x10,0x2E,0x5E,0xBE,
+	0xB8,0x33,0xBA,0x02,0x37,0x3A,0x7A,0xC0,0x05,0xD0,0x25,0x86,0x48,0xF0,0x2B,0x14,0xFA,0xE2,0xBD,0xF6,
+	0xDD,0xEB,0x39,0xC3,0xA1,0x67,0x2E,0xBC,0xD5,0x92,0xD8,0x28,0xFA,0xC0,0xFF,0x2F,0x5E,0x09,0x4F,0xB0,
+	0xAF,0x74,0xEF,0x13,0x48,0x49,0x4F,0x71,0x72,0x7E,0x3C,0xB7,0x89,0x00,0x67,0x04,0xE6,0x68,0xE7,0x03,
+	0x49,0x48,0x46,0x1B,0x32,0x51,0xC6,0x39,0xB5,0xE6,0xD0,0x71,0x26,0xA0,0xA0,0x04,0x12,0x3F,0x8A,0x4D,
+	0xC9,0x08,0xCE,0x67,0x93,0x01,0x46,0x0D,0xE4,0x67,0xFA,0x8A,0xEF,0x1E,0x70,0x7C,0xBE,0x52,0xE2,0x7C,
+	0x16,0x16,0x4F,0x1D,0x65,0xA3,0xC4,0x9A,0x57,0xE2,0x17,0xC0,0xEC,0x01,0xFB,0x50,0x7E,0x7A,0xE8,0x00,
+	0xEB,0x6C,0xF1,0x69,0xBB,0x13,0x34,0x68,0xF3,0x55,0x9C,0xC6,0x55,0x42,0x04,0x28,0x27,0x4D,0x24,0xA4,
+	0xB5,0xF2,0x3F,0xE9,0x35,0x54,0x51,0x25,0x12,0x36,0x19,0x21,0x95,0x62,0x0D,0x6B,0xAA,0x5C,0xF7,0xF5,
+	0x71,0x2B,0xFB,0x97,0x60,0x42,0x31,0x6D,0x5E,0x5E,0xBD,0xFA,0xFF,0x78,0x7D,0x33,0x66,0x9A,0x6B,0x07,
+	0x03,0x56,0x9E,0xA3,0x4A,0xDD,0x73,0xC5,0xDB,0x7B,0xE2,0x54,0xD8,0x78,0x9A,0x69,0xF7,0x51,0x0A,0x6E,
+	0xAE,0x19,0xE3,0x9F,0x66,0x4A,0x09,0x5E,0xE4,0x48,0xEF,0x9C,0x9C,0xEB,0x6C,0x04,0x25,0x4C,0x34,0xC5,
+	0x5B,0x9C,0x84,0xB8,0x54,0x25,0x9B,0xC2,0x9A,0x0E,0x0B,0x5A,0xA6,0x61,0xAD,0x43,0xBD,0xEA,0x15,0x6C,
+	0xE4,0x2A,0x5C,0x7B,0x10,0xAD,0x05,0x4B,0x7A,0x66,0xC5,0xAF,0xFD,0xE2,0x32,0x86,0x2C,0x40,0x1F,0x37,
+	0x50,0x1F,0x6A,0x90,0x60,0x9C,0xCA,0x93,0x81,0x53,0xBC,0x55,0x27,0x64,0x94,0x69,0xDC,0x8B,0x1B,0x43,
+	0xF9,0x91,0x75,0x87,0xD4,0x0E,0x4D,0x41,0x22,0x67,0x37,0xF4,0xA3,0x13,0x54,0xB9,0x34,0x66,0x27,0x54,
+	0x90,0x5F,0x29,0xD4,0x24,0x9D,0x79,0x69,0x48,0x12,0xD5,0x39,0xC7,0x05,0x83,0x7E,0xDB,0x2C,0x59,0x22,
+	0x2A,0xD4,0x3F,0xC6,0xCE,0xAC,0x4C,0x1D,0x93,0xB7,0x4F,0x56,0xBC,0x5B,0xD5,0x32,0x2B,0xD5,0x09,0xA9,
+	0x5F,0xB8,0x02,0xC3,0x92,0x76,0xB6,0x56,0xD6,0x35,0xE3,0xDF,0x12,0x8E,0xBE,0xC7,0xB0,0x26,0x8E,0x9C,
+	0x8E,0x37,0xE0,0xE5,0xCE,0x5B,0xEB,0xDF,0xCC,0xE8,0x93,0xEA,0x42,0xD4,0xEF,0x00,0x87,0x99,0x26,0xD9,
+	0x88,0xF7,0x78,0xBA,0xB0,0x33,0x30,0x7D,0x50,0x65,0x49,0x0A,0x7C,0x58,0x09,0x9F,0x10,0x57,0x8B,0x6B,
+	0x41,0x8F,0xD0,0xAE,0xF5,0x58,0xE1,0xBB,0xB1,0x48,0xC0,0x8A,0x96,0x78,0x31,0x01,0xC7,0x5B,0xF1,0xBB,
+	0x57,0x7B,0xE8,0xAB,0x6C,0x9A,0x21,0xD1,0x96,0x3B,0x87,0x1B,0x51,0xC3,0xB9,0x9B,0xF9,0x9B,0x6F,0xB7,
+	0xAD,0x20,0x99,0x8A,0x95,0xB7,0xE2,0x3B,0x91,0x9F,0x98,0xF2,0x45,0x3C,0x36,0x4A,0xB8,0x63,0xD6,0xFE,
+	0x09,0xC9,0x6E,0x2B,0xF7,0xDD,0xA6,0xDB,0x3B,0x8D,0x89,0x85,0xA7,0x0A,0x59,0xD6,0x96,0x0C,0xCF,0x41,
+	0xC5,0x0A,0xD8,0x08,0x74,0x0F,0x27,0x01,0x15,0x7A,0x28,0xED,0x2A,0x1F,0x31,0xD4,0xEB,0xD1,0xF9,0x64,
+	0xFF,0xCD,0xC4,0xE8,0x15,0x62,0x4C,0xC3,0xCC,0xBF,0xAC,0xA5,0xD5,0x63,0xFE,0x31,0x73,0x30,0x23,0x68,
+	0xB1,0x2E,0xE9,0x42,0xAF,0x63,0x52,0xE3,0x35,0xDC,0xB2,0xA5,0x29,0x8E,0x98,0x39,0x69,0xE5,0x9C,0x73,
+	0xD7,0x51,0xAA,0xCB,0x3B,0x83,0x97,0x29,0x7B,0x73,0x73,0x21,0xC3,0x22,0xAF,0x20,0x5F,0x66,0x5B,0x82,
+	0x6A,0x32,0x9C,0x06,0xA1,0x67,0x8C,0xA7,0x09,0xD2,0x26,0xE5,0x87,0x0F,0x3E,0x1C,0x10,0x49,0xFE,0xA7,
+	0xA8,0x0B,0x76,0x3D,0x1B,0x40,0x73,0x71,0x68,0xA4,0x5E,0x95,0xE8,0x3D,0xC0,0xB7,0x41,0x2A,0x90,0xB1,
+	0x8B,0x9D,0x0C,0x65,0xC4,0xC5,0x3F,0x1C,0x6B,0x4C,0x66,0xA6,0xF7,0x09,0x50,0x63,0xCE,0xE2,0x6D,0x71,
+	0x4E,0xA6,0x77,0x0D,0xEB,0xFF,0x30,0xB7,0x04,0x28,0x56,0xB7,0xC3,0x41,0xF9,0x64,0xB7,0xE7,0x3C,0xD9,
+	0x2A,0x05,0xA4,0x39,0x94,0x25,0xF4,0xD9,0x82,0x68,0x56,0xDF,0x1D,0x6E,0xD7,0x19,0x3E,0x5C,0xF4,0x28,
+	0x3B,0xFF,0x0C,0xA6,0x81,0x88,0x24,0x2C,0xDE,0xF9,0x17,0xA9,0xD8,0x1A,0xFD,0x3C,0x34,0x27,0x4D,0xBB,
+	0xC0,0xEE,0x22,0xDD,0x79,0x69,0x56,0xE9,0x09,0xDB,0xF4,0x85,0x9D,0x3B,0xFC,0xC8,0x13,0x5B,0xBB,0x39,
+	0x5C,0xFB,0x3C,0x1D,0xE3,0x46,0xB1,0xAE,0xBA,0x23,0x5A,0x06,0x29,0x6C,0x7F,0x7C,0x27,0xEC,0x48,0x67,
+	0x0C,0x09,0x03,0xBE,0x56,0x22,0x32,0xBA,0xC8,0x09,0x14,0x78,0xE0,0x2D,0xAF,0xDA,0x85,0x06,0x65,0xAF,
+	0xE7,0x21,0x2B,0xC9,0x35,0xF1,0x13,0x68,0x30,0x0E,0xCB,0x66,0x84,0xFB,0x1D,0xBF,0xAB,0x20,0x33,0x7E,
+	0x48,0x40,0x3A,0x79,0xE5,0x4F,0xB5,0x6E,0xB9,0xED,0xE5,0x6C,0xD3,0x7D,0x37,0xA0,0xA8,0x08,0xED,0x83,
+	0xD1,0x4F,0x8E,0x7D,0x29,0x4A,0x89,0x67,0x51,0x90,0xF4,0x3A,0xE1,0xE1,0xA4,0x5B,0xFC,0x33,0x28,0x6C,
+	0xA8,0x16,0xC7,0x65,0xBC,0x72,0x32,0x50,0x7C,0x92,0x21,0xC7,0x47,0x17,0xBC,0x78,0xC2,0x67,0xD5,0x90,
+	0xB5,0x63,0xB5,0x3B,0x8A,0xC7,0x9A,0x81,0xD2,0xF3,0x9B,0xC0,0xFE,0x9E,0xD2,0xD9,0x7A,0xE4,0xBA,0x0E,
+	0x11,0x0B,0xF2,0xA4,0xFE,0xDF,0x1C,0xA3,0x63,0xCE,0xAD,0xC8,0x10,0xE5,0x00,0x1B,0x75,0x4A,0xDB,0x41,
+	0x92,0x13,0x1C,0x2F,0x07,0xE9,0x79,0xD9,0x4C,0xE6,0xC1,0x0A,0x77,0x69,0xAD,0xE1,0x0B,0x34,0x49,0xD3,
+	0xA7,0xCC,0xC3,0xC9,0xA9,0x87,0x77,0x1B,0x9E,0x48,0xA3,0x63,0x90,0x57,0x56,0x86,0x02,0x2C,0x10,0xBC,
+	0xEB,0x31,0x16,0xBB,0x7D,0xEC,0xE8,0xF4,0xF8,0xC0,0x5A,0xB3,0x0F,0x5B,0xD7,0x73,0x9C,0x96,0x7F,0x48,
+	0x61,0xF8,0xC1,0x3E,0x0A,0x79,0xD7,0xA6,0x8A,0x4F,0x03,0x89,0xAC,0xCE,0x49,0xA6,0xA4,0x14,0x48,0xAC,
+	0x8F,0xBA,0x0C,0x9F,0x56,0x78,0x02,0x15,0x1C,0x94,0xCF,0x4A,0xCF,0xD6,0xFF,0xF9,0xD9,0x76,0x46,0xD6,
+	0x61,0xE1,0x7B,0xD5,0x8C,0x8C,0x93,0x1F,0xFB,0xB3,0x32,0x1F,0xB4,0xD7,0x17,0x33,0x8E,0xB2,0x0D,0xC4,
+	0xDE,0xAD,0xB4,0x0E,0xFB,0x92,0xBC,0x93,0x84,0x11,0x0D,0x54,0x41,0x64,0xE6,0xD4,0xF9,0x8E,0x8D,0x1E,
+	0x82,0x91,0xB1,0xE5,0x1B,0xD1,0x02,0x51,0x0E,0xB0,0xFC,0xC5,0x98,0xAF,0x8A,0x0A,0x48,0xF0,0x85,0x7D,
+	0x25,0xD0,0x1E,0x5E,0x64,0x0B,0x00,0x9F,0x10,0x40,0x0A,0xD1,0x96,0x64,0xD0,0x08,0x37,0xED,0xD1,0x59,
+	0xF8,0xBD,0x1F,0x32,0x94,0xAC,0x8E,0xC3,0xAD,0xC5,0x39,0x34,0x51,0xAD,0xDE,0x71,0xE6,0xD7,0xFB,0xC5,
+	0x17,0xE4,0x24,0x15,0x0C,0x93,0xE1,0x51,0x94,0xAC,0xF4,0x12,0x19,0x80,0x81,0xF5,0x14,0xC7,0x07,0x7B,
+	0xAE,0xCC,0x38,0xB5,0x61,0x68,0xE9,0xAA,0xA5,0x09,0xA3,0xA4,0x10,0xA6,0x18,0x00,0x60,0xC4,0x9B,0x67,
+	0x25,0x30,0x95,0x34,0xEC,0x4F,0x15,0x4B,0xF0,0x55,0x70,0x8C,0xE6,0x1A,0xA0,0xF3,0x8B,0xA1,0x99,0x41,
+	0xB7,0x9D,0xE1,0x5A,0x69,0x56,0x71,0x9C,0x66,0x39,0xF9,0x78,0xDF,0x9B,0x28,0x35,0x78,0x84,0x52,0x4A,
+	0x76,0x57,0x59,0x8D,0xEF,0x78,0x5A,0x70,0xBC,0xE8,0x83,0xAB,0x94,0xCB,0x8A,0x08,0x9D,0xA6,0x33,0x18,
+	0xA7,0x4D,0x8A,0xFE,0x22,0xE7,0x6A,0x69,0x58,0x08,0xA2,0xE1,0xBC,0xA8,0x04,0x0A,0x6D,0xC4,0xE5,0xBC,
+	0x2E,0xE9,0x03,0x96,0xAE,0x1A,0xFD,0xCD,0x8C,0xAC,0x0D,0x0E,0xEF,0x48,0x6C,0x2F,0xAB,0x2A,0x71,0xE4,
+	0x6C,0x08,0x93,0x1A,0x99,0xFB,0xBC,0x7D,0x5F,0x60,0xDB,0x7B,0xFD,0xE6,0xDC,0x4F,0x81,0x88,0x0C,0x53,
+	0x87,0x5C,0x5E,0x91,0x6B,0x73,0x72,0x15,0x58,0x5C,0xD5,0xFA,0xEA,0x0D,0x8A,0x43,0x2C,0x5D,0x73,0x95,
+	0xF2,0xB2,0xA0,0x7F,0xD1,0x12,0x67,0x0C,0x08,0x3E,0x92,0x52,0x76,0x5E,0x71,0x91,0x2A,0x51,0x25,0x1D,
+	0x50,0x31,0xB4,0x5A,0x0F,0xCF,0x24,0x42,0x92,0x5F,0xD8,0x94,0xE9,0x90,0x6B,0x6C,0xD6,0xAB,0x42,0xE0,
+	0xD3,0x6D,0xAD,0x0E,0x91,0x1F,0x62,0x03,0x8F,0xF3,0xCD,0x81,0xD5,0xCF,0xF8,0x6C,0xD8,0x30,0x68,0x10,
+	0x61,0x4C,0xEC,0x36,0x35,0x95,0x84,0x59,0xF8,0xB3,0x33,0xE1,0x5B,0x4F,0xED,0x0F,0x11,0x4D,0x80,0x03,
+	0x53,0xE7,0x01,0xC5,0x43,0x97,0x3C,0x60,0x95,0x4E,0xFD,0xE0,0xB9,0xDD,0xC2,0x16,0x2F,0xDE,0xBA,0x83,
+	0xD6,0xD0,0xAD,0x2A,0xC1,0xD9,0x30,0xCB,0xD5,0xC4,0xC6,0x11,0x3D,0x7B,0x13,0x94,0xB4,0xF4,0x12,0x1A,
+	0x05,0x85,0xFB,0xDA,0xDA,0xE5,0x5B,0x00,0x72,0x5A,0xFD,0x84,0x9C,0x63,0x1B,0x16,0xB6,0xDB,0x11,0xCA,
+	0x9D,0xC6,0xB7,0x11,0x6D,0x59,0x8B,0x79,0x9D,0x40,0xAC,0xA0,0xEC,0x94,0xDD,0xDB,0xA4,0xE7,0xFC,0x14,
+	0x7A,0xB8,0xA3,0xC1,0x2A,0x5C,0x70,0xBF,0xC7,0x79,0x86,0x8F,0xB1,0xFE,0xCD,0xD5,0x04,0xD5,0xE8,0xF6,
+	0x74,0xFC,0x8A,0xF8,0xC6,0x38,0x2A,0x59,0xBD,0x99,0x81,0x8B,0x5D,0x76,0xC0,0x7A,0x6F,0xB4,0x01,0xA3,
+	0x28,0x35,0xA6,0xF0,0x9E,0x77,0xC8,0xD5,0xC2,0x05,0xA4,0x47,0x43,0xB7,0x9B,0xF9,0x46,0x5A,0x03,0x19,
+	0xA1,0xA0,0x2E,0xC5,0x87,0x3A,0xC1,0x7A,0xEF,0xB6,0x5E,0xC2,0xE6,0xF6,0x65,0xC7,0xBB,0x8C,0xD5,0x0D,
+	0x69,0xB3,0x40,0x8C,0x15,0x59,0x4E,0x5A,0xE7,0xD7,0x87,0xD6,0xF3,0xAD,0xCF,0x1C,0x08,0x92,0x56,0x74,
+	0x94,0x69,0x2B,0x6B,0xFE,0x8E,0xB9,0xC6,0xD2,0xAE,0x36,0x0D,0x4F,0x91,0xD7,0x1E,0x1E,0x7E,0x23,0x7B,
+	0xFF,0x3F,0xB9,0xCA,0x1A,0x5F,0x75,0x1D,0xAD,0xF0,0xA1,0xE4,0xF7,0x54,0xA5,0x14,0x87,0x16,0x10,0xC4,
+	0x08,0x1D,0xEF,0x04,0xFE,0x60,0xEA,0xF0,0xD0,0x40,0x1A,0x11,0xFE,0x8C,0xF0,0x1C,0xF4,0x60,0xBC,0x52,
+	0x65,0x4B,0xB8,0x39,0x59,0x21,0x51,0x9F,0x7B,0xBF,0x97,0x03,0x23,0xE6,0x93,0x2A,0x44,0x16,0x1B,0xD3,
+	0x0F,0xEF,0xDD,0xEF,0x7C,0xA2,0x7C,0xEB,0x85,0x1E,0x99,0x46,0xE5,0x34,0x9B,0x3D,0xD3,0x62,0x63,0xB1,
+	0xDA,0x24,0x39,0x57,0x18,0x60,0xD1,0xE4,0x1E,0x02,0xB0,0x24,0xA9,0x69,0x29,0xF0,0xD5,0xBA,0x90,0x51,
+	0x9C,0x21,0xA3,0xF4,0x1F,0xBB,0xDC,0x76,0x57,0x9E,0x1F,0x4E,0xC6,0x48,0xE7,0xC5,0x1E,0x2B,0x6B,0x8E,
+	0x39,0xB9,0xA3,0x7C,0x92,0x9D,0xF4,0x31,0xE7,0x8B,0xCD,0x12,0x15,0xD7,0x63,0x8E,0x34,0x05,0xD9,0xB7,
+	0x50,0x21,0x3A,0xF7,0xFD,0x6B,0x94,0x0A,0xAB,0x65,0xE9,0x2C,0xE5,0x09,0x9A,0x2E,0xDA,0x98,0x74,0x1E,
+	0xE0,0x01,0x1A,0x6F,0x95,0x78,0x20,0xBF,0x6D,0xB4,0x7E,0x5C,0xAB,0x0C,0xF8,0x7A,0x81,0xFB,0xFD,0xEF,
+	0x88,0x67,0x36,0x2F,0x5C,0x2E,0xEF,0x5F,0xAF,0x4A,0xD8,0xEA,0x05,0x86,0xF5,0x1A,0x20,0x4D,0x3C,0xDB,
+	0x29,0x5E,0x64,0xED,0xA7,0x68,0x08,0xAA,0x4B,0x1C,0x92,0x51,0x02,0x88,0xD1,0x8A,0xAB,0xB3,0x65,0x48,
+	0xD8,0x64,0x4B,0xA9,0xEF,0xF1,0x6E,0xAC,0x13,0x22,0x60,0x87,0xBC,0x0F,0xD2,0x4B,0xFA,0x01,0x3D,0xDA,
+	0xE1,0xB8,0x87,0x4B,0x52,0x2C,0xA8,0xED,0x96,0xF9,0x65,0x0F,0x2D,0x68,0x15,0x6E,0x2A,0xA4,0x0B,0x40,
+	0x26,0x6A,0x5B,0x6D,0xEF,0x21,0x38,0x3A,0x05,0x67,0x5A,0xB3,0xA0,0xBB,0xFA,0x83,0x14,0x7C,0x45,0x42,
+	0x44,0x27,0xBA,0xA2,0xE1,0x2C,0x72,0x8A,0x4A,0xA5,0x76,0x5E,0xCA,0x9A,0xBD,0xB7,0xC0,0xFE,0x28,0xFE,
+	0xB8,0x35,0x37,0x91,0x25,0x04,0x32,0x6D,0x4F,0xBF,0x11,0xAD,0x78,0x16,0xBB,0xA2,0x65,0x7D,0x09,0x60,
+	0x3D,0xF3,0xBD,0xCA,0xDA,0x07,0x65,0x96,0x40,0x12,0xB4,0xFB,0x38,0x17,0x2C,0x46,0xDE,0x55,0xA6,0xC0,
+	0x33,0x64,0xA9,0x6C,0xB2,0x8B,0xD0,0xA3,0xF3,0x7A,0x48,0x52,0x22,0x7A,0xCA,0xEB,0x74,0x77,0x09,0x50,
+	0x94,0x35,0x5B,0x4B,0x73,0x55,0xED,0xFE,0xC9,0x01,0x05,0xD5,0x8B,0x32,0x72,0x1E,0x89,0x29,0x6A,0x45,
+	0x53,0xD6,0x17,0xD0,0x00,0x59,0xCD,0xE1,0x80,0x38,0x03,0x1E,0xA3,0xFC,0x5E,0x37,0x70,0x31,0xEE,0x02,
+	0x0A,0xCE,0x86,0x7D,0xB0,0xC7,0x5E,0xBC,0xA4,0x57,0x3F,0x73,0xC1,0xA6,0x50,0x03,0x39,0xB2,0x0D,0xCC,
+	0xD8,0x5F,0xEB,0x46,0x25,0x34,0xDE,0x83,0x71,0x15,0x78,0x78,0x62,0x02,0x07,0x94,0x3E,0x7A,0x12,0xDE,
+	0xF2,0x1B,0x29,0xAF,0x0E,0x14,0xBD,0xC6,0xC2,0xFE,0x3B,0x77,0x58,0x5D,0x61,0x5B,0xF1,0x36,0xB7,0x7F,
+	0x2D,0xBD,0x77,0x0E,0xD6,0x1A,0x9C,0xC9,0x9D,0x7D,0xAB,0x6C,0x01,0x23,0x61,0xC8,0x7C,0x8C,0x36,0x5A,
+	0x2E,0x5D,0x62,0x5E,0x3A,0x28,0x0E,0x12,0x90,0xF6,0xFE,0x16,0x7D,0x8D,0xCF,0xCC,0xC9,0xEE,0x2B,0x4D,
+	0x46,0x1E,0x11,0x18,0x55,0x8E,0xE6,0x6D,0xFA,0x3E,0x77,0x89,0xAF,0x10,0xF7,0x2E,0x97,0x9B,0xA2,0x61,
+	0x80,0x20,0xCA,0xFF,0x54,0x11,0xC4,0xF1,0xC2,0x0B,0xDE,0xE4,0xB8,0x9D,0x48,0x7D,0x94,0xCF,0x8E,0x2F,
+	0x17,0x12,0x76,0x81,0x15,0x0C,0xD6,0xF4,0xA0,0x77,0x40,0x00,0x31,0x1E,0xA0,0x37,0x01,0x1D,0x25,0x84,
+	0x6F,0x64,0x45,0x23,0x29,0x54,0x03,0x0B,0x11,0x76,0x4A,0x55,0x5A,0x87,0x57,0x81,0x58,0xFE,0x21,0xF5,
+	0x2C,0x15,0xA9,0x60,0x66,0xDC,0xF3,0x75,0xBD,0xEE,0x56,0x40,0x6D,0x01,0x67,0x34,0x38,0x5B,0x30,0x5D,
+	0x4E,0xA8,0x74,0xA1,0xD6,0xC4,0x4B,0x52,0x6C,0x31,0x78,0xF6,0x0F,0xE4,0xDF,0x8D,0x2C,0xBA,0x14,0xF6,
+	0xAB,0xC5,0x63,0x05,0x14,0x2D,0x89,0x85,0x10,0x53,0x59,0xA1,0x12,0x19,0x5D,0xA7,0x75,0xA7,0x6D,0xA2,
+	0x1B,0x15,0xB9,0x4B,0x81,0x12,0x2C,0xD3,0x30,0xA7,0x55,0x35,0x54,0x4A,0x8D,0xF9,0xDA,0x7C,0x2A,0xEC,
+	0xAD,0x3E,0x86,0x48,0x7C,0xC7,0xAA,0x04,0x5D,0xFF,0x54,0x80,0x66,0x4C,0xBC,0x18,0xF6,0xED,0x9A,0xAB,
+	0xC9,0xC2,0x80,0xB9,0xF1,0xF6,0xC4,0xFA,0x56,0x9A,0xAD,0xED,0xB8,0x2F,0x1D,0xC9,0x7F,0x67,0x89,0xA8,
+	0x70,0xB5,0x84,0xEA,0x61,0x86,0x95,0xFD,0xF7,0xCF,0xBB,0xAA,0x41,0xC6,0x81,0xB8,0x71,0xF7,0x8A,0xC0,
+	0x2C,0x5A,0x2F,0x71,0x59,0xEE,0x2C,0x85,0x0E,0x67,0xE2,0x8E,0x16,0xEC,0xDE,0x7D,0xAE,0x52,0xA8,0x2F,
+	0x58,0xA6,0x3C,0x8B,0xF0,0x5D,0x92,0xBC,0xD9,0x18,0x1C,0xC9,0x53,0x83,0x65,0xF3,0x77,0xD6,0x8E,0xEF,
+	0xA5,0xB1,0xAD,0x78,0xD6,0xEE,0xDF,0x39,0x70,0x81,0xAF,0x2C,0x80,0xC3,0x2B,0x91,0x34,0x64,0x6B,0xB8,
+	0xDD,0x1A,0x1C,0x73,0xCC,0x94,0x10,0xC6,0x38,0x7F,0x71,0x86,0xFC,0x94,0x13,0x31,0x1F,0x56,0x4D,0x63,
+	0xF5,0x91,0x43,0x64,0xB5,0x80,0x42,0x50,0x06,0xF1,0x9F,0x28,0xAD,0x07,0x7B,0xB1,0xE4,0xDE,0x85,0x86,
+	0x13,0xA2,0x94,0xA4,0x05,0xB4,0xB4,0xD5,0x1F,0x74,0x73,0x88,0xAD,0x38,0x97,0x10,0x19,0xAC,0xD9,0x97,
+	0x5B,0xF3,0xE3,0x2C,0xE5,0x5C,0x5C,0x12,0xD1,0x9B,0x8B,0xF6,0xFE,0x6A,0xF0,0x13,0xD9,0xD7,0xB4,0xD9,
+	0x7E,0x98,0xEB,0x30,0xA5,0xDD,0x0C,0xE9,0xCB,0x74,0x87,0xCD,0x98,0xDB,0x1C,0xC9,0x53,0xF3,0x05,0x87,
+	0xEA,0x1D,0xF3,0xD4,0x69,0x77,0x25,0x09,0x1D,0x03,0xDD,0x25,0x75,0xF8,0xEF,0xB1,0xE6,0xD7,0x5E,0xE6,
+	0x4F,0x36,0x15,0x75,0x1B,0x96,0xF5,0x28,0x16,0xF8,0x83,0x12,0xAB,0x8E,0xEC,0x9B,0x5C,0x28,0x76,0xD9,
+	0xE8,0xE9,0xD5,0x5F,0x98,0x04,0x81,0xF8,0x81,0xFC,0xE4,0x83,0x7C,0xB8,0xEF,0x49,0xE1,0xD4,0x88,0xBC,
+	0x16,0x7C,0x77,0x15,0x57,0x9C,0x8E,0xC8,0x92,0x36,0x49,0xAD,0x05,0xBE,0xE9,0x98,0x5D,0x51,0x17,0x65,
+	0x01,0x96,0x86,0x98,0xBC,0x3B,0x41,0x59,0x41,0xD6,0xBD,0xF9,0x6F,0x54,0x1E,0xA8,0x6D,0x43,0xD5,0xEB,
+	0x1A,0xD2,0x9A,0x6A,0x92,0xFC,0x66,0xEF,0x5E,0xFC,0x76,0xEA,0x0C,0xDC,0xC6,0x1C,0xBD,0xB5,0x3E,0xE5,
+	0x65,0x9F,0xFE,0xFE,0x7F,0xFD,0x1F,0x4F,0xF2,0xD0,0xA7,0xF0,0xB6,0xD2,0xDB,0xA9,0x6D,0x0A,0xF7,0xEF,
+	0xFE,0xFE,0xAF,0xC6,0xEC,0x64,0x00,0x2F,0xE7,0xB0,0xF8,0x1E,0x12,0xD6,0xFF,0xFF,0x1C,0x41,0x80,0x00,
+	0x0C,0x4C,0x04,0x00,0x18,0x2E,0x6F,0xD8,0xC1,0xBF,0x43,0xCC,0x56,0xBD,0x51,0xEF,0xE0,0xCE,0x90,0x11,
+	0x15,0x01,0x47,0x32,0x32,0x41,0x45,0x36,0x2A,0x61,0xB6,0x85,0xC0,0xB8,0x35,0x67,0xF1,0x38,0xEA,0xA5,
+	0xC4,0x54,0x6B,0x2D,0x2D,0xAD,0x60,0xEA,0xEA,0x06,0xE1,0x97,0x90,0x5B,0xC6,0x31,0xB6,0x4F,0xC2,0xB7,
+	0xAE,0x63,0x38,0xC2,0x01,0xE2,0x00,0x44,0x62,0xD1,0x22,0x80,0x06,0xCF,0xA8,0xE6,0x57,0x5D,0x31,0xB8,
+	0x09,0xCE,0xEE,0x59,0x97,0x81,0x5A,0x5E,0xB5,0x30,0x50,0xB1,0xF2,0xEF,0x79,0x31,0x9A,0x0F,0xC4,0xC1,
+	0x92,0xB7,0x7A,0x8F,0x7D,0x42,0xA9,0x42,0x71,0x60,0x4D,0xB9,0x89,0xCA,0x48,0x52,0xEC,0x23,0xAE,0x2E,
+	0x7E,0xBB,0x22,0x97,0x72,0xED,0xA9,0xE0,0x08,0xF3,0xD8,0x09,0xBB,0x53,0xD2,0x2C,0x3E,0x53,0x49,0x6C,
+	0x5E,0x28,0xE5,0xE2,0x62,0x99,0xEA,0xE1,0x19,0xF2,0xA5,0xCE,0xCB,0x43,0x9A,0xC1,0x59,0xB2,0x03,0x7B,
+	0x2F,0x1A,0xC3,0xF4,0x98,0xB1,0xD3,0x57,0x2F,0x5A,0xF2,0xD4,0x58,0xF1,0x24,0xE8,0xD1,0x0E,0xEA,0x99,
+	0x9D,0x3D,0xFD,0xC9,0x8D,0x44,0xFB,0xB9,0xDD,0xB8,0x1A,0xA7,0x0C,0x0C,0x19,0x44,0x9D,0x2B,0xF9,0x06,
+	0x9F,0x42,0xAD,0x8E,0x87,0xB1,0x58,0xDC,0x4B,0xA5,0xBA,0x82,0xF4,0x6F,0xF9,0x70,0x97,0x7D,0xBA,0x3C,
+	0x75,0xE6,0x16,0x29,0xEE,0x05,0x73,0xFF,0xB4,0x62,0x3B,0xEF,0x36,0x0F,0x7C,0xE9,0xD6,0x98,0x71,0xB6,
+	0x70,0x90,0xCB,0xE4,0x44,0x20,0x78,0x75,0x13,0x3F,0xDF,0x9F,0xFF,0xD3,0x04,0x80,0x78,0xF8,0x84,0x7C,
+	0xB2,0xCB,0xAB,0x94,0x87,0x42,0xEC,0x83,0x13,0x58,0xDE,0xB0,0x26,0xE9,0x0C,0x1E,0x4A,0x38,0xA6,0x38,
+	0x24,0x58,0xE4,0x93,0x12,0x69,0x4F,0x28,0x82,0x11,0x85,0x79,0x10,0x70,0xAE,0x15,0x07,0x42,0xED,0x82,
+	0x93,0x18,0x02,0x1D,0xDA,0x02,0xD6,0x95,0xCE,0x33,0x1C,0x33,0xE8,0xBE,0xE5,0x92,0x10,0x7C,0xF3,0xC1,
+	0xAF,0x18,0xC4,0xFC,0xCE,0x64,0xBB,0x0E,0xE7,0xF3,0x60,0x9B,0xD1,0xC9,0xAA,0x21,0xE9,0x55,0x49,0x50,
+	0x33,0xA4,0xDD,0xF7,0x14,0x51,0xBC,0xB0,0x4E,0x7A,0x2D,0xDF,0x64,0xE2,0x05,0xC5,0xC2,0xC3,0x73,0xEC,
+	0x66,0xF2,0x11,0x60,0xB1,0x85,0x13,0x43,0xA7,0x9A,0xEB,0xDC,0x37,0x93,0x82,0xE1,0x64,0x50,0x4D,0xEB,
+	0xE3,0x83,0xD9,0x89,0x2E,0x78,0x5D,0x0E,0x3E,0x78,0x4C,0x47,0xCB,0x5C,0xF6,0xE8,0x0C,0xF5,0x6E,0x58,
+	0xE7,0x92,0x74,0x94,0xC4,0xF6,0x26,0xC8,0x24,0x50,0xE6,0x3E,0x7A,0x9F,0x19,0xFB,0x43,0x18,0x54,0x65,
+	0xBE,0xE7,0xEC,0x2B,0x68,0x9B,0xEF,0x2F,0xF9,0x22,0x0D,0x7B,0x2B,0x33,0x04,0xFD,0xA9,0x3D,0x9B,0xBD,
+	0xE1,0x55,0xA7,0xCD,0xB5,0x72,0x38,0x56,0xC1,0xEA,0xC7,0xCB,0x9B,0x59,0xE6,0x5A,0x44,0x19,0xD3,0x2A,
+	0x90,0x30,0x2D,0x2B,0xCF,0xB2,0x23,0x36,0xBE,0x3A,0xB1,0x0A,0x6D,0x5D,0x76,0x5F,0x04,0x7C,0x19,0x52,
+	0xBA,0xB1,0x38,0x49,0xBA,0xAF,0xA1,0x4C,0x6F,0x59,0x27,0x69,0xBA,0xD6,0xF9,0x28,0x43,0x4F,0x27,0x7E,
+	0xBD,0x5F,0x08,0x27,0x12,0x21,0x1F,0xFD,0x8B,0xF2,0x7E,0x1F,0x54,0x2B,0xFF,0x86,0x67,0xA0,0x50,0x62,
+	0x59,0x4B,0xE9,0xA3,0xA9,0x21,0xD7,0x16,0x05,0x59,0x68,0x12,0x63,0xBA,0x67,0x32,0x36,0xCD,0x42,0x3E,
+	0xB0,0xF3,0x04,0x03,0xEF,0xA6,0x7E,0x07,0xE3,0xA4,0x35,0xC1,0xFB,0xC6,0x4B,0xAF,0x21,0x21,0x96,0xEE,
+	0x95,0xE0,0x69,0x69,0x72,0xB3,0xE6,0x33,0xB2,0xCB,0x33,0x57,0xC5,0xE5,0x9F,0xBC,0x00,0xC4,0x0D,0x3C,
+	0x93,0xA3,0x98,0xD1,0xC3,0x83,0x4F,0x3D,0xAF,0x6E,0x13,0xAD,0xF0,0xC7,0xE9,0x49,0x0F,0x31,0xB8,0x72,
+	0x37,0x30,0xCA,0x89,0xD5,0xAD,0xDB,0x31,0x39,0x39,0x09,0xE4,0xB2,0x72,0xD9,0xC0,0xB9,0xB5,0x75,0x96,
+	0x75,0xE4,0xED,0x66,0x66,0x78,0x68,0x4C,0x8B,0xE9,0x39,0xF7,0xC7,0x56,0xD9,0x15,0x60,0x82,0xC2,0xBC,
+	0x8B,0x8F,0x1D,0xF8,0x49,0xA1,0xF2,0x2E,0xDE,0x73,0xBE,0x59,0x3F,0x97,0xBA,0x1E,0x10,0x0B,0xF0,0xF1,
+	0xBE,0xAD,0x3A,0xC6,0xCC,0x8B,0x9A,0x0A,0x3E,0x21,0x8B,0xA9,0x53,0x65,0xA2,0x8D,0x95,0x47,0x13,0xD3,
+	0xCC,0x31,0xCB,0x2D,0x2B,0xEC,0xBB,0xF9,0x21,0xCA,0x50,0xF2,0xBC,0x10,0xBB,0x87,0xFE,0xA9,0xC3,0x18,
+	0xBE,0x73,0x99,0xCE,0x02,0x30,0x94,0x08,0xB8,0xEE,0xC5,0x62,0x48,0xCC,0xCA,0xBE,0x83,0x93,0x68,0x63,
+	0x09,0x8D,0x35,0x5A,0x19,0xAD,0x7A,0x42,0x30,0xDD,0x47,0x23,0xA0,0xEB,0xA3,0x5B,0xCC,0xCC,0xE1,0x1E,
+	0x1B,0x89,0x60,0x54,0xD6,0x8C,0x4A,0x3E,0x7D,0x31,0x3C,0x7F,0x00,0x8D,0xF8,0x2D,0x60,0xED,0x93,0xD9,
+	0x4A,0xC8,0x73,0x7D,0x2A,0xE0,0x80,0xE0,0x65,0x10,0xA8,0xF1,0x57,0xCF,0x80,0xC0,0x05,0x28,0xCD,0x24,
+	0x7D,0x96,0x76,0x93,0x86,0x97,0xEC,0x97,0x0A,0xB5,0x54,0x95,0xC4,0x58,0xDC,0xF7,0xB9,0x7A,0x5D,0x01,
+	0xA1,0x63,0xDD,0x85,0x43,0x19,0x2D,0xA6,0xE0,0xF2,0x8D,0xF7,0xF0,0xFD,0xA5,0xAF,0x06,0x95,0xF2,0x97,
+	0xC6,0xB5,0xB2,0xD3,0xE9,0x93,0xB9,0x55,0x77,0xF9,0x1A,0xF0,0xA3,0x82,0x99,0x42,0x76,0x9E,0x49,0xA4,
+	0xC4,0x9A,0x0B,0x62,0x76,0x65,0x35,0xC6,0xAA,0xF6,0x53,0x46,0x16,0x85,0xDB,0xFB,0xB7,0x85,0xEF,0xC9,
+	0x6F,0xB7,0x5A,0x9D,0x57,0x4A,0x75,0x99,0x4F,0x6A,0x01,0xC7,0x32,0xC6,0x42,0xEF,0xF0,0xF6,0xC6,0x76,
+	0x72,0x89,0xEF,0x37,0xCB,0xB1,0x5A,0xFE,0x60,0x70,0xFD,0xCF,0x72,0xF0,0x6E,0x1D,0x4F,0x38,0x9C,0x71,
+	0xCB,0xFA,0x32,0x68,0xC0,0xD5,0x50,0xCC,0x1D,0xE8,0x74,0x9B,0x8E,0xFC,0xF5,0x9E,0x42,0xB9,0xBE,0xBB,
+	0xEE,0xBC,0x1A,0xDC,0x3E,0x86,0x5F,0x09,0xAD,0xC2,0x27,0x05,0xC7,0xBE,0x2D,0xFB,0xCD,0xBA,0xAF,0x45,
+	0x7E,0xD2,0x15,0x79,0x92,0x9F,0x74,0x1D,0xBB,0xFB,0x07,0xCB,0xF4,0xD2,0xC7,0xDD,0xBC,0xEB,0x1B,0x39,
+	0xF6,0x48,0xEE,0x6B,0xDF,0xB3,0xDE,0x4C,0xEB,0xFB,0x1E,0x4D,0x78,0x9C,0x86,0x50,0x0D,0x4B,0xD6,0x0E,
+	0xE0,0xB2,0x6D,0x88,0x90,0x9F,0x6E,0xB8,0xD5,0x06,0x44,0x3A,0x32,0xDE,0x77,0x4D,0xBB,0xD4,0xA8,0xEE,
+	0xE8,0xDE,0x8A,0x6B,0xBE,0xD4,0x10,0xA8,0x45,0x37,0x8F,0x9B,0xCE,0x32,0x7F,0xC3,0x13,0xCF,0xF9,0x7B,
+	0xFF,0x6E,0xDF,0x15,0x87,0x07,0x80,0x04,0x10,0x20,0x10,0x20,0x40,0x40,0x90,0x24,0x50,0x60,0xE0,0xB2,
+	0xA5,0x86,0x88,0x14,0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,0x51,0x61,0xA9,0xA3,0x5F,0x5D,0x81,0x05,
+	0x90,0x22,0x11,0x21,0xC0,0x42,0x91,0x25,0xD0,0x62,0xE9,0x11,0x04,0x04,0x89,0x15,0x91,0x23,0x19,0x31,
+	0xC1,0x43,0x99,0x35,0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,
+	0x52,0x64,0x48,0x50,0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,
+	0x82,0x06,0xC1,0x45,0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,
+	0x93,0x27,0x59,0x71,0xC3,0x47,0xD9,0x75,0xD3,0x67,0x12,0x08,0xED,0x49,0x82,0x0C,0x18,0x28,0x12,0x28,
+	0x48,0x48,0x92,0x2C,0x58,0x68,0xCA,0x08,0x40,0x45,0x8A,0x1C,0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,
+	0x59,0x69,0xEB,0xBA,0x0D,0x4D,0x83,0x0D,0x98,0x2A,0x13,0x29,0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x7F,0xE4,
+	0xA8,0x49,0x8B,0x1D,0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,
+	0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,
+	0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,
+	0xDA,0x6E,0x4B,0x59,0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x74,0x46,
+	0x8A,0xEF,0x84,0x84,0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,0x70,0x70,0x8E,0x14,0x21,0x80,0x8C,0x94,
+	0x31,0x31,0x1C,0xB0,0x61,0x51,0x9C,0xB4,0x71,0x71,0x95,0xC7,0x0A,0xE9,0x85,0x85,0xB0,0x32,0x15,0xA1,
+	0xE0,0x52,0x95,0xA5,0xF0,0x72,0xA5,0x33,0x26,0x34,0x8D,0x95,0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,
+	0xF1,0x73,0x44,0xC0,0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,
+	0x23,0x15,0xCC,0xD4,0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,
+	0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,
+	0xE3,0x57,0xDD,0xF5,0xF3,0x77,0x96,0xCE,0x82,0xE3,0x86,0x8C,0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,
+	0x78,0x78,0xA6,0x3A,0xAE,0x3E,0x8E,0x9C,0x39,0x39,0x1E,0xB8,0x69,0x59,0x9E,0xBC,0x79,0x79,0x05,0x0D,
+	0xA8,0x8B,0x87,0x8D,0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,0xF8,0x7A,0x9F,0xBD,0xA9,0x1B,0x8F,0x9D,
+	0xB9,0x3B,0x1F,0xB9,0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,
+	0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,
+	0x7B,0x7D,0x47,0xC9,0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,
+	0xAB,0x1F,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x20,0x3A,0x81,0x87,0xA0,0x06,
+	0x14,0xA0,0x30,0x22,0x44,0xC0,0xB0,0x26,0x54,0xE0,0x55,0x96,0x45,0xAB,0xA8,0x16,0x15,0xA1,0x38,0x32,
+	0x45,0xC1,0xB8,0x36,0x55,0xE1,0xC9,0xA0,0x82,0xE2,0xA1,0x07,0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,
+	0xD4,0xE2,0xB9,0x55,0x2F,0x78,0xA9,0x17,0x95,0xA3,0x39,0x33,0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,
+	0x06,0x84,0xE0,0x46,0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,
+	0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,
+	0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,
+	0xD7,0xE7,0x24,0x8E,0x0C,0x19,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x9A,0xA8,
+	0x23,0xC5,0xAA,0x1E,0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,0x5D,0xE9,0xFC,0x03,0x0B,0x8D,0xA3,0x0F,
+	0x9C,0xAA,0x33,0x2B,0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x5B,0xC4,0x62,0xC7,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,
+	0xCD,0xCB,0xBB,0x3F,0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,
+	0x5E,0xEC,0x6A,0x5A,0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,
+	0x8E,0x8E,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,
+	0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,
+	0x64,0xD0,0xB4,0xA6,0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,
+	0x75,0xF1,0x25,0x83,0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,
+	0xA5,0x93,0xAD,0x97,0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,
+	0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,
+	0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,
+	0xF6,0xF6,0x6D,0xD3,0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,
+	0x2C,0x98,0xA6,0x8E,0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,
+	0x3D,0xB9,0x3E,0xBA,0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,
+	0xEC,0xDA,0xB7,0xAF,0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,
+	0xFD,0xFB,0x66,0xCA,0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,
+	0x2F,0x9D,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,
+	0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,
+	0xEF,0xDF,0xFF,0xFF,0x8F,0x95,0x80,0x00,0x0C,0x4C,0x8C,0x73,0x73,0x5F,0x62,0x04,0x64,0xCD,0xAA,0xD7,
+	0x86,0xCF,0x51,0xEF,0xE0,0xCE,0xC0,0x83,0x72,0xCE,0x67,0xC8,0xC0,0xBE,0xE6,0xAE,0xBA,0xA4,0xB6,0x85,
+	0x8C,0xD6,0xF9,0x07,0x67,0x24,0x6F,0xA1,0xFF,0x4B,0x76,0xD4,0x0A,0x72,0x60,0xEA,0xEA,0x06,0xF1,0x97,
+	0x94,0xF2,0xC2,0x13,0xC7,0x63,0xE7,0x02,0xBA,0xC6,0x30,0x66,0xE0,0x67,0x67,0x4D,0x95,0x83,0x76,0x68,
+	0xCE,0x49,0xA4,0x40,0xD7,0x43,0x38,0x8F,0xE0,0x47,0x12,0x12,0xB9,0xDE,0x4B,0xBF,0xF0,0x09,0xCB,0x32,
+	0xF1,0x2B,0xF1,0xF6,0xAC,0x4A,0x69,0xE3,0x94,0x46,0xE5,0x9E,0xC4,0x46,0x0E,0x75,0xD4,0x66,0x49,0xE8,
+	0x54,0xBA,0xD9,0xD1,0x93,0xB6,0x29,0xB7,0x69,0x05,0xAD,0x51,0xF7,0x67,0xA9,0xE0,0x08,0xF3,0xB8,0xEE,
+	0x9A,0x20,0x3F,0xD1,0x69,0xD3,0x13,0xDF,0xB8,0x24,0xE5,0xE2,0x62,0x99,0x6E,0x7E,0x58,0x69,0x32,0xBC,
+	0x41,0xB0,0x31,0xD4,0x1D,0x05,0x03,0x7B,0x2F,0x1A,0x0A,0xEF,0x1A,0x02,0x13,0xD4,0xC8,0x91,0xF2,0x56,
+	0x0D,0xF7,0x24,0xE8,0xD1,0x0E,0xF3,0x9F,0x90,0xCF,0x42,0xBD,0x3C,0x84,0x4F,0x63,0xF7,0xB7,0xAF,0x23,
+	0x8F,0x0B,0xF8,0xB3,0x1C,0x2C,0xD6,0x44,0x4C,0x2C,0xD2,0x6C,0x5A,0x6C,0x4B,0x47,0x13,0x99,0xCA,0x64,
+	0xE7,0x1D,0xF1,0x07,0x09,0x44,0xDA,0x7C,0x5B,0x6D,0xAB,0xEA,0xAE,0xDA,0xD0,0x72,0x8A,0x6C,0xF3,0x4D,
+	0x1F,0xF3,0xD3,0x6D,0xDA,0x6E,0xCA,0x42,0x97,0x41,0x0B,0x5D,0xEB,0x63,0x5E,0x69,0xE8,0xBE,0xDB,0x7D,
+	0xDB,0x6F,0x04,0x80,0x78,0xF8,0x3E,0x64,0x8F,0x72,0x3C,0x24,0x68,0xA9,0x3B,0xFA,0xC5,0xAC,0xDE,0xB0,
+	0x26,0xE9,0xD4,0xA4,0x37,0x51,0x1D,0xCF,0x86,0x57,0x0C,0xAA,0x61,0x85,0x4F,0x28,0x82,0x11,0x85,0x2C,
+	0x91,0xF3,0x4C,0x25,0x15,0x9D,0xFD,0x67,0x76,0x87,0x02,0x1D,0xDA,0x02,0x57,0xE7,0x0E,0x8C,0x55,0x26,
+	0x82,0x9C,0x98,0xAF,0xE5,0xC7,0x64,0x3C,0x32,0x5A,0xB4,0xE4,0x32,0xF9,0x1E,0x1B,0xC1,0xA8,0xD4,0xE4,
+	0x72,0x74,0xE4,0x72,0xF4,0xFA,0x3C,0x50,0x3F,0xFE,0x34,0x72,0x62,0x36,0xDC,0xF4,0x73,0x75,0x35,0xE7,
+	0x40,0x75,0x55,0x03,0x58,0x7A,0xEE,0xBE,0xE4,0x16,0xD5,0xE5,0xF2,0x76,0x8D,0xD1,0xD9,0xE9,0x65,0x76,
+	0xCC,0x3E,0x07,0xF0,0x40,0x16,0xDD,0xF5,0xF3,0x77,0xD9,0x89,0x2E,0x58,0xFD,0x73,0xCF,0x7A,0x6E,0x2A,
+	0x69,0x20,0x13,0x6A,0x92,0x34,0x36,0x70,0x6B,0xD6,0xF1,0x66,0xC6,0xE6,0x3E,0x41,0x69,0xC2,0x4B,0x38,
+	0x79,0xE8,0xE5,0x0B,0xAB,0xFC,0x07,0x18,0x59,0x45,0x4D,0xA8,0x4B,0x21,0x67,0xEB,0x52,0x81,0x55,0x6B,
+	0x0A,0x1D,0x4F,0x99,0xAA,0xB6,0x37,0x44,0xE9,0x80,0x28,0x3D,0xFF,0x7B,0x3E,0x07,0xDB,0x50,0x06,0xCC,
+	0x4A,0x70,0x79,0x97,0xB3,0xE1,0xD6,0xEC,0x7A,0x7C,0xED,0xD0,0xF7,0x2D,0x4A,0xF0,0x3D,0x5D,0x1E,0xCA,
+	0x94,0x5B,0xDE,0xFC,0x7B,0x7D,0x37,0x0F,0x00,0x5F,0xB7,0x0B,0x10,0x7C,0x1D,0xEC,0x81,0x51,0xD7,0xED,
+	0xFA,0x7E,0x6C,0xD5,0x73,0x6F,0x6F,0xF9,0x3E,0x18,0xD7,0xFB,0x4A,0x00,0xDF,0xFD,0xFB,0x7F,0x7E,0x1F,
+	0x54,0x2B,0xFA,0x07,0xB7,0xA6,0x31,0x5D,0xA3,0xC4,0xD9,0xCD,0xBF,0x54,0xD7,0x16,0x05,0x59,0xD0,0x94,
+	0x1C,0xC5,0x22,0x3A,0x66,0x59,0x38,0xF0,0xC7,0xE2,0x04,0x03,0xEF,0xA6,0xE9,0x90,0xF7,0xBD,0xFD,0xCB,
+	0x86,0x0F,0x12,0x3D,0xBF,0x96,0x96,0xEE,0x95,0xE0,0x91,0xC7,0x2A,0xAC,0x67,0xB3,0xCD,0xB8,0x5A,0xCC,
+	0x3C,0x44,0x16,0x04,0xA0,0xC8,0x90,0x80,0xBC,0xE6,0x10,0x22,0x68,0x49,0xF0,0x66,0x56,0xE4,0x68,0x6A,
+	0xE6,0x7A,0x48,0x72,0x92,0x82,0xB4,0x10,0x04,0x3B,0xF8,0x76,0x57,0xE5,0x15,0xBE,0x8A,0xC4,0x65,0x6B,
+	0x90,0xC6,0x09,0x47,0x44,0x8E,0xF1,0x67,0xD6,0xE6,0xA9,0x53,0xF7,0x72,0x36,0x46,0x91,0xA7,0x01,0xF1,
+	0xC2,0x5E,0xF9,0x77,0xD7,0xE7,0xC2,0xBC,0x8B,0x8F,0x9A,0x5E,0x0C,0xA7,0x12,0xD1,0x3F,0xC4,0xBC,0x9C,
+	0x7F,0x28,0xBA,0x1E,0x10,0x0B,0xD7,0xFC,0x2E,0x8B,0x17,0xC3,0xCD,0x52,0x9A,0x2E,0xE9,0x3E,0x8B,0xA9,
+	0x53,0x65,0xC3,0xCF,0x52,0x21,0xCC,0xD5,0xCA,0xEA,0xE9,0x75,0x6B,0x95,0xBB,0xF9,0x21,0xCA,0x71,0x1E,
+	0xAE,0x89,0x3B,0xC6,0xCD,0x10,0x0E,0x80,0x00,0x96,0x63,0xCE,0x0E,0x1D,0xF1,0xB3,0x52,0xE2,0x48,0x88,
+	0xCC,0x84,0xF2,0x6E,0x5E,0xEC,0x79,0x49,0x13,0xC9,0x13,0x98,0xBD,0xE8,0x1A,0x3E,0x40,0xC0,0xFA,0x7E,
+	0x5F,0xED,0xD4,0x42,0x88,0x8E,0x93,0x09,0x3C,0x50,0x6E,0x89,0x62,0xC1,0xF3,0x6F,0xDE,0xEE,0x4D,0x57,
+	0x03,0x74,0x99,0xD9,0x9F,0xE3,0x31,0x85,0x6C,0xC2,0xFB,0x7F,0xDF,0xEF,0x28,0x85,0x85,0x18,0x5B,0x78,
+	0x32,0xF0,0x3C,0x26,0x6C,0xEC,0xA7,0x99,0x64,0xB2,0xBB,0x62,0x2D,0x9E,0x6C,0x93,0x62,0xF3,0xE3,0xB2,
+	0x12,0xDD,0x7C,0xB6,0x05,0x0A,0x27,0x61,0x26,0xDA,0x5E,0x03,0xB8,0x1A,0x6A,0xA1,0x97,0xD2,0xB5,0x9F,
+	0x08,0xC2,0x4D,0xD7,0xD1,0x9C,0xAD,0x2E,0x91,0xDD,0xFD,0xB2,0x98,0xC8,0xBC,0x71,0x57,0xBF,0x8C,0x71,
+	0xA3,0xD3,0x3B,0xD7,0x30,0xB4,0xC0,0x80,0x25,0x28,0xF4,0xE6,0x76,0xF4,0x18,0x2F,0x23,0xD7,0x9C,0xF0,
+	0xD5,0xD6,0x87,0x9D,0x3A,0x2A,0xFC,0xF6,0x77,0xF5,0xA5,0xC6,0xC1,0xDA,0xF6,0x3A,0xA6,0xF8,0x88,0x8D,
+	0xAF,0xD9,0xF5,0xE7,0xF6,0xF6,0x6D,0xEB,0x46,0x68,0x45,0x75,0x68,0x58,0x1D,0xB7,0x67,0x0A,0xFD,0xF7,
+	0xF7,0xF7,0x46,0x4A,0xE2,0x13,0xE6,0xB1,0x34,0xD4,0xF2,0xD5,0x08,0x17,0xC6,0x71,0xCB,0xB4,0xA7,0x6A,
+	0x25,0x96,0x09,0x09,0x56,0x1F,0x67,0x3F,0x88,0xCB,0x98,0xB2,0xF1,0x22,0x59,0x69,0x2E,0x92,0x8F,0x4D,
+	0x68,0x7C,0x76,0xD5,0x8A,0x15,0xC1,0xBC,0xE0,0xBE,0x9B,0xE9,0x0E,0x56,0x2F,0x6E,0x7F,0xFB,0xB5,0xDB,
+	0xFD,0xDD,0x9F,0x42,0xBD,0xB5,0xA6,0xCA,0x5E,0x69,0x4E,0x6C,0xB9,0x9B,0x0E,0xCD,0x93,0xD3,0xF6,0xEE,
+	0x7E,0xFC,0xD9,0xD7,0x29,0x9D,0x31,0xCA,0x39,0xBD,0xA9,0x78,0x6A,0xA4,0xFE,0xFE,0x7F,0xFD,0xE6,0x4F,
+	0xAE,0x0F,0x18,0xEB,0x3B,0x99,0x48,0x6E,0xE0,0x54,0xF7,0xEF,0xFE,0xFE,0x7C,0xC8,0xB7,0xDB,0xFC,0x99,
+	0x1D,0xF1,0x07,0xDF,0x3B,0xCF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x80,0x04,0x10,0x20,0x10,0x20,
+	0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,0x01,0x01,0x88,0x14,0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,
+	0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,0x90,0x22,0x11,0x21,0xC0,0x42,0x91,0x25,0xD0,0x62,0x09,0x11,
+	0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,0xC1,0x43,0x99,0x35,0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,
+	0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,0x52,0x64,0x48,0x50,0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,
+	0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,0x82,0x06,0xC1,0x45,0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,
+	0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,0x93,0x27,0x59,0x71,0xC3,0x47,0xD9,0x75,0xD3,0x67,0x02,0x08,
+	0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,0x48,0x48,0x92,0x2C,0x58,0x68,0x0A,0x18,0x09,0x09,0x8A,0x1C,
+	0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,0x59,0x69,0x03,0x09,0x88,0x0A,0x83,0x0D,0x98,0x2A,0x13,0x29,
+	0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,0x89,0x0B,0x8B,0x1D,0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,
+	0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,
+	0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,
+	0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x4B,0x59,0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,
+	0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,0x20,0x10,0x84,0x84,0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,
+	0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,0x31,0x31,0x1C,0xB0,0x61,0x51,0x9C,0xB4,0x71,0x71,0x05,0x81,
+	0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,0xE0,0x52,0x95,0xA5,0xF0,0x72,0x0D,0x91,0xA1,0x13,0x8D,0x95,
+	0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,0xF1,0x73,0x44,0xC0,0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,
+	0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,0x23,0x15,0xCC,0xD4,0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,
+	0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,
+	0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,0xF3,0x77,0x06,0x88,0x28,0x18,0x86,0x8C,
+	0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,0x78,0x78,0x0E,0x98,0x29,0x19,0x8E,0x9C,0x39,0x39,0x1E,0xB8,
+	0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,0xA8,0x1A,0x87,0x8D,0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,
+	0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,0xB9,0x3B,0x1F,0xB9,0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,
+	0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,
+	0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0x47,0xC9,0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,
+	0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,0xAB,0x1F,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,
+	0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,0x14,0xA0,0x30,0x22,0x44,0xC0,0xB0,0x26,0x54,0xE0,0x28,0x12,
+	0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,0x45,0xC1,0xB8,0x36,0x55,0xE1,0x21,0x03,0x84,0x82,0xA1,0x07,
+	0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,0xD4,0xE2,0x29,0x13,0x85,0x83,0xA9,0x17,0x95,0xA3,0x39,0x33,
+	0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,0x06,0x84,0xE0,0x46,0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,
+	0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,
+	0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,
+	0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0x22,0x0A,0x0C,0x88,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,
+	0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,0x0D,0x89,0xAA,0x1E,0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,
+	0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,0x9C,0xAA,0x33,0x2B,0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x2B,0x1B,
+	0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,0xCD,0xCB,0xBB,0x3F,0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,
+	0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x6A,0x5A,0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,
+	0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,0x8E,0x8E,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,
+	0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,
+	0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,0x64,0xD0,0xB4,0xA6,0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,
+	0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,0x75,0xF1,0x25,0x83,0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,
+	0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,0xA5,0x93,0xAD,0x97,0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,
+	0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,
+	0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,
+	0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x6D,0xD3,0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,
+	0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,0x2C,0x98,0xA6,0x8E,0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,
+	0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,0x3D,0xB9,0x3E,0xBA,0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,
+	0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,0xEC,0xDA,0xB7,0xAF,0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,
+	0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,0xFD,0xFB,0x66,0xCA,0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,
+	0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,0x2F,0x9D,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,
+	0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,
+	0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,0x9C,0x67,0x80,0x00,0x55,0x40,0xE0,0x44,
+	0x0D,0xAB,0x69,0xF0,0x0C,0xC1,0xE8,0xA6,0x59,0xE0,0x4C,0xB4,0x25,0x41,0x01,0x84,0xB2,0x27,0x32,0xE0,
+	0x1D,0xC9,0xC0,0x30,0x58,0x2B,0x01,0x85,0x86,0x02,0x01,0xE7,0x12,0x2A,0x12,0x6B,0x4D,0x21,0xE9,0xA1,
+	0x9A,0xEF,0x09,0x05,0x22,0x66,0x01,0x28,0x32,0x25,0x09,0x7B,0x4D,0x4B,0x81,0x31,0xD8,0x29,0x57,0xAF,
+	0xB5,0xBB,0x00,0xD0,0x82,0xF0,0x8B,0x62,0x3D,0xC4,0x5C,0x2C,0x9A,0xEC,0x0D,0x9C,0xE2,0x7A,0x4F,0x50,
+	0x3A,0x53,0x8C,0x56,0xAD,0x26,0xF8,0xF5,0xDC,0xC8,0x3A,0xBE,0x75,0x44,0x4D,0x5A,0xD3,0x27,0xB9,0xC3,
+	0x66,0xC1,0xDC,0x76,0xD7,0xAE,0xB0,0xAA,0x7C,0xD8,0xF7,0x11,0xB1,0x2A,0xF1,0xD3,0x1C,0xC8,0xD3,0xE6,
+	0xCE,0xCA,0x92,0x2C,0x2E,0x48,0x0A,0x30,0xF9,0x27,0x10,0xDA,0x0F,0x4C,0x6D,0xD2,0x5E,0x69,0x0A,0x18,
+	0x09,0x49,0xA2,0xE3,0x6E,0x2D,0x20,0x3A,0x55,0x69,0x5A,0xA1,0x29,0xE4,0xC4,0x41,0xAE,0x49,0x5E,0x2D,
+	0x63,0xB1,0x17,0x7D,0x2F,0xB4,0x3A,0x5F,0x27,0xB5,0x4F,0x82,0x89,0x0B,0x4B,0x19,0x96,0x90,0x9B,0x29,
+	0xD9,0x49,0xE5,0x05,0x32,0xDA,0x82,0xD1,0x47,0x81,0xC3,0xC8,0x14,0xB4,0x92,0x68,0x1E,0x92,0x5E,0xFF,
+	0x4F,0x64,0xB5,0xA6,0x0D,0x1F,0xCC,0x2F,0x1E,0x6F,0x2A,0xBE,0xE1,0x0C,0xFC,0x2C,0x46,0xCD,0xBE,0xA7,
+	0x71,0x91,0x89,0xAF,0x5B,0x2A,0x6C,0xA6,0x73,0x02,0x51,0x7E,0xD7,0x36,0x6C,0x2B,0x60,0x7E,0x0F,0x05,
+	0xD8,0xDF,0x9B,0x7D,0x63,0xC2,0x53,0x0E,0xDE,0x03,0x04,0x80,0x78,0xF8,0xE4,0x44,0xFE,0xBB,0x2C,0xC0,
+	0xD0,0x58,0xFF,0xD6,0x8B,0xEF,0xDE,0xB0,0x26,0xE9,0x4C,0x8C,0x5E,0x7D,0xE5,0xC2,0xEF,0x34,0x6C,0xC6,
+	0xCE,0x2E,0x4F,0x28,0x82,0x11,0x34,0x67,0x37,0x23,0x64,0xD3,0x6E,0x37,0x6A,0x5B,0xF6,0x00,0x02,0x1D,
+	0x24,0xE6,0x3A,0x11,0x91,0x30,0x64,0xC3,0x6F,0x36,0xE2,0x4F,0x0E,0xAC,0x84,0x4D,0x67,0x99,0x48,0x37,
+	0x3F,0x9F,0x04,0xFD,0x60,0xF9,0x8D,0xE1,0xA7,0x18,0x0C,0xA2,0x9C,0xAA,0xFE,0xE4,0x41,0x77,0x54,0xF4,
+	0x4A,0x90,0xA1,0x1B,0xE6,0xA8,0xBA,0x3F,0xA4,0xE4,0xBD,0xC1,0x5B,0x7E,0xDD,0xA6,0x20,0x96,0x11,0xBB,
+	0xFC,0x68,0x36,0x2E,0x54,0x55,0x09,0xD4,0x5A,0x5F,0xF1,0x01,0xAB,0xF1,0x74,0x8E,0x9B,0x7A,0xC6,0xA8,
+	0x0A,0xB3,0xE6,0xC8,0x0E,0xB5,0x3F,0xFB,0xEC,0x44,0x56,0x20,0x63,0xF5,0x21,0x69,0x40,0x1C,0x4E,0xB8,
+	0x31,0xC2,0x66,0x9F,0xF8,0xF5,0x65,0x38,0x6F,0xF7,0x37,0xD7,0xC3,0x93,0xFF,0xAA,0xF8,0x35,0xBE,0xFA,
+	0x64,0x06,0x6A,0x43,0x03,0x85,0x51,0xF8,0xC8,0xB0,0x5A,0x19,0x9D,0x7F,0xBF,0xF3,0x7C,0xF7,0xA5,0x52,
+	0x4E,0xC4,0x05,0xCE,0x0E,0xC8,0xBE,0xEB,0xD3,0xB4,0xDE,0x1B,0x23,0x5F,0x29,0x96,0x7C,0x1E,0x9D,0xC3,
+	0x55,0x53,0xF6,0x22,0x97,0x30,0x48,0xA9,0x80,0xF5,0x63,0x1E,0xF9,0xB1,0x14,0xD6,0xD0,0x8A,0xBF,0x49,
+	0xBC,0x01,0x95,0xFD,0x89,0x56,0x9A,0x83,0x59,0x1B,0x39,0x9F,0x0D,0x53,0x63,0x4E,0xFA,0xE2,0x61,0xA8,
+	0x83,0x52,0xC4,0x9F,0xBB,0x70,0x20,0x02,0x04,0xC0,0xB0,0xFE,0x14,0x5B,0x20,0x62,0xC4,0xC6,0x4D,0xC8,
+	0xAF,0x7F,0x28,0x12,0x05,0xC1,0xEE,0xB2,0xE8,0x79,0x3C,0xB5,0x64,0x56,0x36,0x44,0xBE,0x70,0x35,0x7F,
+	0x84,0x82,0xA1,0xFB,0x15,0xE0,0x25,0x37,0x25,0x19,0x4E,0xD9,0xD2,0xF0,0x29,0x87,0x85,0x83,0xB1,0x1F,
+	0x17,0x8B,0x8D,0xCC,0x86,0x30,0xC7,0x0E,0x6A,0xBC,0x9D,0xB9,0xF5,0x7B,0x9E,0x13,0xEA,0x4C,0x8F,0x1D,
+	0x39,0xD4,0x92,0x7B,0x55,0xA4,0x52,0xA1,0x3F,0xFA,0xDF,0x06,0x11,0x65,0x08,0x34,0xE5,0x3B,0x78,0x55,
+	0xCE,0xE3,0x9A,0xC7,0x90,0xF4,0x3A,0x47,0x66,0xCE,0xA5,0xE5,0x20,0x88,0xFD,0xDC,0xF6,0x16,0x16,0xAC,
+	0x81,0xA6,0xC1,0x29,0x56,0xB8,0x87,0x57,0x26,0x68,0x4E,0x68,0x76,0x6E,0x22,0x0A,0x0C,0xC8,0x1C,0xFE,
+	0xEF,0xA7,0x62,0x59,0x54,0x42,0xCD,0xD4,0xA3,0x37,0x2A,0x1A,0x0D,0xC9,0xFA,0x9C,0x14,0xCD,0x8E,0x5A,
+	0x45,0x19,0x47,0xD0,0xA6,0x76,0x23,0x9E,0x8C,0x8A,0x83,0xF1,0x9A,0xAB,0xF4,0xD5,0x2D,0xAC,0x73,0xA6,
+	0x0E,0x67,0x6C,0x2C,0x8D,0x8B,0x93,0xCF,0x72,0xA4,0x94,0xEB,0x4C,0x6A,0x44,0xC1,0xDB,0xD9,0x5C,0x0C,
+	0x36,0xC0,0xA8,0xAC,0x8F,0xB5,0x7B,0x99,0x57,0x63,0xD2,0x8E,0x5A,0xC8,0x14,0x73,0xE4,0xDC,0x6D,0x16,
+	0x77,0x25,0xE7,0x8E,0xB0,0x62,0xC2,0x84,0xF3,0xE0,0xF2,0x39,0x65,0x9F,0x18,0x30,0x5F,0x24,0xFA,0x98,
+	0xD3,0xD5,0x25,0xED,0x1B,0x97,0x15,0x76,0x74,0x70,0x95,0x0F,0x6A,0x0C,0xF3,0x68,0xCA,0x67,0x84,0x21,
+	0x2E,0x33,0x01,0x82,0x4F,0xB4,0xFA,0x2C,0x64,0xFE,0x90,0xEC,0xBB,0xED,0x4B,0x58,0x72,0x42,0xAC,0x92,
+	0x94,0x1C,0xF6,0x97,0x96,0xFD,0x94,0x9A,0x1E,0xC9,0xC2,0x8E,0xCA,0x4E,0xDA,0x87,0xA4,0xF7,0x94,0x05,
+	0xB5,0xFD,0xDE,0xD4,0x64,0x05,0x77,0xD5,0x1F,0x83,0xC9,0xB4,0x16,0x1E,0x1E,0x51,0x09,0xFD,0xE2,0xB2,
+	0xE3,0xA1,0xC6,0x48,0x02,0xB1,0x10,0x3F,0x18,0xD6,0x82,0x83,0x35,0xE4,0x66,0xC2,0x8D,0x90,0xAC,0xF2,
+	0xF4,0x38,0xAC,0xD6,0x8F,0x60,0x60,0x34,0x9B,0x18,0xD8,0x90,0x90,0xB0,0xC6,0x05,0x3A,0x5E,0xE5,0x59,
+	0x5A,0x05,0x25,0x43,0x0D,0x1B,0x4F,0x53,0x5E,0x79,0x68,0x85,0xB6,0xF9,0x3A,0x57,0xA3,0xB2,0xE7,0x35,
+	0x38,0x1A,0x45,0x0C,0x0E,0x7F,0x85,0xF3,0x1E,0x1F,0xC2,0xAD,0x2D,0xF8,0x95,0x0C,0x35,0x58,0xB1,0x28,
+	0x6F,0x3E,0xF4,0xC3,0x9D,0x87,0x2F,0x45,0xCE,0x9D,0xA2,0x8A,0x9E,0xBF,0xB1,0x38,0x64,0xBD,0x45,0x3A,
+	0x25,0x3C,0xDD,0x89,0xA4,0xD5,0xFD,0x9B,0x1F,0xBC,0x0F,0xDB,0x58,0xD3,0x4E,0x54,0x0F,0x05,0x3A,0xE9,
+	0x23,0xFE,0xA3,0x8E,0xDE,0x4B,0x07,0xEB,0xFD,0xD4,0x85,0x4C,0x8D,0x54,0xB9,0xC2,0xA9,0x9B,0xEC,0x5D,
+	0x27,0x11,0x60,0x88,0x0E,0xD4,0xC4,0xDE,0x0C,0xBE,0xC6,0x69,0xE7,0x6E,0xAA,0xCD,0x2E,0xE5,0x4B,0x09,
+	0xE3,0xD0,0x4A,0x9C,0x84,0xFB,0xCF,0x69,0x71,0xC1,0x6B,0x5C,0xAF,0xB6,0x09,0xED,0x0F,0x5D,0x33,0xEE,
+	0x5F,0x61,0xCF,0xC8,0xD9,0xFB,0xC9,0x96,0xA2,0x1B,0x04,0xDC,0x4E,0x60,0x55,0x92,0x1E,0x54,0x78,0x01,
+	0x06,0xC0,0xEE,0x76,0x23,0xB9,0x68,0x04,0xA9,0x88,0x69,0xC9,0x58,0x7B,0x1E,0x72,0xFE,0xDC,0xEA,0x10,
+	0x10,0x61,0x5C,0x10,0x41,0x91,0x9C,0xC8,0x51,0x9A,0x38,0xFF,0x69,0x0D,0x7B,0x76,0xD9,0x4E,0xBD,0xB3,
+	0x84,0x48,0x88,0xDD,0x15,0xD9,0xC9,0x94,0x9A,0x9E,0xBD,0x3B,0x70,0x8C,0xD9,0xB4,0xD5,0x95,0x1D,0xB1,
+	0x95,0x35,0x60,0x30,0x9A,0x40,0xB8,0x76,0xC3,0x50,0x7E,0x66,0xD3,0xD8,0x56,0x73,0x54,0x84,0xB2,0x58,
+	0xDC,0x5A,0xF5,0x4A,0xB0,0xA0,0xE1,0xAE,0xF2,0x41,0x3C,0x53,0x9A,0x01,0xE0,0x46,0x23,0x63,0xB9,0x77,
+	0xE2,0xB9,0x7F,0x66,0x13,0xB8,0x77,0x17,0xFD,0xEB,0x69,0x99,0x1B,0x43,0xDA,0xAF,0x07,0x28,0xB4,0x7A,
+	0x47,0x13,0xF7,0x97,0x1A,0x03,0x7A,0x2F,0xF1,0x07,0x0A,0xAC,0x04,0xA8,0x5A,0x20,0xA9,0xE7,0xAC,0x68,
+	0x79,0x38,0x78,0x0D,0x8A,0x67,0x4A,0x98,0xA0,0x24,0x90,0xC7,0x6B,0x49,0x18,0xCD,0x1C,0x96,0x05,0x5C,
+	0x61,0xE2,0xBD,0x5C,0xB9,0x88,0x1A,0xDA,0xD1,0xE1,0x7B,0x20,0xEB,0xF3,0x6B,0x4F,0xF8,0x06,0x67,0x8F,
+	0xDD,0x21,0x9D,0x4A,0x8C,0x27,0xBB,0x25,0xDF,0x29,0xE3,0x4F,0xAB,0x69,0xFD,0x7E,0x6A,0xB3,0xF6,0x1A,
+	0xC4,0x29,0xFB,0x3F,0xDE,0x70,0x6A,0x00,0x8B,0x43,0xE5,0x76,0xB8,0x59,0x7A,0x22,0xDB,0x42,0xF4,0x9E,
+	0x92,0x09,0xBB,0x41,0x55,0x51,0x7A,0x53,0x39,0xAB,0xAB,0x61,0x15,0x71,0xAB,0x4A,0x13,0x0A,0x6B,0xB7,
+	0x0B,0xC3,0xB3,0x6F,0xE3,0xB3,0xE4,0x19,0xC3,0x9F,0xF2,0x2E,0x5F,0x73,0xC0,0x12,0x20,0x18,0x1F,0x64,
+	0x70,0x9F,0xB8,0x32,0x64,0x5A,0x4B,0xA1,0x76,0xB0,0xEF,0x50,0x2D,0xBA,0x26,0xFC,0x90,0xEE,0x12,0xB4,
+	0xE3,0x55,0x16,0x90,0x9C,0x41,0x87,0x05,0xAE,0x42,0x8B,0x87,0xC0,0x34,0x95,0x82,0x54,0xF9,0x74,0x4D,
+	0xCD,0xB7,0x87,0x6E,0x92,0x6A,0xED,0xC3,0xD8,0x3E,0xA8,0xD3,0x8A,0x3B,0x67,0xBD,0x2E,0x2C,0x7E,0x47,
+	0x8E,0x08,0x97,0x3E,0x87,0xB1,0xEB,0xFB,0xC1,0xD1,0xCC,0x9B,0xDE,0x11,0x62,0xD7,0xF2,0x1A,0xB3,0xA6,
+	0x41,0xAA,0x24,0xC2,0x53,0x89,0xA4,0xFC,0x18,0x31,0x6B,0xC7,0x33,0x8A,0xD2,0x9B,0xD8,0x39,0x64,0x03,
+	0x3F,0xC2,0x61,0xE7,0x2D,0xDD,0xF9,0x9B,0x6A,0x53,0x5D,0xBF,0x92,0xC7,0x7A,0x13,0x03,0x86,0xDD,0x8A,
+	0x8F,0x88,0xB4,0xDC,0x0A,0x78,0x1D,0x6C,0x18,0x3B,0x16,0x5B,0x29,0xD5,0xB6,0xF8,0x95,0x48,0x3A,0xD3,
+	0x3B,0xD4,0x8A,0x9E,0x2B,0x92,0xDE,0x3C,0xD4,0x54,0xBE,0x00,0xE9,0x3D,0x10,0xA9,0xE0,0x5A,0x02,0x9C,
+	0xD3,0x92,0x69,0xED,0x01,0x12,0x6F,0xA5,0x27,0x25,0x15,0x98,0x88,0x39,0x07,0x9C,0x39,0x59,0xB3,0x2B,
+	0xAD,0x51,0xBC,0xBA,0x14,0x4B,0x6F,0x92,0xE3,0x78,0xFD,0x8B,0x34,0xA3,0xAD,0xCC,0xA3,0x53,0x6D,0x49,
+	0x8D,0xC0,0xF0,0xDA,0x73,0x29,0x0A,0x22,0xC6,0x5F,0x26,0xAB,0xC8,0x42,0xF5,0xAF,0xFF,0x1E,0x6C,0x16,
+	0x13,0xC0,0xF8,0x48,0x41,0xE3,0x2E,0xCE,0x4B,0x4F,0x03,0xB6,0x2B,0x1D,0xEF,0xD7,0x27,0x92,0x30,0x17,
+	0x10,0x7E,0x61,0xFF,0xA1,0x1B,0xF1,0xFB,0x65,0xC2,0x42,0x40,0x86,0x4C,0xA3,0x84,0xD1,0xE9,0x52,0x36,
+	0x47,0xD0,0x8D,0x44,0xBF,0x28,0x20,0x0B,0x87,0x74,0xB1,0x74,0x68,0xA8,0x38,0x36,0xC0,0xC1,0x58,0x3B,
+	0x66,0x78,0xBC,0x61,0x46,0xE2,0x99,0xF8,0x16,0x6E,0x68,0x5B,0x80,0xC1,0x8F,0x76,0xB4,0x1D,0x8E,0xE3,
+	0x05,0x8C,0x7D,0x95,0x50,0x0A,0x59,0x65,0xE0,0x6E,0x03,0xF0,0x17,0xE3,0x40,0x90,0x86,0xBD,0xB1,0x77,
+	0xB5,0x1B,0xFB,0x02,0xCB,0xD0,0x60,0xA4,0xDA,0xEA,0x48,0xD2,0x87,0x40,0xFB,0x0D,0x7D,0xAA,0x0A,0x62,
+	0x47,0xCF,0xA0,0xF2,0x34,0xC5,0x41,0xA5,0x06,0xE5,0xDC,0x58,0x35,0x23,0x09,0x18,0xA6,0x86,0x51,0x8D,
+	0x37,0x80,0x49,0x3D,0x07,0xD1,0x92,0x38,0x43,0xA8,0x0C,0x80,0x43,0xBA,0x1D,0x97,0x8F,0x82,0x18,0x88,
+	0xC9,0xF1,0x9A,0xF0,0x9E,0x64,0xB8,0xC8,0xE0,0x65,0xBA,0xAB,0x6F,0x41,0x0A,0x35,0xAC,0x26,0x29,0x3E,
+	0x01,0xD9,0x37,0xD8,0x26,0x01,0x67,0x3F,0x6A,0x25,0x5B,0x2C,0x2F,0x8C,0x3B,0x6D,0xE9,0xA1,0x3A,0xC9,
+	0x60,0x67,0xE8,0x79,0xA7,0xCA,0xA5,0xE4,0x8B,0xE9,0xCB,0x49,0xAC,0xA6,0xC4,0xD3,0xBC,0x06,0xE6,0x5B,
+	0xAA,0xEB,0x42,0x60,0x8E,0xD2,0xD0,0xB0,0xA6,0xA3,0x60,0x6E,0xAC,0x4C,0x46,0xE9,0xED,0x67,0x4A,0xFF,
+	0x97,0xC9,0x45,0x0D,0xBC,0x7C,0xEE,0x2B,0xCB,0xAC,0xDB,0x79,0xBE,0x86,0x43,0x2D,0x0E,0xD2,0x5E,0x50,
+	0x3D,0x2B,0x73,0xAB,0x32,0xAF,0xF7,0xE8,0x35,0xAA,0xCA,0x5C,0x7E,0xD0,0xC4,0xF6,0x68,0x22,0x1B,0x6F,
+	0xD9,0xA4,0xA1,0x7B,0x51,0xF6,0x88,0x00,0xE1,0x49,0xB4,0x8B,0x36,0x1D,0x71,0xD1,0x61,0x92,0xCC,0x81,
+	0xAB,0xAF,0x86,0xEB,0x84,0x37,0xA4,0x9F,0xB7,0x7D,0x88,0xD0,0x9A,0xBF,0x46,0xBE,0xAA,0xAE,0x1D,0x10,
+	0xBD,0x94,0xAB,0x40,0x76,0xB2,0xF1,0x12,0x45,0x0D,0x95,0x03,0x59,0xC2,0x24,0xD3,0xA1,0xB6,0xB3,0xF5,
+	0xC8,0xB8,0x5B,0xE3,0x10,0x75,0x9D,0x5F,0x58,0xC3,0x80,0xE5,0xC1,0x84,0xDE,0x41,0xC5,0x3F,0x2C,0xE6,
+	0x2C,0xB0,0x15,0x9C,0xEC,0x59,0x59,0x30,0xDE,0xEA,0x6C,0x51,0xC0,0x3E,0xC8,0x18,0xC6,0x79,0x82,0xF0,
+	0x82,0x83,0x8A,0x28,0x57,0xC9,0xE1,0x40,0x4D,0x3D,0x4D,0x4B,0x45,0x97,0x55,0x6D,0xF7,0x66,0xFD,0xD8,
+	0x23,0xC3,0x69,0x50,0x48,0xF6,0x05,0xC2,0x44,0xD8,0x06,0x8C,0x61,0x48,0x0B,0x08,0xE9,0x61,0x26,0x7D,
+	0x75,0x15,0xBA,0xEA,0x20,0x0C,0x4E,0xA6,0xA3,0xA7,0x84,0xE3,0xC4,0x81,0x9C,0xAE,0x18,0x86,0xB6,0xEB,
+	0x25,0x91,0x9D,0xB9,0xD0,0xC9,0x19,0xDF,0x0F,0x9C,0x2F,0x7E,0x1F,0xDA,0xBB,0xB4,0xAD,0x7E,0x97,0x4F,
+	0x6C,0xBE,0x57,0xBC,0x44,0xA3,0xF5,0xC9,0xD7,0xB4,0x01,0xFF,0x0F,0x9B,0xC7,0x98,0x22,0xA4,0xC2,0xB0,
+	0x99,0x91,0xD7,0xC8,0xF6,0xD8,0x48,0xEC,0x24,0x98,0xCD,0x65,0x8D,0x0C,0x47,0x80,0xE6,0xF9,0x4E,0x5A,
+	0x73,0x59,0x46,0xB0,0x5D,0xD2,0x55,0x11,0x9E,0x41,0xD3,0x81,0x67,0xDA,0x9F,0x0D,0x32,0xB0,0x2F,0xEF,
+	0xA4,0xBA,0x99,0x0D,0x39,0x73,0x44,0x39,0x03,0x83,0x2F,0xCA,0x73,0xFD,0x46,0xDF,0x5E,0x2B,0x06,0x8D,
+	0x2E,0xC0,0x31,0x06,0x24,0x17,0xF3,0xFB,0x08,0x62,0x6F,0x5A,0xD6,0xDF,0x96,0x64,0x40,0xFD,0x45,0xBE,
+	0x01,0xB0,0x94,0x2C,0x38,0xC0,0x76,0xD2,0xD6,0xCC,0x18,0x55,0x3D,0xCC,0x01,0x42,0x3A,0x02,0x45,0x31,
+	0x93,0x62,0x28,0xAA,0x73,0xB2,0x7D,0xB7,0x94,0x6A,0x32,0x1E,0x22,0x87,0xB3,0xE6,0xC2,0x62,0x36,0xDE,
+	0x20,0xDF,0x52,0xF2,0x13,0xE3,0xEC,0xD2,0x12,0x0E,0x5B,0x32,0x14,0x46,0x90,0xE5,0x26,0x4E,0x19,0x8C,
+	0x56,0x08,0x03,0xE2,0x13,0x55,0x77,0xB6,0xFA,0xDF,0x17,0x6C,0x67,0xC8,0xB1,0x9F,0xB8,0x1F,0xC1,0x20,
+	0xF2,0xAB,0x82,0x3B,0x31,0x43,0xD1,0x00,0xB2,0xED,0x05,0x3B,0xFC,0xBA,0x19,0x45,0x87,0x2E,0x99,0x33,
+	0x9B,0xE5,0x00,0x08,0x24,0x0B,0x7A,0xB9,0x53,0xED,0xAD,0x56,0xD1,0x97,0xF1,0x0D,0x52,0x6A,0xEB,0x5A,
+	0xD9,0x77,0xDA,0x38,0xA9,0xE7,0x53,0x90,0xF4,0xF8,0xC2,0x18,0x30,0xB8,0x69,0xC7,0x43,0x52,0x45,0x2C,
+	0x5F,0x1B,0x3D,0xEB,0x15,0x35,0x47,0x48,0x5A,0x6A,0x83,0x73,0x35,0xD6,0xCB,0x29,0xF1,0xFB,0xF4,0x67,
+	0xA7,0xD4,0x54,0x19,0x9F,0x59,0x85,0x2D,0x2C,0x25,0xC0,0x7B,0xDD,0xF6,0x51,0xE8,0x0E,0x4C,0xA2,0x63,
+	0x10,0xA7,0xD3,0x99,0x11,0x48,0xEC,0xB5,0x3A,0xD3,0x59,0xDC,0x05,0xDC,0x70,0xDE,0xEF,0x0F,0x49,0xFA,
+	0x8E,0x64,0x98,0x1C,0x1C,0xEC,0x5F,0x71,0x08,0x7B,0x47,0xAF,0xA9,0xF7,0x43,0x6D,0xCE,0x67,0x8B,0x69,
+	0x52,0x76,0x5B,0x4D,0x87,0x0C,0xB3,0x9B,0x99,0x29,0x63,0x3E,0x09,0x0F,0xD9,0x1D,0xDF,0x4B,0xFF,0xFB,
+	0x0E,0xAF,0xE6,0x90,0x31,0x70,0x90,0xA9,0xDE,0xD0,0x14,0xE5,0x17,0xED,0xD8,0xDB,0x23,0xFF,0xEE,0x85,
+	0x30,0x71,0x76,0xAD,0x75,0x25,0x1C,0xF5,0x16,0x77,0x3E,0x24,0x53,0x2E,0x99,0xBD,0x41,0x5C,0x94,0x8B,
+	0xB4,0x02,0x79,0x37,0xB8,0x7A,0x0B,0x1E,0x18,0x45,0x91,0xA0,0x40,0x5F,0x5D,0xBD,0x51,0x77,0x28,0x34,
+	0x92,0x33,0xDF,0xB6,0xDD,0xB9,0x40,0xA4,0x3E,0x37,0x90,0x94,0x61,0x3D,0xEE,0x17,0x21,0x70,0x8B,0x54,
+	0x35,0xF3,0x94,0xD8,0x58,0xAF,0xC2,0x06,0x8A,0xEF,0xBE,0xE5,0x70,0xD5,0x8A,0x61,0x07,0x36,0x47,0xD9,
+	0x5B,0x7F,0xBD,0xED,0x03,0x4D,0x12,0x96,0xD7,0x1A,0xA5,0xC1,0x21,0xDB,0xC9,0xF5,0xF7,0xE4,0x47,0xED,
+	0xC0,0xCD,0x83,0x2D,0xFB,0x73,0x0E,0x9D,0xD9,0x6E,0xE4,0x88,0x3B,0x78,0x97,0xCA,0xB4,0x58,0xEE,0xDE,
+	0x93,0xA2,0x89,0x52,0x88,0x94,0x02,0x0E,0x3D,0x33,0x18,0xBC,0x40,0xC8,0xA0,0x64,0xBB,0x69,0x7C,0xE2,
+	0x3E,0x25,0x9B,0xB8,0xBE,0x58,0x17,0xA4,0x98,0x5B,0x91,0x75,0xAA,0xE8,0x22,0x77,0x48,0x87,0x0D,0x1F,
+	0x7C,0xC2,0x24,0x59,0xFB,0x19,0xD7,0x9D,0x10,0x01,0x1E,0xBB,0x3D,0x13,0xB8,0x14,0x13,0xB1,0x08,0x31,
+	0x36,0x1D,0x12,0x9F,0x5F,0x10,0xE6,0xC1,0xA9,0xD1,0x4E,0x4C,0xD2,0x54,0x3C,0xFD,0x6A,0x57,0xE0,0x21,
+	0x38,0xED,0xF3,0xBA,0xB5,0x11,0xD7,0xD9,0xB6,0x3D,0x0E,0x9C,0x0F,0x32,0xB5,0xF8,0xF9,0xEE,0x80,0xBB,
+	0xC2,0x45,0x8D,0x22,0x52,0x76,0x01,0x20,0x37,0x1E,0x1B,0x78,0xB8,0x8C,0x1F,0xA7,0xFF,0x1D,0xFB,0x74,
+	0x27,0x79,0x52,0xB2,0x45,0x50,0xE8,0x3F,0x76,0x00,0xD5,0x92,0xCA,0xE1,0x93,0x76,0x5D,0x2E,0xFD,0xCA,
+	0xC5,0x41,0xF3,0xC5,0x0E,0xA0,0xF5,0xF9,0x39,0xE1,0x5B,0x41,0xD4,0xE3,0x0B,0xD5,0x3B,0x80,0x37,0xD4,
+	0x83,0x42,0x4C,0x53,0xC5,0xFE,0xB1,0x13,0xBC,0x42,0x03,0xDB,0xA8,0x0C,0x51,0x33,0xF1,0x74,0xE0,0x4B,
+	0xEF,0x7E,0x53,0xC6,0xB7,0x2C,0x78,0x66,0x6F,0x55,0x6D,0xA3,0x09,0x7B,0xE8,0x50,0x4E,0x84,0x17,0xD2,
+	0x09,0x3E,0x26,0xAB,0xC7,0xC4,0x07,0xF3,0x59,0x6F,0x2B,0x46,0xF7,0x8F,0xC1,0xA5,0xB2,0x2B,0x2F,0xBA,
+	0xC4,0x87,0xCF,0xBA,0x95,0x76,0x6B,0x47,0x81,0xF5,0x79,0x77,0x9B,0xE7,0xF9,0xF2,0xE7,0x07,0x2E,0x33,
+	0x88,0x4A,0x47,0xE5,0x50,0x96,0x62,0x8B,0x78,0xA2,0x0C,0xF3,0x4A,0x28,0xB6,0x27,0xDE,0x9D,0xBA,0xF2,
+	0x1F,0x74,0x3C,0x9A,0x13,0x68,0x3F,0xBA,0x45,0xF9,0x52,0x2A,0x79,0x74,0x1D,0x79,0x37,0xD5,0x23,0x6E,
+	0xEC,0x83,0x07,0x23,0x03,0xCA,0x21,0xAB,0xD2,0x3B,0xBC,0xE4,0x78,0xE8,0xE3,0x17,0x6C,0xC7,0x6E,0x3F,
+	0xD5,0x90,0x17,0xAD,0xD9,0xE1,0x5B,0x0F,0x51,0x8E,0xC6,0xBA,0xF7,0x16,0xF1,0x4A,0x0E,0xBC,0x6A,0x29,
+	0x94,0x85,0x12,0xFA,0x0B,0x9E,0x46,0xCD,0x32,0xA7,0xFE,0xFE,0x51,0xD0,0x6F,0x0D,0x7A,0x81,0x59,0xC9,
+	0x4B,0xA7,0xFB,0x83,0x77,0xE7,0x4D,0xB6,0xEC,0x43,0xBB,0xC6,0xFC,0x4E,0x7B,0x4B,0xD7,0x94,0x27,0x2C,
+	0xC4,0x26,0xB7,0xA6,0x32,0x8D,0x99,0x7A,0xDC,0x4F,0xD9,0xA6,0x4F,0x9F,0x9F,0x64,0x10,0xB6,0xF0,0xF2,
+	0xA6,0xB0,0x07,0x6A,0x47,0xB0,0x97,0x37,0xD2,0x2C,0xB4,0x92,0x1C,0x50,0x06,0x41,0x36,0x5A,0x17,0x7C,
+	0xCE,0x5E,0x65,0xFC,0xD8,0x6D,0x0F,0xFA,0x15,0x2B,0x7D,0xA7,0xCD,0x43,0x19,0x02,0x21,0x91,0xF9,0x68,
+	0x74,0xF0,0xEE,0x0F,0x65,0x49,0xC2,0x31,0x20,0x29,0x70,0xA9,0xE2,0x6E,0x3C,0xD2,0x8A,0x99,0x48,0x59,
+	0x37,0xE4,0x64,0xF7,0x22,0xD5,0xE6,0xE2,0x9D,0x6E,0x84,0xCB,0xA5,0xE0,0xFE,0xD2,0xDC,0x2F,0xF9,0x80,
+	0x8C,0x0F,0xDD,0x71,0xF5,0xF6,0x7B,0x0E,0x87,0x06,0xDB,0x1A,0xF5,0xD6,0xF4,0xE6,0xC6,0x96,0xCB,0x3F,
+	0x74,0xB7,0x29,0x23,0xE7,0x98,0xCD,0x23,0x5E,0xED,0x03,0x2B,0x8C,0x6D,0xF8,0x15,0xD3,0xBB,0x0D,0xC0,
+	0x02,0x84,0x9D,0x0A,0x32,0x61,0x4E,0x8D,0xCF,0x73,0xA0,0x63,0x97,0x82,0x15,0x14,0x9C,0xAF,0xA2,0xAC,
+	0x75,0x63,0x75,0x7D,0xAF,0xD9,0x77,0xC4,0x3E,0x99,0x67,0x5C,0xE0,0xEC,0xC7,0xD9,0x95,0xB5,0x78,0xAA,
+	0xC8,0x77,0x8D,0x1E,0xEB,0x55,0x27,0x97,0x54,0xED,0x91,0x43,0x30,0x3D,0x77,0xBF,0xC4,0x4A,0x27,0x62,
+	0x14,0x61,0x38,0x13,0xA6,0xDD,0xCC,0x4B,0x30,0x36,0xF2,0xEE,0x38,0x12,0x74,0xCE,0x2E,0x2E,0x76,0xCE,
+	0xDE,0xF1,0x21,0xCF,0x6C,0x1D,0xD4,0x1A,0xCE,0x02,0x26,0x38,0x3B,0xFB,0x47,0xF7,0x47,0x04,0x63,0x3C,
+	0xED,0xF7,0x67,0xF2,0xCC,0xD8,0x37,0x6A,0x9B,0xF4,0x0D,0xDF,0xAE,0x7F,0xA4,0xAC,0xA0,0x6A,0xCB,0x99,
+	0x10,0xC4,0x4A,0xCF,0xF9,0x9D,0x93,0x73,0x5B,0x09,0x8A,0x44,0xB3,0x2D,0xD3,0x6B,0xC2,0x08,0xDA,0x25,
+	0x72,0x6D,0x68,0x3F,0x31,0x8C,0x00,0x03,0x72,0x01,0x60,0xB2,0x63,0x34,0x58,0xA8,0xD0,0x67,0x85,0x85,
+	0xA0,0xEA,0xCB,0xEA,0x33,0x24,0x35,0x43,0x83,0xFD,0x13,0xA7,0xD5,0xC2,0x57,0xF3,0x89,0x43,0xF1,0x97,
+	0xB3,0x83,0x21,0xE1,0x3F,0x4C,0x11,0xA1,0x70,0x9C,0xE7,0x77,0x69,0xA1,0x06,0xDC,0xFB,0xD5,0xB3,0x9B,
+	0xAB,0x35,0x53,0xE0,0x14,0x5A,0xE0,0xDA,0x97,0x91,0x08,0xC1,0x41,0xD0,0x66,0x5C,0x29,0x92,0x7C,0x0B,
+	0xF0,0xC5,0xC1,0xB0,0x62,0x46,0xD7,0x20,0xF2,0x66,0x47,0xDE,0x29,0x37,0x11,0xF1,0x37,0xC9,0xEC,0x4A,
+	0xE8,0x73,0x5A,0x6B,0xEB,0x92,0x27,0x5D,0x2A,0x76,0x4E,0x77,0x62,0x26,0x80,0xCE,0x8D,0xC8,0xB8,0xEE,
+	0x9A,0x2B,0x72,0x6C,0x69,0xC3,0xC2,0x4E,0x1C,0x6E,0x08,0xF0,0x7C,0xC9,0xCD,0xFE,0x9B,0x2A,0x9E,0xDA,
+	0xCB,0x01,0xB2,0x43,0xD4,0x0B,0x3D,0xD0,0x6A,0x8A,0xD6,0xEF,0x1A,0x29,0x1B,0xCB,0x64,0xC1,0x1B,0x24,
+	0xDE,0xB8,0x89,0x9B,0x35,0x1A,0x0E,0xFF,0x1B,0x28,0xD2,0x4B,0x6A,0x4D,0xCB,0x5F,0x9D,0x6D,0x84,0x8E,
+	0x98,0x0F,0xD1,0x76,0x26,0x37,0x04,0xD3,0xA1,0x7D,0x82,0x71,0x3B,0x6D,0xA8,0xAB,0xC5,0xA6,0x6D,0x60,
+	0xCF,0x9C,0x24,0x50,0xB7,0x3C,0x25,0x0F,0x00,0x01,0xA0,0xB2,0x6B,0xA1,0xC7,0xC9,0xD6,0x96,0x6D,0x41,
+	0xA0,0xD9,0x57,0xF5,0xB1,0xAF,0x2D,0x51,0x60,0x89,0xEC,0x65,0x4B,0x5E,0xE8,0x55,0x33,0x7E,0xB9,0xFD,
+	0xD8,0x1F,0xAB,0xFA,0xFD,0x52,0xBC,0x54,0xCB,0x3F,0x5E,0x7F,0xC3,0x56,0x77,0xBB,0xAE,0xDF,0x5C,0x88,
+	0x35,0x17,0xC6,0x6F,0x92,0x37,0xE7,0x52,0xCD,0x5C,0x2B,0xB2,0x85,0x15,0xC4,0x16,0x20,0x50,0xE5,0xC1,
+	0xE4,0x3F,0x1D,0x25,0x41,0xD8,0xF2,0x54,0x22,0x32,0xB8,0x11,0xC2,0x73,0x05,0x94,0xB7,0xE1,0x57,0x5E,
+	0x42,0x5E,0x3E,0x83,0x2D,0x96,0x25,0x60,0xF4,0xAB,0x68,0x5B,0x31,0x4C,0x56,0x20,0x26,0xF9,0x9B,0xD4,
+	0x81,0x7D,0xBF,0xFC,0xEB,0xA2,0x60,0x46,0x79,0x3F,0x5D,0x83,0x4E,0xD4,0xCE,0xE5,0x50,0x37,0x63,0x7E,
+	0x9E,0xB2,0x05,0x51,0x29,0xC9,0xC9,0xD1,0x19,0x52,0xD6,0x75,0xD3,0xA6,0x58,0xC2,0x51,0x06,0x4F,0xAA,
+	0xB5,0xF5,0x22,0x0E,0x6E,0x35,0x83,0x2C,0xB3,0x73,0x7E,0x4E,0x50,0x1C,0x70,0x0E,0x3D,0x98,0x5C,0x53,
+	0xCB,0x5E,0xC8,0x9F,0x7C,0xD3,0x46,0x19,0x42,0xA3,0x06,0x95,0x3F,0xEB,0xAA,0x5A,0xEB,0x51,0x3F,0xA6,
+	0xE5,0xCD,0xC4,0x0D,0xA6,0xD3,0x47,0x11,0x56,0x3C,0x9F,0x99,0x09,0x55,0xA5,0xA9,0x7D,0x6C,0x09,0x5C,
+	0xF6,0x84,0x79,0x1F,0xBC,0x8B,0xAB,0xA9,0x4A,0x5D,0xC1,0xB2,0xF3,0x35,0x60,0xFC,0xEC,0xB8,0x7C,0xCE,
+	0x20,0x7E,0x54,0xD9,0xCB,0xFD,0xD6,0x1D,0x1E,0x6C,0x28,0x29,0xE9,0x5D,0xAC,0xF1,0x38,0xBF,0xFE,0x8A,
+	0x09,0x3F,0x80,0x25,0x77,0xD6,0xD1,0x5E,0x4B,0xB1,0x05,0x06,0x45,0x52,0x6F,0xD9,0x3D,0xF1,0xF7,0xE5,
+	0x7D,0x3E,0xF8,0xDF,0x5F,0x7B,0x70,0xAD,0xB7,0xC0,0x21,0xFE,0xED,0xBF,0x4D,0xF1,0x33,0xBE,0xE0,0x87,
+	0x70,0x0D,0x36,0xE4,0x96,0x88,0xB8,0xF6,0xE7,0xC6,0x38,0x3F,0x52,0x32,0x31,0x64,0xF6,0x9A,0xD0,0x94,
+	0x1C,0x9C,0xE7,0xD0,0xE9,0xCC,0x0F,0x37,0xD8,0xED,0x78,0x7A,0x63,0x99,0x18,0x65,0xD7,0x1D,0xB9,0x21,
+	0x65,0x48,0x99,0x03,0x5B,0xE0,0xB2,0x65,0x08,0x15,0x69,0x8B,0x4C,0xA5,0x73,0xCD,0x66,0xC5,0xD1,0x29,
+	0xB1,0x17,0xD7,0x44,0xF2,0xE0,0xE6,0x7B,0x96,0xB8,0x0B,0xA0,0xC5,0x82,0xA0,0x67,0x46,0xA6,0x16,0xC9,
+	0x6C,0x13,0xBC,0xAA,0xDE,0x5E,0x3D,0x94,0x65,0xF7,0x42,0x85,0x33,0x10,0xC2,0xDD,0x5A,0x70,0xDB,0xB4,
+	0xB4,0x09,0xC6,0x47,0x27,0xDD,0x71,0x59,0xE5,0x9F,0xE9,0x4D,0x63,0x73,0x45,0xBA,0xE7,0x1C,0x7A,0xF1,
+	0x02,0x64,0x6B,0xF3,0xC7,0x41,0x6A,0x16,0x0A,0x89,0x2A,0x0A,0xBD,0x22,0x3A,0xAE,0xED,0x42,0x24,0x35,
+	0xD8,0x7C,0xEA,0x96,0xC3,0x7C,0x28,0x7C,0x5E,0x16,0x45,0xD8,0xE1,0xC4,0xC4,0xA9,0x36,0x4F,0xAD,0x78,
+	0x9B,0x75,0xDC,0xED,0x1E,0xE2,0xCE,0xC9,0x6D,0x40,0x17,0x5D,0x37,0x2C,0xE6,0x1F,0x9B,0x6D,0xD3,0x9D,
+	0x98,0xFB,0x71,0x84,0x6E,0xC6,0xBA,0xCC,0x1F,0x3F,0xD4,0xB9,0xE6,0x27,0x1D,0xCA,0x36,0xC3,0x4A,0x2D,
+	0x8C,0x6E,0xD2,0x53,0xBF,0xF7,0xCB,0x40,0x93,0x39,0x94,0x63,0x2C,0x8F,0x82,0xDA,0x11,0xD4,0x78,0x0D,
+	0x04,0xE4,0x51,0x4F,0x0B,0x98,0xB3,0xC6,0xE4,0x23,0x7B,0x6E,0xAD,0xEE,0x63,0x89,0xFC,0x2E,0x35,0x54,
+	0x83,0xC1,0x53,0xA0,0x76,0x5E,0x45,0x1E,0x40,0x49,0xE9,0x7D,0x8D,0x42,0x44,0xD4,0x7B,0x9D,0x64,0x1A,
+	0xDA,0x4B,0xBC,0xCE,0x85,0xDF,0xD5,0x06,0xA2,0x4F,0x52,0x5F,0x01,0x97,0xCC,0xD2,0x7B,0xBC,0x36,0xB6,
+	0xC6,0xD7,0x2A,0x21,0x94,0x5E,0x5B,0x4F,0x08,0x9F,0xBF,0x03,0x94,0x39,0x55,0xE2,0x60,0xDF,0x93,0x93,
+	0x32,0x56,0x98,0x13,0xC6,0x33,0x52,0xC5,0xBB,0xD1,0x35,0x16,0x86,0xF3,0xDB,0x46,0x37,0xB3,0xC7,0x5C,
+	0xFA,0x62,0x57,0x67,0x7E,0x97,0x6C,0xFD,0x12,0x00,0x68,0x62,0x34,0xBA,0x0F,0xD6,0xF3,0x50,0x4C,0xA4,
+	0x55,0x19,0xE9,0x80,0x8C,0x24,0x7F,0x84,0x88,0xB7,0x3B,0x58,0xA2,0x3D,0xBF,0x0C,0xC2,0x19,0x62,0xF8,
+	0x96,0x42,0xCB,0x3E,0x14,0x09,0xCA,0xE4,0xCC,0x32,0x93,0xD0,0x4A,0xB8,0x43,0xCE,0x6A,0x71,0x38,0x0F,
+	0x72,0x97,0x5E,0xCC,0x54,0xDA,0xEC,0x8B,0x1E,0xB5,0x4E,0x28,0x65,0x9C,0x01,0xA8,0x88,0x9C,0xA6,0xE2,
+	0xCC,0x96,0x6E,0x02,0xBC,0x44,0x5E,0x1A,0xD1,0xD4,0xE0,0x25,0x79,0x52,0x33,0xD3,0x88,0x9C,0x25,0x0D,
+	0xB9,0x9A,0x0F,0x7B,0x17,0xD5,0x14,0x31,0x20,0x0C,0x4F,0xDF,0x94,0xD9,0x85,0x1A,0xB3,0xD9,0x35,0xAB,
+	0x4E,0xD6,0xDC,0xBB,0x29,0x3E,0xE6,0x3B,0xCE,0xDC,0xE0,0xF3,0xBE,0x70,0xEA,0x2A,0x44,0x71,0x5E,0xE7,
+	0x4D,0xBD,0xCB,0xC1,0x44,0xE9,0xAA,0xB8,0xC0,0x10,0xC1,0xEA,0xD0,0x56,0xEA,0x27,0x4C,0x5F,0xCF,0x41,
+	0x3A,0x0A,0xDD,0x3C,0xC2,0xA5,0xE4,0x3B,0xE6,0x21,0xAD,0xEE,0x59,0xBE,0xAD,0x1D,0x3D,0x9C,0x78,0x98,
+	0x61,0xB5,0xFF,0xCA,0x93,0x9D,0x47,0xEF,0x58,0xBE,0x60,0x40,0x0E,0x0D,0x3E,0x42,0x16,0x61,0x28,0xF0,
+	0xF3,0x4F,0x50,0xB8,0x9E,0xCD,0x42,0xFF,0xA2,0x07,0xE8,0xB4,0x1D,0x61,0x52,0xEF,0xE2,0x47,0x7C,0xB6,
+	0x73,0x51,0x4B,0xFA,0x23,0x0F,0x91,0x18,0x94,0x03,0x71,0x94,0xEE,0x4F,0xDA,0xA7,0xF4,0x76,0x59,0x3E,
+	0x20,0x8B,0x9D,0x97,0x97,0x62,0x91,0x51,0x20,0x4C,0xE1,0xB1,0xF9,0xD8,0x50,0x9C,0x7D,0x14,0x90,0xB7,
+	0x96,0x89,0x30,0x20,0xFC,0xC9,0xD0,0x64,0x52,0x44,0x0B,0x23,0xA5,0xC7,0x6C,0x70,0xFA,0x5D,0x08,0x75,
+	0xE0,0xBE,0x27,0x74,0xAC,0x9A,0x81,0x61,0xE1,0x44,0xB9,0xF5,0x2E,0x89,0x29,0x27,0x76,0x40,0x2E,0x9A,
+	0xD2,0x66,0x89,0x55,0x77,0x3C,0xDF,0x37,0x6C,0x8A,0x43,0x8F,0xC5,0xB5,0x22,0x8A,0xDB,0x67,0x00,0xEA,
+	0xA9,0x82,0x5F,0xFC,0x79,0x27,0xA6,0xCA,0xCA,0x00,0x02,0x6A,0x50,0x2A,0x4A,0xE8,0x55,0x06,0xCA,0xDC,
+	0x1F,0x28,0x22,0x68,0x4D,0x46,0xEB,0x4E,0xFA,0x0C,0xFE,0xEB,0x0A,0x09,0xBD,0xD4,0x15,0xAC,0xD8,0x39,
+	0x6B,0x2F,0x83,0x2D,0x5A,0x62,0x6B,0xB9,0x3D,0x06,0x8E,0x08,0x9F,0x09,0x7B,0x7D,0xFE,0xC0,0x0B,0x7F,
+	0x78,0x67,0xDB,0x3F,0x39,0x35,0x4B,0xE9,0xED,0x40,0xF9,0xEC,0x6A,0x33,0x2D,0x93,0x5A,0x4C,0x5A,0x87,
+	0x30,0x54,0xC3,0x78,0xFE,0xED,0xA2,0x70,0xA2,0x5C,0xDA,0x83,0xA4,0x6D,0xD9,0xA9,0x86,0x4C,0xFD,0x04,
+	0x44,0x83,0x0A,0x65,0x23,0xAF,0xD3,0x92,0x25,0x91,0xF5,0xB1,0xB2,0xC6,0xD9,0xD9,0x70,0x6B,0xA3,0x86,
+	0x3F,0xAE,0x24,0x7D,0xDB,0x90,0xB1,0xE2,0x61,0x18,0xFC,0x75,0x6B,0xC4,0x10,0x42,0xC1,0xD8,0x08,0xE4,
+	0x1F,0xFD,0x34,0xC0,0x31,0x1E,0x94,0x80,0xD8,0x8B,0xDC,0x90,0x02,0x13,0xC2,0xD0,0x71,0x72,0x7D,0x03,
+	0x82,0xB2,0xBB,0x5C,0xD1,0x30,0x95,0x43,0x9F,0x0D,0x6A,0x21,0xD4,0xC2,0xB9,0x61,0xFD,0x1C,0x97,0x96,
+	0x92,0x3B,0x8D,0xE5,0xE7,0x12,0x1A,0xCD,0x74,0xE3,0x2C,0x22,0xA1,0x19,0xBA,0xC3,0x16,0xB9,0x17,0x78,
+	0x64,0xB6,0xD4,0xE4,0x72,0x8B,0x15,0x2D,0x84,0x57,0xF2,0x0C,0xBE,0x74,0x66,0x03,0x17,0x20,0x23,0xF4,
+	0x8C,0x8A,0x95,0x07,0xE8,0x9B,0xBB,0x19,0xFA,0xAC,0x09,0xC1,0xF8,0x26,0x2A,0xE5,0xF2,0x76,0x8F,0x64,
+	0xA5,0x36,0x61,0x50,0xD3,0x82,0x13,0x0A,0x1F,0x3E,0x19,0x1D,0xFD,0x0C,0x66,0x28,0x34,0x15,0x46,0xA8,
+	0x07,0xB3,0x42,0x2A,0x4A,0x19,0xCF,0xC0,0x1F,0x78,0x5E,0x19,0x4A,0xAB,0x94,0x1C,0x1A,0xBA,0x17,0xA8,
+	0xCA,0xD4,0xCE,0xB8,0x39,0xB2,0x4D,0x6B,0x0B,0x1C,0x6F,0x6F,0x51,0x80,0x2D,0x4B,0x6A,0x52,0xCE,0xC4,
+	0x9F,0x3A,0x77,0x1B,0xAC,0x71,0x4F,0x05,0xE4,0x96,0xE0,0x3D,0xCD,0xEB,0x99,0xFB,0xFD,0x80,0xF7,0x8E,
+	0xD6,0x50,0xB8,0xCA,0xDB,0xBF,0x96,0xC9,0xBA,0x5A,0x12,0x11,0x74,0xF8,0xB6,0x5C,0x61,0x89,0x5E,0x79,
+	0xCC,0xB6,0x26,0x7C,0x43,0x2E,0x1A,0x63,0x75,0xE8,0x57,0xBB,0x99,0xBC,0xE7,0x3E,0x36,0x33,0x07,0xEC,
+	0x89,0x7E,0x13,0xE2,0xF4,0xF8,0x94,0x8F,0xD4,0xBC,0xAF,0xE0,0x50,0x7B,0x65,0x06,0xED,0x1E,0x1B,0x52,
+	0xFB,0x7F,0x6A,0xE0,0x45,0x60,0xC4,0xF6,0xC4,0xAF,0x34,0xC0,0xC6,0x88,0xC8,0x64,0xD8,0xEC,0x72,0x13,
+	0xA6,0x87,0x58,0x82,0x13,0x33,0xE7,0x40,0xE6,0xC7,0xD0,0xB6,0x66,0xA0,0x59,0x81,0xA6,0x20,0x31,0x83,
+	0xB4,0x78,0x6C,0xC1,0x46,0x8A,0x11,0x65,0x57,0x49,0x79,0x96,0xE6,0x63,0x97,0xD1,0x9D,0xED,0xB1,0xCF,
+	0x85,0xCC,0x01,0xD7,0xDC,0xE0,0x38,0xCA,0x81,0xD6,0xDA,0xF6,0xE2,0x0B,0xB0,0xFE,0x88,0xC2,0x0F,0x99,
+	0xA9,0xE4,0x60,0xFD,0xE6,0x8A,0xD6,0x8A,0x98,0x23,0x00,0xF0,0x65,0x75,0xF8,0x89,0x57,0xE5,0xA1,0x67,
+	0x85,0x80,0x45,0x63,0xDE,0x7C,0x21,0x6A,0x2F,0xF7,0xF1,0x98,0xD6,0xE6,0x09,0x13,0x35,0x88,0x69,0x73,
+	0x76,0x0C,0x23,0x72,0x64,0xDC,0x06,0x88,0xD7,0xE7,0x5A,0x88,0x2E,0x18,0x63,0xC8,0x1A,0x05,0x52,0x6E,
+	0xCC,0xC5,0x35,0x22,0xB5,0xA1,0xA2,0xC7,0xAC,0x01,0x90,0xED,0x38,0xEB,0xEC,0x9F,0xEC,0x43,0xBC,0x5A,
+	0xDA,0xAB,0x79,0x0E,0x2F,0x8C,0xEC,0xBD,0x1C,0x3A,0x79,0xF4,0x6F,0xCC,0xAD,0x4A,0xFF,0xAA,0x2F,0xF9,
+	0x0F,0x88,0xEF,0x9C,0xFE,0x3F,0xC6,0xD9,0x6C,0x43,0x85,0x5B,0x52,0x4D,0xD6,0xBA,0x28,0x83,0x9A,0x4F,
+	0x1A,0x6C,0xB2,0x19,0x76,0x83,0xF2,0x91,0x5E,0xEC,0x6E,0xB8,0x8C,0x83,0xD8,0x6E,0x32,0x02,0x82,0xFE,
+	0x5D,0xCD,0xFA,0x81,0xA0,0xED,0x03,0x0B,0x30,0x05,0x0B,0xBE,0x3D,0xCE,0x2A,0xEE,0x27,0x9F,0x0C,0x90,
+	0xDE,0x11,0x03,0x5D,0x0C,0xEB,0x4B,0x2D,0xFD,0x63,0xBB,0x67,0x2B,0x8D,0x04,0x80,0xDF,0x10,0x1C,0x52,
+	0xD3,0x9F,0x6B,0x56,0x38,0x1F,0x0E,0x5D,0x60,0x91,0x2F,0x22,0x54,0x7B,0x4C,0xD6,0x62,0x1C,0x94,0x86,
+	0x96,0xBC,0x28,0x30,0x47,0x83,0x44,0x32,0x55,0xF1,0x1D,0x53,0x5F,0x9D,0xEE,0x05,0x71,0x9B,0x70,0x83,
+	0xE2,0x92,0xEC,0x83,0x97,0xD2,0x55,0x11,0xA0,0xC9,0x01,0x05,0xB1,0xB9,0xBD,0x92,0x67,0xC8,0x15,0x33,
+	0x75,0xAB,0x3F,0xC0,0x5D,0x3A,0xBE,0xF9,0x40,0x1B,0x73,0x66,0x46,0xD1,0xF4,0xF7,0x76,0xF4,0x7E,0x2E,
+	0xF2,0x6E,0x6E,0xA0,0xB8,0x33,0xEC,0x81,0x2E,0x7E,0xFC,0x67,0x77,0xF5,0xB8,0xEF,0xA0,0x44,0x41,0xE3,
+	0x85,0x0F,0xDD,0x67,0x61,0x23,0xF5,0xF2,0xF6,0xF6,0xFB,0x2B,0x27,0x2C,0x69,0xF3,0xDF,0xBA,0x05,0xF6,
+	0x07,0x56,0xFD,0xCF,0xF7,0xF7,0x5E,0x08,0x29,0x73,0xA0,0x0A,0x66,0x96,0xA6,0xCC,0x4F,0xDA,0xE6,0xAB,
+	0x31,0xE3,0x36,0xA7,0x8C,0x13,0x73,0x6E,0xAC,0xB6,0xFE,0x22,0x30,0x9B,0x00,0xF9,0x4E,0xC0,0x7D,0xA6,
+	0x0F,0x9C,0x87,0x9B,0xBA,0xFB,0x09,0xCF,0xCF,0x1A,0x2E,0xBB,0xC7,0xA3,0x81,0xCB,0xBD,0x94,0x70,0xF3,
+	0xCA,0xA9,0xFC,0x5C,0xEB,0x29,0x5D,0x7F,0xE1,0xB9,0x90,0x27,0x78,0xDE,0xF0,0xAC,0x7D,0x3C,0xEE,0x19,
+	0xEA,0x51,0xF2,0x86,0x7E,0xFC,0xF5,0xB8,0x21,0xFF,0xEA,0xDE,0x37,0x9D,0xEE,0x0B,0xCC,0x9D,0x3F,0x5C,
+	0x7F,0xFD,0xA4,0xFB,0x2C,0x9A,0x6F,0x12,0x5F,0xFF,0x25,0xBD,0x05,0xBA,0x75,0x6C,0xFE,0xFE,0x25,0x46,
+	0x44,0xF6,0xEB,0xDE,0x40,0x9F,0x41,0xBF,0x0F,0x5E,0xBD,0x25,0xFF,0xFF,0x4B,0x6A,0x22,0xF0,0x98,0x80,
+	0xCC,0xC1,0x06,0x15,0xBF,0xED,0x67,0x7B,0xED,0x9C,0x58,0x01,0x7D,0x07,0x73,0x90,0x31,0xAA,0xFA,0x2F,
+	0x8F,0xCC,0xF0,0xB2,0xAD,0x20,0x1F,0x21,0x8C,0x4B,0x41,0x24,0x24,0xD9,0x69,0x90,0xA4,0xED,0x3A,0x4B,
+	0x05,0x6C,0x3E,0x92,0x20,0x8A,0x49,0x34,0x00,0xD8,0x67,0xA2,0xAA,0xC5,0x89,0x15,0x92,0x2D,0x38,0x67,
+	0x61,0x6E,0xE3,0x43,0xEF,0x2B,0x67,0x5C,0x3D,0x64,0xAF,0x23,0x5C,0xE4,0x30,0x77,0x60,0x07,0xB6,0x52,
+	0xF2,0xB6,0xB4,0xF0,0xBF,0x65,0xCA,0x2E,0xB8,0x21,0x39,0x66,0xE1,0xA4,0x42,0x61,0x6B,0xD7,0x91,0xEC,
+	0x9E,0x07,0x2E,0x1A,0xBA,0x6B,0x31,0xD3,0x8A,0xBA,0xB7,0x52,0x72,0x41,0xF5,0x33,0x40,0x93,0xE3,0xC5,
+	0xDD,0xC8,0xB3,0xE8,0x64,0x0E,0x79,0x88,0x38,0xA3,0x92,0x3B,0x2C,0x9E,0x82,0xC4,0x37,0xA5,0x13,0xEE,
+	0xF6,0x0F,0xE8,0xF2,0x1A,0x89,0x7D,0xC9,0x9B,0x09,0x5F,0x21,0x26,0x77,0x30,0x8B,0x29,0x11,0xDA,0x9C,
+	0x3D,0x44,0x35,0x1C,0x16,0xE5,0xEC,0xD0,0xD0,0x28,0x3C,0x9A,0x68,0x04,0x4B,0x39,0xEB,0x2F,0x65,0x0F,
+	0x22,0xAE,0x40,0x34,0xDF,0x99,0x7A,0x98,0xF1,0x03,0x39,0x68,0xF1,0x68,0xA9,0x77,0xB5,0xE7,0x76,0x1E,
+	0xD4,0xB3,0x5E,0x81,0x2B,0x5F,0x6E,0x22,0xB8,0x6C,0xDE,0x89,0xF4,0xCD,0xF1,0x02,0x8A,0xE0,0x83,0xDC,
+	0xEE,0x4C,0xF9,0xFD,0x2E,0x81,0xAE,0xC0,0xE8,0x91,0x89,0x6C,0x54,0xD1,0xCE,0xDD,0xA3,0x5E,0xB5,0x5B,
+	0x7A,0xAC,0x05,0x96,0xCD,0xE4,0x24,0x02,0x56,0xC9,0x04,0xC0,0x4C,0xBB,0xDA,0x16,0x34,0xBD,0x66,0xA8,
+	0x84,0xF7,0xAC,0x74,0x0F,0x7F,0x9B,0x63,0xA5,0x9C,0xD2,0x0F,0x21,0x9E,0x1D,0x86,0x99,0xAA,0xE4,0x36,
+	0x70,0x13,0x99,0x94,0xC3,0x34,0xFB,0x1B,0x5B,0xC4,0x24,0x8C,0x04,0xC7,0x21,0xC7,0xB3,0xAD,0x5F,0xAB,
+	0x4A,0x77,0xEE,0x66,0x55,0x9C,0x1D,0x73,0x62,0x15,0xA5,0x65,0x0F,0x7C,0x9B,0xC0,0x55,0x1A,0x1B,0x44,
+	0x49,0x03,0xD7,0x40,0xD1,0xEB,0x38,0x76,0x2C,0x7C,0x99,0x20,0x21,0xB4,0xD4,0x40,0x13,0x97,0xA1,0xF5,
+	0x08,0x2A,0x94,0xFD,0xF1,0x71,0x85,0xC5,0xAD,0xB4,0x05,0xE5,0x58,0xCB,0x0B,0x0E,0xB0,0xFD,0x56,0x9A,
+	0x30,0x75,0x98,0x22,0x27,0x9A,0x59,0x51,0x97,0xA4,0x0D,0x51,0x50,0xE8,0x57,0x97,0x04,0x8A,0x3C,0x6A,
+	0x1B,0xC1,0x30,0x7D,0xD0,0x68,0xA1,0x8C,0x03,0xB9,0xAE,0x7C,0xA7,0x77,0x55,0x70,0x18,0xD4,0xB1,0xC2,
+	0xC8,0xE5,0x26,0x3A,0xD5,0x1B,0xA6,0x6C,0x82,0x76,0xFD,0x76,0xAE,0x68,0xF9,0xBF,0x3D,0x2C,0xE8,0x2B,
+	0x54,0x58,0xAF,0x7D,0x47,0x75,0xCF,0x1C,0xDC,0x00,0xD6,0x89,0x34,0x58,0x67,0x3B,0x55,0x79,0xFF,0xFC,
+	0x75,0x76,0x14,0xE7,0xC1,0x78,0xF8,0xF8,0xB7,0xBA,0xE5,0x16,0x96,0xA3,0x4D,0x0C,0x0A,0xF1,0x58,0x75,
+	0x98,0xD1,0x5C,0xDE,0xF8,0x7F,0xCE,0x08,0x01,0xFC,0x61,0xCC,0xBC,0x74,0x7F,0x36,0xC9,0x6F,0x47,0x0D,
+	0xFA,0x9E,0x3F,0x2B,0x6C,0xAB,0xB7,0xEF,0xBF,0x71,0xF0,0x8F,0x42,0x6C,0xDF,0xD3,0x3B,0x62,0xC8,0x0A,
+	0x6F,0xD2,0xCF,0xCD,0xEB,0x74,0x9F,0x32,0x00,0x3F,0xCC,0x40,0x16,0x2D,0x6E,0x11,0x54,0x6F,0x6B,0xA4,
+	0x55,0x07,0xE8,0x32,0xEF,0x7C,0xF8,0x13,0x19,0x0A,0x06,0x1B,0x8F,0x50,0x30,0xF3,0xF4,0x6B,0xFE,0x81,
+	0xF3,0x17,0x5E,0x83,0x8A,0x39,0x03,0x65,0x56,0xAE,0xEB,0x26,0x77,0xE4,0x31,0x0B,0x64,0x98,0xE6,0xE8,
+	0x93,0x82,0x47,0x28,0x2C,0xD2,0x42,0xD5,0x57,0xAB,0x39,0xD3,0xA3,0xE8,0x4A,0xB5,0x9A,0xD9,0x8D,0xF3,
+	0x2D,0xBB,0x6C,0xA6,0x18,0xA6,0x52,0xBA,0x4D,0xCA,0x7A,0xD4,0x97,0xAD,0x26,0x9D,0x51,0x51,0x6F,0xF2,
+	0x19,0xA7,0x03,0x4F,0x87,0xC9,0x99,0x63,0x77,0x09,0x72,0xC3,0x75,0x79,0x37,0x73,0xB5,0xE7,0xA9,0x77,
+	0xF5,0xC5,0xB3,0xA8,0x34,0x3C,0x82,0x68,0x38,0x6C,0x39,0xE2,0x93,0x4A,0x3B,0xFC,0x8E,0xFD,0xD7,0x2A,
+	0x93,0xAA,0x50,0x2A,0xA7,0x5C,0xAA,0x5C,0xFF,0x8D,0xC2,0x9A,0x3E,0x90,0xC2,0x00,0xDB,0x5D,0x5B,0x9A,
+	0x9B,0x76,0xC2,0xBC,0x58,0x23,0x63,0xFB,0xCC,0x85,0x14,0x0E,0x11,0xA6,0x6D,0x24,0xC0,0x84,0xCB,0xAD,
+	0xD9,0xB0,0x91,0xE4,0x02,0x0D,0x4D,0xEE,0x57,0xEB,0x12,0x54,0x5C,0x0E,0xC3,0xBD,0xD8,0xEF,0x76,0x9D,
+	0x08,0xCD,0x57,0xB7,0x1C,0xD7,0x8F,0xC3,0x6C,0x13,0x6E,0x53,0x3E,0xED,0xBF,0xDA,0x7C,0xF8,0xD2,0xDA,
+	0x1B,0xC7,0x24,0x95,0x49,0x66,0xDA,0x19,0x7B,0xEB,0xAA,0x49,0x23,0x25,0x63,0xB2,0x9E,0x75,0xF7,0x9A,
+	0x71,0x4E,0x33,0xFA,0xD8,0x1E,0x34,0xDB,0xB0,0xAF,0x43,0xCE,0xE8,0xDA,0x86,0xEA,0xA4,0xB0,0xDB,0x3F,
+	0x7E,0x10,0xB4,0x64,0xA6,0xE5,0x0F,0x23,0xE1,0xAE,0x0C,0x20,0xD8,0xB2,0xFE,0xD9,0xD7,0xB1,0xC4,0x97,
+	0x01,0xFF,0x8F,0x67,0xA9,0xF1,0xC4,0x12,0x67,0x79,0x7C,0x2B,0x58,0xF7,0x65,0x73,0xA0,0x9D,0xD8,0x74,
+	0x6C,0x66,0x4D,0xD1,0xD7,0x70,0x6A,0xA7,0x83,0x72,0x6D,0xAC,0xAD,0xFF,0x45,0x1D,0x97,0x65,0x5D,0x9C,
+	0xBB,0x58,0xB5,0x10,0x96,0xD3,0x3C,0xB1,0x15,0x7F,0x3F,0xC4,0x49,0x5C,0x26,0xB4,0x8D,0xB0,0x37,0xC6,
+	0x3E,0x86,0x1E,0x86,0x75,0x3C,0x31,0x7D,0x31,0x67,0x83,0xCC,0x45,0x75,0xAC,0x94,0x37,0xBB,0xBF,0x8B,
+	0x4F,0xE7,0xBE,0xE8,0xCD,0xB4,0x4D,0xC7,0x87,0xB6,0x95,0xE5,0x1A,0xFB,0x7A,0xA2,0xDB,0x9C,0xFF,0x53,
+	0xB1,0x1F,0x2D,0x03,0x6A,0x06,0xFB,0x31,0xA3,0xF1,0x0E,0x48,0xF8,0x59,0xD9,0xFD,0xD6,0x10,0x87,0x48,
+	0xEE,0xAD,0xCE,0xE8,0x6A,0xFE,0x09,0xB3,0xC4,0x08,0x85,0x70,0x82,0xBD,0x66,0x8F,0x5E,0x7B,0xC6,0x99,
+	0x1E,0xDA,0x80,0xBE,0x7C,0x8B,0xD5,0x6F,0xF8,0x31,0xF0,0xC9,0x8D,0x8F,0x93,0xEF,0x9F,0xC9,0x71,0x79,
+	0xA9,0x1E,0xAD,0xB1,0x4B,0xCE,0x87,0x44,0x84,0x3A,0xC7,0x98,0x9E,0x58,0xA4,0xB9,0x5E,0x1B,0x76,0xBD,
+	0x13,0xD2,0x08,0xEC,0x8F,0x5F,0x41,0xF1,0x9F,0xF3,0x70,0x7A,0x0C,0xED,0xA6,0xCF,0x5F,0x02,0x2C,0x5E,
+	0x9C,0x60,0x4A,0x1C,0xFA,0x9D,0xEB,0x4A,0xC7,0x4F,0x85,0xDF,0x57,0xD7,0x59,0xCF,0x15,0x53,0x97,0xB9,
+	0xC3,0xF1,0x36,0x2E,0x4B,0x4E,0x10,0xDD,0xFB,0x3E,0x65,0xFE,0x04,0x9B,0x6F,0x39,0xEF,0xBE,0xDB,0x02,
+	0x7F,0x79,0xA0,0x17,0xB1,0xDF,0x94,0xE6,0xD2,0x43,0xA6,0x26,0x3B,0xE5,0xAF,0x16,0xD5,0x65,0x0A,0x6B,
+	0x9E,0xA7,0x70,0xF2,0xC7,0xB4,0x8B,0x2E,0x99,0xD0,0x5A,0x03,0xFB,0x9B,0x2D,0x97,0x88,0x2A,0xF2,0xDA,
+	0xBF,0x42,0x93,0x63,0x42,0xC6,0x31,0xFE,0x8F,0x61,0xF0,0x55,0xD5,0x25,0x89,0xF6,0xC3,0xB6,0xBE,0xC4,
+	0x4D,0xA3,0x1E,0x73,0x0E,0xAF,0x9E,0x4B,0x00,0x6A,0x62,0x64,0xC7,0x52,0x1B,0x97,0x45,0xCB,0xE9,0x4A,
+	0x9F,0xB1,0x17,0x54,0x90,0x2B,0x06,0x7F,0x47,0x0B,0x17,0x8E,0x8F,0xDF,0x73,0x40,0x07,0x10,0xA0,0xE5,
+	0x44,0x99,0xF0,0x7B,0x5E,0xF2,0x1C,0x23,0x96,0x0C,0x17,0x5E,0x87,0x49,0x29,0x6A,0xB7,0xFB,0x38,0xD1,
+	0x15,0xF8,0x66,0x95,0xF7,0x61,0xC6,0xD8,0x04,0x0E,0x0A,0x61,0xB9,0xD9,0x16,0x6F,0xC9,0x46,0x7A,0xA6,
+	0x7A,0xBE,0x40,0x0D,0x8B,0x0A,0xB3,0xBC,0xF4,0xD9,0xFC,0x4A,0x3F,0xE6,0xF2,0xBA,0xA5,0x28,0x8B,0xC4,
+	0x2B,0x77,0xFB,0x29,0x1D,0x84,0xAC,0x19,0xCC,0xE5,0xEC,0xD0,0xD8,0x64,0x48,0xFB,0x0B,0x43,0x7B,0xCE,
+	0x78,0x47,0xF9,0xC8,0x03,0x0B,0x77,0xBD,0x25,0x4B,0x23,0xE8,0xDC,0xB3,0xFD,0x12,0xE7,0xAE,0x8D,0x68,
+	0xC9,0x42,0x67,0xED,0x1A,0x63,0xAA,0x67,0x2F,0x63,0xD9,0xDE,0x1A,0x4E,0xE5,0x23,0xC9,0x81,0x80,0x83,
+	0xD9,0xA1,0x9C,0x49,0x09,0x00,0xDB,0x44,0xDA,0x25,0xB3,0x56,0xEE,0xF2,0xB3,0x42,0xD8,0x61,0x0B,0x66,
+	0x83,0x63,0xF1,0xBF,0xBF,0x29,0x94,0x1B,0x3C,0x2A,0x14,0x9F,0x77,0x60,0x4E,0x95,0xA2,0x58,0xF9,0xF6,
+	0xA2,0x2F,0x37,0xAF,0xB8,0xFB,0xEA,0x97,0x1B,0xF5,0x4C,0xAF,0x29,0x7D,0x08,0x34,0xFA,0x81,0x4C,0x2E,
+	0x9A,0xAA,0x8F,0xAE,0xB9,0xC0,0x9D,0x63,0x84,0x7C,0xA5,0x80,0xB6,0x22,0xB0,0xA5,0x67,0x44,0x15,0xE3,
+	0x62,0xD6,0x25,0x53,0x75,0xD5,0xB7,0xD2,0x6F,0xCC,0x1D,0x73,0x62,0x15,0xBA,0x44,0x6D,0x13,0x14,0x5E,
+	0xD9,0x08,0xCC,0x61,0x51,0x14,0x4E,0xC1,0xBF,0x88,0x8A,0x76,0x76,0xF9,0x4D,0xE6,0xC9,0x00,0xB4,0x24,
+	0x3B,0x3A,0xA9,0xF8,0xF8,0x53,0x82,0xC7,0x67,0xDA,0xF8,0x8B,0x46,0x91,0xBD,0xE1,0x30,0xCA,0x4F,0x61,
+	0x37,0x26,0xAB,0xD3,0x19,0x93,0xD8,0xE7,0x53,0x07,0xAD,0x8A,0x50,0xBC,0xF7,0x2C,0x16,0x58,0xEF,0xB3,
+	0x61,0xE3,0xA1,0x1F,0xC9,0xB7,0xBC,0x12,0xCF,0xB5,0xA1,0x8C,0xB1,0xA5,0x7E,0x26,0x5A,0xAE,0xA5,0xE2,
+	0xFC,0xE5,0xF5,0xB8,0xB6,0x3B,0x40,0x5A,0x6B,0xDC,0xF6,0x3A,0x85,0x38,0x61,0x78,0x6A,0x5A,0xE0,0x76,
+	0x59,0xAC,0x38,0xD2,0xAB,0x3A,0xE8,0x50,0xF8,0x74,0x30,0xC6,0x7D,0xCD,0x38,0x9C,0x34,0x37,0xE0,0x3B,
+	0xEC,0x5F,0x73,0x3D,0x05,0x5B,0xF4,0xF3,0x55,0x1C,0xAD,0x2E,0xB8,0xC0,0xE2,0x97,0xC9,0x1D,0xF5,0xF7,
+	0xA2,0xD7,0xDE,0x1F,0x29,0xE8,0x7A,0xAF,0x07,0x32,0xF2,0xBA,0xE8,0xA9,0x8E,0x62,0x80,0x88,0x2F,0x0B,
+	0x2C,0xEB,0x3D,0xBE,0x8E,0x31,0xBB,0x69,0x16,0x7E,0x72,0x65,0x7D,0x68,0x4B,0x9E,0x2A,0x11,0x7F,0xF4,
+	0x5A,0x5C,0xFF,0xE7,0x67,0xFB,0x28,0xC3,0x0D,0xCA,0x6C,0xF2,0x08,0x8F,0x45,0xE9,0xF5,0xF6,0x6E,0xB0,
+	0x04,0x4D,0x1C,0x64,0xD7,0x34,0x10,0xED,0xC4,0xE3,0x92,0x9C,0xA6,0x3C,0x66,0xA9,0x55,0x6E,0xC6,0xA5,
+	0x3E,0x67,0x06,0x05,0x54,0xE6,0x58,0x75,0x0E,0x9D,0x4F,0xBD,0x2F,0x34,0x53,0x38,0x1A,0x6F,0xED,0x96,
+	0xC6,0xA3,0xF9,0x60,0xDB,0xE4,0x5A,0x6D,0x34,0x1F,0x39,0x2D,0x03,0x57,0x48,0x80,0xD2,0x42,0x68,0x83,
+	0xB7,0x2E,0x48,0x9D,0xA7,0xBB,0x58,0x62,0xD3,0x64,0x0E,0xA3,0xC5,0xC5,0x34,0xA6,0x1F,0xAA,0xC3,0xD7,
+	0xC1,0x14,0xE7,0x80,0xD2,0xB5,0xC6,0xD4,0x67,0x29,0x0E,0xA5,0x14,0xEE,0x4E,0xC6,0x40,0x77,0xCB,0x94,
+	0x89,0xFD,0x17,0x65,0x6C,0x62,0x89,0x13,0xE6,0x2A,0x46,0x42,0x66,0x78,0x11,0x62,0xD1,0x35,0x42,0x4E,
+	0x5F,0x87,0xCC,0x8A,0x06,0x30,0x9D,0x51,0x91,0x1C,0x55,0xDF,0x86,0xF8,0xAE,0x3D,0xAE,0x3D,0x06,0x91,
+	0xA2,0x24,0x0C,0x3E,0x26,0x4C,0x11,0x61,0xE0,0x15,0x9C,0x59,0x82,0x00,0x63,0x07,0x90,0x27,0x81,0x34,
+	0x20,0x61,0xCD,0xB5,0x09,0xB7,0x8B,0x01,0x01,0x86,0x4A,0xF1,0x7C,0x9D,0xBB,0x7D,0x5F,0x9F,0x18,0x09,
+	0x01,0x0E,0x3C,0x79,0x1E,0x23,0x9A,0xCC,0x1B,0x95,0xCD,0x5B,0xEF,0x33,0x18,0x4A,0xD1,0xEE,0x49,0x41,
+	0xD7,0x26,0xC7,0x01,0xEA,0x51,0x6D,0xDA,0x3B,0xED,0x92,0x60,0x99,0x19,0x51,0x0D,0x1C,0x1A,0x9B,0x68,
+	0x98,0x7C,0xC8,0xCE,0x39,0x8B,0x44,0x6E,0x53,0xE2,0xCE,0xD3,0x08,0x99,0x2B,0xD7,0x18,0xA9,0x8F,0xBB,
+	0xDF,0x33,0x1D,0x8E,0x15,0xAF,0x83,0x1D,0xCF,0x26,0xCC,0x98,0xF2,0x44,0x0C,0x4C,0xC8,0xDD,0x18,0xE4,
+	0xF7,0x24,0x95,0xCC,0xF8,0xEC,0xF2,0x04,0x31,0x25,0x32,0x50,0x92,0xAC,0xC2,0x25,0x1E,0x77,0x7B,0x19,
+	0xA0,0x4E,0x43,0x76,0x7E,0xF2,0x7F,0xFC,0x5B,0x8F,0x57,0xB8,0x3A,0x7F,0x82,0x8D,0x41,0x67,0x4E,0x8C,
+	0x6B,0x18,0xB2,0x4C,0x67,0x9B,0x3D,0x44,0x23,0x5C,0xC7,0x54,0xFA,0x72,0xCE,0x63,0x18,0x3E,0xD0,0x74,
+	0xAE,0x90,0x83,0xDC,0x84,0xFA,0x0E,0xD6,0xCC,0x43,0x7D,0xA4,0x19,0x39,0x04,0xA2,0x63,0x7A,0xEC,0xE3,
+	0x17,0xF4,0x5F,0x30,0x6C,0x3D,0xCD,0x9E,0x41,0xF3,0x93,0x98,0x27,0x5C,0x9D,0x61,0x0A,0xB7,0x13,0x4C,
+	0xCC,0x21,0x39,0x07,0x16,0x6F,0x1B,0x02,0x25,0x97,0x7F,0xD6,0x75,0x3B,0x90,0x79,0xC4,0x33,0xC1,0x82,
+	0xDD,0x17,0x16,0xD4,0xCF,0xBD,0x51,0x5F,0xA6,0xE8,0x08,0xA2,0xFD,0x3D,0x01,0xF1,0xE0,0x6D,0xFA,0x6A,
+	0x13,0xDF,0x15,0xE1,0x84,0x05,0x15,0x8F,0x29,0x8C,0xC4,0xD1,0x09,0x66,0x88,0x49,0x15,0xB8,0xC9,0x35,
+	0x29,0x67,0x38,0x80,0xC6,0xEF,0x1D,0x80,0x51,0x10,0xB7,0xD6,0x4E,0xDD,0x1C,0x89,0x21,0x1E,0x67,0x39,
+	0xFC,0x40,0x99,0xDD,0x06,0xFF,0xD5,0xDC,0xB2,0x39,0xE9,0x8C,0x95,0x1D,0xC1,0xC4,0xCB,0x69,0x63,0x23,
+	0x3F,0xFC,0x4C,0xFE,0xEA,0xCB,0xC0,0xCB,0x80,0xE6,0x5C,0x95,0x73,0x23,0x52,0xE7,0xB8,0x6C,0x29,0xD8,
+	0xEA,0x75,0x43,0x8D,0x15,0xEF,0xD9,0x28,0x47,0x34,0xD5,0x2C,0xEC,0x10,0xDE,0xE1,0x73,0x6B,0x64,0x7B,
+	0xF1,0xAD,0xBF,0xE2,0x06,0x52,0xF8,0x86,0x34,0x34,0x5E,0x04,0x94,0x81,0xC9,0x00,0x33,0x40,0xCC,0x9C,
+	0xFC,0x0E,0x4C,0x96,0x33,0xD1,0x3F,0x19,0x47,0x60,0x9E,0xAC,0xD6,0x91,0xE7,0x3E,0xB0,0x40,0xBB,0x82,
+	0x6F,0x4E,0xB6,0x14,0x10,0x53,0x69,0x63,0xDC,0x61,0xC9,0x9D,0x4F,0x05,0xF1,0x97,0x94,0x6A,0x09,0xCC,
+	0xC5,0x01,0x46,0x9A,0xD7,0x22,0xC0,0xA2,0x80,0x07,0xC0,0xC6,0x17,0x40,0x11,0x91,0x4F,0x1D,0x26,0x16,
+	0xF1,0x62,0x28,0xF0,0x5D,0x08,0x4F,0x45,0x94,0xF4,0xF3,0x4F,0x4E,0x90,0x23,0x96,0xF2,0xEF,0x06,0xB1,
+	0x8A,0x09,0x9B,0x55,0x31,0x25,0x8A,0x61,0xC4,0xB4,0xD9,0xD3,0x73,0xEC,0x43,0x50,0x20,0x01,0x09,0xC9,
+	0xB8,0x66,0xD1,0xF5,0x95,0xA1,0x5E,0x25,0xD2,0x68,0xA8,0x71,0xE1,0x52,0xD8,0x19,0xBB,0x68,0x92,0xB2,
+	0xB4,0x59,0x4E,0x0C,0x54,0x38,0x72,0x5E,0x45,0x48,0x3D,0x1D,0x94,0x25,0x0F,0xBC,0x4D,0x6C,0x46,0xD4,
+	0x7D,0xE2,0x7B,0x2E,0x61,0x70,0x97,0xF4,0x17,0x28,0xD3,0x2D,0x60,0xBF,0x4C,0x03,0xDE,0x2B,0x52,0x2C,
+	0x2C,0x67,0xE3,0xEC,0x5F,0x2B,0x3D,0x0C,0x4D,0xEF,0x9F,0xDB,0xFB,0xBB,0x12,0xD4,0xEB,0x03,0x61,0x78,
+	0xC6,0xCD,0x32,0x28,0xF4,0xC7,0xB2,0x2C,0xB8,0xB1,0xCE,0xBA,0xEA,0xF2,0xDA,0xD8,0x1F,0xBB,0x21,0x83,
+	0x74,0x4F,0x4A,0x3A,0xF1,0x96,0x23,0x0D,0xCD,0x85,0x03,0x6C,0xBA,0xD5,0x57,0x8B,0xEE,0xC3,0xAB,0x4A,
+	0x27,0x61,0x8B,0x7D,0xD3,0x82,0x7C,0x69,0x9D,0x6F,0x82,0x4C,0x70,0x50,0xDD,0xF9,0xDF,0x4A,0x5E,0xBD,
+	0xCB,0x54,0x5B,0x84,0xB3,0x3E,0x23,0x23,0x03,0xAF,0x98,0xA3,0xD1,0xF8,0xA8,0xEB,0x82,0xE1,0xCC,0xAB,
+	0x39,0x5D,0x26,0x52,0x52,0x48,0xF4,0xB2,0xF2,0x15,0x3F,0x31,0x14,0xBD,0x65,0xBA,0x94,0x5C,0x6D,0x23,
+	0x10,0x54,0x91,0x47,0x73,0x7C,0x2D,0x5A,0x85,0x5F,0xA5,0x57,0x48,0xBF,0xE7,0x33,0x15,0x51,0xF5,0x57,
+	0x72,0x7E,0xE4,0xB2,0x48,0x65,0x8E,0x3E,0xEF,0x3A,0x6C,0x30,0x99,0x5B,0x04,0xA0,0xD1,0x11,0x6C,0xB6,
+	0x07,0x13,0xE4,0xB6,0xB2,0x3A,0xCC,0x12,0xE1,0x1D,0x84,0x65,0x38,0xDF,0x3B,0xC6,0x5F,0x19,0xAD,0x43,
+	0x4E,0x77,0x6D,0xB1,0xEA,0x59,0xAD,0xC2,0xF4,0x96,0xE2,0x3E,0x5E,0x18,0xE5,0xD2,0x32,0x73,0x91,0x93,
+	0xA0,0x88,0x93,0xD1,0x71,0x7F,0x03,0x0A,0x0A,0xEA,0xCC,0x6E,0x79,0x28,0x6E,0x57,0x6E,0x2A,0x46,0x2E,
+	0x5A,0xC8,0x6E,0xDC,0x6E,0x94,0x8F,0x82,0xDD,0xCD,0xC4,0x44,0x6D,0x1B,0xCE,0x24,0x98,0x76,0x3F,0x59,
+	0x5F,0x15,0xF9,0x1E,0xD3,0x8C,0x4C,0xEF,0xF0,0xA1,0xCD,0xAC,0x5B,0x7C,0x77,0x1B,0x8B,0xE9,0x39,0x6C,
+	0x51,0x7F,0xD8,0x45,0x6B,0x53,0x40,0xB9,0xFF,0x3A,0x26,0x97,0x9D,0xA1,0xEE,0x0E,0x51,0x32,0x2E,0x8A,
+	0x29,0xE3,0x23,0x9E,0xD9,0x7A,0xF3,0x3A,0xA9,0xE1,0xA6,0x1E,0xB8,0x79,0xB6,0xF5,0x8A,0x46,0x25,0x1E,
+	0xDA,0xF7,0x3F,0x4B,0x77,0x21,0x87,0x49,0xB8,0x93,0x2F,0xCD,0x6D,0x5E,0xDF,0x43,0x5B,0xF4,0x36,0xAA,
+	0x8D,0x10,0xA7,0xDA,0x38,0x30,0x44,0x0F,0x14,0xA2,0x58,0x1F,0x79,0x77,0xE4,0x80,0xB0,0x0B,0x87,0x91,
+	0x7F,0x06,0xA2,0x25,0xE5,0xA5,0xB6,0xA2,0x06,0x67,0x84,0x81,0x4E,0x8B,0x0B,0x20,0xC9,0x44,0xD5,0xD8,
+	0xC0,0xC6,0x80,0x74,0xF6,0xED,0x59,0xFE,0x8C,0x7F,0x24,0x75,0x7F,0x24,0xCE,0xA7,0xC0,0xE7,0x19,0x3B,
+	0xF0,0xEE,0x3D,0xE3,0xE1,0x72,0xF7,0x24,0x99,0x08,0xD1,0x90,0xC3,0x31,0x1D,0x75,0x51,0xEF,0x9F,0x46,
+	0x22,0xB6,0xD4,0x79,0x7A,0xE6,0xB0,0x76,0xB1,0xBF,0x2F,0x73,0xD1,0xE3,0x4B,0x6B,0xDF,0x54,0x8D,0x52,
+	0x33,0xDC,0x79,0x9A,0x47,0x87,0x10,0xD4,0xF3,0x62,0xC2,0x6E,0x5A,0x17,0xF5,0xCF,0x90,0x54,0x66,0x8F,
+	0x78,0xFD,0x59,0xC5,0x09,0xB9,0xD4,0x33,0x99,0xF5,0x05,0xD7,0x6B,0x87,0x3C,0xE7,0x45,0xC4,0x19,0x5E,
+	0x52,0xE0,0x5B,0x6C,0xFB,0x03,0x90,0x0F,0x99,0xBE,0x57,0x2E,0x68,0xB1,0xDA,0xDF,0xDF,0xFA,0x86,0x84,
+	0xFA,0xCC,0xF4,0x11,0x0F,0xE7,0xE5,0xBA,0x3A,0xBC,0x2A,0x86,0xDF,0xE1,0xB5,0x36,0x3F,0xC7,0x02,0x15,
+	0x00,0x1E,0xEE,0x29,0x2D,0x75,0x73,0x2F,0xC8,0xA8,0x95,0x9E,0x76,0x00,0xCA,0xBF,0x4B,0x14,0xFB,0x1A,
+	0x62,0xCD,0x4F,0x4D,0x7E,0xED,0x5C,0x76,0x32,0x23,0x4E,0x0C,0x9D,0x51,0xB0,0x18,0xED,0xA9,0xE2,0x47,
+	0xBB,0xAD,0x14,0x5D,0xAE,0x72,0xB0,0x5B,0x63,0x52,0x30,0x84,0xEC,0xC0,0x7A,0x9C,0xDD,0xA5,0xC3,0x39,
+	0xE4,0x3F,0xA9,0x4A,0xBF,0xDE,0xCC,0x89,0xEA,0xC3,0x93,0x2B,0xA5,0x65,0x55,0x63,0xB3,0x20,0xD1,0xE3,
+	0x68,0x53,0x71,0x7F,0x6C,0x8E,0x5B,0x0D,0x7C,0xE9,0x1C,0x52,0xDF,0x9F,0xFA,0xB4,0x74,0xFC,0xC2,0x52,
+	0x6C,0xDF,0xB3,0x24,0x71,0x4B,0x54,0x10,0xA5,0x28,0x8B,0x67,0xA9,0x23,0x66,0xA2,0xC6,0xD7,0x6C,0xF2,
+	0x94,0xFE,0x45,0x23,0xFE,0x1F,0xC4,0x89,0x64,0xC6,0xA5,0x21,0xC6,0xC2,0xEF,0xA2,0x57,0xF4,0x15,0x11,
+	0x87,0xE1,0x45,0x1D,0x97,0x65,0x6D,0xAF,0x46,0x28,0x09,0x55,0x59,0xB1,0x04,0x82,0x9B,0x1F,0x8C,0xA4,
+	0x10,0xB2,0xB4,0x67,0x0C,0x59,0x85,0x98,0xD5,0x91,0x13,0x50,0x26,0x6A,0x8C,0x96,0x91,0xB8,0xBC,0x76,
+	0xDA,0x5E,0x64,0xB1,0xBD,0x9C,0x61,0x21,0x84,0x69,0xED,0x60,0x57,0xB9,0x0D,0xC4,0x45,0x2B,0x4A,0x05,
+	0xD2,0x5B,0x55,0xF3,0x06,0xA8,0xE7,0xD6,0x14,0xBA,0x82,0x11,0xBB,0x20,0xB5,0xEB,0xF1,0xF6,0x5E,0x08,
+	0x29,0x23,0xD9,0x73,0x3C,0xB6,0x5C,0x56,0x4E,0x9A,0x30,0x4E,0x7C,0xF8,0xFE,0xCA,0x2B,0x79,0xFE,0x96,
+	0x6D,0xBA,0x19,0xC8,0xE3,0xB5,0x3E,0x9A,0x67,0xFF,0x7D,0x8F,0x0F,0x9C,0xCF,0x09,0x40,0xFB,0xF4,0x3C,
+	0x6E,0x9B,0xB7,0xAF,0x83,0xBA,0x77,0x0A,0xE6,0x31,0xAE,0x9B,0x38,0xAB,0xFB,0x39,0xCF,0xEB,0xEF,0x22,
+	0x5C,0x73,0xF6,0x37,0x4F,0x37,0xAC,0xD3,0x7F,0xB9,0xF2,0x91,0x4A,0x92,0x3D,0x6A,0x20,0x7B,0x04,0x7A,
+	0x5B,0x8D,0x55,0x3C,0x93,0x40,0x24,0xFF,0xCC,0x9F,0xEA,0x07,0xD9,0x3F,0xEF,0x6B,0xC5,0xF6,0x9F,0x4D,
+	0xBF,0xB9,0xB1,0x69,0xEB,0x24,0x37,0xCB,0xFD,0xBC,0xB0,0x91,0xC4,0xD7,0x97,0xFB,0x3D,0xB7,0x6F,0x14,
+	0xE9,0xCD,0xF9,0x9B,0xDB,0xFF,0xC0,0x20,0x57,0x47,0x07,0x86,0x32,0x52,0xF7,0x60,0x4C,0x2E,0xAA,0xC6,
+	0x72,0x9F,0x8B,0xE1,0x24,0xFE,0xA4,0x85,0x99,0xF1,0x60,0x14,0xC3,0x45,0xC2,0x35,0xF2,0x20,0xC3,0x72,
+	0xA5,0x09,0xF9,0x21,0x19,0xE0,0x31,0x20,0x4D,0x48,0xEE,0xA7,0xF2,0x02,0xC9,0x88,0x3E,0x41,0x89,0x56,
+	0x97,0x07,0x11,0x53,0x22,0x4A,0xF9,0x6A,0x32,0xE8,0xD0,0x86,0x4C,0x46,0xC0,0x44,0x12,0x24,0xE4,0x44,
+	0xC0,0x4C,0xD0,0x64,0x52,0x64,0x93,0x54,0x07,0xF7,0xC8,0x54,0x13,0x25,0x51,0x30,0x71,0x46,0xD8,0x74,
+	0x53,0x65,0x01,0x41,0xFD,0xCD,0xC1,0x45,0x92,0x26,0xED,0x1E,0x61,0x07,0xD1,0x65,0xD2,0x66,0xE2,0x23,
+	0x74,0xDA,0xC9,0x55,0x93,0x27,0x48,0x51,0xC3,0x47,0xD9,0x75,0xD3,0x67,0xC5,0xBA,0x0E,0x9A,0x19,0x0C,
+	0x90,0xB0,0x91,0xAC,0x06,0x3F,0x96,0xCE,0x90,0xB9,0x6A,0x59,0xF0,0x04,0x4A,0x18,0xB1,0x65,0x00,0x16,
+	0x68,0x29,0x45,0x3C,0x7D,0x6F,0x3D,0xCF,0x90,0x4B,0x83,0x4E,0xBC,0x2A,0x73,0x2B,0xC9,0x47,0x43,0xA9,
+	0x8E,0x12,0x41,0xE7,0x2A,0x6E,0xFB,0xDB,0x33,0x6A,0x41,0xC6,0x6A,0x0A,0x97,0x43,0x78,0xE1,0x50,0x48,
+	0x0C,0xCE,0xC2,0x4C,0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0xDA,0x2A,0xFC,0xD0,0xCA,0x5C,
+	0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0xB9,0xF7,0xB6,0xE1,0xC3,0x4D,0x9A,0x2E,0x53,0x69,
+	0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x59,0x61,0x8D,0xCD,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,
+	0xDB,0x6F,0x3E,0x62,0xA3,0x1E,0xDD,0x64,0xD7,0x36,0x2C,0x98,0x93,0xED,0xD5,0x1B,0x78,0x10,0xC3,0x6A,
+	0x12,0xC8,0xF4,0x52,0x85,0x70,0xB3,0x94,0xEE,0x53,0x5C,0x94,0xDE,0x78,0xE5,0xBE,0x84,0x78,0x8D,0x2A,
+	0x13,0xB2,0x4D,0x42,0x3D,0xCF,0x55,0x84,0x6E,0x33,0xB7,0xA1,0x2B,0xBC,0xDD,0xAC,0xF5,0x7D,0xAA,0xB0,
+	0x6C,0x5F,0x19,0x0A,0xFD,0x13,0xBB,0xB2,0x81,0xE9,0xC4,0xC4,0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,
+	0x72,0x74,0x5E,0xA2,0x80,0x70,0xCC,0xD4,0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,0x73,0x75,0x3D,0xE5,
+	0x20,0xF5,0xC5,0xC5,0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x17,0x2E,0x00,0x56,0xCD,0xD5,
+	0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,0xF3,0x77,0xA6,0xFA,0x4A,0x8D,0xC6,0xFE,0x0B,0x21,0x7E,0xD7,
+	0x4A,0x55,0x16,0x8D,0xE6,0x3A,0xC7,0xBF,0x88,0xB6,0x26,0xA0,0x3D,0xEB,0x1A,0xA4,0xEA,0x57,0x8E,0xB2,
+	0xFB,0x7D,0x79,0x8E,0x09,0xB5,0x7D,0x7C,0xE3,0xC5,0x11,0xB4,0x16,0x5A,0x87,0x25,0xDC,0x38,0xC2,0xBD,
+	0x2B,0x18,0xD3,0xEF,0x52,0x72,0xFF,0x86,0xCD,0x58,0x97,0xDF,0x1B,0x2E,0x16,0xD5,0x6E,0x5E,0xC6,0xCC,
+	0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x58,0xFC,0x09,0x4F,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,
+	0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0xC2,0xF0,0xAC,0x5F,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,
+	0xFA,0x7E,0x49,0x5D,0xF7,0x19,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x18,0xD2,
+	0xF3,0x8F,0x48,0xB5,0x91,0xE7,0xD8,0x33,0xC3,0x30,0xCF,0xC4,0xD6,0xC8,0x48,0x53,0xF0,0x8C,0xDC,0x32,
+	0x9A,0xA3,0xC7,0xB6,0x5B,0x5A,0xC0,0x12,0x53,0xE0,0x95,0xF3,0xD8,0x8D,0x61,0x23,0xB9,0xEE,0x0B,0xCB,
+	0xA9,0x0D,0x8E,0x45,0x95,0xC2,0x23,0x17,0x26,0xC2,0x1E,0x16,0x18,0xAF,0x03,0xDB,0xF4,0x0C,0x45,0x57,
+	0xD9,0x14,0x9A,0xFC,0x04,0x6B,0xE0,0x46,0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,0x56,0xE4,0x30,0x46,
+	0x25,0xE5,0xE8,0x56,0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,0x57,0xE5,0xF1,0xAB,0xA2,0xCB,0xE1,0x47,
+	0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0xED,0xD7,0xDD,0xA9,0xE9,0x57,0x97,0xA7,0x79,0x73,
+	0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0xCE,0x8A,0xF0,0xA8,0xCA,0x0E,0x77,0x4C,0x9A,0x2F,0x48,0x5A,0x36,0x2B,
+	0x58,0xE9,0x22,0x57,0x6E,0xE9,0x4A,0x21,0x39,0xE7,0x85,0x03,0xA6,0x8D,0x2A,0xBA,0x7D,0x86,0x8F,0x49,
+	0x0F,0x8C,0xA7,0x0F,0x1F,0xA4,0x41,0x59,0x3F,0x78,0xF2,0xAB,0xF4,0x9C,0x53,0x99,0x8C,0xD3,0xE8,0x6D,
+	0x76,0xE2,0x01,0x87,0x26,0xAF,0xE3,0x3A,0xD9,0xEA,0xF2,0xC8,0x60,0x4D,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,
+	0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x30,0xA5,0xAC,0xCC,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,
+	0x5F,0xED,0x39,0x5E,0x2D,0xEB,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x0B,0x1B,
+	0x21,0x82,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x65,0x22,0x62,0x80,0x64,0x1F,
+	0x07,0xF2,0x32,0x22,0xE1,0x40,0x30,0x56,0x8B,0xFF,0x76,0xB0,0x86,0xD0,0x2C,0xD0,0x73,0xFF,0xC3,0x30,
+	0xA0,0x28,0x86,0x54,0xBD,0xC0,0x7F,0xA8,0x07,0xF7,0xE7,0x83,0x94,0x42,0x0B,0x7E,0xA7,0xB2,0x25,0x25,
+	0x29,0x7D,0x77,0xB8,0x06,0xF6,0x6D,0xB3,0x34,0xBE,0x05,0xCE,0xC6,0x93,0x6D,0x33,0xA3,0x8B,0xCC,0x4E,
+	0x02,0xD8,0xE4,0xC6,0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x78,0x5A,0x03,0xD9,0xEC,0xD6,
+	0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x11,0x3E,0xE2,0xD4,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,
+	0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x19,0x2E,0xE7,0xD5,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,
+	0xF7,0xF7,0x7C,0xAA,0x8F,0xD9,0x8E,0x4C,0x57,0xB6,0xDE,0xB2,0x48,0xDE,0x69,0xAE,0x58,0x0C,0xD5,0x18,
+	0x2C,0x7C,0xC6,0x5C,0xBE,0xB4,0xBA,0x45,0x49,0xDF,0xA6,0xAA,0x63,0x44,0x47,0xCB,0x40,0x97,0xA6,0x0B,
+	0xE0,0xE5,0x17,0xF2,0x4D,0x50,0x17,0xB1,0x70,0x87,0x17,0xDC,0x7B,0xF7,0x7F,0x1D,0x9F,0xDB,0x1F,0xC2,
+	0x4C,0x51,0xC7,0x98,0x7D,0x14,0x72,0x42,0x0A,0x9A,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,
+	0x7E,0xFC,0xDA,0x38,0x0B,0x9B,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x43,0x69,
+	0x53,0x91,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x67,0x71,0x4E,0x90,0xEF,0xDF,
+	0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x80,0x04,0x10,0x20,0x10,0x20,
+	0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,0x01,0x01,0x88,0x14,0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,
+	0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,0x90,0x22,0x11,0x21,0xC0,0x42,0x91,0x25,0xD0,0x62,0x09,0x11,
+	0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,0xC1,0x43,0x99,0x35,0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,
+	0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,0x52,0x64,0x48,0x50,0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,
+	0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,0x82,0x06,0xC1,0x45,0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,
+	0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,0x93,0x27,0x59,0x71,0xC3,0x47,0xD9,0x75,0xD3,0x67,0x02,0x08,
+	0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,0x48,0x48,0x92,0x2C,0x58,0x68,0x0A,0x18,0x09,0x09,0x8A,0x1C,
+	0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,0x59,0x69,0x03,0x09,0x88,0x0A,0x83,0x0D,0x98,0x2A,0x13,0x29,
+	0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,0x89,0x0B,0x8B,0x1D,0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,
+	0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,
+	0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,
+	0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x4B,0x59,0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,
+	0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,0x20,0x10,0x84,0x84,0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,
+	0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,0x31,0x31,0x1C,0xB0,0x61,0x51,0x9C,0xB4,0x71,0x71,0x05,0x81,
+	0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,0xE0,0x52,0x95,0xA5,0xF0,0x72,0x0D,0x91,0xA1,0x13,0x8D,0x95,
+	0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,0xF1,0x73,0x44,0xC0,0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,
+	0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,0x23,0x15,0xCC,0xD4,0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,
+	0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,
+	0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,0xF3,0x77,0x06,0x88,0x28,0x18,0x86,0x8C,
+	0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,0x78,0x78,0x0E,0x98,0x29,0x19,0x8E,0x9C,0x39,0x39,0x1E,0xB8,
+	0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,0xA8,0x1A,0x87,0x8D,0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,
+	0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,0xB9,0x3B,0x1F,0xB9,0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,
+	0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,
+	0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0x47,0xC9,0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,
+	0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,0xAB,0x1F,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,
+	0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,0x14,0xA0,0x30,0x22,0x44,0xC0,0xB0,0x26,0x54,0xE0,0x28,0x12,
+	0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,0x45,0xC1,0xB8,0x36,0x55,0xE1,0x21,0x03,0x84,0x82,0xA1,0x07,
+	0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,0xD4,0xE2,0x29,0x13,0x85,0x83,0xA9,0x17,0x95,0xA3,0x39,0x33,
+	0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,0x06,0x84,0xE0,0x46,0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,
+	0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,
+	0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,
+	0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0x22,0x0A,0x0C,0x88,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,
+	0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,0x0D,0x89,0xAA,0x1E,0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,
+	0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,0x9C,0xAA,0x33,0x2B,0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x2B,0x1B,
+	0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,0xCD,0xCB,0xBB,0x3F,0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,
+	0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x6A,0x5A,0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,
+	0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,0x8E,0x8E,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,
+	0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,
+	0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,0x64,0xD0,0xB4,0xA6,0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,
+	0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,0x75,0xF1,0x25,0x83,0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,
+	0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,0xA5,0x93,0xAD,0x97,0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,
+	0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,
+	0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,
+	0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x6D,0xD3,0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,
+	0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,0x2C,0x98,0xA6,0x8E,0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,
+	0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,0x3D,0xB9,0x3E,0xBA,0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,
+	0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,0xEC,0xDA,0xB7,0xAF,0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,
+	0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,0xFD,0xFB,0x66,0xCA,0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,
+	0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,0x2F,0x9D,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,
+	0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,
+	0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x80,0x04,
+	0x10,0x20,0x10,0x20,0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,0x01,0x01,0x88,0x14,0x11,0x21,0x18,0x30,
+	0x41,0x41,0x98,0x34,0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,0x90,0x22,0x11,0x21,0xC0,0x42,0x91,0x25,
+	0xD0,0x62,0x09,0x11,0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,0xC1,0x43,0x99,0x35,0xD1,0x63,0x40,0x40,
+	0x02,0x04,0xC0,0x44,0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,0x52,0x64,0x48,0x50,0x03,0x05,0xC8,0x54,
+	0x13,0x25,0x58,0x70,0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,0x82,0x06,0xC1,0x45,0x92,0x26,0x51,0x61,
+	0xC2,0x46,0xD1,0x65,0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,0x93,0x27,0x59,0x71,0xC3,0x47,0xD9,0x75,
+	0xD3,0x67,0x02,0x08,0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,0x48,0x48,0x92,0x2C,0x58,0x68,0x0A,0x18,
+	0x09,0x09,0x8A,0x1C,0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,0x59,0x69,0x03,0x09,0x88,0x0A,0x83,0x0D,
+	0x98,0x2A,0x13,0x29,0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,0x89,0x0B,0x8B,0x1D,0x99,0x2B,0x1B,0x39,
+	0xC9,0x4B,0x9B,0x3D,0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,
+	0x5A,0x6C,0x4A,0x58,0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0x43,0x49,
+	0x8A,0x0E,0xC3,0x4D,0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x4B,0x59,0x8B,0x0F,0xCB,0x5D,
+	0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,0x20,0x10,0x84,0x84,0x30,0x30,0x14,0xA0,
+	0x60,0x50,0x94,0xA4,0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,0x31,0x31,0x1C,0xB0,0x61,0x51,0x9C,0xB4,
+	0x71,0x71,0x05,0x81,0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,0xE0,0x52,0x95,0xA5,0xF0,0x72,0x0D,0x91,
+	0xA1,0x13,0x8D,0x95,0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,0xF1,0x73,0x44,0xC0,0x22,0x14,0xC4,0xC4,
+	0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,0x23,0x15,0xCC,0xD4,0x33,0x35,0x5C,0xF0,
+	0x63,0x55,0xDC,0xF4,0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,
+	0xF2,0x76,0x4D,0xD1,0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,0xF3,0x77,0x06,0x88,
+	0x28,0x18,0x86,0x8C,0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,0x78,0x78,0x0E,0x98,0x29,0x19,0x8E,0x9C,
+	0x39,0x39,0x1E,0xB8,0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,0xA8,0x1A,0x87,0x8D,0xB8,0x3A,0x17,0xA9,
+	0xE8,0x5A,0x97,0xAD,0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,0xB9,0x3B,0x1F,0xB9,0xE9,0x5B,0x9F,0xBD,
+	0xF9,0x7B,0x46,0xC8,0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x4E,0xD8,
+	0x2B,0x1D,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0x47,0xC9,0xAA,0x1E,0xC7,0xCD,
+	0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,0xAB,0x1F,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,
+	0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,0x14,0xA0,0x30,0x22,0x44,0xC0,0xB0,0x26,
+	0x54,0xE0,0x28,0x12,0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,0x45,0xC1,0xB8,0x36,0x55,0xE1,0x21,0x03,
+	0x84,0x82,0xA1,0x07,0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,0xD4,0xE2,0x29,0x13,0x85,0x83,0xA9,0x17,
+	0x95,0xA3,0x39,0x33,0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,0x06,0x84,0xE0,0x46,0x16,0xA4,0x70,0x62,
+	0x46,0xC4,0xF0,0x66,0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,
+	0x57,0xE5,0x61,0x43,0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0x69,0x53,
+	0x87,0x87,0xE9,0x57,0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0x22,0x0A,0x0C,0x88,0xA2,0x0E,
+	0x1C,0xA8,0x32,0x2A,0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,0x0D,0x89,0xAA,0x1E,0x1D,0xA9,0x3A,0x3A,
+	0x4D,0xC9,0xBA,0x3E,0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,0x9C,0xAA,0x33,0x2B,0xCC,0xCA,0xB3,0x2F,
+	0xDC,0xEA,0x2B,0x1B,0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,0xCD,0xCB,0xBB,0x3F,0xDD,0xEB,0x62,0x4A,
+	0x0E,0x8C,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x6A,0x5A,0x0F,0x8D,0xEA,0x5E,
+	0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,0x8E,0x8E,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,
+	0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,
+	0xDF,0xEF,0x24,0x82,0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,0x64,0xD0,0xB4,0xA6,0x74,0xF0,0x2C,0x92,
+	0x25,0x91,0xAC,0x96,0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,0x75,0xF1,0x25,0x83,0xA4,0x92,0xA5,0x87,
+	0xB4,0xB2,0x35,0xA3,0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,0xA5,0x93,0xAD,0x97,0xB5,0xB3,0x3D,0xB3,
+	0xE5,0xD3,0xBD,0xB7,0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,
+	0x76,0xF4,0x6C,0xD2,0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x65,0xC3,
+	0xA6,0x96,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x6D,0xD3,0xA7,0x97,0xED,0xD7,
+	0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,0x2C,0x98,0xA6,0x8E,0x3C,0xB8,0x36,0xAA,
+	0x6C,0xD8,0xB6,0xAE,0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,0x3D,0xB9,0x3E,0xBA,0x6D,0xD9,0xBE,0xBE,
+	0x7D,0xF9,0x27,0x8B,0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,0xEC,0xDA,0xB7,0xAF,0xFC,0xFA,0x2F,0x9B,
+	0xAD,0x9B,0xAF,0x9F,0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,0xFD,0xFB,0x66,0xCA,0x2E,0x9C,0xE6,0xCE,
+	0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,0x2F,0x9D,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,
+	0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,
+	0xFE,0xFE,0x6F,0xDB,0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
+	0x00,0x00,0x80,0x04,0x10,0x20,0x10,0x20,0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,0x01,0x01,0x88,0x14,
+	0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,0x90,0x22,0x11,0x21,
+	0xC0,0x42,0x91,0x25,0xD0,0x62,0x09,0x11,0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,0xC1,0x43,0x99,0x35,
+	0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,0x52,0x64,0x48,0x50,
+	0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,0x82,0x06,0xC1,0x45,
+	0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,0x93,0x27,0x59,0x71,
+	0xC3,0x47,0xD9,0x75,0xD3,0x67,0x02,0x08,0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,0x48,0x48,0x92,0x2C,
+	0x58,0x68,0x0A,0x18,0x09,0x09,0x8A,0x1C,0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,0x59,0x69,0x03,0x09,
+	0x88,0x0A,0x83,0x0D,0x98,0x2A,0x13,0x29,0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,0x89,0x0B,0x8B,0x1D,
+	0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,0x1A,0x2C,0x52,0x68,
+	0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,
+	0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x4B,0x59,
+	0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,0x20,0x10,0x84,0x84,
+	0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,0x31,0x31,0x1C,0xB0,
+	0x61,0x51,0x9C,0xB4,0x71,0x71,0x05,0x81,0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,0xE0,0x52,0x95,0xA5,
+	0xF0,0x72,0x0D,0x91,0xA1,0x13,0x8D,0x95,0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,0xF1,0x73,0x44,0xC0,
+	0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,0x23,0x15,0xCC,0xD4,
+	0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,0xB2,0x36,0x55,0xE1,
+	0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,
+	0xF3,0x77,0x06,0x88,0x28,0x18,0x86,0x8C,0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,0x78,0x78,0x0E,0x98,
+	0x29,0x19,0x8E,0x9C,0x39,0x39,0x1E,0xB8,0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,0xA8,0x1A,0x87,0x8D,
+	0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,0xB9,0x3B,0x1F,0xB9,
+	0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,
+	0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0x47,0xC9,
+	0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,0xAB,0x1F,0xCF,0xDD,
+	0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,0x14,0xA0,0x30,0x22,
+	0x44,0xC0,0xB0,0x26,0x54,0xE0,0x28,0x12,0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,0x45,0xC1,0xB8,0x36,
+	0x55,0xE1,0x21,0x03,0x84,0x82,0xA1,0x07,0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,0xD4,0xE2,0x29,0x13,
+	0x85,0x83,0xA9,0x17,0x95,0xA3,0x39,0x33,0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,0x06,0x84,0xE0,0x46,
+	0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,0x17,0xA5,0x78,0x72,
+	0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,
+	0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0x22,0x0A,
+	0x0C,0x88,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,0x0D,0x89,0xAA,0x1E,
+	0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,0x9C,0xAA,0x33,0x2B,
+	0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x2B,0x1B,0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,0xCD,0xCB,0xBB,0x3F,
+	0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x6A,0x5A,
+	0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,0x8E,0x8E,0xE3,0x4F,
+	0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,
+	0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,0x64,0xD0,0xB4,0xA6,
+	0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,0x75,0xF1,0x25,0x83,
+	0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,0xA5,0x93,0xAD,0x97,
+	0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,0x36,0xB4,0x74,0xE2,
+	0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,
+	0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x6D,0xD3,
+	0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,0x2C,0x98,0xA6,0x8E,
+	0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,0x3D,0xB9,0x3E,0xBA,
+	0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,0xEC,0xDA,0xB7,0xAF,
+	0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,0xFD,0xFB,0x66,0xCA,
+	0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,0x2F,0x9D,0xEE,0xDE,
+	0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,
+	0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,
+	0x7B,0xA9,0x80,0x00,0x55,0x40,0xA9,0x57,0x94,0x3C,0x15,0x02,0x2B,0xE9,0x78,0x05,0xB1,0x7B,0x88,0x9D,
+	0xAC,0x41,0x67,0x7F,0xC6,0xCC,0x46,0x33,0xBE,0x01,0xF5,0x72,0xAD,0x23,0x01,0x8D,0x05,0x22,0x28,0x56,
+	0x1C,0x7E,0x10,0xD0,0x58,0x42,0x96,0xC3,0xD6,0xA2,0x09,0x0D,0x87,0x03,0xA9,0xAB,0x14,0x02,0x19,0x7A,
+	0xC5,0x63,0xC7,0xB3,0x53,0x2B,0xF7,0xE9,0x04,0x44,0xE1,0xC6,0xD7,0x1C,0x90,0xE1,0x86,0xBB,0xB0,0x32,
+	0xC0,0x26,0xC8,0xE5,0x7C,0x15,0x8A,0x28,0x91,0xE9,0x20,0x03,0x3B,0xE4,0xD3,0x16,0x8D,0x9A,0x97,0x7E,
+	0xB4,0x44,0x01,0xC1,0x44,0x64,0x91,0xE4,0xBC,0xBB,0x11,0x56,0x50,0xAA,0xA1,0xF3,0x06,0x00,0xE0,0xB7,
+	0x3F,0xDA,0x61,0xF5,0xC9,0xBF,0xB9,0x23,0xCE,0x6A,0x47,0xAC,0x2C,0x48,0xDD,0x44,0x67,0x08,0x91,0x5A,
+	0xC6,0x2D,0x1E,0x4E,0x1B,0xB7,0x9A,0x3C,0x2F,0x49,0x86,0x62,0xB8,0xA3,0x12,0x3D,0xAE,0x4D,0xA2,0x6C,
+	0x5D,0x66,0xDB,0xD2,0x2B,0x6F,0x43,0x60,0x47,0x2C,0x6A,0x5B,0x46,0x2F,0xEB,0xAF,0xD1,0x07,0x5E,0x13,
+	0xAF,0x48,0x70,0xFF,0x35,0xA0,0x1F,0xDF,0xD9,0xB5,0xFB,0x79,0xEF,0xE6,0xAD,0xA6,0x8F,0xAB,0xBA,0xCE,
+	0xD7,0xE2,0xA9,0x4F,0xEB,0xB3,0x31,0x92,0xD5,0x6A,0x9F,0x5F,0x7C,0x09,0xD2,0x54,0xE6,0xA4,0xF5,0xFC,
+	0x45,0x49,0xBA,0x2A,0x42,0x60,0x65,0xF1,0x0E,0xAA,0xFB,0xB2,0xFB,0xCE,0x6D,0x50,0xCC,0xCC,0x79,0x21,
+	0x7B,0x98,0x94,0x49,0x0C,0x08,0xCF,0x3D,0x97,0xD2,0x65,0x40,0xA3,0x42,0x38,0xBD,0xE9,0x69,0x04,0x80,
+	0x78,0xF8,0x0D,0x14,0x93,0x36,0x91,0xA1,0x64,0xD0,0xCE,0xB0,0xD3,0x76,0xDE,0xB0,0x26,0xE9,0x04,0xA8,
+	0xD0,0x3E,0x3C,0x32,0x46,0x53,0x90,0xA5,0x12,0x81,0x4F,0x28,0x82,0x11,0x0D,0xB8,0x13,0x34,0x14,0x21,
+	0xC0,0x5A,0x99,0xB1,0x53,0x74,0x02,0x1D,0x24,0xE6,0xD3,0x2C,0x91,0x4C,0x27,0x4D,0xE9,0x35,0xE5,0x37,
+	0xF8,0xF3,0x34,0x1F,0xCD,0x55,0x42,0xB6,0xB0,0xF8,0xF4,0x10,0xF3,0x87,0x14,0x65,0x4E,0x7A,0xB7,0x97,
+	0xE1,0x55,0xAC,0x82,0xED,0xBE,0xE8,0x92,0x98,0x53,0x27,0x36,0xD2,0xCA,0x25,0x97,0x34,0x1B,0x22,0x27,
+	0x32,0xF6,0x2B,0xE6,0x43,0xC9,0xED,0x1A,0x71,0x7B,0x05,0xC5,0x0F,0x55,0xC9,0x37,0x31,0xFB,0xF7,0x7F,
+	0x42,0x28,0xB5,0x97,0x00,0x1B,0xC6,0x79,0xAE,0x1E,0x5F,0xCE,0xC3,0xA3,0x0E,0x12,0xC4,0xA7,0xEE,0x28,
+	0x23,0xF2,0x8E,0x12,0x08,0xAB,0xB4,0x65,0x19,0xA2,0x1B,0x68,0x37,0x86,0x61,0x42,0x7F,0xF2,0xAC,0x90,
+	0x09,0x01,0xA7,0x72,0xBE,0x1A,0x5D,0x14,0xCA,0xF7,0x8F,0xB4,0xDB,0x0A,0x56,0x66,0x48,0xD4,0x8F,0x60,
+	0xB9,0xE0,0x25,0x3E,0x45,0x52,0x08,0xCF,0x06,0xA4,0x86,0x1B,0xD5,0x5D,0xA0,0xAE,0x5B,0x1C,0x08,0x0A,
+	0x6E,0x1E,0x16,0x6C,0x6E,0x76,0xB1,0xE8,0xD4,0xB2,0x0E,0x59,0xC8,0x3B,0x97,0x08,0xE1,0xAC,0x74,0x42,
+	0x7D,0x3F,0x27,0x9F,0x3C,0x13,0xDF,0xC9,0x32,0x86,0x15,0x76,0xEC,0xDC,0x9E,0xEF,0xF9,0x78,0x5C,0xAB,
+	0xC9,0xE0,0x65,0x94,0x1A,0x7D,0x21,0xFF,0x88,0x63,0xE9,0x7F,0x3E,0x2C,0x20,0x02,0x04,0xC0,0x27,0xE4,
+	0x96,0x88,0x4A,0x20,0x7C,0x4D,0xC8,0x01,0x14,0xEF,0x28,0x12,0x05,0xC1,0xD0,0x94,0x16,0x47,0xBE,0x02,
+	0x15,0xDD,0x6D,0xB2,0x1A,0xDE,0x7B,0x60,0x84,0x82,0x1A,0x65,0xD5,0xE2,0xD5,0x04,0x77,0x48,0x71,0xD6,
+	0x3D,0x19,0x29,0x8F,0x85,0x83,0x91,0x67,0x21,0xAA,0x95,0x96,0x04,0x49,0xE7,0x9D,0x85,0xAD,0xD0,0xF0,
+	0x28,0xC1,0xB8,0x4E,0x94,0x68,0xB0,0xE3,0x4C,0x1B,0x5A,0xD8,0x50,0xA6,0x87,0xA0,0x01,0x85,0xC8,0x47,
+	0xF6,0xA3,0x6F,0xF6,0x05,0xFB,0xC0,0xF4,0x92,0xD6,0x97,0xE6,0x03,0x81,0x04,0xB7,0x9E,0xA9,0xC5,0x01,
+	0x39,0x6B,0xC7,0xE5,0x13,0xB5,0xAB,0x8D,0x7E,0x29,0x43,0xD8,0x34,0xE5,0xB9,0xF6,0x47,0x67,0x39,0xF3,
+	0xF4,0x7A,0x22,0x0A,0x0C,0xC8,0xEC,0x8C,0x15,0xCC,0xB5,0x7A,0x6C,0xD4,0x83,0xAC,0x5D,0xA7,0x2A,0x1A,
+	0x0D,0xC9,0xCA,0x5E,0x00,0x22,0xF0,0x38,0x45,0x01,0x09,0xF8,0xE1,0xA7,0x23,0x96,0x8C,0x8A,0x9B,0x5F,
+	0x8C,0xA5,0x97,0x6B,0x8C,0x45,0xE9,0x2E,0x7F,0xA6,0x73,0x1B,0x8D,0x8B,0x2B,0xFD,0x1F,0xA3,0xC1,0xE4,
+	0x2C,0xCF,0x88,0xBD,0xD4,0x0B,0x35,0x20,0x8B,0x8B,0x26,0xAF,0xE1,0xC2,0x65,0x68,0xCB,0x61,0xDA,0x0C,
+	0xA7,0xE0,0xB5,0x52,0x21,0xCB,0xE2,0x42,0xE2,0x24,0x44,0x57,0x61,0x12,0x45,0x3C,0xFE,0xAF,0x8B,0xE8,
+	0xAA,0x73,0xF9,0x4D,0x5C,0xEA,0x60,0x5A,0x6F,0x31,0xCB,0x11,0x5F,0xE3,0x99,0x9D,0x2D,0xC3,0xCB,0xCD,
+	0x5B,0xA5,0x21,0xF8,0xB3,0x60,0xBF,0xD1,0xE0,0x6F,0x4D,0x79,0xA6,0x94,0x8C,0x02,0x1D,0x29,0x30,0xBE,
+	0xB9,0x5A,0x74,0x42,0xFD,0xB1,0xA3,0xE0,0x86,0xF4,0xCC,0xD7,0xD8,0x3A,0x0D,0xF2,0xD7,0x5C,0x1D,0x1B,
+	0xE9,0x62,0x2D,0x7E,0x25,0x49,0x1A,0xDB,0x95,0xA2,0x1D,0x92,0x45,0xDB,0x96,0x0E,0x2C,0xA1,0xC2,0x69,
+	0x72,0xCC,0xD6,0x75,0x35,0x6C,0xD9,0x94,0x52,0x5E,0x16,0xC8,0x20,0xBD,0x1A,0xEF,0xDB,0xFA,0x20,0xF4,
+	0x37,0xA4,0xA7,0x11,0xEA,0xD9,0xCC,0x79,0x89,0xF2,0xD7,0x15,0xE5,0x91,0xD3,0x89,0xB7,0xB5,0x22,0x10,
+	0x63,0xA8,0x07,0x31,0xF5,0x39,0x07,0x83,0xA7,0xEE,0x4E,0xBD,0x63,0x4A,0x8E,0xC4,0x47,0x29,0x5F,0x4E,
+	0x57,0x20,0x25,0x82,0x06,0xFB,0x4E,0xFA,0x6B,0x26,0x4F,0xC3,0x3B,0x78,0xD0,0x95,0x29,0xF1,0x7F,0x8A,
+	0x53,0x98,0x66,0x7F,0xBA,0xBE,0xD2,0x8D,0xDF,0x55,0xC0,0xE8,0xDA,0xB4,0x55,0x6B,0x8D,0x45,0x50,0x7C,
+	0xBF,0xB3,0x9E,0xF0,0xF8,0x75,0x3E,0x0B,0xA0,0x24,0x1D,0x6D,0xBC,0x64,0xAB,0x88,0x1D,0x30,0xD3,0x8C,
+	0x7D,0x76,0xC3,0x52,0xC2,0xB8,0x71,0x93,0x74,0x30,0x49,0x6F,0x09,0xB4,0x9B,0xF5,0x4E,0xBE,0x10,0x3B,
+	0xF9,0x18,0xA2,0x28,0xCF,0x33,0xD8,0xE3,0xB3,0xDE,0xD6,0x99,0xCD,0x5F,0x5C,0xA4,0xDF,0x2A,0x26,0x73,
+	0xC6,0x2C,0x2A,0x2D,0x4F,0x30,0x1E,0xAC,0x41,0x9F,0x9F,0x7A,0x79,0x58,0x70,0x4F,0xA0,0x84,0x99,0xE2,
+	0x57,0x2F,0x5A,0x6F,0xE0,0xDA,0xBF,0x5A,0x7C,0x32,0x79,0xB9,0xCF,0x51,0x8F,0x89,0x76,0xB0,0xBF,0xC8,
+	0xE9,0xBD,0x9F,0xA9,0xAE,0xF2,0x60,0x56,0x1D,0x42,0x7F,0xC6,0xB1,0xFF,0x44,0x3E,0x62,0xEF,0xAE,0x1D,
+	0xB0,0xE1,0x30,0x6B,0x80,0x0C,0xDC,0x0A,0x33,0x95,0x0F,0xB4,0x4F,0x5B,0x63,0xC5,0xF2,0x01,0xC1,0xE1,
+	0x71,0x0E,0x41,0x18,0xB5,0xD6,0x86,0xD2,0xB4,0xED,0xCD,0xA1,0xDA,0x79,0xB2,0x53,0x20,0xFE,0x1E,0x0F,
+	0xE5,0x25,0x51,0x88,0x28,0xF2,0xA7,0x0C,0x31,0xE2,0x08,0xD1,0x04,0x26,0xB8,0xC6,0x17,0xEE,0x30,0x2A,
+	0x2D,0xB8,0x9A,0x9F,0xF1,0x62,0x5E,0x69,0xE8,0x41,0xF0,0x84,0x6C,0x2A,0x98,0xAC,0x81,0x43,0x32,0xF6,
+	0x56,0x25,0xE1,0xBE,0xE1,0x0D,0xB9,0xC7,0x97,0x22,0x29,0x46,0x3F,0x49,0xDD,0x0E,0xD4,0x9F,0x73,0xE1,
+	0x61,0xA8,0x7D,0x37,0xD0,0xF8,0xF3,0x38,0x62,0xB8,0xE1,0xA5,0x28,0x68,0x2A,0x6A,0x0E,0x2A,0x28,0x59,
+	0xED,0x27,0xD2,0xA9,0x15,0x0A,0x4A,0xA8,0x1A,0xC0,0x62,0x7A,0xFE,0x07,0x20,0x5C,0xF0,0xAA,0x8D,0xCB,
+	0x23,0xE4,0x26,0x43,0x32,0x66,0xC0,0xCB,0x29,0xF5,0x37,0x72,0x3B,0x2C,0x57,0x97,0x21,0xE9,0xB3,0xE7,
+	0xDE,0xE8,0x33,0xE2,0x0A,0x06,0xF3,0x3A,0x70,0x88,0x49,0x85,0x22,0xC8,0x1F,0x1E,0x70,0xE6,0xE6,0x37,
+	0xA9,0xAC,0xBA,0xCE,0x1B,0x6E,0xE6,0x0A,0xC8,0x50,0xB2,0x28,0x1E,0x61,0x08,0x3F,0x0D,0x9C,0xF2,0x8C,
+	0xE0,0x22,0xE5,0x9A,0xC9,0x81,0x52,0x70,0xFA,0xE7,0x54,0x4B,0x2B,0x4C,0xFB,0x9D,0x25,0x21,0x0E,0x36,
+	0x69,0x2B,0x99,0x96,0x79,0x68,0xA0,0x46,0xBF,0x0B,0x7F,0x3F,0xD8,0xD8,0x72,0x1B,0x34,0x2A,0xA4,0x9F,
+	0x59,0x27,0xC4,0x04,0x6F,0x52,0x44,0x14,0x0A,0x3A,0x6A,0x9D,0x91,0xF3,0x54,0x21,0xB2,0xF1,0x36,0x12,
+	0xE4,0xBD,0xD6,0x95,0x92,0x35,0x0B,0xB2,0x97,0xA4,0x5C,0x31,0xB3,0xF0,0x87,0xDF,0xA1,0xB2,0x84,0x07,
+	0x75,0x91,0x86,0x52,0x94,0xF2,0x49,0x21,0xFA,0x69,0x75,0xE3,0x23,0xDF,0x8B,0xE7,0x33,0xFF,0x4B,0x8F,
+	0x83,0xE6,0xC7,0x31,0xFB,0x68,0x7A,0xEC,0x81,0x19,0xBC,0x46,0x37,0x6D,0x8B,0x9E,0xC1,0x31,0x08,0x2F,
+	0xF0,0x3C,0x2C,0x9A,0x5E,0x1A,0x6C,0xB6,0x72,0x75,0xCC,0x74,0x21,0x49,0x18,0x71,0x30,0x15,0x25,0x61,
+	0xD0,0x70,0xFF,0x27,0x30,0x1E,0xEA,0x03,0x1E,0x07,0x13,0x87,0x0D,0xFA,0xF9,0xA3,0x00,0x55,0xB5,0x25,
+	0xBB,0x75,0xA2,0xD5,0xE5,0x3C,0x8D,0x97,0xB7,0x71,0xB6,0x6A,0xAA,0xD4,0xD0,0x6E,0xBA,0xF4,0xC2,0x92,
+	0x4E,0x85,0x56,0x29,0xBA,0xF9,0xDC,0x68,0xD6,0x16,0xEC,0x98,0x3A,0x79,0x26,0x3C,0x67,0x15,0xAA,0x9A,
+	0x7F,0xFB,0x2D,0x6B,0x2A,0xD6,0x66,0xEF,0x47,0x56,0x3F,0xCB,0x15,0x56,0xC9,0x29,0xBA,0xD2,0x6F,0xCF,
+	0x13,0x14,0xBB,0xEE,0x44,0xBD,0x77,0xDB,0x16,0x55,0x23,0xC2,0x92,0x74,0x17,0xC8,0x19,0x6E,0x59,0x13,
+	0xB8,0x3F,0xE9,0x2F,0x97,0xFA,0x5E,0xED,0x7C,0x85,0x2E,0x92,0x00,0xE1,0xB6,0xBE,0x7A,0x35,0xCE,0x7A,
+	0x6E,0xC4,0x1A,0x79,0x38,0x5D,0xFF,0x36,0xBA,0x53,0x72,0xAF,0xFB,0xBE,0x44,0x97,0x20,0x2F,0xFA,0x92,
+	0x3B,0x1C,0x37,0xFE,0x56,0x10,0xB7,0xBF,0xF8,0x40,0x65,0x1B,0x69,0x17,0x8F,0x9F,0xBF,0x79,0x5B,0x45,
+	0x02,0x82,0xD8,0x82,0x1E,0x65,0x0F,0x93,0x6A,0x6F,0xCE,0x1F,0x52,0x82,0x82,0x41,0x66,0xA1,0xEA,0xBF,
+	0x16,0xB1,0x46,0x96,0xAC,0x70,0x7C,0x8B,0x3E,0xEE,0xA0,0xC3,0xC0,0x84,0x61,0x86,0x62,0xE0,0xE5,0x59,
+	0xAE,0x81,0xF8,0xE7,0xFA,0xA0,0x51,0x97,0x8F,0x39,0xC9,0x41,0xFB,0x28,0xF9,0xB2,0xCF,0x1C,0x3B,0xB3,
+	0xDF,0xC8,0x66,0xC6,0x44,0x98,0x98,0x24,0x55,0x5A,0x48,0xE0,0xD7,0xBF,0x73,0x04,0x15,0x5B,0x8D,0xD6,
+	0x01,0x2B,0xD0,0x86,0xE0,0xAA,0x00,0xF6,0x41,0x6A,0x38,0x0B,0xD6,0xE3,0x1F,0x6F,0x04,0x4A,0x99,0xC5,
+	0x97,0xE4,0xDE,0x81,0x6A,0x3B,0x89,0xE5,0xD3,0xC6,0x57,0x7F,0x0A,0x01,0x5D,0x35,0xD4,0xD8,0x86,0xF1,
+	0x56,0x7C,0x71,0x66,0xD1,0x1E,0x59,0x2D,0xAD,0x37,0xA6,0xEC,0x9C,0x08,0x86,0x48,0xB3,0x65,0x72,0xAB,
+	0x9E,0x69,0xEA,0x0E,0xD8,0x83,0xD2,0x9A,0x5F,0xAE,0x04,0x9A,0x3B,0x66,0x7A,0xBB,0x9F,0x68,0xE3,0x8E,
+	0x13,0x75,0x99,0x8D,0x59,0x49,0x67,0x16,0x27,0xE9,0xEF,0xAB,0xD6,0xF1,0xAE,0x9F,0x87,0x4E,0x54,0x6D,
+	0x6E,0x14,0x6B,0x40,0xA7,0x3A,0x63,0xBB,0xD7,0xF0,0x62,0x8A,0x0A,0xA0,0x9A,0x2C,0x5D,0x13,0xB2,0xFA,
+	0x1A,0xCA,0xDA,0xEC,0x5B,0xDC,0x78,0x1A,0x0B,0xA1,0xD0,0xBC,0xB3,0xA2,0xD0,0xE1,0x49,0xAF,0x72,0x67,
+	0x59,0x14,0x4E,0x38,0xBA,0x08,0x9B,0xCD,0x9B,0x2F,0xD9,0xF5,0x6F,0xC8,0x33,0x12,0x5F,0xE8,0x46,0xD9,
+	0x4A,0xD3,0x8B,0x1F,0x33,0x2F,0x79,0x84,0x4D,0xD3,0xD3,0x82,0xBE,0xAD,0x44,0xD4,0x06,0x9F,0xE4,0xC6,
+	0x30,0x95,0x0C,0x5C,0x62,0x20,0x36,0x94,0x8F,0xF4,0xEC,0x36,0x67,0xD3,0xAD,0xD6,0x57,0x3C,0x6E,0xA9,
+	0x4B,0x45,0x84,0x49,0xF8,0x77,0x45,0xD5,0x76,0x9D,0x9B,0xF8,0x39,0x34,0xAD,0xBC,0x8E,0x06,0xE3,0x25,
+	0x31,0xA4,0xE9,0x5C,0x5A,0x1E,0xD3,0xAE,0xB3,0xD1,0xED,0x8C,0xCF,0x06,0xFD,0xF7,0xD3,0x0E,0x65,0xA4,
+	0xD9,0x84,0x9C,0x44,0x33,0x50,0x69,0x66,0x1B,0x9A,0x7C,0xF7,0x70,0x0D,0xD8,0xAD,0x84,0x93,0xBC,0xC7,
+	0xD6,0xBA,0x36,0x09,0xC4,0xD3,0xC4,0x09,0x55,0xF8,0xDD,0xE4,0x7B,0x99,0xBF,0xC6,0x15,0xB0,0x15,0xA7,
+	0x6E,0xDB,0xD8,0x65,0xF3,0x34,0xC7,0x5D,0x06,0x68,0x8D,0x77,0x8D,0xB8,0x2D,0xDC,0x46,0x5D,0x7F,0x75,
+	0xF2,0xC7,0x81,0x3B,0xF8,0x1B,0xEF,0x4E,0x10,0xFA,0x66,0x91,0x10,0x4D,0xD4,0xEE,0x7F,0x49,0x2F,0xFC,
+	0xDA,0x89,0x2A,0x1A,0x37,0x92,0x81,0xF8,0xCC,0x9B,0x14,0x30,0xDC,0x46,0x59,0x2E,0x47,0xD9,0x63,0x32,
+	0xD7,0xB5,0xA4,0xD5,0x6D,0xD7,0x8D,0x5C,0x84,0xFC,0x97,0x64,0x4C,0x6F,0x54,0x6E,0x1E,0xDB,0xFB,0xFD,
+	0x6E,0xD6,0x81,0x86,0x70,0x4D,0xA6,0x4B,0x07,0xDE,0x86,0x6E,0x64,0xB3,0x81,0x08,0xEC,0x94,0x36,0x93,
+	0xE7,0x01,0xEE,0xA5,0x29,0xBF,0x8E,0x7E,0x53,0xB2,0xCA,0x0A,0x63,0xD2,0x7C,0x7C,0x7A,0x4D,0x25,0xAF,
+	0xC5,0x91,0x87,0x6F,0xA2,0xB1,0x6F,0x1B,0xEF,0xD1,0x5B,0x6A,0xDC,0xF3,0x58,0x24,0x03,0x92,0x8F,0x9E,
+	0x0A,0xB2,0x1F,0xBF,0xF8,0x52,0x3F,0x82,0x66,0xBE,0x3A,0xF3,0x09,0xAF,0xE0,0x4E,0x4B,0x2D,0x54,0x8E,
+	0xCD,0x02,0xA8,0xE3,0x8E,0xFD,0xE6,0x19,0x44,0xD2,0x95,0x90,0x33,0xA8,0x46,0x71,0x49,0x47,0x94,0x35,
+	0x57,0x43,0x89,0x7E,0x86,0x00,0x91,0x63,0x94,0x06,0x51,0x2D,0xC3,0x22,0x72,0x65,0xDC,0xC9,0x0C,0xB6,
+	0xD6,0x13,0x2E,0x54,0x19,0x48,0xB3,0xBF,0x60,0x3C,0x5A,0xB1,0xDB,0x34,0x4C,0x41,0x80,0xC8,0xE4,0x2D,
+	0x90,0x38,0x11,0x06,0x94,0x4C,0xD8,0x65,0x54,0x26,0x41,0x50,0x8E,0x8E,0x48,0x57,0x2A,0x8E,0x62,0x83,
+	0x42,0x07,0x32,0x45,0x52,0x27,0x93,0x23,0x7D,0x44,0x8A,0x27,0xB2,0x2B,0xD5,0x90,0xCB,0x66,0x78,0xA5,
+	0x98,0xED,0x4D,0xCE,0x86,0x2F,0xC1,0x54,0x95,0x65,0x99,0x3F,0xC0,0x8D,0x9D,0x63,0x5E,0xEE,0xD4,0x6D,
+	0x18,0x07,0xE2,0x46,0x43,0x25,0xD2,0xA9,0x61,0x0A,0x3E,0xA8,0x5A,0x38,0x0F,0x98,0x74,0x59,0x97,0x98,
+	0x17,0x64,0x7D,0x46,0x9B,0x43,0x9E,0xBE,0x9C,0x4C,0x1D,0x00,0x88,0xB3,0x93,0x6A,0x9C,0x0E,0xD3,0x2B,
+	0x45,0xB7,0xDB,0x28,0xB3,0x42,0x46,0xFC,0x9D,0x49,0x27,0x62,0x5B,0x4B,0x9F,0xC8,0xC0,0x6B,0xA3,0x8F,
+	0xDD,0xBB,0x66,0xAD,0x88,0x10,0x6B,0x8C,0x4C,0xA7,0x08,0xBE,0x22,0x44,0xF2,0xFE,0x92,0x66,0xCA,0x5B,
+	0x32,0x0B,0x8E,0x4A,0xE4,0x41,0xDC,0x98,0x06,0xE6,0xDC,0x3C,0xDB,0xA0,0x08,0x2B,0xAA,0x43,0x29,0x7C,
+	0x9B,0x6C,0x93,0xE8,0x0E,0xC7,0x57,0x9C,0xD3,0x4E,0xE1,0x7B,0x2A,0xF0,0xD1,0x5F,0x59,0x0B,0x23,0x7D,
+	0x22,0x47,0x1B,0xFC,0x4C,0x03,0x64,0xD6,0x0A,0x52,0x09,0x7C,0xEC,0x18,0xC6,0xC2,0xEF,0xA6,0x6B,0x16,
+	0x74,0xB0,0xB3,0xEF,0x12,0x51,0xC7,0xF6,0x11,0x5C,0x18,0x34,0x6F,0xCE,0x84,0xB9,0x8C,0x1F,0xC5,0xE4,
+	0xA6,0x79,0xA1,0x60,0x32,0x2E,0x1D,0xA4,0x8B,0x7A,0x21,0xC7,0x91,0x32,0xA6,0xD6,0xAF,0xCF,0x0D,0x96,
+	0x88,0x35,0x46,0xB1,0x9A,0x93,0xFF,0xB1,0xF2,0xD3,0xC0,0x31,0x2B,0x34,0xFC,0xB4,0x36,0x3F,0x5C,0x64,
+	0x68,0xDD,0xD0,0x60,0x74,0x28,0xC8,0x21,0x2A,0x35,0xF4,0x50,0x39,0xCD,0x62,0xB0,0x65,0x77,0xCA,0xB4,
+	0x75,0x57,0x85,0x45,0x7A,0x1E,0xD7,0x47,0x77,0x45,0xAE,0xC6,0x43,0xA9,0x9D,0x7C,0x91,0xB8,0x2D,0x87,
+	0x81,0x1A,0x36,0xF2,0x12,0xC8,0xD2,0x75,0xB3,0x9C,0x7F,0x0A,0x7C,0xFE,0xC2,0x42,0x93,0xA7,0x2C,0xAE,
+	0x99,0xC7,0xD6,0xB1,0xE3,0x43,0x56,0x3C,0x96,0x70,0x26,0xFA,0xD0,0x15,0xB6,0xEC,0x3D,0x30,0x5F,0xDE,
+	0x1F,0x86,0xFE,0xEA,0xD9,0x74,0x2C,0xF7,0x79,0x87,0xF5,0x89,0xFC,0x5F,0xD4,0xCF,0x94,0xA5,0x13,0x5C,
+	0xF1,0x5A,0x37,0x1D,0xA7,0x65,0x0A,0xE2,0x36,0xBD,0x41,0x5B,0xED,0x26,0xC7,0xA8,0x55,0x76,0xB9,0x4C,
+	0x3B,0x1C,0xA6,0x9A,0x48,0x31,0x3E,0x8A,0x91,0x52,0xF6,0x7E,0xF2,0x74,0x92,0x5A,0xBA,0x87,0x7A,0xBE,
+	0xC0,0x7F,0x9E,0x7D,0x06,0x55,0xBC,0xEB,0x78,0x1D,0xF8,0x8D,0xA3,0x3A,0x07,0x4C,0xE7,0xA1,0x6F,0x13,
+	0x67,0xE3,0x56,0x92,0x9B,0x7A,0x77,0xFE,0x8B,0xB2,0x13,0xA2,0xBD,0x1D,0x59,0x08,0xE2,0x7F,0x81,0xBC,
+	0xF3,0xDF,0xFA,0x0B,0x62,0x6B,0x1B,0x76,0x94,0x26,0x50,0x74,0xE4,0xCD,0xD0,0x70,0x51,0xED,0x5E,0x3C,
+	0x19,0xC1,0xA4,0x17,0x13,0xE8,0xBA,0x15,0xE4,0x47,0x4F,0x37,0x59,0x4A,0x22,0x67,0xB3,0xF2,0x81,0xC7,
+	0x98,0x09,0xDD,0xB1,0xCC,0xC8,0x4E,0xA3,0xAD,0xE3,0x9C,0x1E,0xE2,0xD4,0x07,0x68,0xF4,0x83,0xB9,0x73,
+	0xC9,0x68,0xB5,0x36,0x57,0x2F,0x12,0x46,0x42,0xE1,0xE8,0x4E,0x99,0x59,0xB0,0xE3,0xBE,0x1B,0x97,0x18,
+	0x84,0xEC,0xED,0x2D,0x88,0x03,0xE0,0x53,0x7C,0x8D,0x70,0xF6,0x4D,0xE7,0x98,0x20,0xFF,0xE8,0x59,0x33,
+	0x82,0x8F,0xFB,0x45,0x54,0xC2,0xC5,0x01,0x39,0x6B,0x75,0x96,0xDF,0xC6,0xE9,0x93,0xCF,0xC5,0xED,0x46,
+	0x96,0xA3,0xB9,0x6B,0xA0,0x3A,0x15,0xE5,0xD7,0xED,0x21,0x07,0xB2,0x88,0xBA,0x0A,0x94,0xC3,0x3E,0x2B,
+	0xCE,0x04,0x67,0x2C,0x5B,0xEE,0x03,0xC3,0xAC,0x88,0xE5,0x7C,0x3D,0x24,0x7A,0xB8,0x88,0xCA,0x80,0x3A,
+	0xD5,0xD0,0x23,0x13,0xA3,0x8C,0x87,0x66,0x1E,0xB6,0x07,0x49,0x2E,0x8A,0x9A,0xF7,0x7D,0xEB,0x13,0x1F,
+	0x05,0xB2,0x2B,0x1C,0xA4,0xE9,0x03,0xC4,0x4F,0x07,0xDB,0x69,0x7D,0xE6,0x20,0xFD,0x0F,0xEC,0x8D,0xCA,
+	0x14,0xF2,0x64,0x08,0xB5,0x11,0x72,0x6D,0x71,0xC8,0xC0,0x78,0xAE,0x86,0xE2,0x5B,0x74,0x85,0x42,0x01,
+	0xCE,0xC0,0xC2,0x5E,0xB6,0xAD,0x3D,0x0A,0x86,0x88,0x4F,0xD4,0x6B,0x38,0xA7,0x91,0x3F,0xC2,0xEE,0xED,
+	0x4F,0x54,0xED,0x7C,0x2E,0x84,0xEF,0xDD,0x5A,0xAA,0x25,0x99,0xCB,0x62,0xDF,0x16,0xB4,0xE7,0xDB,0x00,
+	0xE1,0xF3,0x24,0x46,0x7C,0xF2,0xF4,0x23,0x9C,0x92,0xEC,0xA3,0x1F,0xD8,0x53,0x16,0x0A,0x6C,0xF2,0xD7,
+	0x3D,0xB7,0x62,0xF3,0x6D,0xD7,0x7C,0x32,0xF5,0x9D,0x1D,0x79,0x08,0x9F,0xE7,0x30,0xB5,0xD2,0xF1,0x64,
+	0xE7,0xB2,0xB1,0x23,0xFE,0x48,0x45,0xF1,0x5E,0x9D,0x07,0xB5,0x14,0x3A,0x97,0x1E,0xEC,0x2B,0x02,0x2C,
+	0x00,0x65,0xE4,0xC1,0x1F,0x92,0xD9,0x42,0x38,0xB7,0x54,0xF2,0x2E,0xDC,0xFC,0xE4,0xA1,0xF2,0xAC,0x53,
+	0x0E,0xD7,0xE8,0x54,0xF2,0x90,0x4C,0x90,0x06,0x95,0x8B,0x1B,0x73,0xB7,0xCF,0x4D,0x07,0x69,0xED,0xC2,
+	0xDD,0x9E,0x79,0xEC,0x64,0x1A,0x5F,0xAE,0xF0,0xD4,0x2F,0xEB,0xA6,0x35,0xD5,0x10,0x75,0xB7,0x65,0xF6,
+	0x8C,0xFF,0x3D,0x1B,0xF1,0x95,0x1E,0x70,0xA1,0x65,0xA2,0xEE,0x30,0x13,0x56,0xE0,0x37,0xD5,0xBE,0xB7,
+	0x4F,0x8A,0xAA,0x6B,0x24,0xB9,0x89,0x5E,0x6D,0xFB,0x23,0x3E,0x59,0xF4,0xC1,0xC1,0xA7,0x24,0x40,0xF5,
+	0x7E,0x90,0xAB,0x8E,0xBA,0xF8,0x27,0xC8,0xE8,0xFE,0x0F,0x55,0xEC,0xB7,0xEF,0x1A,0xFB,0xD9,0xEB,0x46,
+	0x4E,0xDE,0x98,0xFA,0x65,0xB0,0xDC,0x7F,0xF1,0x50,0x38,0x28,0x2A,0x61,0xAE,0xCA,0xB6,0xD7,0x72,0x6E,
+	0x64,0x66,0xC1,0x6A,0x74,0xDF,0xDA,0xB8,0xD0,0xF1,0xA1,0xBC,0x1F,0x70,0xC1,0x61,0x9A,0x4B,0x3E,0x7E,
+	0x6B,0xF7,0xA7,0x4A,0x56,0x41,0xC3,0xA6,0x3C,0xA2,0xB7,0x6F,0x6E,0xB0,0x37,0x6E,0x48,0x90,0x36,0x47,
+	0x0A,0x69,0x6F,0xDC,0x86,0x14,0x37,0xFF,0x67,0xB4,0x7B,0x0E,0xF6,0xDF,0x60,0x56,0xA0,0x0D,0xAB,0x57,
+	0x9C,0xBC,0x4A,0x4C,0x64,0xAD,0xA8,0x00,0x53,0x20,0x91,0x13,0x38,0x07,0x28,0x5E,0xC0,0x8D,0xE1,0x32,
+	0x04,0xAC,0x18,0x53,0x75,0x55,0xED,0x93,0x80,0x0A,0xF9,0x22,0x01,0x8E,0x14,0xD7,0xD0,0xBC,0x2F,0x01,
+	0x6E,0xBD,0x20,0xC8,0x20,0x02,0x2D,0x4F,0x4E,0x1E,0x1C,0xD7,0xD1,0xBD,0x39,0x3B,0x5D,0xEE,0x7F,0xAA,
+	0xE9,0x0B,0xF2,0x7C,0xCB,0x87,0x2E,0x82,0xEE,0x49,0x04,0x9F,0xA3,0x07,0x0B,0xAE,0xFB,0x0A,0xB0,0x66,
+	0xE4,0x10,0x4E,0x76,0xF0,0x81,0x98,0xA3,0x5F,0x53,0xFA,0x53,0xA2,0x48,0xB9,0xBF,0x2F,0xF2,0xC1,0xA1,
+	0xDA,0x7B,0xAA,0x0A,0xFC,0x19,0x17,0xB3,0x93,0xFA,0xB1,0x3A,0x4F,0x28,0x21,0x79,0x26,0x06,0xD1,0x65,
+	0x6E,0x51,0xBC,0x0C,0x80,0x31,0x69,0x7B,0x98,0x98,0xEB,0x2A,0x3E,0x5C,0x76,0x08,0xE6,0x48,0xCA,0x56,
+	0x0A,0xDB,0xB0,0x9B,0xB5,0xE6,0x1F,0xDA,0xE5,0xB7,0xE4,0x3A,0xB0,0x0D,0x5D,0x49,0x80,0x48,0xA6,0x0B,
+	0x0C,0x4E,0xB3,0x33,0x44,0xA7,0x90,0x5E,0x5C,0x5B,0x51,0xCF,0xE1,0x03,0x8A,0xC2,0x22,0xB6,0xE2,0x3B,
+	0xEF,0x26,0x4A,0xCE,0x55,0x66,0xD5,0xB7,0xF3,0x6F,0xF0,0x13,0xD3,0x23,0xA7,0x96,0x5E,0x71,0x2F,0x71,
+	0xC9,0xC1,0x02,0x4C,0xC0,0x02,0xF0,0xE4,0xE8,0x70,0x24,0x9A,0x5B,0x00,0x83,0xF4,0xA6,0x9C,0x3C,0x09,
+	0xC6,0x18,0x50,0x16,0xA0,0xF1,0x45,0x6F,0x79,0x03,0xE9,0x86,0x6D,0x2F,0xB3,0x7D,0x06,0x19,0xF9,0x64,
+	0x4E,0x8C,0xCB,0x0A,0x47,0x1E,0x24,0x03,0xF5,0xB0,0xD9,0x84,0x26,0x52,0x6B,0xEA,0xE7,0x2D,0xA0,0x56,
+	0x70,0xAE,0xB3,0x46,0x90,0x65,0xCC,0x11,0x0B,0x53,0x2D,0x93,0xD0,0x57,0xBC,0xBE,0xED,0x5C,0xAE,0x9C,
+	0xA4,0xC5,0xDC,0x05,0xAE,0xA7,0xA5,0x4A,0x28,0x76,0xEC,0xA3,0xF3,0x66,0xED,0xFA,0x20,0x7D,0x49,0x3F,
+	0x2E,0x51,0x39,0x73,0xA1,0xCD,0xA9,0x57,0xF1,0xAD,0xE5,0x87,0x85,0xAC,0xA7,0x3E,0x24,0xA4,0xFF,0x4F,
+	0xDB,0x70,0x51,0x8B,0x0A,0x10,0x44,0x15,0xD1,0x76,0x33,0xA2,0xF1,0x8A,0x6C,0xAA,0xAD,0xEA,0x24,0xD4,
+	0xDD,0x8A,0x08,0x0A,0x8A,0x16,0x29,0x86,0x43,0xA0,0xA4,0x85,0xE2,0x99,0x7C,0x17,0xF2,0x93,0x6A,0xD8,
+	0x0D,0xAB,0x6D,0xD4,0xA5,0xA7,0xF2,0x5B,0x48,0xAA,0x58,0x9A,0x8B,0x13,0xA2,0xAF,0xDD,0xEB,0x46,0x84,
+	0x2B,0x78,0xFB,0x8E,0xE9,0x2C,0xEF,0xAA,0x39,0x5C,0x06,0x16,0x78,0x08,0xA4,0xBA,0x88,0x77,0x0D,0xC0,
+	0x18,0x55,0xB4,0xBA,0xAA,0x5D,0xB9,0x5E,0xB9,0x86,0x59,0xC8,0xA0,0x1C,0xFF,0xF2,0x99,0x1A,0xFF,0xAB,
+	0x5F,0x5E,0x64,0xAD,0xC0,0x87,0x6D,0x99,0xA8,0x79,0xAE,0x7F,0x40,0xBA,0x02,0xBB,0x4E,0x5F,0xA8,0x5F,
+	0xDD,0xF6,0x2A,0x68,0xE1,0xFC,0xA3,0x36,0x66,0x92,0x7F,0x0E,0x83,0x53,0xFF,0x49,0xEB,0x7E,0x74,0x46,
+	0xDC,0x5C,0x33,0xAE,0xE2,0x62,0xF9,0x1A,0x8B,0xC1,0x3F,0x96,0xE1,0x75,0xEB,0xBB,0x74,0xE1,0xBF,0x1B,
+	0x5B,0xE2,0x56,0x0F,0xCE,0x43,0x39,0xF8,0x64,0xE3,0x61,0x3B,0x18,0x7A,0xF5,0x87,0x00,0x2A,0xFA,0x1B,
+	0x0B,0xCE,0x5E,0x86,0x65,0xC0,0xE0,0x83,0xC0,0x7F,0x59,0x2D,0xB7,0x1D,0x35,0xD4,0x54,0x3E,0x20,0xE6,
+	0x10,0xDD,0x0E,0xD2,0x15,0xED,0x09,0x11,0xE4,0xFE,0x3D,0xD4,0x55,0x3F,0x28,0x99,0xA2,0x21,0xCD,0x73,
+	0x04,0x04,0x5C,0x23,0x0C,0xE6,0xC8,0x21,0xF7,0xAF,0xA7,0x21,0x67,0x2F,0x96,0x63,0x05,0x05,0x91,0x30,
+	0x04,0x0F,0xC0,0x31,0xE6,0xD7,0x84,0x06,0x51,0xFC,0x1F,0x5F,0xCD,0x8B,0x98,0xBD,0xF7,0x37,0x0E,0x65,
+	0xFF,0xA2,0xCF,0xC3,0xAD,0x79,0x53,0xF2,0xEA,0xB5,0xE9,0xA7,0x93,0xA5,0x9C,0x56,0xF4,0xB2,0xD5,0xF6,
+	0x98,0x45,0xD8,0x67,0x03,0x28,0x9A,0x63,0xFD,0xA9,0x0F,0x81,0x6A,0xFB,0x25,0x9D,0x4F,0x85,0x99,0x80,
+	0x66,0xEB,0x56,0x6A,0x68,0x7A,0x7D,0xF2,0x2E,0x83,0x1C,0x1C,0x41,0xEF,0x82,0xCA,0x00,0x23,0x02,0x44,
+	0xCD,0x04,0x92,0x30,0xC0,0xA5,0x0A,0x0A,0xB5,0xAC,0x0A,0xC1,0x8F,0x45,0x83,0x4D,0x99,0xB5,0xC3,0x38,
+	0x2C,0xFD,0x1E,0x92,0xB6,0x8D,0x2F,0x0A,0xC4,0x82,0x07,0x55,0x3F,0xCF,0x36,0xC9,0x60,0x34,0xA6,0xDC,
+	0x58,0x47,0x26,0x9F,0x87,0x3C,0x80,0x4C,0x11,0x37,0x9B,0x35,0x41,0xC6,0x81,0xB8,0xF9,0x16,0x05,0xB1,
+	0xEF,0x1A,0x36,0xB0,0xC7,0xCF,0x67,0x99,0xCA,0x61,0x74,0x14,0xC0,0x73,0x2C,0xFC,0xC4,0x00,0xC4,0x58,
+	0x31,0x01,0x43,0x98,0xA6,0xC2,0x93,0x1C,0xBE,0xD1,0x18,0x35,0xAC,0x63,0xCC,0x15,0xB0,0x32,0xD7,0xC7,
+	0x25,0xAA,0xCE,0xE1,0x65,0x1E,0xC7,0xC4,0x70,0x02,0x4B,0xD0,0x66,0xF9,0xCF,0x99,0xEB,0xC5,0x02,0x0D,
+	0x0E,0x90,0x04,0x97,0xA6,0x8C,0x24,0x34,0x74,0xB0,0xE0,0xA0,0x66,0xD4,0x9F,0x4C,0x1F,0xFF,0x2A,0x63,
+	0x2C,0xB1,0x11,0xA6,0x31,0x36,0xDD,0xB0,0xD5,0xD5,0x07,0x13,0x82,0x6C,0x6E,0xE1,0x84,0x5F,0xED,0x2C,
+	0x5F,0xF6,0x87,0xA1,0x51,0xD6,0xB4,0xD8,0x88,0x0D,0x0D,0x82,0xA3,0xDB,0xAF,0x97,0xB6,0x46,0xD4,0xB1,
+	0x40,0xD7,0x69,0x4D,0x00,0x45,0x5C,0xEA,0x85,0x38,0x44,0xE2,0x84,0xB4,0x0F,0x89,0xB2,0xDB,0xCF,0x68,
+	0x85,0xE9,0x2A,0xD4,0x04,0xD5,0x1D,0xD6,0x4F,0x28,0x04,0x89,0x87,0x44,0x84,0x38,0x96,0x49,0x1D,0x29,
+	0x4F,0xD2,0xC9,0x6C,0xB6,0x8C,0x47,0xDB,0x15,0x82,0x90,0x0D,0xAA,0x58,0x2B,0xD4,0x06,0x84,0x48,0x35,
+	0x77,0x4B,0x06,0x9D,0x33,0xD8,0x00,0x85,0x26,0xA8,0x08,0x95,0x25,0x6D,0x32,0xAB,0x75,0xFC,0x9F,0xA8,
+	0x42,0xEC,0x8D,0x24,0x7D,0x58,0x16,0xDD,0xF3,0x66,0x72,0x31,0x35,0x79,0xC7,0xC8,0xE3,0xBC,0x39,0x6D,
+	0xDE,0xC4,0x2B,0xAF,0x5F,0xFF,0x33,0x0D,0xEC,0xD4,0x97,0xA5,0x60,0x47,0xCC,0xD1,0x26,0x25,0x14,0x05,
+	0x5A,0xD9,0x8A,0x99,0x29,0xDF,0x16,0xE8,0x69,0xC7,0x85,0xE1,0x06,0xBA,0x1E,0xEE,0x90,0xBC,0x4D,0x95,
+	0xCD,0x11,0x44,0xB1,0xDE,0xD3,0xCC,0xA4,0xC5,0xBD,0x10,0xDC,0xC6,0xF9,0xAF,0xA1,0x43,0x42,0x55,0x52,
+	0x07,0xD2,0x47,0x60,0x7A,0xF2,0x27,0xB8,0x2A,0xAF,0x9F,0x80,0x05,0xA5,0xD2,0x09,0x0E,0x6F,0x4A,0x70,
+	0x15,0xF1,0xBE,0x28,0x23,0x92,0x54,0x7A,0x48,0x02,0x00,0x90,0x33,0xD0,0xC2,0x64,0xFA,0xF0,0x3B,0x70,
+	0x80,0x1C,0xE4,0xF7,0x94,0xAD,0x80,0x0A,0xC4,0xE4,0x2B,0xC6,0x33,0xAE,0x70,0x34,0xBC,0xF7,0xB0,0xEA,
+	0xBD,0x2C,0x70,0x36,0x47,0x43,0xA2,0x84,0x9C,0xCE,0x1B,0x03,0x12,0xAA,0xD3,0x4E,0x7B,0x46,0xB5,0xC3,
+	0x43,0x26,0x87,0x1C,0x3B,0x26,0x77,0xF3,0x34,0xD5,0x76,0x97,0x54,0xE0,0x78,0xB5,0xC3,0x55,0x3D,0x57,
+	0xF5,0xEE,0x3E,0x46,0xE3,0x87,0xF8,0xC6,0xD7,0x47,0xAB,0x47,0xE3,0x42,0xAE,0x63,0xA7,0x6B,0xB3,0x77,
+	0xA2,0xFA,0x64,0xD1,0xE4,0xD8,0x23,0x57,0xE2,0xFA,0xB8,0x22,0x75,0x68,0xEB,0xB2,0x0E,0x0B,0x56,0xBA,
+	0x33,0xF5,0xFB,0x21,0x3D,0x4B,0x65,0x1A,0x71,0x27,0x12,0x51,0xF8,0x67,0x0D,0x71,0x11,0xEB,0xC9,0xF3,
+	0x06,0x4F,0x3E,0x8A,0x51,0xAB,0x8A,0xEA,0xB1,0xBE,0xBA,0x3D,0xB9,0xA9,0xD2,0xA8,0xDA,0x0A,0x6D,0xA8,
+	0x3B,0x82,0x04,0xFA,0x2D,0x14,0xD8,0x57,0xF2,0x4D,0x20,0xBF,0xE5,0xE5,0x21,0x99,0xAE,0xE2,0x8B,0xEB,
+	0x39,0x9C,0xE7,0xFE,0x1C,0xA7,0x53,0xA3,0x29,0x21,0x2C,0x1C,0x79,0x95,0x13,0x04,0x78,0x67,0xB3,0x39,
+	0xA6,0xAB,0xBF,0x6A,0x6A,0xE7,0xDB,0x00,0x32,0x2F,0x82,0x51,0xF4,0xBE,0xCF,0xB5,0x16,0x21,0x6A,0x80,
+	0x18,0x93,0x86,0x0E,0x8C,0x2D,0x19,0x69,0xAA,0x8C,0x91,0x5C,0x1F,0x9D,0xE2,0xE7,0x59,0x00,0xE4,0x45,
+	0xBB,0x2C,0x83,0x55,0xEE,0xA3,0x38,0x6A,0x3B,0xD1,0xE7,0x0B,0x35,0x20,0x28,0x9C,0x79,0xAE,0x44,0xAA,
+	0x0F,0x82,0xA7,0xA2,0x72,0x45,0xB8,0x5D,0x68,0x2A,0x37,0x0E,0xA3,0xE6,0x94,0xF6,0xD3,0x00,0x96,0x07,
+	0xDB,0x74,0x94,0x27,0xC7,0x40,0xAC,0x5B,0x91,0xEF,0xF7,0x98,0xC4,0xEE,0x28,0xF6,0xC2,0x54,0x46,0xA0,
+	0x4E,0xD4,0x8A,0xD6,0x8E,0xDC,0xBF,0x7A,0xB0,0xDF,0xBF,0x35,0x21,0x9D,0x4F,0xA4,0x6E,0x1D,0xEA,0x81,
+	0x19,0x01,0x9D,0xE3,0x2F,0x8C,0xB5,0x6E,0x4C,0x92,0x0B,0xB7,0x0A,0x17,0x4C,0x10,0x06,0xF8,0xFF,0x9A,
+	0xFB,0xE9,0x2E,0xF5,0x4A,0x9B,0xB0,0x13,0xE6,0xD9,0xEC,0xC0,0xF0,0xB8,0x74,0xF4,0xA1,0xD9,0xB2,0xD3,
+	0x17,0xEA,0x64,0xD4,0xE1,0x99,0x23,0x86,0x5D,0x09,0x6A,0xA3,0x55,0x73,0x65,0xB7,0xD0,0xDA,0x07,0xAA,
+	0x09,0x32,0x34,0x87,0x92,0x56,0x64,0xB3,0x54,0x72,0x79,0xB7,0x31,0xFB,0xBC,0x93,0xA1,0xA8,0x62,0xBA,
+	0x44,0xFA,0x5C,0x89,0xA6,0xA7,0xBE,0xBC,0xB2,0x97,0x28,0x4A,0x02,0x3C,0x99,0x91,0x93,0x3C,0x54,0x9D,
+	0xA7,0xE6,0xF0,0x9B,0x98,0x78,0xBA,0x7A,0xED,0x46,0x3A,0x98,0xFB,0xB5,0x5D,0x8D,0x26,0xC5,0x27,0xFF,
+	0xDA,0x26,0x69,0xAE,0xCC,0x54,0xCD,0xFB,0x8E,0xD5,0x9F,0xE3,0x4E,0x0B,0x70,0x1F,0x7C,0x6D,0x25,0x3E,
+	0xCA,0x19,0xB6,0xDF,0x0E,0x1E,0x7E,0x37,0x59,0x1C,0x6C,0x33,0x9B,0xA3,0x68,0xA8,0xE7,0xAA,0xAB,0x06,
+	0x5E,0xE3,0x09,0x22,0x87,0x10,0xAE,0x8A,0xAD,0x30,0x3E,0xAE,0xA1,0x52,0xE5,0x62,0x5F,0x66,0xC7,0xD0,
+	0x21,0x05,0x73,0xAF,0x41,0x7F,0xC7,0x19,0xE6,0x51,0x63,0x8F,0x77,0x88,0x30,0xBF,0x5C,0x0F,0x30,0xAE,
+	0xC3,0x53,0x3F,0xAF,0x35,0x50,0x1A,0x9B,0x0C,0x6F,0xE4,0xF8,0xFD,0xE2,0xC0,0x50,0x0D,0xAD,0x94,0x68,
+	0x8D,0x84,0xEA,0x09,0x22,0x4F,0x97,0x97,0xFA,0x9F,0x92,0xEC,0xEE,0xFE,0x9C,0x61,0xE6,0x6D,0x59,0x54,
+	0x3E,0xEE,0x5E,0x7D,0x8A,0x5D,0x5A,0x20,0x35,0x5D,0x18,0xC1,0x68,0x6E,0x15,0x03,0x56,0x2E,0x55,0x37,
+	0x34,0x8A,0xD4,0xFD,0x93,0x73,0x9D,0x79,0x0C,0x87,0x39,0x05,0xB5,0x17,0x32,0x14,0xED,0xE0,0xF6,0x1A,
+	0xFD,0xE0,0xCF,0x80,0xC4,0x08,0xD0,0xF4,0xD6,0xA5,0x10,0xD0,0xC2,0x89,0x4C,0x34,0xEC,0xE7,0x40,0x8D,
+	0xCA,0x84,0x14,0xE9,0xA6,0x33,0xF1,0xC1,0x43,0x95,0xDB,0xF6,0x91,0x09,0x16,0x01,0x31,0xA3,0x8A,0x40,
+	0x77,0x59,0x57,0x6E,0x24,0xE2,0xF2,0x2C,0x6A,0xE6,0x47,0xC6,0xAF,0xCA,0x69,0x9A,0x9F,0x6A,0xA5,0x75,
+	0x81,0xEB,0x4C,0x44,0xED,0xB4,0x1B,0x0E,0xCF,0xAC,0xCC,0x28,0xB5,0xE7,0x15,0xBF,0xF6,0x14,0x11,0x50,
+	0x80,0x54,0xC2,0x32,0x2E,0xE9,0x82,0x1A,0xDF,0x25,0xDC,0x75,0xA2,0x55,0x8E,0x74,0x05,0xF6,0x5B,0x2D,
+	0x2D,0xAC,0xE1,0x64,0x37,0x8E,0xFF,0xE1,0x1E,0xA4,0x06,0x3B,0xF5,0xA6,0xDF,0xDD,0xDD,0x40,0x92,0x5D,
+	0x2A,0x8E,0x5C,0xEA,0xAD,0xE9,0x1D,0x89,0xE7,0x5A,0x60,0xED,0xA5,0x88,0x0B,0x85,0xED,0xAC,0x54,0xFE,
+	0xAC,0xCC,0xD4,0x66,0x7E,0xA9,0xDE,0x18,0x6B,0x60,0xFB,0x18,0xA4,0x40,0x5D,0xEA,0x2D,0xEB,0xD8,0xD1,
+	0xBA,0xC2,0x49,0xDB,0x5F,0x61,0x74,0x0B,0x7B,0x71,0x0B,0x0D,0x1E,0x13,0x89,0x5D,0xBB,0x24,0xAD,0x4A,
+	0x6E,0x4E,0x29,0x4E,0x7E,0x4E,0x1B,0x74,0x34,0x4D,0x9C,0x77,0x97,0xF0,0x6E,0xA3,0xEA,0xDB,0x8C,0x59,
+	0x07,0xF0,0xBC,0xE8,0x86,0xF4,0x0C,0xE5,0x96,0x32,0x45,0x42,0x6D,0xB7,0xD0,0x34,0xB0,0xC9,0xDF,0x8B,
+	0x59,0x5D,0x97,0xB7,0x68,0x1D,0x32,0x84,0x48,0xB4,0xEA,0xB6,0xF2,0x42,0x12,0x71,0x09,0x4E,0x84,0x64,
+	0x39,0xBE,0x43,0xB5,0x75,0xB7,0x96,0xC9,0x24,0x4F,0xDC,0x3D,0x02,0x99,0x03,0xE2,0x97,0x2B,0x14,0xB4,
+	0x08,0xDB,0x4C,0xC2,0xF4,0x38,0x54,0x2D,0x82,0x0A,0x57,0xA6,0xB7,0xAA,0x04,0x70,0xA2,0x73,0x56,0xD4,
+	0xD6,0x04,0x3C,0x4E,0x51,0xF3,0x51,0xA5,0x3B,0x40,0x4F,0x61,0x23,0xB3,0xC1,0x85,0x09,0xF0,0x6C,0xB5,
+	0x5C,0xD6,0xD6,0xA7,0x37,0xA1,0x27,0xF6,0x44,0x5A,0x02,0x85,0xD9,0x28,0x5E,0xAD,0xD1,0x97,0x36,0xEC,
+	0xCB,0x15,0x0C,0x4F,0x0F,0x98,0x09,0xF5,0xDD,0x94,0x11,0x7C,0x3D,0x44,0xD0,0x98,0xD4,0xB6,0x8A,0x9D,
+	0xC1,0xDD,0x7A,0x9A,0x94,0x4A,0xB7,0xF1,0x0B,0x8A,0xB0,0xBD,0xDC,0xB1,0xD3,0xC3,0xCD,0x27,0x73,0x51,
+	0x50,0xF7,0xD7,0x93,0x50,0xD4,0xFD,0x2D,0x56,0xDF,0xD0,0x8A,0x4C,0x5A,0xA9,0xDD,0x9D,0x43,0x81,0x35,
+	0x8F,0x4A,0x76,0x4C,0xFB,0xEA,0x16,0xBC,0xA7,0xD3,0x66,0x10,0xD2,0xF1,0x15,0x21,0x98,0xA2,0x4E,0xAC,
+	0x5D,0x51,0x46,0x04,0xC3,0xD0,0x85,0xF6,0xDA,0xBC,0x9C,0x26,0xE6,0x13,0xDF,0xFF,0x75,0x11,0xE7,0x69,
+	0x2B,0xFD,0x08,0x07,0xA4,0xB3,0x16,0xDF,0xFB,0x71,0x91,0xD8,0x1E,0xFE,0x80,0x79,0x2A,0x5C,0x9F,0xA9,
+	0x6E,0xF2,0xFB,0x27,0xA1,0xFF,0xE0,0x4E,0x57,0x2D,0x68,0x04,0xA9,0xF3,0xAA,0xCC,0xC4,0xAF,0x30,0x92,
+	0x23,0x92,0xD1,0x1F,0xF6,0x3A,0xE7,0x43,0x33,0x27,0xC1,0x3F,0xB4,0xBE,0x91,0x83,0x45,0x5E,0xF3,0x04,
+	0xCC,0xAF,0x71,0x81,0xB2,0x24,0xD0,0xD3,0x50,0x40,0xED,0x35,0x74,0x0C,0xAA,0xE1,0xB7,0x33,0x89,0xBE,
+	0x3A,0xDE,0x75,0xAA,0xD0,0xC3,0x80,0xFC,0xC1,0x0E,0xE3,0xB2,0x9D,0x66,0x00,0xEC,0x23,0x06,0x28,0x6C,
+	0xAF,0x2B,0xF7,0xB6,0x21,0x27,0x21,0x94,0x5B,0x67,0xE0,0x8A,0x53,0x08,0x60,0x8A,0x43,0x28,0x81,0x3F,
+	0x25,0x16,0x16,0x35,0x94,0xF5,0x86,0xA5,0xF1,0xB2,0xF1,0xC1,0xE1,0x92,0xC8,0xD5,0x82,0x19,0x1A,0x1B,
+	0x90,0x85,0x26,0x36,0x3E,0xF1,0x26,0x9D,0x86,0x2A,0xB6,0x77,0xAB,0x0E,0x78,0xFD,0x64,0xEE,0xF3,0xD2,
+	0xC7,0xF5,0x29,0xB3,0xBF,0x6C,0xBE,0x7A,0xF6,0x48,0x0E,0xBC,0x17,0xF9,0x24,0x95,0xCB,0x4A,0x60,0xD4,
+	0xC1,0xA4,0xA9,0x5F,0x29,0xD5,0x5C,0x9B,0xBA,0xE8,0xF4,0x53,0x1E,0x0B,0x91,0x5F,0xEB,0x5E,0x2D,0x45,
+	0x0D,0xA0,0xB5,0x20,0x62,0x47,0x48,0xBE,0xED,0xCE,0x77,0xAF,0xCD,0x63,0x0A,0x59,0x0C,0xFF,0x9B,0x56,
+	0xFF,0xD3,0xAD,0x16,0x98,0x93,0xA9,0x64,0xFF,0xD3,0x2E,0xAC,0x0F,0x09,0x5D,0x1C,0x5F,0xD0,0x9A,0xC5,
+	0xC7,0x45,0x39,0x82,0xE2,0x12,0xB1,0x4B,0xD4,0x15,0xDB,0x50,0x15,0x88,0x64,0xC9,0xB9,0x4E,0x7F,0xF2,
+	0x25,0xF3,0x8C,0xDD,0xF5,0xC8,0xAD,0x60,0x7C,0x2B,0xDA,0x91,0x49,0x02,0x77,0x0F,0x45,0x10,0x97,0x47,
+	0x24,0x12,0x7C,0xA4,0x22,0x9A,0x4B,0xAC,0x66,0xE0,0x96,0x42,0x54,0x71,0x74,0x20,0xC3,0xBE,0xD2,0x76,
+	0x79,0xB4,0x7C,0xE6,0xF4,0xDA,0x18,0x94,0x7B,0x7A,0x84,0x72,0x24,0xBF,0xDC,0x38,0x15,0xED,0xE2,0x66,
+	0x1D,0x13,0xD7,0xB1,0xD0,0x40,0xA9,0xEF,0x02,0xB3,0x9F,0x84,0x4A,0x28,0xE2,0x53,0xC5,0xF2,0x5D,0x78,
+	0x77,0xDE,0xFA,0x60,0x60,0x54,0x1A,0x2C,0xEE,0x79,0xEC,0x73,0x40,0x1B,0x56,0x0C,0xEC,0xFF,0xDA,0x90,
+	0x27,0x39,0x60,0xAF,0xED,0xCA,0xA4,0x18,0xB3,0x9E,0x1C,0x49,0x12,0x37,0x69,0xB6,0xA4,0xE5,0x3E,0xCD,
+	0x17,0xC9,0x14,0x87,0x20,0x56,0x55,0x03,0xD6,0x1A,0x27,0x39,0x21,0xDA,0xF6,0x4B,0x44,0x2C,0xDC,0x19,
+	0x33,0x9A,0x0E,0x3B,0xF0,0x95,0x11,0xAC,0x89,0xA7,0x88,0xEA,0xCB,0x56,0x2E,0x98,0xE2,0xF7,0xCE,0x4C,
+	0x6D,0x63,0xF3,0xBC,0xC2,0x7D,0x2F,0xEA,0xB6,0xBF,0x8E,0x89,0xC8,0xD8,0x26,0x43,0x8C,0x7A,0xBF,0x67,
+	0xB8,0x57,0xE0,0xCD,0xE8,0x21,0xB7,0xDB,0x8A,0x46,0x1A,0xCB,0x0F,0x6A,0x34,0x7B,0x05,0xA6,0x8B,0x5D,
+	0x91,0xF0,0x7B,0x4A,0x6D,0xD6,0x21,0xA8,0x74,0xF6,0x82,0x4D,0x69,0xEF,0xA7,0xBA,0x81,0x83,0x0E,0x79,
+	0xC3,0x70,0x16,0x50,0xEF,0x76,0xAB,0x5C,0x55,0x9E,0x0A,0x34,0x6E,0x70,0x3E,0x8E,0xE6,0x3F,0x49,0xC8,
+	0x9C,0xB0,0xB8,0x26,0x25,0xA3,0x07,0x70,0x36,0x36,0x97,0x54,0xED,0x45,0x17,0x05,0x22,0xD3,0x07,0xD1,
+	0xAD,0xCC,0xB0,0xD5,0x1E,0x24,0x20,0xBE,0xED,0xAC,0x73,0x6F,0xB3,0x77,0x84,0x02,0x00,0x30,0xF9,0x10,
+	0xB1,0x16,0x22,0x3D,0xAF,0x84,0xB2,0xE0,0x46,0x6D,0x24,0x39,0x00,0xC0,0xA8,0xF0,0x26,0x05,0xA8,0x4C,
+	0x6B,0x67,0xE1,0x3D,0xBC,0x10,0xC1,0x2C,0x85,0xD7,0x59,0x8F,0x31,0x24,0x0F,0xC1,0xA6,0xDE,0x4B,0x87,
+	0xC6,0x90,0x52,0x34,0x24,0x3C,0x11,0x1F,0xB7,0x4E,0x01,0xC8,0x36,0x82,0x2B,0xC1,0x3C,0xE8,0x39,0xC1,
+	0xEF,0x75,0xE2,0x34,0x25,0x30,0x67,0x84,0x54,0x89,0xCA,0xF4,0x56,0xBB,0x0A,0x53,0x06,0x87,0xB0,0x52,
+	0x90,0xF7,0x42,0xE1,0x65,0x7A,0xE2,0x74,0xE4,0x38,0xF3,0xB5,0x63,0xE8,0x1B,0xAF,0x46,0x6B,0x22,0x61,
+	0xEE,0xAA,0x5D,0x18,0x48,0xBB,0x53,0xA5,0xA5,0xA5,0xF9,0xDB,0x93,0x8A,0x43,0xE1,0xC7,0x58,0xE3,0x75,
+	0x45,0xED,0xCE,0xE2,0x5E,0xC5,0xE2,0xAE,0x5A,0xE8,0x6B,0xB3,0xE9,0x17,0xAA,0x2A,0xBD,0x27,0xBA,0x35,
+	0x27,0xDC,0xF3,0x0D,0x7E,0x89,0x90,0x19,0xEC,0x4F,0xD8,0x36,0x5C,0x09,0x44,0x83,0x29,0x1C,0x4B,0x9E,
+	0x1B,0x68,0x32,0x4D,0xE8,0xCC,0xEA,0x24,0x39,0x84,0x7B,0x30,0xF1,0x9E,0x53,0x17,0xFE,0x3A,0xBB,0x1F,
+	0xBE,0xCB,0x81,0xC9,0xEE,0x9D,0xE7,0xCE,0x0F,0x92,0x4C,0x3D,0x3D,0xA7,0xDE,0x15,0x94,0x51,0x77,0x86,
+	0x82,0x71,0x30,0x4A,0xA8,0xCC,0xB2,0x12,0x19,0x5E,0x60,0x78,0xDD,0xC7,0xA3,0x64,0x38,0xBD,0x2B,0x5F,
+	0xBD,0xF8,0x6C,0xA7,0xDF,0xE3,0x69,0x69,0x7D,0x13,0x0B,0x67,0x27,0xA1,0x7B,0xDA,0x8B,0xA3,0x7D,0x1F,
+	0x9B,0xAB,0x3B,0x3C,0xFC,0xC9,0xA2,0x65,0x3A,0xE4,0x5C,0xA6,0xDF,0xF5,0xA0,0x84,0x72,0x2D,0x66,0xE9,
+	0x40,0xAB,0x53,0x59,0x95,0x26,0x03,0x70,0x89,0x2C,0xBE,0x87,0xCE,0x6C,0x64,0x96,0x84,0x7E,0xC7,0xBE,
+	0xD0,0x4E,0x1D,0x01,0x35,0x39,0xFB,0x65,0xFC,0x37,0x31,0x4F,0x06,0xE9,0x4E,0x4F,0xA1,0xBF,0x55,0xB7,
+	0x27,0x5F,0x41,0x0C,0xB4,0xA1,0xAA,0x4C,0xD6,0xC5,0x51,0x28,0x00,0x7A,0xCD,0x82,0x2A,0x95,0x43,0x9D,
+	0x91,0xA4,0x56,0x22,0x26,0xCF,0x75,0x0E,0xE8,0x7F,0xD6,0x2D,0xA8,0x33,0x36,0x72,0xB7,0xBF,0x38,0xE3,
+	0x47,0x57,0xA5,0xED,0x90,0xB4,0xA3,0xBF,0x95,0x02,0xDA,0x21,0x85,0x22,0x56,0x17,0xC0,0xD5,0x71,0x01,
+	0xD2,0x7B,0xFA,0x93,0xE3,0x6A,0x01,0xA8,0x7D,0xB4,0xFD,0x90,0x5A,0xCC,0xC7,0x08,0x94,0xB8,0x88,0xE8,
+	0xF2,0x67,0xFF,0x80,0xD9,0x31,0x8C,0x54,0xE1,0xBA,0x96,0x44,0x8D,0x71,0xCD,0xBE,0xC4,0x68,0x2E,0x16,
+	0xD4,0x48,0x86,0xDA,0x25,0x72,0x15,0xC4,0xA8,0x05,0x47,0xDD,0x69,0x97,0xA3,0xEF,0xA4,0x71,0x49,0x0B,
+	0xDF,0xF1,0x97,0x25,0xFD,0x3A,0x57,0xBC,0x44,0x98,0x3D,0x69,0x3D,0x89,0xA8,0xBA,0x92,0x9B,0x80,0xE0,
+	0xCE,0xBD,0x00,0xF7,0xC9,0x98,0xBC,0xCC,0x8D,0x65,0x55,0x9C,0x91,0xB2,0x61,0x6A,0x69,0xE4,0x94,0x32,
+	0xFF,0x50,0x65,0xB8,0xC0,0xAD,0xC1,0x69,0x13,0x12,0x86,0xE3,0x81,0xAD,0x65,0xB9,0x9D,0x0A,0x86,0x8F,
+	0xE2,0xA5,0x11,0xD6,0xEF,0x1E,0xCF,0x11,0x73,0x9C,0x37,0xDF,0x28,0xCD,0x57,0x37,0x63,0x43,0x5F,0xEB,
+	0x0E,0xC4,0x83,0xFB,0xD4,0x3D,0xA8,0x24,0xE1,0x1B,0xF6,0x66,0x31,0x60,0xA8,0x50,0x44,0x4B,0xEE,0x51,
+	0x70,0x90,0xA0,0x8D,0xEA,0x2A,0x32,0xFC,0x83,0xEE,0x9B,0x76,0x01,0x9A,0xA6,0x4C,0xDE,0xC7,0x1B,0xE7,
+	0x05,0xD0,0xB9,0xF3,0xA3,0x44,0x91,0x00,0x69,0x0E,0x16,0x36,0xA9,0x8B,0xA1,0x89,0x04,0xB1,0xD0,0xC1,
+	0x70,0x6C,0x3D,0xCC,0x84,0xD8,0x86,0x75,0x8D,0xC7,0x78,0xBF,0xC3,0x66,0xE0,0x2C,0xB3,0xFB,0x70,0x99,
+	0xE3,0x27,0x68,0x95,0xF1,0x04,0x53,0xB6,0x21,0x08,0xB7,0x2A,0x20,0x55,0xD3,0xD0,0x5B,0x6F,0xFA,0xF6,
+	0x9A,0x4A,0x85,0x91,0x8E,0x1D,0xA1,0x47,0xFF,0x2B,0xB1,0x68,0xC4,0xF5,0xE3,0x94,0x71,0xC6,0xCC,0xB9,
+	0xD8,0x4A,0x31,0x2E,0x83,0x68,0x39,0x73,0xBF,0x4A,0xA1,0xF7,0x53,0xBC,0x62,0x42,0x35,0x07,0x83,0xFC,
+	0x19,0x67,0x32,0xD1,0x59,0x33,0x89,0x59,0xD8,0x38,0xF2,0xF0,0x04,0x46,0xA0,0xCC,0x45,0x20,0xC1,0x3B,
+	0x36,0xD1,0x1F,0x7C,0x55,0xC2,0xEB,0x18,0xBB,0xF3,0xE3,0x0F,0x36,0x27,0x11,0xAD,0xEB,0x0F,0xAD,0x58,
+	0x57,0xEC,0x75,0xF9,0xBA,0xB2,0x0E,0x7F,0x9F,0x98,0xC6,0xC9,0x28,0xF4,0x05,0x30,0x11,0xD2,0x50,0x48,
+	0xAD,0x1E,0x9B,0xCD,0xF3,0xBD,0x28,0x97,0xC8,0x48,0xEA,0x93,0x9B,0xE6,0x2A,0x5A,0x12,0x00,0xDD,0xBA,
+	0x1D,0x97,0xD9,0x1A,0x45,0x0B,0x62,0x3B,0x99,0xCD,0xFB,0xF9,0x7D,0x41,0x3B,0xA5,0x9C,0x83,0xC0,0x0B,
+	0xB7,0x45,0x54,0x85,0x86,0x21,0xB0,0xDB,0x0B,0x17,0xE3,0xD9,0xC2,0x2C,0xD8,0xD9,0x9F,0xAF,0x93,0x78,
+	0xB8,0xCF,0x3C,0x60,0x24,0x75,0xDC,0xA2,0xB2,0x34,0x95,0xD3,0x14,0x3E,0x9B,0xD7,0x17,0xD4,0x25,0x48,
+	0x42,0x71,0xF2,0xEC,0x90,0x52,0x42,0x8C,0x25,0xFC,0xE4,0x5C,0x9A,0x4A,0x3D,0x61,0xB4,0x14,0x1D,0xE7,
+	0xF3,0xC0,0x77,0xB5,0xE1,0x32,0x4B,0x47,0x10,0xD6,0x75,0xB6,0xC2,0xEC,0x6D,0x88,0x1D,0x3E,0x8E,0xA1,
+	0x1E,0xDF,0x93,0x5D,0xD0,0x03,0x19,0xA2,0x2C,0x76,0x9A,0x5A,0xD3,0x35,0x6A,0xD8,0xEF,0xF2,0x8C,0xC8,
+	0x74,0xD7,0xE2,0x13,0x80,0x18,0x79,0x21,0xC8,0x31,0x4B,0x63,0x52,0x5D,0x1C,0x2C,0x2B,0x73,0x81,0x11,
+	0xFC,0x10,0xC6,0xD0,0x59,0x6C,0x4C,0xA1,0xEC,0xFB,0x5C,0x61,0x99,0x49,0x15,0xD4,0xC0,0xE7,0x4F,0x26,
+	0xA4,0x42,0x5A,0x82,0x93,0x39,0xF3,0x8A,0x52,0x1B,0x7E,0xFA,0x1B,0xA0,0xCC,0x11,0xD3,0x81,0x5C,0x4A,
+	0x5B,0x10,0x7A,0xDF,0x43,0xFE,0x36,0x1A,0xE4,0x97,0x8D,0xBB,0x98,0xB3,0x26,0xEA,0x2A,0xA9,0x9C,0xFC,
+	0x3D,0x7F,0xFF,0x0B,0x28,0x3D,0xBF,0xAB,0x51,0x7C,0xEF,0x2B,0x68,0xA2,0xAC,0xDE,0xCB,0xFC,0x77,0x65,
+	0x38,0xE0,0x08,0x6E,0xD6,0x20,0x1D,0x51,0x9C,0x14,0xBB,0xBD,0x58,0x72,0x3E,0x4A,0xAA,0x5B,0x18,0xF7,
+	0x57,0xC9,0x30,0x81,0x69,0x9C,0xB0,0x84,0x49,0x9E,0x08,0x3E,0x8E,0x06,0xAE,0x7C,0x37,0xB6,0x56,0xFD,
+	0x6D,0xEE,0x24,0x0F,0x1E,0x31,0x7F,0xF9,0xE2,0x05,0x59,0x49,0xD1,0x6B,0x69,0xD0,0x20,0x67,0x2F,0x9F,
+	0xC9,0xDA,0x4B,0x3F,0xC0,0x10,0xCB,0x3F,0xBD,0x94,0xD4,0xDF,0xBF,0x19,0xD8,0x79,0x90,0x7E,0xD8,0x80,
+	0xC1,0xDC,0x2A,0xEF,0x5B,0xCF,0xF0,0xD3,0x2B,0x82,0x23,0x55,0x25,0x8E,0xAD,0x90,0x85,0xDB,0x73,0x58,
+	0x6A,0x87,0xAF,0xB0,0xC5,0xCA,0x9E,0x4E,0x21,0x4C,0x7B,0xFC,0x27,0xCE,0x9F,0xE5,0x8E,0xCD,0xAD,0x98,
+	0xC2,0x69,0xD7,0x5E,0xD5,0x82,0x11,0xED,0x07,0x87,0xF2,0x15,0xEE,0x0D,0x01,0x74,0xCB,0xA1,0x2A,0x06,
+	0xB8,0x61,0x39,0xFB,0x00,0x37,0x20,0x3F,0x19,0xE6,0x48,0x9D,0xCB,0xA6,0x08,0xE4,0xD6,0x3F,0x50,0xAC,
+	0x85,0x81,0xD2,0xF3,0x24,0x23,0x58,0x9E,0xE6,0x6A,0xC0,0x47,0xF6,0xFE,0xB1,0xC1,0x06,0xFE,0xFA,0xD3,
+	0x32,0x56,0xB5,0xE5,0x86,0xC0,0xC9,0xB7,0x8A,0x47,0xE0,0xBB,0x86,0xC5,0x63,0xA8,0xA4,0x65,0x60,0x54,
+	0x66,0x68,0xBC,0x91,0x55,0xE3,0x6F,0x68,0xF7,0x35,0x7F,0x22,0x1A,0xA3,0xD2,0x0A,0xCE,0xCC,0xCC,0x12,
+	0x94,0x01,0x91,0xF8,0xA1,0x74,0x6D,0xE6,0x9D,0x12,0x44,0x06,0x6E,0x69,0x40,0xBA,0x44,0xE5,0xDC,0x89,
+	0x1D,0x10,0x13,0xF3,0x49,0x51,0xBC,0x49,0x8F,0x3A,0xCB,0x3D,0xEF,0x71,0x53,0x99,0x1C,0x11,0x5D,0xF2,
+	0xCB,0xE9,0x65,0x07,0xC5,0xCF,0x81,0xC0,0xDB,0xA0,0x35,0xEE,0x08,0xD5,0x5A,0xB0,0xDF,0xCF,0x6F,0xEE,
+	0x77,0x53,0xD2,0x0C,0xDC,0x40,0x33,0x4B,0xA8,0x96,0xE0,0xFE,0xA0,0x18,0xAA,0x18,0xA4,0x5C,0x98,0x72,
+	0x5C,0x8D,0x9F,0x39,0x65,0xD7,0x37,0x9F,0x1F,0x56,0x3B,0x5E,0x4C,0xCA,0x02,0x8D,0x7F,0x82,0x37,0xBD,
+	0x0D,0x8B,0x35,0x60,0xF2,0xED,0xCF,0x19,0x24,0x7E,0xA1,0x80,0x7C,0xAD,0xEF,0x6F,0x74,0x2B,0xC6,0x72,
+	0xB4,0x1D,0x8C,0x5C,0x05,0xF0,0x4D,0xD4,0x47,0xF0,0xF7,0xD8,0x5A,0x08,0x76,0x7E,0x37,0xFE,0x2E,0xB3,
+	0x9E,0x5C,0x86,0x5F,0x6A,0x9E,0xDA,0x07,0xCF,0x79,0xBE,0xB6,0xCD,0x1D,0x2D,0xBA,0x0D,0x03,0x4D,0xD4,
+	0x9B,0xED,0xF0,0x96,0x44,0x2C,0xBD,0x8F,0xA5,0x1C,0xE9,0x74,0xE3,0x40,0x84,0x86,0x54,0xC1,0xB3,0xF0,
+	0xD9,0x41,0xEB,0x2E,0x6E,0xF9,0x74,0x60,0xE6,0xDF,0x1C,0xD9,0x52,0xEF,0xAC,0x6B,0x35,0xD9,0xBC,0xDF,
+	0x02,0xB6,0x36,0xF7,0x47,0xD8,0xE6,0x90,0x0B,0xBA,0x1D,0x47,0x89,0xF4,0xFF,0xC3,0x97,0x0F,0x4D,0xB1,
+	0xE8,0xB4,0xA9,0x81,0x09,0xED,0xDA,0x51,0xA6,0xE0,0xED,0xA2,0x35,0xB3,0x7F,0xD5,0xFF,0x91,0x9D,0xA0,
+	0x7C,0xFA,0xE6,0x7B,0x43,0x43,0xBD,0xFC,0xD7,0x01,0x08,0xEA,0x2C,0xC3,0x4A,0xDD,0x1B,0xE7,0xAA,0xE8,
+	0xD6,0xDB,0x8E,0xE2,0x9C,0x46,0x1E,0x7F,0xCC,0xC2,0x87,0x8F,0xDC,0xCB,0x8C,0x76,0xE9,0xE1,0xFE,0x1D,
+	0x5B,0xBC,0xAC,0xD4,0x4B,0xDC,0x8D,0x46,0xA7,0x95,0x71,0x6E,0x9E,0x2B,0x6B,0x1A,0xFE,0x49,0xDB,0x4D,
+	0x6F,0xDF,0x43,0x3D,0x7D,0x23,0x5C,0x28,0xAB,0xC9,0xBD,0xAC,0xFF,0xDE,0x76,0x17,0x0F,0x07,0x09,0x88,
+	0xF1,0x0A,0x37,0xC3,0x8A,0x14,0x2A,0x38,0x9E,0x37,0x27,0xE3,0xCA,0x54,0xE1,0x18,0x9E,0x02,0x07,0x6B,
+	0xA2,0x91,0x23,0x1F,0xB2,0xA5,0x77,0x6F,0xC1,0x97,0xFF,0xFF,0x1F,0xE5,0xEF,0xBB,0x88,0x99,0x38,0x37,
+	0xA9,0xF0,0xFF,0x9B,0xF1,0xD9,0x3F,0x8F,0xE3,0x04,0x04,0x84,0x27,0xB8,0xB8,0xE4,0x14,0x6C,0x49,0x41,
+	0xE5,0xDB,0xC0,0xB8,0x1E,0xED,0x70,0x54,0xEA,0x69,0xE8,0x43,0xDA,0x2C,0xCB,0xCE,0xBC,0xE0,0xF8,0x62,
+	0xFD,0x6E,0xC1,0xB8,0x58,0xA6,0x44,0xA5,0xCE,0x10,0x11,0x1C,0x3F,0xDF,0xF1,0x73,0x46,0x6D,0xD2,0x12,
+	0xFE,0x0F,0x91,0x90,0x70,0x38,0x21,0xCE,0x34,0x20,0xC3,0xCA,0xE2,0x11,0x38,0xA6,0x87,0xF6,0xB8,0x83,
+	0xD0,0x2C,0xEF,0x51,0xE3,0xE5,0xEE,0x84,0xF1,0x7F,0xF0,0x20,0x07,0x0C,0xB0,0xD6,0x82,0x2E,0xF8,0x02,
+	0x21,0x59,0xE0,0x64,0xF0,0x25,0x7D,0xD9,0xB1,0xBF,0xC9,0x40,0xF1,0x2E,0x69,0x51,0xBD,0xE9,0x89,0x03,
+	0xF3,0x06,0xC9,0x32,0xD1,0x01,0xF3,0xB7,0x11,0xCB,0x27,0x76,0x32,0x48,0x81,0xB0,0x2D,0x98,0xDB,0xA7,
+	0x37,0x0A,0xDA,0xEA,0x9D,0xDA,0xE9,0xD8,0x4A,0xB9,0x6A,0x24,0xFF,0x73,0xCA,0x6C,0x1F,0x0A,0xF4,0xFD,
+	0x9B,0xE5,0xC9,0xCB,0xC5,0x45,0xA6,0x89,0xDB,0x75,0x5C,0x83,0xFB,0x7E,0xE3,0x5B,0x34,0x25,0x6D,0x2F,
+	0xAB,0x3D,0xD4,0xCB,0xC8,0x25,0x1E,0x89,0x8F,0x41,0x6A,0xFF,0xAA,0x92,0xBF,0x7B,0x4D,0x50,0xD2,0x5F,
+	0x2E,0x0E,0x6B,0x90,0xAB,0x86,0x2E,0x2E,0xE5,0x2A,0xE6,0x13,0xE9,0x4A,0xD0,0x1E,0xAD,0x68,0x09,0xDA,
+	0x9A,0xF4,0x7E,0x3E,0x46,0x22,0x22,0x7A,0xB5,0xC0,0x01,0x6D,0xDB,0xFC,0xE3,0xA9,0x8E,0x23,0xEA,0x30,
+	0x3B,0x21,0xFD,0xAE,0x6B,0xCE,0x07,0xD2,0x2D,0xEE,0x11,0x03,0x28,0x6A,0x91,0xA2,0x19,0xE3,0x25,0x98,
+	0x49,0x83,0x00,0x69,0x3A,0xD0,0xDF,0x3F,0x5F,0x8F,0x3B,0x66,0x03,0x8A,0x82,0x40,0x8C,0xF0,0x75,0xC6,
+	0x8F,0x1C,0x36,0x6B,0x27,0xC8,0xCD,0xF2,0x53,0x71,0x8E,0x59,0x56,0x26,0xA0,0x10,0x8C,0x1F,0xB0,0x68,
+	0x14,0x09,0x3D,0xB5,0xB0,0xED,0x87,0xA3,0x4C,0x10,0xF7,0xA5,0xF3,0x32,0xC8,0x31,0x91,0xF8,0x39,0x77,
+	0x1D,0xEF,0xC0,0x31,0x3C,0x2E,0xFF,0xB7,0xF0,0x33,0x7C,0x42,0xB3,0xFF,0x7C,0xF9,0x95,0x30,0x2A,0xC8,
+	0xCE,0x59,0xD6,0x1A,0xF2,0xF4,0x34,0xF7,0xC2,0x1A,0x34,0x56,0xFE,0xBB,0xAA,0x82,0xC0,0x53,0x67,0x33,
+	0xB1,0xF5,0xEA,0x23,0x0E,0xEB,0xC7,0xB7,0x81,0x8E,0x2B,0xC8,0x60,0x5E,0xD2,0x5E,0xB2,0x68,0xF9,0xC1,
+	0x00,0x72,0xF5,0xB5,0x8F,0x34,0x55,0x43,0x42,0x88,0xD5,0xFD,0x74,0xA5,0x5F,0x6C,0x8D,0xE7,0xFE,0x08,
+	0x41,0x65,0xB9,0xF6,0xDD,0x84,0xAA,0x08,0xFA,0xB4,0xE9,0x68,0xA9,0xB6,0x08,0x74,0x12,0x74,0x54,0xA5,
+	0x92,0xC2,0xA2,0x18,0x7F,0x73,0xAB,0x61,0xCD,0x57,0x47,0x34,0xDC,0x30,0x77,0xAB,0xEF,0x57,0x23,0xCF,
+	0xDB,0x3A,0x77,0x11,0x0C,0x92,0x70,0xFF,0xC5,0x34,0x1F,0xAA,0xDA,0x58,0x9F,0xC2,0x98,0x5B,0x7C,0x2A,
+	0x86,0x9C,0x05,0xE4,0x09,0x84,0xE2,0x8A,0xE7,0xFA,0x8F,0x0C,0x19,0x5C,0xA2,0x3A,0xA9,0xF1,0xC6,0xFC,
+	0xDA,0x3B,0x4F,0x06,0x96,0x46,0x4E,0x6C,0x84,0xF6,0x3F,0xBB,0x28,0xF2,0x7F,0x8A,0x78,0x9E,0x42,0x16,
+	0x1F,0xF8,0x2F,0xC9,0x0F,0x77,0xA3,0xBB,0x54,0x73,0x65,0xFA,0x18,0x71,0xDF,0xA7,0x66,0x3D,0xDB,0xB7,
+	0x06,0x63,0x98,0xEA,0x6D,0xCD,0x58,0x84,0xD9,0x0E,0xD4,0x54,0xBB,0x1B,0x88,0xD9,0xF8,0xED,0x71,0x76,
+	0xA0,0x1E,0xF0,0x70,0xEA,0xA8,0xDF,0xCD,0x0D,0x85,0x78,0x16,0x55,0xCC,0xDA,0x0B,0x21,0x7D,0x99,0xE7,
+	0xA0,0xB9,0x31,0x64,0x68,0xCF,0xCA,0x00,0x75,0x5D,0x28,0x75,0x7E,0xC1,0xBB,0xD1,0xCB,0x0C,0x57,0x35,
+	0xC1,0x61,0x6F,0x97,0x83,0x33,0x5A,0xA0,0x35,0x6D,0x11,0xA4,0xBA,0xAB,0xD9,0x92,0x97,0xCB,0xAA,0xAD,
+	0x2E,0xA6,0xA8,0xEA,0xA4,0x83,0x5C,0xB4,0x95,0x49,0x58,0x96,0xA6,0x6A,0xE0,0xFA,0xDA,0x18,0xA1,0xFB,
+	0x25,0x96,0x81,0x11,0x64,0xA9,0x4B,0x8B,0xBF,0x89,0x29,0xE1,0x77,0x79,0x40,0x9B,0x26,0x78,0x05,0x35,
+	0xB4,0xE7,0x25,0xB5,0x95,0xC1,0x9A,0x98,0x26,0x89,0xEA,0xB2,0x0A,0x31,0xFE,0xF2,0x1C,0x33,0x96,0xBB,
+	0xC8,0xC5,0x1A,0xB2,0xBD,0xEE,0xF2,0x43,0x0B,0x22,0xAD,0xA1,0x9F,0xB5,0x9E,0xD8,0xE1,0x34,0xA5,0xD8,
+	0xDF,0xF5,0x52,0xF6,0x88,0xC8,0x27,0xF6,0xBC,0xE8,0xD0,0xE9,0x48,0xC4,0x19,0xA1,0x7F,0xF1,0x2F,0x9F,
+	0xE4,0xA3,0xE2,0x61,0x3E,0xCE,0x43,0x2A,0xA1,0x66,0x26,0xDD,0x5F,0x27,0xD6,0x28,0x8C,0x90,0xE0,0xAC,
+	0xFF,0xAA,0x7A,0xDD,0xED,0x8E,0x15,0x2E,0x52,0x71,0xD5,0xB8,0x8D,0x91,0x29,0x53,0x2C,0x86,0x3B,0xDA,
+	0x15,0x9E,0x42,0x84,0xE2,0x83,0x3D,0x14,0x2D,0xEB,0x49,0xC1,0x3D,0xAD,0xF3,0x3B,0xC8,0x7D,0x14,0x80,
+	0xED,0x85,0xA2,0x39,0x70,0xEA,0x53,0xA0,0xAC,0x17,0x1B,0x3B,0x4E,0xC2,0x98,0xBF,0x97,0x52,0x04,0x11,
+	0x87,0x98,0x9A,0x66,0x17,0x10,0x12,0x4B,0x4E,0x92,0xAC,0xA2,0xFD,0xA5,0x52,0xA7,0xA8,0x3C,0xA6,0x36,
+	0x2B,0xF1,0xE3,0x32,0xD9,0xEA,0xA3,0xD0,0x97,0xB1,0xBD,0xF1,0x4F,0x53,0xFC,0x67,0x11,0xBB,0x2C,0xE5,
+	0x93,0xA5,0xE5,0x3A,0xAA,0xE9,0xBB,0x00,0xC2,0x3E,0x45,0x0B,0x54,0xA8,0x8C,0x5B,0x9E,0xD1,0xFB,0x35,
+	0x64,0x69,0x06,0xD3,0x25,0x77,0x21,0x80,0x7A,0xAF,0xDF,0x67,0xF5,0xEB,0xF5,0xE4,0x72,0x98,0x7A,0xB0,
+	0x4F,0x98,0xB5,0xCF,0x90,0xB3,0xC7,0x10,0xCB,0x28,0xA4,0x10,0x44,0x4E,0xA5,0x7A,0xA4,0x6B,0x66,0x37,
+	0xB2,0xF9,0x8A,0x61,0xE7,0x51,0x21,0x2D,0x05,0xED,0x7F,0x2A,0x4C,0xD3,0x47,0xE3,0x14,0x3A,0x05,0x77,
+	0x9D,0xC5,0x45,0x17,0xF5,0xEC,0xB4,0x18,0x2C,0x92,0xBC,0x68,0xBE,0xA4,0x6D,0x05,0x6A,0xE1,0x8E,0x0E,
+	0xD5,0x28,0x2E,0xA0,0x49,0x2C,0xCE,0xC8,0xAB,0xB6,0x67,0x5A,0xC8,0xD2,0x95,0x5C,0xFF,0xE5,0xEF,0xB4,
+	0xC3,0x41,0x69,0xED,0x9F,0xAA,0x3B,0x2F,0xFF,0xCE,0xD7,0xF9,0x69,0x71,0xB9,0x1F,0xF5,0x6C,0xCF,0xC9,
+	0x11,0xB4,0x3E,0x39,0x20,0x75,0x20,0x5D,0x51,0x76,0x5C,0x7A,0xBF,0x33,0x86,0x9D,0x80,0xB3,0x4C,0x11,
+	0x91,0x9E,0xAE,0x88,0x4D,0x47,0x51,0x38,0x3F,0xD0,0x62,0x7D,0x39,0x96,0x1E,0xAC,0xF9,0xD0,0x67,0x1C,
+	0x5B,0x70,0xC3,0xB1,0x0D,0xFB,0x18,0x33,0xB8,0xFC,0xEA,0x34,0x6B,0x4C,0x0F,0x9D,0x7C,0xE2,0x14,0xD3,
+	0x0A,0x20,0x5E,0x5D,0x2E,0x55,0x7D,0x79,0x22,0xB1,0xA6,0x06,0x58,0xBE,0x3A,0xF3,0x74,0x06,0xE0,0x52,
+	0x3A,0x2D,0xD0,0xD1,0x2F,0xCB,0x50,0xA0,0xF4,0x22,0xCC,0x95,0x0F,0x8B,0x64,0x87,0x33,0xFC,0x60,0x17,
+	0xE2,0x9A,0xC1,0x30,0x84,0x0D,0x21,0x58,0x21,0x7D,0x7A,0x22,0x31,0xDD,0xEE,0xA3,0x55,0xB6,0xD3,0x59,
+	0x27,0x9F,0xCE,0xB1,0x20,0x53,0xEF,0x28,0x90,0x63,0xB7,0xCC,0x06,0x38,0x5D,0x6B,0xDF,0x7D,0x14,0x22,
+	0xFD,0x61,0x45,0x03,0x14,0x46,0x4E,0xC0,0x61,0x24,0x40,0x8C,0x9C,0xA9,0xE7,0xB2,0xAF,0xF8,0x5B,0x45,
+	0x93,0x97,0x5A,0x83,0x33,0x41,0x18,0x85,0x9B,0xB1,0x79,0xC3,0x47,0x7E,0xA6,0x85,0xDA,0x8D,0xEA,0x10,
+	0xBE,0x4D,0x89,0x61,0x5B,0xDF,0x31,0xD3,0x46,0xB1,0xF7,0x6D,0xB0,0x57,0xDD,0x80,0xB3,0xB8,0x0A,0x6A,
+	0xAD,0x25,0x21,0x35,0xD0,0x0B,0xA2,0x1C,0xEC,0xD9,0x32,0xD3,0x4E,0xE3,0xEF,0xA8,0x56,0x6B,0x2A,0x10,
+	0xDD,0xF8,0xDE,0x62,0x1F,0x6B,0x46,0x5E,0xB6,0x4F,0xFA,0x6A,0x93,0x64,0xA0,0xA8,0x54,0x49,0x34,0xAD,
+	0x1A,0xE6,0xCD,0x68,0xF1,0x51,0x9B,0x29,0xD1,0xAB,0xAC,0xB9,0x59,0x28,0x68,0x8E,0xBF,0xF6,0xB1,0x91,
+	0x68,0xBA,0x81,0x3C,0xFA,0x2B,0x7A,0xB7,0xA6,0x01,0x6E,0xC8,0x14,0x9A,0x32,0x3E,0xB8,0x0E,0x9C,0x1B,
+	0xB1,0xFF,0x32,0x7F,0xF6,0x02,0x48,0x5E,0x4F,0x43,0xE1,0xEB,0x61,0x47,0xE4,0x89,0xE4,0x36,0x23,0x1F,
+	0x7C,0xF2,0x8B,0x5C,0xF1,0xFF,0x93,0x5A,0x00,0x0D,0x67,0x0F,0x31,0xDD,0x2B,0x0F,0xB1,0x52,0x0B,0xD8,
+	0xA9,0x27,0x5D,0x88,0xB3,0x6F,0xDB,0x43,0xAD,0x9A,0x17,0x02,0xE5,0x73,0x2E,0xFA,0x93,0x55,0x2A,0x8C,
+	0xA2,0x30,0xF4,0xF2,0xAA,0x7D,0xA6,0x31,0x27,0x93,0x34,0x6E,0x21,0x7C,0x1C,0xCA,0xA3,0x31,0xFC,0xE2,
+	0xB4,0x7C,0xC5,0x11,0x97,0x14,0x3A,0x67,0x83,0x40,0x5D,0xA9,0x19,0xD4,0x6E,0x82,0x51,0x8D,0xD4,0x13,
+	0x64,0xA5,0xF2,0xAA,0x93,0xE6,0x15,0xA5,0x00,0x11,0x64,0x92,0x50,0x0C,0xEE,0x7A,0x83,0x8B,0xD6,0x12,
+	0x34,0x56,0x41,0x27,0x64,0x36,0x77,0x45,0xAE,0x37,0x9C,0xEE,0x09,0x57,0x73,0x50,0x71,0xC9,0x98,0x6A,
+	0x62,0xF5,0x45,0x0D,0x63,0x37,0xF1,0xA3,0x59,0xE3,0x49,0xB6,0xC6,0x39,0x04,0xA1,0xF6,0x14,0x8A,0xF4,
+	0xF4,0xBC,0x91,0xAE,0x72,0xCA,0xB3,0xD2,0xB5,0xB5,0x03,0xCD,0xEB,0x53,0x5E,0xC1,0x27,0x14,0xC6,0x0C,
+	0x4A,0x1E,0x11,0x08,0x17,0xC5,0xD6,0x99,0xE8,0x7A,0x71,0x53,0xCD,0xAE,0x5C,0x1A,0xEC,0x7C,0x4E,0x19,
+	0xD2,0x7B,0xE1,0xD8,0x7D,0x5F,0x1F,0xC2,0xBB,0x79,0xAD,0xDF,0xAE,0x58,0x24,0xA1,0x64,0x4B,0x77,0xFE,
+	0x2B,0x57,0x6C,0x6A,0x05,0xFC,0x55,0x98,0x0A,0x96,0x1B,0x75,0x3B,0xF7,0xB5,0x11,0x48,0x37,0x97,0x68,
+	0x7B,0xB7,0x6D,0x8F,0xC3,0x4D,0x1F,0xB3,0x3C,0xBE,0x1F,0x9B,0x1A,0x57,0x71,0x5C,0x93,0x3F,0xE2,0xA2,
+	0xE9,0x5D,0x0E,0x6C,0xB9,0xF1,0x56,0xE9,0x00,0x8C,0x75,0xDA,0x96,0x1F,0x25,0xCD,0xA9,0x0E,0xAA,0x3E,
+	0x36,0x7C,0xD6,0x6D,0xE4,0xC8,0x64,0x4C,0xC9,0x3E,0x07,0xDD,0x2B,0x2F,0x3E,0x59,0xBD,0xAE,0xDF,0xFB,
+	0xFE,0x1D,0x74,0x78,0x68,0x60,0x07,0xA6,0x86,0x4C,0xC6,0xA7,0x17,0xE0,0x48,0xA0,0x81,0xCC,0xBC,0x12,
+	0xD6,0x2C,0x30,0x6B,0x36,0xF3,0x1F,0xB2,0x97,0x6D,0xA9,0x2D,0x79,0xC7,0x3C,0x76,0x6A,0xE7,0x95,0x61,
+	0xE5,0xA2,0x81,0x17,0x60,0x81,0xF1,0x06,0xF9,0x16,0x50,0x45,0x6F,0x64,0x17,0x2E,0x22,0x93,0xCE,0x93,
+	0xD7,0x73,0x93,0x75,0x64,0x5C,0x13,0x92,0x74,0x3C,0x18,0x65,0xBB,0x8B,0xE1,0xC2,0x18,0x12,0x50,0xE3,
+	0xBB,0x6D,0x27,0x9D,0x25,0xE4,0x0E,0x30,0xE5,0xE5,0x6E,0xD2,0x19,0x46,0x66,0xD3,0x64,0x45,0x2D,0x48,
+	0x21,0x10,0x41,0x5E,0x04,0x4A,0xA9,0x42,0xFD,0x77,0xA1,0x83,0xCA,0x1B,0x31,0x7B,0xB2,0x12,0x68,0x21,
+	0x24,0xE2,0xE1,0x5F,0x15,0x6B,0x07,0x4A,0x47,0xA7,0x2E,0x2C,0x6A,0x5B,0x1C,0xAA,0xAB,0x98,0x4E,0x9D,
+	0x3A,0x75,0x86,0x48,0x4A,0xA9,0x06,0x4C,0xA3,0xAA,0x14,0xBE,0xAA,0x8F,0x8A,0x0E,0xE9,0x8A,0x11,0x44,
+	0x9C,0xA7,0x05,0xAC,0x49,0x34,0x1D,0xAA,0x2B,0x9A,0xC5,0xAE,0x9D,0xEA,0x6A,0x70,0x31,0x76,0x77,0x25,
+	0x2B,0x84,0x81,0xB5,0x8B,0xC9,0x1C,0xBB,0x1F,0x67,0x05,0x16,0x0F,0xCB,0xD9,0x3F,0xDC,0x40,0x1A,0x6D,
+	0x6D,0x73,0x05,0xBE,0x16,0xA3,0x2C,0x53,0xB1,0xA2,0xA9,0x6E,0x58,0x3C,0xAA,0x7F,0x32,0x59,0x40,0xC1,
+	0xBC,0xAB,0x7B,0x09,0x37,0xC6,0x7C,0xFA,0x18,0xB4,0x1B,0xC9,0x4B,0xD9,0xC3,0x5E,0x7F,0xA8,0xB3,0xEE,
+	0xFC,0xC6,0x61,0x74,0xE8,0x55,0xFA,0x44,0xB3,0x89,0x41,0xD1,0x3E,0x50,0x79,0x88,0xBB,0xE6,0xFC,0xFB,
+	0x8B,0x2E,0x44,0xD4,0xB2,0x9F,0x70,0x02,0x32,0x43,0xD3,0xE2,0x60,0x9E,0xD2,0x56,0x7C,0xFF,0x05,0x6F,
+	0xAF,0xEA,0x8D,0x68,0xC8,0xAA,0xFC,0x36,0x8D,0x77,0x86,0x13,0xD9,0xFE,0xE5,0x07,0xCC,0x49,0x5A,0xC0,
+	0xB2,0xD0,0xF6,0x21,0x21,0xB1,0x88,0x97,0xFC,0x2D,0xD2,0x6A,0x5A,0xD1,0x2D,0xC9,0x38,0xD1,0x6D,0xCD,
+	0x2F,0x22,0x09,0xE9,0x56,0xF5,0x04,0x94,0xB0,0x99,0x84,0x90,0xA0,0xB9,0xB0,0x57,0x65,0x84,0x8A,0x52,
+	0xA2,0x57,0x6E,0xA0,0xD0,0x6A,0x33,0xD7,0x13,0xB8,0x7A,0x03,0x13,0xB5,0x2A,0xB1,0xB5,0xE5,0xC9,0x51,
+	0x26,0x9E,0xE7,0x25,0xC1,0xB6,0xB5,0x66,0x3C,0xDE,0xCF,0x14,0x98,0x5B,0xFD,0x51,0x62,0xC0,0x96,0xF0,
+	0x16,0x08,0x5D,0x5E,0xE1,0xB5,0xB5,0x70,0x94,0x08,0x78,0x7F,0x4F,0x67,0x0D,0x0B,0xAF,0x87,0x7E,0xAE,
+	0xEC,0x58,0x1C,0x0B,0xDD,0x07,0x9A,0x78,0x5A,0xA5,0x49,0xED,0x09,0x6F,0x5E,0xEC,0x43,0x04,0xDF,0xE1,
+	0xDE,0x9C,0x47,0xC0,0x70,0x95,0x58,0x48,0x55,0xCB,0x84,0x96,0x10,0xD9,0x03,0xCD,0x7E,0x36,0xF0,0x18,
+	0x12,0x24,0xA7,0x9B,0xB4,0x7A,0x47,0x9C,0x10,0xD4,0x00,0x5D,0x7F,0x37,0xA6,0x4E,0xC6,0x3A,0x51,0x6E,
+	0xCA,0x4D,0xA0,0x2A,0x76,0x71,0x88,0xAE,0x95,0xD4,0x26,0xCB,0x44,0x0C,0x91,0xE1,0x19,0x68,0xED,0xEA,
+	0xEF,0x6C,0xFE,0xBE,0x7B,0xD8,0x37,0xB5,0x64,0x6F,0x27,0x2A,0x43,0xFF,0x60,0x0B,0xA6,0x75,0xC9,0x5A,
+	0x1C,0xEE,0x6B,0xD9,0xA5,0x62,0xBB,0x5B,0x90,0x42,0xBF,0x7E,0x81,0xD5,0xE4,0x7D,0x9F,0x9F,0x16,0x62,
+	0x2F,0x24,0xC2,0xFB,0xF9,0x53,0x0B,0x31,0x2E,0xED,0x1E,0xE4,0x1C,0xCD,0xC7,0x13,0x8D,0x25,0x48,0xC0,
+	0x27,0x4D,0x22,0x80,0xBE,0x9E,0xCD,0xD2,0xD8,0x29,0xC5,0x02,0xEE,0x26,0x2D,0x9A,0x93,0x60,0xCF,0x11,
+	0x3F,0xBD,0xC0,0xC3,0xC0,0xCF,0x3D,0x12,0x74,0x26,0xB7,0xA8,0x5B,0xC8,0xD9,0xE5,0xBD,0xEE,0x75,0x46,
+	0xEB,0xC5,0x5A,0x42,0xB1,0xA9,0xD7,0xC0,0x41,0xC9,0x09,0x30,0xE5,0xEB,0xCE,0x23,0xBB,0x0F,0x40,0x8D,
+	0xF6,0x40,0x48,0x37,0xF6,0x88,0x3E,0x84,0x42,0x05,0xDA,0x34,0x17,0xC8,0x12,0x31,0x02,0x10,0x01,0x9D,
+	0x2D,0x2E,0xC0,0x12,0xF6,0x2A,0xB7,0x81,0x5D,0xE0,0xF7,0xD4,0x70,0xFA,0x5C,0x35,0xD9,0x8A,0x65,0x9B,
+	0xA0,0x01,0x87,0x04,0xB0,0x6E,0x41,0x2B,0x7E,0x4A,0xFC,0x49,0xF1,0xFB,0xC3,0x48,0x18,0x26,0x40,0x5F,
+	0x32,0x2A,0x48,0xE3,0xE0,0x7A,0xBE,0x5A,0x51,0xCA,0x2E,0x40,0x4F,0x83,0xB6,0x55,0xB0,0x41,0xC9,0x24,
+	0x61,0xC1,0xE1,0x0D,0x73,0x62,0x71,0x28,0xCB,0x0A,0x59,0x38,0xDB,0x2A,0xA7,0x82,0x8A,0xA9,0xB5,0xE8,
+	0x62,0xB0,0xCA,0x1A,0xB8,0xEB,0xE1,0xDD,0xD5,0xC6,0x86,0xB3,0xE3,0xFD,0x51,0x7D,0xBB,0xD3,0x44,0x44,
+	0xA1,0x08,0x9C,0xEE,0x97,0xC2,0x74,0xF8,0x05,0xBC,0x90,0x40,0x1D,0xB7,0xFE,0x1A,0x68,0x0D,0xA3,0x8C,
+	0xA4,0x22,0xF3,0x3E,0x84,0xD1,0xFD,0x74,0xB4,0xF1,0x69,0xD9,0x7E,0xE1,0xEB,0x96,0xBA,0xB4,0x35,0xF0,
+	0x7E,0x9C,0xB7,0xD9,0xC8,0x50,0x67,0x8B,0x22,0x1E,0x77,0x02,0x19,0x90,0xCE,0x1C,0x26,0xDA,0x92,0x39,
+	0xDB,0xC3,0x6A,0x04,0x89,0x73,0xB8,0xC1,0x76,0xBA,0xD2,0xA0,0xD6,0xEE,0xF2,0x28,0xD8,0x62,0xD6,0x9D,
+	0x88,0x02,0xC4,0xB0,0xF8,0x48,0x48,0x41,0xE6,0xBF,0xDF,0x7A,0xDA,0xE1,0xF6,0x52,0xCA,0x10,0xD5,0xC7,
+	0x91,0x52,0x33,0x3D,0x2C,0xE5,0xD5,0x91,0x38,0x0A,0x05,0x2D,0x08,0x98,0xA3,0xF4,0x99,0x7E,0x11,0x26,
+	0xA0,0xF8,0xC0,0x26,0xFA,0x45,0x6C,0x1F,0x8B,0xE5,0x2C,0x0C,0x55,0x36,0x8C,0x04,0x21,0x57,0xEA,0xF8,
+	0x50,0x91,0xE8,0x92,0x98,0x4E,0xCA,0xCC,0x98,0x31,0xAD,0xA3,0xE2,0x19,0x1D,0xD6,0x8E,0x5D,0x95,0x39,
+	0x1B,0xC9,0x95,0xA4,0x91,0xAC,0xDF,0xAD,0x5F,0xE4,0x5C,0x24,0x31,0xDB,0x3C,0x87,0x5C,0x3B,0xE7,0x45,
+	0x62,0xD8,0x0E,0x8C,0x80,0x81,0xB8,0x21,0x1B,0x78,0x54,0x53,0x81,0x2B,0x69,0xDF,0x79,0x3A,0xDD,0x6B,
+	0x28,0x3C,0x16,0x2D,0x4F,0x96,0xDE,0x6C,0x4C,0xFA,0x2A,0xDE,0x92,0x7A,0xC7,0x5D,0x8D,0xB9,0xAB,0xE4,
+	0xBE,0xF0,0xBB,0x32,0xEB,0xD8,0xD9,0xD3,0x13,0x8B,0x14,0x88,0xC7,0xB6,0x87,0x61,0xB9,0x96,0xCC,0x4A,
+	0xE8,0x37,0xA1,0xF8,0x91,0x76,0xF5,0x74,0x2C,0x97,0x2E,0x2E,0x09,0x26,0x69,0x67,0x09,0x58,0x72,0x68,
+	0x78,0x45,0x70,0x71,0xE1,0xDE,0x36,0xAE,0x08,0xDB,0x3F,0x38,0x6F,0x70,0xA0,0xC4,0xF9,0x91,0x41,0xCB,
+	0xAC,0x70,0xFC,0x2B,0xAA,0x83,0x2E,0x93,0x8B,0x5A,0x8D,0xFD,0x92,0xEF,0x71,0x68,0xAD,0xD5,0x35,0xE2,
+	0xCF,0xEA,0xE5,0x8A,0x84,0xDD,0xB1,0x9F,0xBB,0x70,0x1E,0xF6,0x64,0x5F,0xA0,0x37,0xB5,0x5F,0xE6,0x51,
+	0x6E,0x85,0xB8,0xD4,0x75,0x72,0x4F,0x52,0x01,0xA4,0x96,0xBB,0x34,0xA3,0x06,0x96,0x4B,0x6E,0xC6,0x30,
+	0x36,0x96,0x5E,0x70,0xBA,0xEE,0x9A,0x83,0xD3,0x10,0x8F,0xA6,0x2F,0x61,0xEB,0xA7,0xBC,0xCA,0x32,0x60,
+	0xFB,0x72,0x69,0xC3,0x8E,0xA9,0xEB,0x40,0xE3,0x16,0xEF,0x77,0x3E,0x87,0x1E,0xEA,0x89,0x29,0xE8,0x42,
+	0xBF,0x69,0x56,0x97,0xE5,0x41,0x4B,0x16,0xD6,0x62,0xBC,0xD6,0x40,0x65,0x44,0x25,0x63,0x03,0xEB,0x00,
+	0xAC,0xB4,0xB5,0x10,0xA8,0x6E,0x34,0xD0,0xE4,0x2B,0xDF,0x6B,0xB7,0x24,0x57,0x81,0xBE,0x69,0xD1,0xA7,
+	0xC2,0xFD,0x61,0xFE,0x81,0x2D,0x37,0xA8,0x7E,0x16,0x47,0x5E,0x4A,0x61,0x32,0x4E,0x64,0x1A,0x5C,0x4B,
+	0xF9,0x8C,0x27,0x8A,0x5B,0xFB,0x66,0xC2,0x40,0x14,0x8A,0xD1,0xD3,0x45,0xF4,0x2A,0xF2,0x76,0x26,0x64,
+	0x9D,0xF8,0xFE,0xF0,0xFE,0x36,0xC3,0x4F,0x6F,0xFF,0xB3,0x1A,0xE2,0x27,0x9D,0xB2,0xE4,0x05,0x83,0x5C,
+	0xC2,0x16,0xE6,0xB0,0xBF,0xEE,0x11,0xAB,0x72,0xC9,0xAD,0xAA,0xFE,0x74,0x97,0x48,0xEB,0x3D,0xF3,0x3B,
+	0x54,0xD2,0xDC,0xCE,0x45,0x13,0x80,0x4E,0x18,0x36,0xAC,0x2A,0x4A,0xE1,0x0A,0xEC,0x93,0x42,0xE4,0x9A,
+	0x43,0x20,0xE2,0x5A,0xB6,0x60,0x42,0x1A,0x4B,0xE0,0xB2,0x94,0xB6,0x5C,0x6B,0x6A,0x88,0x44,0x5D,0xCB,
+	0xCD,0xD1,0x09,0xEF,0x95,0x9D,0xCB,0x5E,0x7F,0x6F,0x3A,0xBD,0x9F,0x22,0x2B,0x86,0xA9,0x24,0xC1,0x08,
+	0xBB,0x6E,0x03,0x77,0x36,0x3E,0xFA,0xB2,0x2C,0x6F,0x73,0xB7,0x5B,0x1F,0x0A,0x1F,0xBA,0x7F,0x4B,0xD5,
+	0x71,0xB2,0x12,0x3F,0x04,0x33,0xD2,0xD2,0x9D,0xFD,0x42,0xF6,0xCD,0x9D,0x84,0x49,0xFA,0x5C,0x1F,0x07,
+	0xE3,0x20,0x29,0xF9,0xDE,0x61,0xB9,0xD0,0x92,0x04,0xFB,0xD9,0x03,0x97,0xC1,0x01,0xAD,0x99,0x6D,0x43,
+	0xB7,0xBE,0x3B,0x06,0x86,0x93,0xEA,0x24,0xD7,0x5E,0xE2,0x82,0x62,0xD6,0xF3,0x42,0x55,0x14,0x6A,0xCF,
+	0x47,0x44,0xCC,0xA1,0xB4,0x94,0xF7,0xC3,0x49,0xBC,0xA5,0xB0,0xC0,0xA5,0x00,0x76,0x34,0xAA,0xFA,0xCA,
+	0x9E,0x24,0xAF,0x43,0xA0,0x57,0x25,0xE2,0x3E,0xAD,0x2F,0x67,0xE0,0x4C,0xBD,0x63,0xBE,0x87,0xD3,0xF7,
+	0xC4,0xB7,0x55,0x28,0xE2,0xBE,0x75,0xF7,0x4E,0x1A,0xE5,0xF3,0x7E,0x62,0xA6,0xA9,0x5D,0x35,0xBC,0x8F,
+	0x1F,0xF8,0x20,0x17,0x87,0x2B,0x21,0xDE,0xFC,0xE7,0x22,0xE9,0x5B,0x1F,0x10,0x1A,0x76,0x26,0xED,0x3E,
+	0x2A,0xE3,0xDF,0xFE,0x08,0x97,0xF0,0x18,0xC3,0x35,0x8B,0xE6,0xBA,0x10,0x0D,0x1A,0x9A,0x75,0x89,0x17,
+	0x9D,0xFE,0x2F,0x68,0xAC,0xBE,0xA7,0x83,0xBB,0x71,0x77,0x23,0x04,0x10,0x81,0x06,0x23,0x26,0x1E,0xF5,
+	0x50,0x49,0xB8,0xBD,0x11,0x15,0x48,0x1E,0x2C,0x75,0xF0,0xD7,0xF7,0x69,0xFE,0xA8,0xC4,0x0C,0xD0,0x2F,
+	0xF5,0x36,0x7E,0x89,0x1B,0x7C,0x6E,0x81,0x1F,0x1D,0xB4,0x4F,0xC3,0x79,0x3F,0x2F,0xAA,0xD2,0xE6,0x8B,
+	0xAC,0x05,0xF1,0xC3,0x77,0x5A,0x0F,0x8C,0x64,0x90,0x03,0x4D,0xFF,0xB5,0xA1,0x04,0x1A,0x7C,0xA6,0x70,
+	0x58,0xBE,0xA5,0x40,0x94,0x28,0xB8,0xFB,0x9F,0xA6,0xA1,0x71,0xF8,0x88,0xF8,0x46,0xF3,0x05,0x32,0xEB,
+	0xF2,0xBC,0x22,0xA5,0xB0,0xFE,0x1F,0xB6,0xC3,0x8D,0x13,0x36,0xEF,0xCA,0x24,0x45,0x58,0x6A,0x85,0xC5,
+	0xC8,0x24,0x71,0x21,0xD4,0x00,0xF9,0x47,0x73,0xC2,0x1F,0x73,0x7E,0x9E,0x36,0x69,0xB0,0xA3,0x68,0xD3,
+	0x43,0x8F,0x12,0x34,0x38,0xBB,0x3E,0x80,0xEB,0x2E,0x6A,0xE1,0x14,0x66,0x67,0x3C,0x44,0x66,0x14,0xAE,
+	0xE9,0x26,0x9C,0xAA,0xEA,0xFD,0xB3,0x5C,0xB6,0x9A,0x60,0x41,0x12,0xBA,0x07,0x75,0x77,0x63,0x53,0x40,
+	0x79,0x8B,0xA1,0x05,0xA0,0x6B,0x35,0x03,0x35,0x23,0x15,0xC5,0xD3,0x06,0xE5,0xCA,0x72,0x8E,0xA9,0x03,
+	0xB5,0x2A,0x67,0x3C,0xB5,0x98,0x73,0xFB,0x72,0xB8,0xC2,0x89,0x92,0x85,0xB8,0xF2,0xE7,0x69,0x24,0x4A,
+	0xB7,0x26,0x3E,0xBF,0x55,0x62,0x7D,0x18,0x01,0x99,0x46,0x32,0x72,0x91,0x7A,0x6E,0x83,0x44,0x65,0x4E,
+	0xA2,0x2B,0x7B,0x2E,0x2B,0xBA,0xDD,0xC9,0x5D,0x81,0x71,0x28,0xCB,0x3A,0x9E,0x5E,0x8D,0xE8,0x34,0xF9,
+	0x85,0x96,0x0C,0x99,0xDB,0x8A,0xE0,0x46,0xBC,0x42,0xDF,0xBE,0x78,0xB4,0x62,0xA2,0x69,0x08,0xA5,0xA3,
+	0x98,0xE0,0xFE,0x1B,0x5F,0xEA,0x12,0xED,0x73,0x2E,0x4E,0x2B,0x08,0x61,0xAA,0x0A,0x02,0x20,0x7A,0x92,
+	0xA2,0x75,0x05,0x7D,0x7F,0x6B,0x22,0x89,0x8E,0xF5,0x97,0x2F,0x48,0x71,0x5A,0x1A,0x87,0xC7,0x91,0x55,
+	0xDB,0x0E,0x2D,0x00,0x8A,0xAF,0x30,0x7A,0x3A,0x34,0x41,0x7B,0x59,0x45,0x71,0x5F,0x7A,0xE8,0x5A,0xCD,
+	0x20,0xBF,0xEC,0xE6,0x93,0x9B,0x0E,0xB4,0x41,0x10,0x83,0x5B,0xF3,0x7D,0x0E,0xCE,0x85,0xFC,0x20,0x07,
+	0x68,0x3B,0xAE,0xD2,0x9E,0x3F,0xA4,0xCA,0xF0,0x7C,0x0E,0xBF,0xBD,0x09,0x0E,0x84,0x59,0xEA,0x35,0xED,
+	0x62,0x9E,0xC6,0x5B,0x0D,0x7E,0xC9,0xCF,0xAF,0x0D,0x5E,0xE6,0xE4,0xB1,0x7F,0xB0,0xE2,0x41,0xA7,0x4E,
+	0x0D,0xAB,0xC9,0xDF,0x73,0xB9,0x80,0x6A,0x0D,0x54,0x30,0x93,0x7B,0x5B,0x14,0x60,0xF2,0x18,0xC7,0x40,
+	0xD8,0x57,0x66,0x9D,0x35,0x17,0x5A,0xAC,0x6A,0xB4,0x94,0xF1,0x0C,0x55,0xCA,0x51,0x5D,0xBB,0x05,0x44,
+	0x8E,0x30,0xE1,0x92,0xF7,0x59,0x6A,0x7E,0x07,0xE0,0x09,0x52,0x02,0x48,0xBA,0x92,0xB5,0x35,0x5B,0xAC,
+	0xCB,0xEA,0x4D,0x77,0x36,0x52,0x7F,0x58,0x74,0xE7,0xF9,0x08,0x32,0xCC,0x76,0xFE,0xB6,0x55,0x56,0x2D,
+	0xF2,0x76,0x1C,0xAA,0xC2,0x5D,0x71,0xE2,0xB8,0x34,0x99,0x3C,0x67,0x72,0xA6,0x5E,0x31,0xA1,0x39,0xD5,
+	0xC0,0x17,0xBF,0x73,0x14,0x37,0xEC,0xD6,0x9D,0x53,0xAF,0x4F,0x54,0x74,0x35,0x29,0x6C,0xB4,0x30,0xDF,
+	0x18,0x79,0xE0,0xC9,0xED,0x52,0xBF,0x1F,0x01,0xC3,0xF2,0xAA,0x95,0xC9,0x47,0x0C,0x36,0xC7,0x68,0xAD,
+	0x28,0xA3,0xEE,0x9C,0x7E,0x77,0x4E,0x21,0x27,0x5F,0xE4,0xBE,0xB4,0xBB,0x9E,0x79,0xE1,0x50,0x1E,0x7D,
+	0x79,0x3F,0xCA,0xF6,0xFB,0x85,0xC3,0xE9,0x38,0xF2,0x69,0xB0,0xA8,0xE1,0x5B,0x6F,0x3F,0x16,0x48,0x66,
+	0x16,0xEE,0xCB,0x9D,0xB7,0xC4,0xA4,0xDE,0x4A,0xA0,0x1F,0x28,0x76,0xC2,0x3A,0x12,0x27,0x6D,0x60,0x1F,
+	0x2F,0x5F,0xB0,0x20,0x3D,0xC6,0x04,0x44,0xAB,0x3D,0x48,0x44,0xE5,0x0C,0x60,0x11,0x13,0xC3,0xD4,0xA0,
+	0x4D,0xCB,0x80,0xB2,0x17,0x40,0x1B,0xF8,0xF7,0x20,0x87,0xC2,0x10,0x06,0x9B,0x11,0x65,0x3D,0x99,0x45,
+	0x29,0xEE,0x51,0x34,0x56,0x1C,0xBC,0xB2,0x5F,0xAE,0x7C,0xB1,0x00,0xB5,0x79,0xA7,0x87,0x1C,0x5E,0x1B,
+	0x44,0x2B,0x60,0x18,0x9B,0xC6,0xF2,0x71,0x0B,0xFC,0x70,0x7A,0xFA,0xE9,0xE3,0x95,0xCD,0x8F,0x7D,0xA9,
+	0xA2,0x76,0xC7,0xE1,0x52,0x68,0xB0,0x62,0xAA,0x89,0x29,0x5C,0xD3,0x2B,0x4A,0xC2,0x05,0x99,0x57,0x2B,
+	0xD3,0xA8,0x0E,0xA0,0x14,0x86,0x61,0x57,0x8E,0x1B,0x12,0xD5,0x52,0xC4,0x74,0x03,0x47,0xD8,0x9B,0x76,
+	0xD4,0x87,0x79,0x0A,0x77,0x2A,0x59,0x71,0x9D,0xA5,0x0A,0xD4,0xB1,0x11,0x94,0xEB,0xD8,0x4C,0x20,0x34,
+	0x44,0xBC,0xD5,0x9A,0x17,0xAF,0xD0,0x58,0xB2,0x40,0xAF,0xC5,0x73,0x4F,0x19,0xF8,0xD9,0xFF,0x18,0x4D,
+	0x3D,0x27,0x2B,0xAB,0x4E,0x26,0x7B,0x28,0xDA,0x88,0xA1,0x9F,0xCF,0x19,0xC3,0x7D,0x3E,0xCE,0xBB,0x5B,
+	0x81,0x36,0x83,0xC5,0x5E,0xE6,0xA2,0xDA,0x66,0x28,0xDA,0xA0,0xB2,0xA1,0xC9,0x1A,0xCE,0xDA,0x2D,0x6F,
+	0x7A,0x67,0xAD,0xDE,0x01,0x3F,0xA8,0x45,0x1E,0xCD,0xDD,0x36,0xB7,0x15,0x24,0x0E,0x13,0xE4,0xEC,0x4D,
+	0x88,0x0C,0x1E,0x08,0x67,0xEC,0x7B,0x7B,0x1A,0xF6,0x9D,0x53,0xD8,0x8C,0xBF,0xC8,0x2E,0x20,0x34,0x5E,
+	0xBB,0xED,0xCC,0x26,0xC9,0xED,0xBB,0xFB,0xD5,0x55,0x80,0xFD,0x87,0x3D,0xE6,0xB7,0x32,0x00,0xB2,0xDD,
+	0x05,0x10,0x03,0xE3,0x72,0x5B,0x12,0xCE,0x4D,0x9C,0xD3,0x33,0xFF,0xBC,0x5C,0xE4,0x89,0xDC,0xC2,0x77,
+	0x1E,0x09,0x2E,0x53,0xF8,0x6D,0xF8,0x03,0xBA,0x00,0x2D,0xA7,0x64,0xC3,0xA8,0xD8,0x94,0xB2,0x3F,0xA0,
+	0x4E,0xD7,0xD6,0x55,0x14,0x02,0xC2,0x74,0x27,0xF3,0xB9,0xC4,0xA8,0x9F,0x1A,0x8A,0x93,0x47,0xE0,0xE2,
+	0xB4,0x78,0xE4,0x60,0xA3,0xA7,0x13,0x9C,0xA0,0xFE,0x2E,0x29,0xDB,0x6D,0xB4,0xF7,0xB5,0x79,0x7D,0x76,
+	0x76,0xD5,0x3C,0x77,0x75,0xAA,0x1B,0x96,0x4F,0x4E,0x55,0xA5,0xD7,0xF6,0x4D,0x1C,0x05,0xDF,0x35,0x65,
+	0x33,0xBE,0xAD,0x52,0x2D,0x9A,0xBD,0x53,0xBD,0xB5,0xC2,0x83,0xEF,0xDE,0x49,0x95,0x7A,0x01,0x1C,0x3A,
+	0xE9,0x37,0x59,0x4C,0x9D,0x2B,0x7E,0xA7,0xEE,0x14,0xD0,0xEB,0x7D,0xB8,0xA5,0xE9,0x78,0x1E,0x15,0xDC,
+	0x9C,0x0C,0xA5,0xDA,0x69,0xDD,0x31,0x2D,0x76,0x06,0x83,0xF4,0x0F,0x3A,0x5C,0xF0,0x3D,0xB7,0xE1,0xC9,
+	0x1B,0x27,0xBB,0x6D,0x71,0x57,0xAE,0x30,0x11,0x13,0x24,0x1B,0xB7,0x4F,0xFB,0x39,0x28,0xCE,0x81,0xE2,
+	0x95,0xD1,0x9D,0xED,0x8F,0x3D,0x26,0x4B,0x95,0x03,0xF3,0x68,0xAB,0x4F,0x4F,0x70,0x7D,0x9C,0xE3,0x66,
+	0xC4,0xA5,0x2E,0x66,0x0C,0xFD,0x7E,0x45,0x67,0xBD,0x54,0xBA,0x79,0xDF,0x6C,0x38,0xBB,0x33,0x27,0x2A,
+	0x43,0xFC,0x4F,0x14,0xE8,0xC6,0x28,0xEE,0xDA,0xF8,0x51,0x86,0xED,0x60,0x44,0x98,0xB1,0x63,0xA0,0xFA,
+	0xCB,0xD9,0xBF,0x01,0x53,0xF2,0xFF,0xC7,0xDA,0xDD,0x51,0x74,0x70,0x88,0xE9,0x28,0xE5,0x3F,0x43,0x54,
+	0xD0,0x76,0x4C,0x26,0xF2,0x64,0xF6,0xB8,0xFA,0x52,0xF9,0x70,0x07,0x03,0x3F,0x89,0x99,0x12,0x62,0x41,
+	0xBD,0x40,0x50,0xE5,0x2D,0xAF,0xFD,0x5E,0x5E,0x9F,0xD9,0x30,0x04,0xB1,0x31,0xEA,0x0C,0xFE,0xE9,0x43,
+	0x58,0x2E,0xDD,0x2D,0x43,0x8F,0xCA,0x24,0xEF,0xCE,0x7E,0xF8,0x8F,0x82,0x10,0xC5,0x7D,0x2F,0x67,0xD9,
+	0xBE,0xD7,0xD6,0xC1,0x7C,0x07,0x1B,0xC2,0x03,0x0F,0x98,0xF4,0x1F,0x66,0x0B,0x54,0xBF,0xD6,0x16,0x00,
+	0x36,0xA5,0x53,0x01,0x9A,0xAB,0x11,0xD0,0xFD,0xE6,0x91,0xD5,0x19,0xB2,0x4B,0x10,0xB5,0xCF,0xCD,0xAC,
+	0x7C,0x46,0xDD,0xC0,0xFC,0x05,0xC9,0xB6,0x2A,0xB4,0x0D,0xD0,0xFD,0x8C,0x65,0x76,0xDA,0x00,0xFD,0xBE,
+	0x10,0x18,0x41,0x4A,0x4E,0x6A,0x47,0xCC,0x5C,0xC8,0x6A,0x4E,0xA1,0x04,0x15,0x7C,0x1D,0x2D,0xB6,0xBC,
+	0x0B,0xFD,0xA4,0x90,0x9B,0x69,0x4C,0xF4,0x80,0x4B,0x43,0x9D,0x0A,0xA3,0x9C,0xD3,0x64,0x47,0x42,0x6A,
+	0x1A,0xEB,0x11,0x1C,0xAA,0x41,0x8E,0x66,0xBA,0xDB,0x13,0x3C,0xB6,0x6B,0xD3,0x39,0x71,0xFB,0x7C,0xF0,
+	0x88,0x0F,0x04,0xB8,0x12,0x2F,0x30,0x72,0xA3,0x9F,0x48,0x19,0x31,0xA6,0xD6,0x4D,0xE2,0xBE,0x14,0xBD,
+	0x11,0xCF,0x52,0xFD,0x4D,0xCF,0x0E,0xD9,0x10,0xA7,0x10,0xCE,0x75,0x89,0x93,0x48,0x90,0x4C,0x49,0x6B,
+	0x08,0x4A,0x4D,0x19,0x96,0x0D,0xAF,0x29,0xEC,0x06,0x15,0x48,0xB9,0x0C,0xFB,0x87,0xB6,0x44,0x41,0x0C,
+	0x9C,0x84,0x3B,0x0F,0xD1,0x46,0x57,0x75,0x71,0xCF,0x50,0x24,0x66,0xBA,0x9C,0x90,0x99,0xE3,0x9C,0x12,
+	0xE4,0x59,0x39,0x20,0x85,0xD2,0xDC,0x08,0x52,0x11,0xA2,0x18,0x50,0xE3,0x0D,0x84,0xDF,0x32,0xFB,0xD4,
+	0x28,0xFA,0xD5,0x44,0x1D,0x10,0x8B,0x08,0xD3,0x32,0xCD,0x10,0xA3,0xCC,0xB8,0x3D,0x49,0x00,0xB6,0xF6,
+	0xEF,0x8F,0xFD,0xE3,0x85,0x7E,0xD7,0xA2,0xE8,0xC7,0x90,0x41,0x5D,0xDF,0x80,0x45,0x48,0x76,0x90,0x65,
+	0x7A,0x74,0x2C,0x70,0x51,0x73,0x88,0xD5,0x1D,0x16,0xD8,0x21,0x6E,0x36,0x08,0xD5,0x79,0x16,0x0D,0x94,
+	0x4B,0x85,0x81,0x44,0xDC,0xDD,0x11,0xE0,0xE2,0x34,0x81,0xE5,0xB9,0x1E,0xB2,0x3E,0x4A,0xA4,0x09,0x20,
+	0xDC,0x54,0xCD,0x70,0xEB,0xB5,0x8B,0xE4,0xF3,0x54,0xB2,0xEA,0xD7,0x74,0x46,0xA4,0x38,0xA4,0xD2,0x62,
+	0xD3,0x1A,0xED,0x8B,0xD9,0xC7,0x06,0x09,0xAB,0xD5,0xA1,0x18,0x33,0xF5,0xC1,0xB9,0x4D,0xA2,0xFD,0xFC,
+	0x21,0x3B,0xBA,0x16,0x1D,0xCC,0x3C,0xD7,0x61,0xC7,0xD3,0x09,0xE9,0x3A,0x7B,0xD2,0x22,0xA7,0x83,0x1D,
+	0xA3,0x19,0xB4,0x7F,0x15,0x86,0x1F,0x9D,0x75,0x98,0xDB,0xEB,0x58,0xD4,0xA2,0x36,0xD7,0xC5,0x12,0x79,
+	0x55,0x5F,0xD0,0x69,0x64,0x3F,0x52,0x1D,0x77,0x1F,0xB7,0x5C,0x25,0x54,0x1A,0x79,0x11,0x1F,0x4A,0x79,
+	0x61,0x5D,0xD8,0x59,0x55,0x1E,0x5F,0xC1,0xAC,0x3C,0x43,0x6C,0x94,0x5D,0x57,0xF8,0xE5,0x3D,0x93,0x18,
+	0xF4,0x1D,0x47,0x49,0x16,0x96,0x11,0x28,0xF0,0x9F,0x1B,0x7C,0xC5,0xB4,0xDF,0xFD,0xFB,0x7F,0x40,0x54,
+	0x01,0xC2,0x60,0x96,0x86,0x27,0xA0,0xA0,0x81,0x53,0x96,0x9E,0x2E,0x6D,0x10,0xED,0x87,0x4D,0x02,0x64,
+	0xB6,0xC4,0xC3,0x15,0xE4,0x3E,0xC6,0x9A,0xBE,0x92,0x65,0x83,0x73,0xE7,0x3E,0x0E,0x92,0x80,0x09,0xA7,
+	0xCE,0x3A,0xCF,0x9B,0x3F,0x11,0xA5,0x97,0x8F,0x81,0xD1,0x15,0xB3,0x76,0x59,0x65,0xC0,0xCE,0x79,0xB6,
+	0x10,0xEE,0x67,0x3D,0xE4,0x4F,0x60,0xC2,0x72,0xAF,0xF3,0x1C,0x27,0x7D,0x6A,0x77,0x74,0xC7,0x38,0xEA,
+	0x89,0x02,0x68,0xF3,0x3D,0xE5,0xE7,0x63,0xBB,0x56,0x68,0x52,0x73,0xA4,0xA1,0x30,0xFC,0x80,0x21,0x72,
+	0xB5,0xE4,0x69,0x73,0x33,0x41,0x75,0x43,0xF2,0xA7,0xF5,0x5A,0x6E,0x34,0xAD,0x83,0xB4,0xE5,0xE9,0x8E,
+	0x38,0x86,0x79,0xD7,0xFD,0x87,0xE2,0x8F,0xEC,0x82,0x73,0x31,0x22,0x33,0x4D,0xAE,0x46,0x30,0x49,0x09,
+	0xFD,0x17,0xEA,0x9B,0x0F,0xD6,0xAD,0xA1,0x7E,0xAE,0xDD,0x54,0x9B,0xC3,0x69,0x4E,0xDD,0xF6,0x67,0x89,
+	0x49,0x02,0xA3,0xF6,0x80,0xE8,0xCA,0x0C,0x6D,0xA6,0x5F,0xBC,0xA2,0x47,0x9F,0x79,0x32,0xE5,0x3C,0xF4,
+	0xFE,0x7A,0xF8,0x40,0xCB,0xE9,0x00,0x4F,0x5D,0xFD,0xA2,0xCE,0x14,0x01,0x74,0xAE,0x18,0xEC,0x72,0xEF,
+	0x42,0xA4,0x26,0xCB,0x70,0x8F,0x0A,0x0C,0x73,0x80,0x20,0xBE,0x19,0x4C,0xFC,0x8F,0x0B,0xCD,0xAA,0xDF,
+	0x53,0xCF,0x1B,0x6C,0x2D,0xE2,0x37,0xEE,0x92,0xCC,0xA7,0xCF,0xE6,0xEC,0x27,0xCA,0xF0,0x8E,0x0D,0xE6,
+	0x0D,0x43,0xB3,0xDB,0xD3,0xCC,0xBF,0x7E,0x8E,0xAC,0xBF,0xFE,0xD5,0xCD,0xDF,0xA5,0x85,0x6F,0xDC,0x02,
+	0x76,0xA6,0x95,0x17,0xFC,0xC3,0x67,0x81,0xD5,0x5F,0x68,0x12,0x23,0xF3,0x5B,0x97,0x79,0xF3,0xEF,0x41,
+	0x1B,0x7A,0xBA,0x1B,0x9C,0x82,0x45,0xD5,0xE5,0xD0,0x5A,0x03,0xA4,0xB2,0x12,0x0A,0x05,0x7D,0x62,0xB4,
+	0xCA,0x41,0xC1,0x53,0xA9,0x68,0xE9,0xC1,0x54,0xBC,0x6E,0x4C,0x0E,0x80,0xE5,0xB3,0xBD,0xA0,0x95,0xA2,
+	0x7C,0xE9,0xB0,0x63,0x18,0x96,0xAA,0x33,0x48,0xF5,0xF4,0xE6,0x76,0xF4,0xD1,0xA2,0x93,0x9C,0xA2,0x23,
+	0x3F,0x96,0xB8,0x57,0x6D,0x3E,0xF6,0xA6,0x36,0x7D,0x7F,0xEC,0x87,0x84,0xA1,0x62,0x98,0x1C,0x31,0x76,
+	0xAA,0xB4,0x21,0x42,0xD8,0x95,0xA9,0x7C,0x19,0xD7,0x39,0x72,0xD8,0x5C,0x33,0x36,0xCF,0xF5,0xF7,0xA7,
+	0xB7,0x94,0x22,0xAE,0xAE,0x54,0x12,0x6C,0x3A,0x9A,0x48,0x07,0x6A,0xFA,0xAC,0x9E,0x35,0xAB,0xA1,0x64,
+	0x81,0x94,0x90,0x23,0xE3,0x64,0x46,0xAB,0x53,0x74,0x78,0xDC,0x96,0x2A,0x74,0xE9,0xAA,0xB8,0x0D,0x0B,
+	0xBA,0x1F,0x9D,0xD9,0x4F,0xBF,0xEF,0x19,0xFA,0xB8,0xD0,0x73,0xB3,0xD6,0xB5,0x9D,0x0E,0x16,0xEA,0x5B,
+	0xE9,0x7B,0x0B,0xDD,0x16,0x08,0x46,0xD6,0x28,0x1E,0xA8,0x1F,0x10,0xDF,0xB0,0xFF,0x4C,0xDF,0x22,0x4B,
+	0x35,0x74,0xAE,0x5B,0x98,0xDF,0x3A,0x0F,0x74,0x56,0xA0,0x7B,0x21,0x36,0xF4,0xEE,0x5D,0xFE,0xC7,0xB6,
+	0x8F,0xDC,0xA3,0xDA,0x94,0xDD,0xF3,0x6A,0xE8,0x35,0xFD,0xBF,0xBF,0x76,0xAB,0xBF,0xAC,0xCF,0x31,0x5E,
+	0xB5,0xDC,0x7B,0x5B,0xCD,0xBF,0xFF,0xDB,0xD9,0xDE,0xDE,0xF5,0x65,0xC9,0xC4,0x58,0xE7,0x45,0xBC,0x5B,
+	0x9E,0xDD,0x50,0x41,0xDF,0x96,0x08,0x91,0x0B,0x23,0x48,0xB0,0x41,0x63,0x1C,0x14,0xC3,0x8D,0xF8,0x62,
+	0xF9,0x6C,0x87,0x81,0x8C,0x61,0xB9,0x81,0x9A,0xB8,0xF2,0xE1,0xCC,0xB9,0xAA,0xBB,0xD3,0xA0,0xDD,0xB4,
+	0xAF,0x83,0xCD,0xA0,0x97,0x41,0x91,0x53,0x3E,0x45,0xEB,0x30,0xD7,0x65,0x9C,0x3F,0xD3,0xD9,0xFE,0xF1,
+	0x14,0x06,0x14,0x3D,0xB1,0x21,0xD2,0x86,0xBB,0xA7,0x28,0x06,0x92,0x44,0x37,0xD0,0x15,0x52,0xE7,0x6E,
+	0x75,0xB1,0x9C,0x4B,0x35,0xC5,0x6A,0x1A,0x7F,0xBA,0x85,0xBB,0x3E,0x2B,0x69,0x9A,0xC4,0x2D,0x7D,0xF7,
+	0x9A,0x6C,0x32,0x76,0x22,0xB8,0x09,0xD0,0x73,0x2F,0x8C,0xF5,0xC5,0x30,0x0B,0x85,0xD6,0x96,0x52,0xA9,
+	0x02,0xE3,0x01,0xCB,0xA5,0xDE,0xB8,0x88,0xE9,0xB1,0x38,0x69,0xF9,0x2A,0x9A,0xBC,0x01,0x0B,0x55,0x1D,
+	0x3D,0x2F,0x1D,0xBC,0x4F,0xA3,0xA2,0xB8,0x57,0x6A,0xDD,0xFC,0xE7,0x49,0x3A,0x93,0x99,0x4A,0x4B,0x8D,
+	0xCE,0x68,0xD7,0x70,0x2F,0x0F,0xCF,0xBC,0x83,0x69,0x21,0x4F,0x38,0xA2,0xDB,0x98,0x36,0x09,0x93,0x38,
+	0xA6,0x4B,0x82,0xAD,0xF7,0x4D,0xC0,0xB1,0x12,0x28,0xA9,0x4F,0xEB,0xB3,0xAC,0x6A,0xBB,0xEF,0x32,0x7F,
+	0xA8,0x4F,0x75,0x13,0xF2,0xCE,0x1E,0x82,0xE7,0x40,0x0C,0x9E,0x13,0x8E,0x79,0xCB,0x4F,0x0B,0x43,0xB0,
+	0x9A,0x52,0x6D,0xDC,0xCC,0x6C,0x79,0x9E,0x56,0xC3,0x8F,0x96,0x74,0x61,0x0B,0xDC,0x91,0xF0,0x24,0xFD,
+	0xE4,0xB2,0xD7,0x15,0x59,0xA3,0x1A,0xF1,0x4F,0xFB,0x44,0x04,0x24,0x3A,0xF3,0xDA,0xB6,0x5A,0xD0,0xF9,
+	0xC7,0x15,0x13,0xE9,0x58,0xE8,0xEC,0xC2,0x57,0x3C,0x7C,0xE6,0x13,0x5C,0xFF,0x74,0x7D,0x8A,0xDB,0x74,
+	0xD9,0xAB,0x01,0x78,0xB8,0x73,0x91,0x5C,0xE8,0x13,0xAD,0x62,0x2A,0x2F,0x92,0xEC,0xDC,0x44,0x72,0x11,
+	0xC8,0xF7,0xE2,0x43,0xC0,0xD1,0x99,0x91,0x73,0xBF,0x20,0xA2,0xF4,0x1C,0x9C,0x4D,0xB0,0xF8,0x94,0x61,
+	0x3F,0x8B,0x14,0x64,0xFA,0x74,0xCC,0x2D,0x23,0xE1,0xF4,0x2B,0xD1,0x15,0xDC,0x8A,0x16,0x5E,0xBC,0xA2,
+	0xEE,0x7A,0x47,0x3C,0xAA,0x12,0xEF,0xA7,0xF2,0x39,0xE1,0x83,0x9B,0x5D,0xD5,0xE5,0xF2,0xFB,0x18,0x2D,
+	0x66,0xEC,0xCB,0x57,0x76,0xF4,0xDD,0xDE,0xD1,0xFA,0x69,0x17,0x3B,0xFC,0xF7,0x26,0x94,0x6D,0x39,0xFC,
+	0x30,0x31,0x76,0xFE,0x4A,0x55,0x1E,0xCE,0x0D,0x73,0xFB,0x37,0x4E,0xCA,0xB6,0x63,0x3F,0x80,0x56,0xB4,
+	0xEB,0x95,0xFE,0xEA,0x38,0x74,0xB2,0x6C,0x87,0x4F,0x02,0x0F,0x7D,0x0D,0xEC,0xD6,0x65,0x8C,0x13,0x8A,
+	0x78,0x1A,0xC4,0x75,0x9E,0x40,0x2D,0x22,0xB1,0x5B,0xCD,0xDB,0x3F,0x53,0xE1,0xF8,0x10,0x13,0xCE,0x25,
+	0x62,0xA7,0xE6,0xFD,0xC7,0xBB,0x07,0x85,0x4B,0xCD,0xD1,0x9F,0x22,0x12,0x95,0x8E,0x54,0x6E,0xBB,0xDE,
+	0x69,0x90,0x9E,0x68,0x9D,0xFB,0xFA,0x25,0xB3,0x36,0xB8,0x4D,0xC1,0xF5,0x47,0xFD,0x38,0xF2,0xE4,0x45,
+	0x16,0x2D,0xB1,0x1C,0xFB,0x3E,0x92,0xC8,0xD0,0xE0,0x9A,0x6F,0xB3,0x6D,0x08,0x87,0x21,0xCC,0x5C,0x8E,
+	0xAF,0x11,0xF4,0xA7,0x2A,0x82,0x20,0x66,0x18,0x5B,0x74,0xC4,0x42,0xA2,0x20,0xA2,0x52,0x4F,0xFC,0x12,
+	0x6A,0xE1,0x68,0x76,0x46,0x56,0x92,0x92,0xE4,0x83,0x7C,0xF1,0x56,0x81,0x21,0x16,0x86,0xE0,0xA5,0x23,
+	0x75,0x5D,0x61,0xE3,0x92,0xC4,0x71,0xA6,0x87,0xA0,0xFD,0xB6,0x87,0x83,0xAD,0x12,0xEA,0x83,0x79,0xC8,
+	0xC3,0x80,0x66,0x36,0xF1,0xE5,0x00,0x08,0x80,0x89,0x54,0x24,0x6F,0xAF,0xD3,0xDA,0x9A,0x77,0xC0,0x04,
+	0xD9,0x62,0x50,0xCC,0x06,0x05,0x68,0x79,0x2D,0x08,0xF7,0x8C,0xEB,0xC8,0xC0,0xE4,0x5B,0xED,0x86,0xC1,
+	0x17,0xA0,0x61,0x3D,0xE3,0xAD,0x4F,0xD6,0xC0,0xE4,0x75,0xA7,0x92,0x83,0xB6,0x52,0x07,0xC7,0xBC,0x3A,
+	0xB6,0xFE,0x86,0xF7,0xC1,0x52,0xFF,0x05,0x55,0x2B,0xA4,0x8A,0x02,0xEB,0x32,0x8A,0x16,0xFF,0x31,0xAE,
+	0x4A,0x5B,0x18,0x9A,0xFD,0x37,0xFE,0x9A,0x0D,0x69,0x3F,0x9C,0xD8,0x91,0xFE,0x64,0x43,0xD7,0x0E,0x5C,
+	0xA6,0xEF,0xFD,0xFE,0xA3,0xE9,0x7E,0x1B,0x9A,0x88,0x6A,0x2F,0x19,0xA6,0x73,0xAE,0x81,0x75,0xB7,0x7E,
+	0xA0,0x22,0x6B,0x9E,0x67,0xC7,0x46,0xC4,0x40,0x76,0x11,0x94,0x7C,0xA9,0xBD,0x4A,0xD2,0x9F,0x51,0xF6,
+	0xE2,0x1F,0xB2,0xEF,0xAE,0xC4,0xDC,0x8C,0x7A,0xEA,0x86,0xD8,0x96,0xCB,0x3F,0x20,0xD5,0xFE,0xFA,0x87,
+	0x4F,0xB1,0xDE,0x7E,0x5F,0xED,0xA3,0xDB,0x2C,0x71,0x23,0xDF,0x68,0x08,0x71,0x96,0xC6,0xCA,0x59,0x34,
+	0xD8,0xEC,0x53,0xC4,0x0D,0xB3,0xE3,0x87,0x76,0x9C,0xC4,0x34,0x26,0x2C,0xFB,0xFD,0x1A,0xC1,0x24,0x82,
+	0x24,0x90,0x7B,0x87,0x10,0xB6,0xB0,0x5F,0x6C,0x91,0x74,0x26,0x8F,0x6F,0xD3,0x10,0xE0,0x52,0xCE,0x82,
+	0x36,0x01,0x24,0x13,0x05,0x82,0x60,0xC9,0x73,0xD3,0x45,0xD5,0xA1,0x9F,0x0F,0xA5,0x15,0xDC,0x55,0xF5,
+	0x44,0xDF,0x01,0xC5,0x0F,0xB0,0x15,0xEE,0x86,0xC1,0x19,0xF5,0x4A,0x35,0x43,0xB5,0x04,0x50,0x6B,0x4E,
+	0xB1,0xB1,0xA4,0x33,0x49,0x19,0x84,0x90,0x92,0xB9,0x7C,0x7E,0xFA,0xC7,0x92,0x03,0x75,0xFE,0x0C,0x84,
+	0xB1,0x98,0x9E,0xD7,0x7F,0xB3,0x83,0x60,0x2F,0xDF,0xCB,0x03,0x04,0xF5,0x1B,0x77,0x4D,0x75,0xE7,0x25,
+	0x17,0x49,0x15,0xB5,0x46,0xDB,0x42,0xFE,0x81,0xF6,0x2F,0x2C,0x4E,0x74,0x47,0x77,0x37,0x57,0x7A,0x03,
+	0xD9,0x26,0x3D,0xEE,0x09,0x0A,0xE6,0x1A,0x8E,0x9E,0xA0,0x4E,0x78,0x45,0x9C,0x59,0xE0,0xD5,0x76,0xE2,
+	0xF1,0x85,0x62,0x1E,0x07,0x66,0x2A,0x63,0x35,0xF8,0x06,0x44,0x90,0xB7,0x3A,0x43,0x75,0xB8,0x8D,0x10,
+	0xAA,0xF8,0x0B,0x1D,0xB0,0xB0,0xC8,0x29,0x29,0xED,0x50,0xC1,0x2A,0xF0,0xEF,0x1A,0x0A,0x64,0xCF,0xC9,
+	0xBC,0xF9,0xDC,0xFB,0xBF,0x99,0x60,0xBF,0xD9,0xB9,0xCA,0x55,0x2F,0xDC,0x59,0x7C,0x3A,0x7C,0x08,0xEC,
+	0x8F,0x5F,0xE0,0xF2,0x81,0x61,0x5D,0x24,0x83,0x90,0x38,0x3C,0xA3,0x8E,0xA8,0x18,0xED,0x11,0x05,0xD9,
+	0xDE,0x02,0x7B,0x55,0xA8,0xDC,0x87,0x99,0x6C,0x13,0xDD,0x18,0x62,0x73,0x24,0x6B,0xAD,0x13,0x90,0xA8,
+	0xC1,0xDD,0x8F,0x89,0x17,0xB2,0x4F,0x99,0xAF,0xD0,0x3F,0x2B,0xD0,0x52,0x07,0x71,0x6B,0x0B,0x92,0x04,
+	0xEF,0x32,0x5F,0x29,0x73,0x70,0xF0,0x84,0x48,0x6D,0x8B,0xE3,0x59,0xAC,0x64,0xFC,0xD1,0x6C,0xB2,0xF3,
+	0x47,0xFB,0x1C,0x46,0x62,0x73,0x94,0x72,0xE3,0x0B,0x39,0xB5,0x6F,0xFD,0xD1,0xA1,0xB4,0x44,0xC8,0x23,
+	0x37,0x2E,0xD7,0xE3,0xC1,0xFC,0x6E,0x9D,0x34,0xF5,0x58,0xB5,0x9A,0x73,0x61,0xDD,0xEE,0xAC,0x19,0x46,
+	0xE7,0xA2,0x3B,0x37,0x1B,0xAD,0x78,0x02,0xFB,0x48,0xD8,0x61,0xAE,0x6C,0xEC,0xD4,0x14,0x3C,0xC4,0x24,
+	0xAF,0x2C,0xA3,0x8B,0xB0,0xCE,0x07,0x8B,0x77,0x27,0x58,0xB2,0xFE,0x1D,0x30,0x25,0x98,0x8B,0x69,0x13,
+	0xBD,0x66,0x41,0x98,0x2D,0x27,0x10,0x52,0x6A,0x08,0x4C,0x26,0x9A,0xAE,0x9E,0x40,0xE5,0x58,0x9D,0xDB,
+	0xEC,0xC7,0x38,0xE7,0x73,0xF7,0x8A,0x1D,0xED,0x67,0xD2,0x35,0x6D,0x53,0xCB,0xBC,0xFF,0x6B,0xD0,0x88,
+	0xF6,0xA4,0x20,0x53,0xB8,0xA5,0xA5,0xDE,0xCB,0x4D,0x1D,0x5E,0xD4,0x72,0xC3,0x68,0x8E,0xA7,0x82,0x72,
+	0x3F,0x2C,0xB7,0x57,0x6F,0x5A,0x90,0xA0,0x5A,0x69,0x55,0x5E,0x57,0x01,0xF2,0xCD,0x3A,0x37,0x6B,0x5B,
+	0x36,0x48,0x3B,0xAB,0xE2,0x79,0xB8,0xCC,0x77,0xE5,0x37,0x2C,0x52,0x81,0xEA,0x83,0xF9,0x0E,0x12,0xE8,
+	0x6D,0xF1,0x70,0xB0,0xCB,0xC2,0x6D,0x1C,0x9B,0x1F,0x27,0xBA,0xEA,0x52,0xE2,0x02,0xDA,0x60,0x1A,0xB4,
+	0x77,0xC1,0xCF,0xFF,0x2E,0xAE,0x13,0x55,0x49,0x43,0xFB,0x0F,0x23,0x62,0x2B,0x5B,0x0F,0x02,0x70,0x2D,
+	0x2D,0x26,0xE6,0x24,0x34,0x12,0x64,0x3F,0x7A,0x14,0xC4,0xE1,0x26,0xBD,0x2E,0xDE,0x91,0x2B,0x2C,0x2C,
+	0x53,0xEA,0xCD,0x2C,0xD5,0x8F,0xD0,0xD7,0xFF,0x1B,0x74,0xB0,0xD0,0x9E,0x5D,0xD6,0x03,0xAE,0x63,0x24,
+	0x86,0x6A,0xDB,0x11,0x5F,0xBF,0xA5,0x63,0x15,0xB2,0xAD,0x91,0x1F,0xAD,0x39,0xD6,0xC9,0x84,0x0E,0x82,
+	0x8E,0xC3,0x16,0xD2,0x58,0x0A,0xE6,0x59,0x6D,0x1E,0x3D,0xC3,0x7C,0xA5,0x3A,0x64,0xC9,0xE5,0x04,0x45,
+	0xC8,0x4F,0x6A,0x89,0xC1,0x6F,0x44,0x97,0x7B,0xFD,0xD1,0x10,0x56,0x57,0x11,0xD0,0x35,0x57,0x05,0xE8,
+	0xC6,0x30,0xD0,0x46,0xCD,0xE7,0x7B,0xFC,0x2F,0xB0,0xC3,0x41,0xB4,0x6D,0xD0,0x86,0x4E,0x59,0x64,0x85,
+	0xBA,0xDB,0x84,0x61,0xA5,0x15,0x7A,0x51,0xB9,0x14,0x25,0xD6,0x80,0x77,0xBD,0xA3,0xEA,0x7A,0xDB,0x89,
+	0xC9,0xA7,0xE0,0xE4,0xD3,0xC9,0x6D,0xA0,0xCD,0xE7,0x9E,0xBC,0x85,0xF9,0xCE,0x89,0x71,0x30,0x93,0x8F,
+	0x9A,0x1A,0xA5,0x22,0x7B,0x16,0x24,0x43,0x4A,0x5B,0xD8,0x88,0xAE,0x33,0xDE,0x9B,0xBE,0x60,0xBB,0xD6,
+	0x32,0x15,0x6C,0x5B,0xCB,0x3E,0x63,0x1B,0x6C,0xA7,0xD6,0x71,0xDE,0xCB,0x46,0xC1,0x4C,0x5A,0x67,0x55,
+	0xEB,0x36,0x62,0xC8,0x2A,0x1C,0x06,0x4D,0x8C,0x50,0x2E,0x6C,0x7D,0xBD,0x7A,0x69,0x85,0xD1,0x28,0x79,
+	0xD4,0xB0,0x1E,0xAF,0x32,0xB4,0x3E,0xAE,0xD6,0x52,0xFC,0x07,0xF4,0x80,0x47,0x8E,0x43,0xF5,0x07,0x4D,
+	0xAE,0x34,0x6F,0x01,0x62,0x9F,0x5F,0x1C,0x59,0x1E,0x9F,0x1E,0x75,0x17,0x3E,0xBD,0xFF,0x92,0xCF,0x7B,
+	0x6B,0xE7,0xB8,0x8F,0x39,0x7F,0x23,0x11,0x6F,0x30,0xB9,0xF8,0xB8,0xAD,0x08,0xAE,0x77,0xBA,0x4C,0xCE,
+	0x46,0xAD,0x9F,0xE7,0x03,0xA8,0x57,0x94,0xD0,0xDD,0x79,0x54,0x27,0x3E,0xC2,0x26,0xF2,0xEC,0x1B,0xEC,
+	0xFF,0xA2,0x8B,0xD7,0xC8,0xBA,0x89,0x13,0x3B,0x7D,0x4E,0x87,0x39,0xD2,0xE9,0x00,0xEE,0x33,0x12,0xF5,
+	0x39,0x5E,0x42,0xDB,0x4D,0x8E,0xE0,0x31,0x32,0xAD,0x1E,0x2F,0x25,0xE4,0xE7,0x38,0x77,0xD1,0xFB,0x9C,
+	0xFF,0x7C,0x70,0xE2,0x5C,0xE5,0xF5,0x95,0xC5,0x75,0x1D,0x36,0x1B,0x72,0x10,0x74,0xC4,0xA1,0xC0,0x88,
+	0xD4,0xE8,0x3F,0x2E,0x8E,0x2B,0xF9,0x4F,0x63,0x2F,0x0E,0x09,0x97,0x59,0x99,0x05,0x29,0xE8,0x61,0x56,
+	0xEC,0xFE,0x58,0x47,0x4F,0xAF,0xB9,0xF3,0xFE,0x67,0x86,0xB5,0x76,0x78,0x24,0x16,0x8C,0xBD,0xDA,0x49,
+	0xDE,0x77,0xCB,0x22,0xE9,0xB7,0x36,0xAA,0x37,0x50,0x54,0x06,0x32,0x76,0x28,0xF6,0x9D,0x22,0x01,0xB4,
+	0x5F,0x86,0xDC,0x56,0x5E,0x69,0x1D,0xEF,0xAD,0xFA,0x18,0x9D,0x9C,0xA2,0x9F,0x50,0x52,0x85,0xEA,0x29,
+	0x39,0x84,0x11,0xE0,0xF2,0x74,0x54,0xF9,0xB9,0xAD,0x84,0x7C,0xC3,0xC8,0x85,0x57,0x9D,0x24,0xE5,0xCE,
+	0x19,0x38,0xC2,0x4B,0x61,0x53,0xA2,0x7B,0x6C,0xC8,0x5E,0xEA,0x5C,0xBC,0x28,0x49,0x25,0x82,0xBA,0xE6,
+	0x91,0x02,0x70,0xF8,0x8A,0x00,0x3A,0xAE,0x7B,0x1A,0x1D,0xEA,0xE6,0x65,0x73,0x3C,0x9F,0xA8,0x07,0x7A,
+	0xB2,0xE2,0xFB,0xDE,0x3F,0x11,0x49,0xA8,0xB2,0x02,0xE7,0xDD,0x5A,0x97,0x45,0x13,0x6C,0xAA,0xFF,0x7A,
+	0xA0,0x10,0xE4,0x5B,0x74,0x8B,0x9A,0x27,0x15,0x30,0x0C,0xBB,0x57,0x54,0x23,0x4E,0x72,0xBF,0x4C,0xC4,
+	0xFC,0xD3,0xF5,0x80,0xD0,0xDF,0x7D,0xD4,0x07,0xF1,0xE5,0x37,0xD2,0xEA,0x20,0x07,0xA6,0x43,0x5F,0x6F,
+	0x70,0x72,0x8D,0x93,0xE4,0x9D,0xE5,0xA2,0xE0,0xBF,0x62,0x1B,0x09,0xD1,0xCF,0x9B,0xB4,0x73,0xC5,0xB1,
+	0xD5,0xBF,0x1D,0xC1,0xC6,0xB1,0xE4,0xDD,0x00,0x19,0xE8,0xB6,0x8A,0xBF,0x4C,0x67,0x68,0xB6,0xFC,0xE3,
+	0x8A,0xFC,0xC0,0x41,0x0D,0x9F,0xA6,0xF2,0xC9,0x95,0x7D,0xE1,0x00,0x9D,0x23,0x09,0x53,0x0E,0x1B,0x63,
+	0x4F,0x95,0x71,0x3A,0xBE,0xF4,0x3F,0x7E,0xC4,0xDB,0x65,0x1A,0x09,0xB7,0x64,0x57,0xB0,0x14,0x69,0x2A,
+	0x48,0xF6,0x5B,0x06,0xEA,0xD3,0x02,0xD3,0xC4,0x41,0x69,0x92,0x2A,0x68,0x7C,0x82,0x0F,0xE3,0x6F,0xAD,
+	0xC9,0x5E,0x4E,0x46,0x76,0xB5,0x8E,0x7C,0xD8,0x1A,0xAF,0x6E,0x35,0xB6,0x3A,0x5C,0x7D,0x54,0xE7,0x3A,
+	0xD8,0xFF,0xBF,0xF9,0xD0,0x81,0x7D,0x92,0x3E,0xB9,0x33,0x6B,0xA8,0x51,0xD7,0x0F,0xE4,0xF5,0x2B,0x13,
+	0x0A,0xD9,0xCF,0x3F,0xE9,0xB4,0xC7,0x53,0xB6,0x96,0xEF,0xA2,0x5E,0x97,0x4E,0xCD,0xAF,0xD8,0xD8,0x8B,
+	0xB3,0xDE,0xF4,0xF9,0x01,0x94,0x4E,0x00,0x6E,0xB1,0x13,0xFD,0x8E,0xC2,0xD6,0x99,0x31,0xD3,0x1E,0x5A,
+	0x1D,0xBB,0x4B,0x03,0xCE,0x26,0x5F,0x21,0x02,0x93,0x98,0x4D,0x7B,0xA2,0x51,0x1F,0xE3,0x23,0x0A,0x16,
+	0xFC,0x65,0xDB,0xB9,0x10,0x82,0x88,0xAD,0x7D,0xBF,0x01,0xBA,0x16,0xB9,0x8D,0xFB,0xCA,0xE4,0x59,0xB9,
+	0x73,0x00,0x96,0xB0,0xA3,0xED,0x39,0x01,0x64,0xCD,0x42,0x57,0x36,0xE9,0xD1,0xB0,0x3A,0x08,0x0F,0xE4,
+	0x6B,0xD0,0xF9,0x52,0xBA,0xEC,0xB0,0x56,0xD0,0x6E,0x5E,0x01,0xBF,0xFD,0xFE,0xC2,0x46,0x2A,0x6F,0x95,
+	0x42,0x8E,0x93,0xC5,0x06,0x23,0xD2,0x11,0xFE,0x83,0xF0,0x43,0x68,0xEF,0xCB,0x76,0x1B,0x49,0xB1,0x32,
+	0x50,0x27,0xBD,0x7B,0x6D,0xF1,0xF8,0xE0,0x79,0x35,0xAF,0x46,0x06,0x23,0x28,0xA3,0x8C,0x6E,0x11,0x40,
+	0xA6,0xFA,0x37,0xB9,0x23,0x9E,0x91,0x70,0x70,0xA5,0x20,0xF0,0x32,0x80,0xDF,0xC5,0xE9,0xD0,0x3E,0xAD,
+	0xED,0xEB,0x6B,0xC4,0x7D,0xED,0x51,0x66,0x80,0xEB,0x10,0x45,0x26,0xB8,0x8D,0xD1,0x82,0x2A,0xE1,0x82,
+	0xDC,0x57,0x7E,0x5D,0x07,0x86,0xC2,0x11,0x07,0x4A,0xD8,0xB5,0x70,0xEB,0x59,0x5B,0x2E,0x0A,0xBA,0xEE,
+	0x33,0x66,0x74,0xB0,0xDD,0x3A,0x0D,0x1E,0xD6,0x89,0x22,0xC3,0xC4,0xEF,0xC4,0xF0,0x59,0xC2,0xC7,0xC6,
+	0x5C,0xE9,0xFA,0x5B,0x6D,0xE6,0x57,0x74,0x3B,0x2F,0xD3,0x8D,0xC4,0x78,0x75,0xB5,0x99,0x46,0x59,0x6E,
+	0xFF,0xAC,0x4A,0x43,0x03,0xA8,0x56,0x3D,0xB2,0xF1,0x1C,0x84,0x0A,0x79,0x65,0x79,0x29,0x48,0xEA,0x9B,
+	0x19,0x57,0xE8,0x93,0xB3,0xE5,0x74,0x2D,0xC3,0x64,0xF0,0xA7,0x1D,0x35,0x5B,0x1E,0xA0,0x97,0xFA,0x0A,
+	0x91,0x8C,0x9D,0xCD,0xE1,0x5B,0x79,0xB2,0xA5,0x3F,0x56,0x0F,0x21,0xF4,0xCB,0x78,0x57,0x75,0x33,0x6B,
+	0x43,0xE4,0xF3,0x42,0xFF,0x82,0x6C,0xAD,0xCD,0xB6,0x24,0x02,0x54,0xE9,0x7A,0x39,0xCB,0xC3,0x76,0xB4,
+	0xBC,0x9F,0x50,0x21,0x93,0x35,0x2C,0x44,0x32,0x85,0x72,0x2D,0xCA,0x19,0x4C,0x04,0x26,0x35,0x4F,0xCA,
+	0xAB,0x22,0xC5,0xA4,0x8C,0x3E,0x65,0xD7,0x36,0x1F,0x25,0xF7,0xD2,0x2E,0x2D,0x5A,0x6D,0xF4,0x8E,0x21,
+	0x9B,0x2C,0x6D,0xDB,0xF2,0x1E,0x5D,0x65,0xCB,0x92,0x55,0xB8,0x31,0x20,0x2A,0xCC,0xF7,0xF8,0x1F,0xC0,
+	0x24,0xA4,0x8C,0xC0,0xEE,0x25,0xC8,0xE0,0x51,0xF0,0x4E,0x84,0x6A,0xDF,0x77,0x6C,0xD0,0xB8,0x86,0x69,
+	0xBE,0x93,0x0C,0xF0,0x13,0xFE,0xE6,0x1C,0x77,0x3A,0xB2,0xBE,0x9E,0xA9,0xFB,0xEC,0xBC,0x54,0xD7,0x41,
+	0xFA,0xA7,0xCF,0xE4,0x16,0xB7,0xD1,0xE0,0x02,0xB3,0xDC,0x95,0xDB,0x75,0xC6,0xF0,0x66,0x17,0x84,0x7C,
+	0x56,0xD6,0x16,0xFF,0x2C,0x39,0x54,0x66,0x53,0x37,0x31,0x10,0x81,0x9B,0xFA,0x44,0x3C,0x85,0x71,0xE8,
+	0x9D,0x10,0x94,0x62,0x95,0x34,0x21,0x27,0x98,0x8F,0x81,0x38,0x12,0x27,0x97,0x0D,0xEA,0xBA,0x07,0xF2,
+	0xBE,0x18,0x15,0x5A,0x96,0x34,0x6F,0xAF,0xFE,0x8F,0x89,0xE2,0xC8,0x6C,0x70,0x19,0xB7,0x4C,0x17,0xB4,
+	0x3C,0xC6,0xC6,0xA9,0x04,0x34,0xD8,0x2A,0xCA,0xE3,0x0F,0x14,0xD1,0xFD,0x96,0x18,0x2B,0x58,0xC7,0x13,
+	0xF7,0xDA,0x75,0x4B,0x88,0xC2,0x5C,0x1C,0x61,0x26,0x07,0x7D,0xCE,0xA2,0x21,0x8F,0x43,0x13,0xEB,0xB2,
+	0x74,0xE1,0xF9,0xF8,0x37,0x98,0xC7,0x6D,0x89,0xD6,0xC6,0x2D,0xFE,0x85,0x78,0x2C,0xD8,0x1F,0x12,0xC9,
+	0x5E,0xB9,0x61,0x85,0x66,0xA9,0x38,0xBD,0x87,0xD2,0xDB,0x0A,0xA1,0x7F,0xA2,0x58,0xF5,0x0F,0x78,0x2B,
+	0x94,0x23,0xB0,0xD7,0x0F,0xE0,0xE8,0x82,0x4D,0x3E,0x7A,0xFC,0xF0,0x5E,0x3A,0xC1,0x3F,0xAF,0x45,0xCD,
+	0xAA,0xA3,0x82,0xAE,0x6F,0x11,0x73,0xF7,0xEE,0x03,0x16,0x8B,0x2D,0x01,0xEF,0xFB,0xD4,0x6F,0x33,0x3D,
+	0xA4,0x73,0xF1,0x8A,0xA6,0xD1,0x06,0xA0,0xF3,0x5E,0x26,0x2F,0xDC,0x0C,0x18,0x70,0xF9,0x9F,0x72,0xB4,
+	0x37,0xC4,0x73,0xE6,0x69,0xA8,0x70,0x26,0x46,0x19,0x69,0x2D,0xA0,0xF0,0x4C,0x20,0x7C,0xAA,0xE6,0x32,
+	0x16,0x87,0xC2,0x85,0x36,0xFE,0xE7,0x30,0x25,0xC9,0xC7,0x73,0xFA,0xBD,0x4F,0x17,0x49,0x60,0x93,0x99,
+	0xD5,0x86,0x76,0xBB,0xC1,0xCA,0x6E,0x65,0xA4,0x83,0x27,0x53,0xAC,0x0E,0xD9,0x41,0xBB,0x4A,0x1D,0x7A,
+	0xB2,0x81,0x62,0x8B,0xFA,0x29,0x54,0x83,0x4D,0xF8,0x8C,0x52,0x7D,0xA8,0x32,0x0B,0xF4,0x00,0xF8,0x54,
+	0x1B,0x2B,0x04,0x8E,0x0D,0x66,0xA0,0x3F,0x7C,0xA9,0xA2,0x70,0xED,0xFF,0x87,0xFC,0x18,0x27,0x10,0x82,
+	0x14,0x99,0xBF,0xFC,0x35,0x23,0xDA,0xFB,0xCC,0x06,0x62,0x17,0x9B,0xC9,0xE8,0x48,0xAB,0x89,0xB7,0x42,
+	0xEE,0x29,0x3A,0x4E,0xB2,0x15,0x70,0xB1,0x18,0x75,0x72,0xAC,0x16,0x82,0x64,0x9F,0xFD,0x1C,0x95,0xA5,
+	0xEE,0x0E,0xB3,0x43,0xBA,0x52,0xE6,0x3D,0x7C,0x56,0x5E,0x0A,0x7E,0xEF,0x3A,0xB3,0x6B,0x0F,0xD4,0x31,
+	0x75,0x9F,0xF3,0x7A,0xE3,0x63,0xD1,0x9C,0xBA,0xF5,0x94,0xA5,0x77,0x66,0xD5,0x77,0x12,0x59,0x99,0x3B,
+	0xFD,0x64,0xC5,0x4B,0xEC,0x14,0x3C,0x86,0x0C,0xD1,0xB6,0x85,0xDF,0xF4,0x9F,0xFD,0x9D,0x2C,0x03,0xDE,
+	0x72,0x7B,0x2C,0x69,0x37,0xDC,0x68,0x94,0xD0,0xF3,0x34,0xA3,0x03,0xD5,0x44,0x32,0x0C,0x9B,0x7C,0x5A,
+	0x01,0x13,0x9F,0x37,0x25,0xF0,0x0B,0x17,0xA4,0x7D,0xD9,0x4F,0xB4,0x0F,0x7F,0x68,0x56,0xFF,0xE9,0xB9,
+	0x42,0xD6,0x58,0xC1,0x0E,0x10,0x0D,0xAA,0x14,0x90,0xA4,0xDB,0xD8,0x8F,0xE0,0x86,0x7C,0x19,0x3C,0xEE,
+	0x60,0x7F,0xEE,0x06,0x3E,0x54,0xD3,0x34,0x4C,0x5F,0x2C,0xB3,0x21,0xF7,0x7A,0x8E,0xE7,0xC5,0xFA,0x86,
+	0x9E,0x7C,0x60,0xBD,0x01,0x86,0x73,0xF6,0x87,0x49,0xB8,0x67,0xBB,0xB3,0xEF,0x0F,0xF2,0xB9,0x6D,0xD1,
+	0xF3,0x3A,0x2B,0xAD,0x56,0xAC,0x23,0x8F,0xE7,0x99,0x51,0x65,0xB7,0xFF,0x46,0xDC,0xFA,0x95,0x9E,0x71,
+	0x3A,0xDA,0x81,0x1E,0x91,0xB4,0xEF,0x3C,0x39,0x07,0x16,0x00,0x2C,0xD9,0x0E,0xEC,0x5F,0xA5,0x64,0x03,
+	0x11,0xC6,0x94,0x1B,0x53,0x73,0x40,0x09,0x69,0x2C,0x52,0xBF,0x30,0x15,0x55,0xBB,0xEF,0xBB,0xEE,0x3B,
+	0x59,0x25,0x3B,0xBF,0xAB,0x19,0x6F,0x1A,0x3D,0x1B,0x85,0x45,0x8E,0x68,0x97,0xE2,0xBC,0xF8,0xFC,0xBB,
+	0x43,0x97,0xA4,0x28,0xBE,0x3C,0xF6,0x6E,0x4D,0xA7,0xB1,0x6C,0xFE,0x47,0x4E,0xDF,0x44,0x57,0xB7,0x52,
+	0x9A,0x42,0x16,0x38,0xEB,0xD3,0x09,0x7E,0x6F,0x50,0x61,0x3A,0xE9,0xFE,0xDD,0x27,0x81,0x71,0xB7,0x3F,
+	0x11,0xD0,0xCF,0x3F,0xDC,0x01,0x6B,0xA8,0xCA,0x1D,0xB6,0x4F,0x1A,0x3F,0xDB,0x39,0x4C,0xD1,0xA7,0x9F,
+	0xBF,0x5D,0x1A,0x02,0x1C,0x8D,0x7F,0xFA,0xE8,0xCB,0x6E,0x27,0x64,0x9F,0xC2,0x6F,0x74,0x1C,0x1E,0x78,
+	0xFE,0x43,0x7F,0x0A,0x2D,0xD5,0xA3,0x95,0xB6,0xCA,0x31,0x46,0xEA,0x7E,0x7F,0x71,0x69,0xE3,0xDA,0x05,
+	0x96,0x92,0xAE,0x10,0x61,0xBD,0x2E,0x6A,0x45,0xBF,0x95,0x9D,0x03,0xAF,0x9A,0x67,0x26,0x62,0x59,0x0C,
+	0x2A,0x07,0x09,0xDD,0xD3,0x2E,0xD1,0xC2,0xCF,0x6A,0x78,0xBE,0x02,0x69,0x7B,0x9F,0x39,0x64,0x63,0x86,
+	0x76,0x0A,0xD9,0x17,0xDD,0x0F,0xC9,0x32,0xEC,0x64,0xE3,0x2A,0x9A,0xB8,0xA1,0x08,0xC1,0x24,0x79,0xD1,
+	0x7D,0xAB,0xBE,0x4D,0x37,0xF9,0x91,0x3D,0x01,0xDA,0x6E,0xFE,0xB1,0x62,0xDA,0x22,0xB7,0x45,0xA9,0x03,
+	0x48,0x2A,0x76,0x0E,0x74,0xDA,0x75,0x9D,0x07,0xAA,0xF3,0x6A,0xF7,0xA5,0xDB,0x79,0xBD,0xB7,0x48,0x87,
+	0x3E,0xE7,0x6D,0x5F,0x37,0x9C,0x8E,0x9C,0x22,0xCB,0xEA,0x5C,0xF7,0xA2,0x18,0x4B,0x7D,0xCC,0x0F,0x31,
+	0xDB,0x75,0x12,0xCE,0x56,0x02,0x82,0x6B,0x63,0x6B,0xB7,0x0D,0xA3,0x45,0xEB,0x1F,0xFC,0xC1,0x52,0xF4,
+	0x6C,0x00,0x8F,0xFF,0xBD,0x80,0x09,0x19,0x22,0x0F,0x04,0xB9,0xAB,0x20,0x15,0x35,0x0C,0x9F,0xB9,0x6B,
+	0xBB,0x93,0x40,0x68,0xB5,0xC1,0xB0,0x6D,0x7E,0xCD,0x58,0x68,0x0D,0x9E,0xF2,0x78,0x35,0xF2,0x9D,0x48,
+	0x6F,0x0F,0x7A,0x0E,0x39,0x38,0x2C,0xCD,0xF0,0xFC,0x77,0x2F,0x6D,0x4B,0x82,0x97,0xCC,0xFD,0xEB,0x5D,
+	0x28,0xC1,0xA8,0x27,0x28,0x6A,0x91,0xDD,0xE7,0x80,0x08,0xE7,0x3E,0x40,0xA5,0x7A,0xFF,0x92,0x84,0xE6,
+	0x5C,0x5F,0x03,0x06,0x12,0x42,0x46,0xEE,0x8B,0x34,0x94,0x57,0x08,0x74,0xF3,0x78,0x25,0x5C,0x0B,0x65,
+	0x92,0x30,0x26,0x00,0x47,0xCE,0xCF,0x66,0x0A,0x51,0x65,0xD2,0x0B,0x1F,0xFD,0xA1,0x71,0xB8,0x2D,0x91,
+	0xE0,0xED,0x51,0xD6,0xC4,0x30,0xA1,0x0E,0xA0,0xB3,0xBF,0xB1,0x33,0x37,0x22,0xC1,0xED,0xFC,0x5D,0x09,
+	0x74,0xDE,0xA8,0xA2,0xDD,0xB9,0x3F,0xBF,0xA8,0x8B,0x0A,0xDD,0x64,0x8C,0x14,0x64,0x4B,0x72,0x87,0x54,
+	0x51,0xD3,0x11,0xEC,0x04,0x15,0x4B,0xD4,0xEE,0xD8,0x63,0xBB,0xE6,0xA8,0xD4,0x86,0x7C,0x1C,0xFE,0x4F,
+	0x41,0xBB,0x3F,0xFF,0x92,0xA2,0x7F,0x86,0xD6,0x0A,0x75,0x22,0xD3,0x72,0xB0,0x3F,0x3C,0x77,0xBA,0x0E,
+	0x02,0xD1,0x74,0xD1,0xFD,0xC8,0x3C,0x6E,0x2E,0xFA,0x98,0xEE,0xD3,0xA9,0xB6,0xB2,0xE4,0x19,0xCA,0xCC,
+	0x30,0xF5,0x0E,0xA9,0x59,0xE6,0x1E,0x6C,0x3B,0x88,0x60,0xBE,0x88,0xDA,0x5E,0x04,0x1A,0xD4,0x3C,0xAD,
+	0x1D,0xC1,0x33,0xEF,0x53,0x8B,0x01,0xCB,0x88,0x71,0xE9,0x95,0x13,0xCB,0xB4,0x28,0x95,0xC4,0xF1,0x9B,
+	0xDA,0x4C,0x36,0x4A,0x65,0x56,0x88,0x5F,0x10,0xEA,0x7E,0x3B,0x52,0x91,0x86,0xC0,0x09,0x44,0x56,0x16,
+	0x59,0xC4,0x7A,0x04,0xEC,0x31,0x5D,0x5C,0x7E,0x93,0x31,0x9B,0x08,0xC5,0x44,0xFA,0x80,0x52,0x32,0x7C,
+	0x87,0x5D,0x38,0xF6,0xD2,0xCB,0x7F,0x33,0xAA,0x73,0xFB,0x8F,0x34,0x83,0xB0,0x1D,0x7A,0x3F,0xEC,0xE1,
+	0x77,0xAE,0x77,0x42,0x44,0x2D,0x1E,0x9F,0x8A,0x5B,0x73,0xBF,0x78,0xAB,0xE2,0x71,0x65,0x8B,0xD8,0x16,
+	0xFD,0xF1,0x0E,0xC0,0x26,0x46,0x0F,0xC4,0xD6,0xFC,0x8F,0x26,0x36,0x7A,0xC4,0x74,0xEA,0xA7,0x34,0x4C,
+	0xE4,0x49,0x07,0xD4,0xB4,0x4E,0xE1,0x87,0xF9,0x6B,0x93,0x23,0x16,0x4E,0x4F,0x24,0xE0,0xC4,0xE9,0xA3,
+	0xA6,0xA9,0x93,0x62,0xE1,0x8A,0x80,0x7B,0x34,0xCD,0x3D,0xD1,0x69,0x48,0x28,0x44,0xE1,0xE2,0xDF,0xA0,
+	0xEF,0xD5,0x40,0xB6,0xAA,0x77,0xC4,0x1D,0xE5,0x64,0x34,0xE3,0x15,0x17,0x3B,0x89,0x01,0x36,0x0C,0x20,
+	0xE8,0xBE,0xD2,0x3C,0x24,0x3A,0x40,0xE9,0x73,0x89,0xA1,0xFA,0xBD,0xC4,0x9F,0x40,0xB2,0xBD,0xE0,0x20,
+	0xB0,0xC0,0x0E,0x20,0xE5,0x60,0xAE,0x63,0xE3,0xC5,0x62,0x31,0x64,0xB7,0x01,0x01,0x2C,0xEC,0xA0,0x68,
+	0x32,0x61,0xA0,0x3C,0x68,0x05,0x45,0x2A,0xBD,0x17,0xB5,0xC8,0xCE,0xE0,0x8A,0xAB,0x5A,0x7B,0x72,0x7A,
+	0x15,0x92,0x52,0x3A,0x9F,0xAD,0x42,0x1E,0x2E,0xEF,0x69,0x78,0xB4,0xC2,0x7A,0x0F,0x2B,0x27,0x18,0xE9,
+	0x65,0xBA,0x88,0x49,0x8D,0x8A,0xD9,0x5D,0x27,0xA8,0x77,0x7D,0x72,0x90,0xB4,0x7D,0x5C,0x21,0xA8,0xC8,
+	0x49,0x46,0xA3,0xB3,0xB6,0x7A,0x31,0xD4,0xFB,0x83,0x5A,0xB5,0x93,0x5A,0xB2,0xD2,0xA2,0xCF,0xF4,0xE6,
+	0xBB,0x6A,0xFB,0x58,0xCA,0x00,0xF0,0x5C,0x8D,0xEC,0x5A,0x7E,0x30,0x92,0x9E,0x98,0x4F,0xA2,0xD7,0x34,
+	0x2D,0x2E,0xB9,0x4D,0x2D,0x33,0x34,0x7B,0xB1,0x3D,0xF3,0x4B,0x3F,0xF5,0x15,0x77,0x0D,0x63,0x0E,0xA0,
+	0x6A,0xF9,0xBB,0x9E,0x54,0x8F,0x6B,0xFD,0x1A,0x51,0x9B,0xB3,0x85,0x6F,0xF7,0x75,0xB8,0xF1,0xCF,0x85,
+	0xC5,0x2F,0x74,0x1E,0x5B,0x0D,0x6C,0xAF,0xCE,0xD5,0xBE,0x97,0xCE,0x3C,0x07,0xC2,0xE5,0xCE,0x2D,0xF1,
+	0xB7,0xF3,0x9E,0x26,0x53,0x19,0x61,0x02,0xF7,0x41,0xA5,0x59,0x11,0x64,0xCD,0xB6,0xC0,0x5F,0x77,0xBC,
+	0xD3,0x3C,0x79,0x6D,0x91,0x12,0x67,0xB1,0x77,0x92,0xB5,0x08,0xC6,0x81,0xDB,0x38,0xCF,0x05,0x5C,0x58,
+	0xC1,0xF5,0x12,0x00,0x42,0xD9,0x21,0xF9,0x04,0x40,0x3F,0x2C,0x21,0x06,0x93,0x3E,0x6A,0xF8,0xC8,0x90,
+	0x90,0xB0,0x82,0x60,0x9C,0x13,0x77,0xC3,0x59,0x1B,0xBC,0x4D,0x53,0x49,0x0E,0xC4,0x47,0x69,0x55,0xFD,
+	0x7A,0x7B,0x8F,0xAD,0x04,0xF2,0x8A,0x27,0x37,0xF6,0x45,0x0C,0x42,0xA8,0xA3,0x64,0xE7,0x58,0x82,0xAE,
+	0x8D,0x67,0x9E,0xBE,0xB6,0x17,0x8E,0x55,0x7C,0xBD,0x0E,0x51,0x6C,0xFE,0x74,0xDA,0x59,0x36,0x3E,0xAF,
+	0x9C,0x38,0x81,0x58,0x49,0x58,0xC4,0x56,0x27,0xBB,0x94,0xA6,0xE4,0xEB,0x07,0xFD,0xDE,0xA6,0x8F,0xF4,
+	0x4F,0xBF,0xD5,0x8F,0xFA,0x69,0x8F,0xE9,0xCF,0xBF,0xCB,0x6C,0x39,0x36,0xC0,0x44,0x0C,0x58,0xEC,0x5D,
+	0x1C,0x54,0xD9,0x28,0x28,0x2F,0xBF,0x4E,0x9B,0x43,0x77,0x8C,0xD5,0xCC,0x94,0xF0,0xA8,0x08,0x3D,0x44,
+	0x8E,0x42,0xDC,0xFA,0xD6,0x56,0xD3,0x10,0x4B,0x9F,0x9D,0xFA,0x83,0xB9,0xA0,0xFB,0x8A,0xDC,0xD9,0x3A,
+	0x62,0xB1,0xCF,0x05,0xFE,0x93,0x10,0x1C,0x24,0x55,0xDB,0xB9,0x7E,0x42,0xB1,0x3D,0xBB,0x3A,0x3F,0x0A,
+	0xDC,0xAB,0x4C,0xF8,0x2B,0x3A,0xA7,0x37,0x6B,0xA5,0x37,0xB1,0xE4,0xE3,0x63,0x99,0x88,0x33,0x97,0x26,
+	0x94,0xCD,0xA0,0x9A,0x95,0x95,0xF7,0x67,0x7E,0xA0,0x22,0xC3,0x8B,0xEA,0xA0,0xCE,0xFD,0x6C,0x81,0xF0,
+	0x60,0x42,0x41,0x7D,0xC1,0xAF,0xF3,0x32,0xB2,0xA4,0xC5,0xA1,0xAE,0x04,0xAC,0x0A,0xEA,0x77,0x72,0xEA,
+	0x68,0x4F,0x7B,0x35,0x3D,0x07,0xE6,0x4F,0x5C,0x01,0x9D,0xC0,0x35,0x71,0x4D,0xC0,0x3D,0xD9,0x6E,0xC8,
+	0x6C,0x9B,0x10,0xE5,0xEB,0x26,0x1A,0x7F,0x68,0xA6,0x4C,0xD0,0x15,0x7D,0xE3,0xC0,0xFF,0x9A,0x07,0x75,
+	0x77,0x63,0x81,0x35,0x94,0xAD,0x01,0xC4,0xFC,0x9D,0xEE,0x51,0xC0,0xB9,0x15,0xC5,0xD3,0x06,0x09,0xA0,
+	0xE5,0x72,0x25,0x3A,0x4D,0x7A,0x67,0xD4,0x7C,0x1C,0x73,0xCD,0xD5,0x45,0x46,0xCE,0x9A,0x0B,0x65,0xCC,
+	0x3B,0x95,0xA1,0x2F,0x9C,0x9E,0x69,0x57,0x56,0x97,0xE8,0x0B,0x7B,0xEF,0x5E,0xE2,0xE4,0x88,0x9A,0xC9,
+	0x9B,0x09,0xA4,0x98,0x8F,0x63,0xE0,0xF2,0x40,0x79,0x91,0x09,0x67,0xA7,0xB4,0xB6,0xA3,0xFC,0x3F,0x5E,
+	0xF6,0x9C,0x31,0xEA,0x43,0xA0,0xB3,0xE2,0x6C,0x48,0xB8,0x0F,0x15,0xAE,0x1B,0xFB,0xF5,0x07,0x1C,0xFD,
+	0x08,0xA8,0x21,0x0C,0x16,0xD7,0x52,0x91,0xFB,0xD7,0x92,0x84,0x0C,0x2E,0x52,0xF0,0xE2,0xEE,0x09,0xD8,
+	0x11,0x7A,0x32,0x1A,0xF4,0x43,0x1A,0xFD,0xBF,0xB2,0x97,0xE8,0x63,0x2D,0xC7,0x69,0x9C,0x0C,0x21,0xED,
+	0xB4,0x50,0x13,0xEA,0xD9,0xAC,0x59,0x5D,0x70,0x82,0x67,0xD9,0x99,0x7F,0x63,0x97,0x48,0x42,0x6F,0x1F,
+	0x24,0x69,0x5A,0x8F,0x6E,0x5E,0xBC,0x6B,0xBD,0xCD,0x2A,0x1C,0x0A,0xE7,0x52,0x24,0x43,0x94,0x36,0x63,
+	0xE7,0xBE,0x77,0x65,0x92,0x71,0x4A,0x0A,0x8A,0xE2,0x5C,0x08,0x84,0x1F,0x64,0x21,0x76,0xAD,0x60,0x7A,
+	0x45,0x64,0x6B,0x1D,0x09,0xE1,0x55,0x18,0xF0,0x62,0xEB,0x60,0x6B,0x03,0xB2,0xA7,0xD1,0x31,0xAA,0xF1,
+	0x15,0xA0,0x5D,0x35,0xE5,0x7B,0x3A,0x70,0x24,0xE7,0xC4,0xBB,0x13,0xE4,0x52,0x41,0xE2,0xA2,0xB4,0xA5,
+	0x32,0xF4,0x9A,0xAE,0x49,0xD6,0x33,0x26,0x12,0x05,0x64,0x37,0xA1,0x75,0x86,0xE5,0xD0,0x73,0x9C,0xF0,
+	0xCC,0xB9,0xA5,0x93,0xC0,0x3B,0xC5,0x63,0x27,0x13,0xAD,0x67,0xFB,0x8B,0x33,0x65,0xE9,0x34,0x0D,0x9D,
+	0xB3,0xC0,0x55,0xD0,0xE5,0x75,0xD1,0x8B,0x52,0xFF,0x78,0x1A,0xD4,0x5C,0xF8,0x8A,0xD1,0x37,0x21,0x14,
+	0x9B,0x56,0x92,0x88,0xF7,0x39,0xA9,0x07,0xC2,0xAF,0xB6,0x72,0x95,0x34,0xB6,0x9D,0x5A,0x20,0x30,0xCF,
+	0x16,0xFB,0xB4,0x8E,0x7C,0xCC,0xD5,0xA2,0x53,0x5E,0x7F,0x2F,0x14,0x1B,0x3B,0x89,0xFE,0x89,0x51,0x03,
+	0xAD,0xCF,0x72,0xDA,0x44,0x4D,0xA7,0x4A,0xC3,0xD0,0xE1,0x19,0x10,0xB0,0x66,0x9A,0xCB,0xB3,0xC2,0xC9,
+	0x45,0x1C,0x51,0x16,0xC6,0x51,0x56,0x0E,0xDB,0xF4,0xEB,0x5C,0x29,0x5A,0xF6,0x58,0x31,0xC5,0x9E,0xEE,
+	0xE4,0xA0,0x1C,0x8E,0xD8,0x7B,0x16,0x3A,0x90,0x05,0x57,0x4F,0x7F,0x4D,0x37,0xBF,0xA7,0x1C,0xD3,0x0F,
+	0x78,0x76,0x4F,0xD9,0xAB,0x1F,0x0F,0x59,0xDA,0x53,0x38,0x87,0x39,0x55,0xD7,0x4F,0x0E,0x70,0x42,0x06,
+	0xF8,0xC4,0x5B,0x75,0x7A,0x51,0x6E,0x11,0x40,0x6B,0x8F,0xB5,0x7A,0x4F,0x8F,0x8D,0x6E,0x37,0x7B,0xE5,
+	0x99,0xAC,0x99,0x28,0xD9,0x75,0xC6,0x86,0x66,0xF7,0x92,0x04,0x50,0x54,0xDF,0x01,0x7D,0x61,0x03,0x27,
+	0x41,0xD4,0xE7,0x5D,0x1E,0xA1,0xA9,0xE2,0x57,0xC3,0x52,0x30,0x34,0x5C,0x67,0x3C,0x83,0x8D,0x03,0xC8,
+	0x5A,0x4E,0x36,0xF6,0xF5,0x2F,0xA8,0x43,0x69,0x84,0x0D,0xA0,0xE7,0xDB,0x5A,0xCB,0x50,0xC6,0xE4,0x7D,
+	0x6D,0xD0,0xD0,0xE4,0x13,0x45,0xAB,0x8C,0xFE,0x76,0x14,0xE9,0xA6,0x33,0xE9,0x43,0x4E,0xC5,0x71,0xC5,
+	0x53,0xA3,0xCC,0x5E,0x39,0x9B,0xB1,0x9D,0x7A,0xEB,0x3B,0x6C,0xE9,0x52,0x5D,0x35,0x18,0x21,0x06,0x19,
+	0xB5,0x58,0xF1,0x73,0xA8,0xC7,0x81,0x3C,0xD0,0x6D,0x84,0xBB,0x98,0x0C,0x53,0x8A,0x9A,0x77,0xE4,0xB1,
+	0x3F,0xEC,0x18,0x1E,0x88,0x9F,0x2A,0x65,0x1B,0xAB,0x44,0x7A,0xA4,0x3A,0xB2,0x3A,0xDA,0x88,0x7D,0x38,
+	0x88,0x21,0x71,0x08,0xF7,0xA5,0x0D,0x6B,0xA4,0x3D,0xCA,0x5E,0xBE,0xFC,0x8A,0x01,0x11,0x3F,0x06,0x7D,
+	0x2A,0xCE,0x6D,0x85,0x26,0x38,0xEB,0x1A,0x97,0xEA,0xB0,0xCE,0x6B,0xDE,0xE0,0x0E,0x12,0x57,0x2B,0x65,
+	0x48,0xCE,0x62,0xEC,0x5B,0x08,0x31,0x6B,0x65,0x22,0x3F,0x3C,0xE0,0x22,0x2F,0x89,0x75,0x40,0x2F,0x9C,
+	0xDD,0xC5,0x5D,0xEF,0x88,0x7D,0xE7,0x6B,0x1C,0x62,0x2D,0x18,0xE0,0x6F,0xC9,0x8D,0x5C,0xA6,0x3D,0x25,
+	0xE5,0x0C,0xF3,0x4B,0x99,0xB7,0x2D,0xD3,0x24,0xDC,0x79,0x8F,0xDB,0xE0,0x96,0x9D,0xC8,0x3F,0xDA,0x37,
+	0xC1,0xE6,0xCB,0x44,0x8D,0xF3,0xF6,0x55,0x5A,0x5D,0x84,0x18,0xB1,0x05,0x29,0xD1,0xD4,0x17,0x38,0x96,
+	0x84,0x7E,0x8E,0x9B,0x8E,0x5C,0x13,0x72,0x44,0xD2,0xDB,0x37,0x96,0x5F,0x99,0x30,0x83,0xDA,0x6B,0x56,
+	0x57,0xB2,0x88,0x88,0xCE,0xE7,0xFB,0x64,0xDF,0x3E,0xED,0x40,0xCB,0x78,0xC5,0x1B,0x06,0x5E,0x5E,0x31,
+	0x0C,0x39,0x5B,0x5D,0xC9,0x69,0xF1,0x60,0xA3,0xD7,0x40,0x99,0xD5,0xF2,0x24,0x1E,0x14,0xE1,0xBF,0xB4,
+	0x31,0x97,0x6C,0x4D,0x6F,0xB5,0x7C,0x14,0x96,0xB7,0x31,0x84,0x6C,0xD5,0x86,0x39,0x34,0x7A,0x4D,0x1C,
+	0xE0,0x6F,0xF9,0xE1,0x57,0x7E,0xAD,0x6F,0x52,0x8A,0x62,0x2D,0x1B,0xBA,0xA2,0xF2,0xC3,0xD1,0x62,0x28,
+	0x75,0xBF,0xA2,0x4C,0xBE,0x9B,0xC0,0x3E,0xD7,0x3B,0xE4,0x90,0x07,0x3B,0x62,0xBD,0x13,0xF7,0x26,0x89,
+	0xDB,0x6A,0xD0,0x3B,0xD4,0x3A,0x8B,0x85,0x47,0x9B,0xC0,0xFB,0xA0,0x84,0xC4,0x70,0x64,0x6D,0x99,0x3E,
+	0xD4,0xD9,0x77,0x52,0xEE,0x41,0x85,0xBC,0x5F,0xB2,0x09,0x20,0xDB,0x3F,0xF9,0x3B,0x56,0xF8,0x63,0xE0,
+	0x15,0xF8,0x10,0xE1,0x48,0x27,0x4E,0xA8,0x97,0x90,0x99,0x4A,0x34,0x06,0xDC,0xB8,0xCF,0xB2,0x6F,0x1E,
+	0x76,0xF3,0xD3,0x98,0x8E,0x30,0x89,0x25,0x8A,0x2B,0x1E,0xAC,0xD5,0x9F,0xF4,0xFA,0xDC,0xF0,0x5F,0xA5,
+	0x2F,0x93,0x1E,0xE8,0x1F,0xD2,0x15,0xEA,0xEF,0x0C,0x97,0xAF,0xF0,0xF3,0x3A,0xEA,0x0E,0x60,0x94,0x5B,
+	0x90,0x42,0x3B,0x7B,0xE9,0xBD,0xF5,0xEF,0x5C,0xF9,0x08,0x84,0xA1,0x88,0xF8,0x66,0x53,0x9F,0x28,0x70,
+	0x44,0x4F,0x99,0x34,0xF3,0x22,0x02,0x30,0xA2,0x0C,0xB2,0xF6,0x93,0x69,0x78,0x74,0x78,0xCA,0xFA,0xDC,
+	0xC3,0xAC,0x05,0xE3,0x2C,0x0F,0xF9,0x87,0x95,0xE8,0x29,0x71,0xC8,0x4D,0xCF,0x05,0xD4,0x09,0x03,0x51,
+	0x22,0x05,0x40,0xF7,0x13,0x6B,0x1D,0xD3,0x43,0x0B,0xC7,0x19,0xD1,0xCC,0xD1,0x80,0x0D,0x68,0xA0,0x04,
+	0xF0,0x29,0x28,0x02,0xA0,0x24,0xAE,0x5D,0xFE,0x69,0x72,0xC3,0x33,0xDA,0x2F,0xAF,0xE2,0xF3,0xF4,0x30,
+	0x47,0x68,0xD8,0x07,0x2B,0xEC,0x7B,0xD2,0xBA,0xF9,0xBA,0x62,0x33,0x4A,0xD5,0xA6,0x42,0x66,0xAF,0x59,
+	0x5D,0xE0,0xE5,0x2E,0x49,0x76,0xB2,0x92,0x6A,0xA1,0x17,0x37,0x9B,0x5C,0xF9,0xE7,0x53,0x6F,0x0A,0x8C,
+	0xA9,0x82,0x5C,0xFC,0x24,0x27,0x09,0xCA,0xCA,0x60,0x07,0xAE,0xD8,0xAF,0x08,0xFA,0x8B,0x41,0xC0,0x4B,
+	0x58,0x39,0x92,0x15,0x0B,0x46,0xC4,0x10,0x59,0xC6,0x7C,0xEB,0x29,0x82,0xE3,0x6D,0xE4,0x27,0xF5,0x39,
+	0x6B,0x4C,0xAB,0x4D,0x9C,0x67,0x19,0xE9,0x81,0x04,0xF3,0x7F,0xDA,0x34,0x8B,0xBB,0xC8,0x29,0x0E,0xB9,
+	0x8A,0x30,0xF9,0xDB,0x3E,0x06,0xC3,0x36,0xD8,0x2C,0x74,0x1E,0x69,0x0C,0x14,0x07,0xD8,0x85,0x2A,0x0B,
+	0xB5,0x00,0x3C,0x2E,0xB8,0x2B,0x9E,0xD8,0x4B,0x4F,0xBC,0x1E,0xAC,0xF8,0x4F,0x69,0xC6,0x1A,0xCB,0x61,
+	0x18,0x26,0x6F,0x20,0xE8,0x7E,0xAE,0xEA,0x25,0x0D,0xA7,0xCB,0x96,0x07,0xC3,0xEF,0x3A,0xB0,0xB3,0x75,
+	0xF8,0x6D,0xCC,0x46,0xAF,0x2D,0x3C,0x50,0x7C,0x98,0x0C,0x6D,0x93,0x36,0x92,0x42,0xE2,0x53,0x9C,0xA8,
+	0x76,0xDB,0x7C,0x60,0x7D,0x1E,0xEC,0xD0,0x46,0xB1,0x7C,0x10,0x6F,0xDA,0xFE,0xB8,0x70,0x4C,0x45,0x63,
+	0x22,0x1A,0x0D,0x78,0x51,0x3D,0x53,0x51,0xE8,0x5D,0x2A,0xD6,0xC5,0x1C,0xB9,0xE3,0x02,0x15,0xF5,0x17,
+	0xB4,0x37,0x9B,0x53,0x63,0x50,0x42,0xB4,0xF7,0xFA,0x40,0xD9,0x8E,0x19,0xFE,0x3F,0xCD,0x76,0xE0,0x10,
+	0x9D,0x5B,0x51,0x6D,0xCB,0x7F,0x65,0x04,0x40,0x35,0x5C,0xA7,0x56,0x3E,0x56,0xF1,0xC0,0x53,0x1C,0x4C,
+	0xCC,0x28,0x37,0x34,0xB2,0x10,0x58,0x1A,0x37,0x34,0x35,0xA5,0xED,0x5B,0xB2,0x08,0xB2,0x0B,0x35,0xD3,
+	0xF3,0xEC,0x49,0x51,0xD0,0x18,0x51,0xF6,0x42,0xDF,0x71,0x66,0x9C,0x7D,0x0E,0x1D,0x68,0x17,0xBE,0x5C,
+	0xE7,0x37,0x15,0x58,0x64,0x57,0x13,0x8C,0x34,0x1A,0x04,0x99,0x8A,0x1F,0xC4,0x73,0x9A,0x34,0x14,0xB9,
+	0xCA,0x5F,0x4A,0x94,0x46,0x65,0x67,0xCD,0x20,0x17,0xE7,0x38,0x96,0x37,0x77,0xED,0xB7,0x57,0xC9,0x09,
+	0x9C,0xD1,0x87,0x9B,0x08,0x93,0x85,0x9C,0x1A,0x36,0x4F,0x96,0x48,0xD3,0xC0,0xD5,0x86,0x63,0x46,0x34,
+	0x2C,0x5C,0x06,0x29,0xB7,0x70,0x16,0x0A,0xE8,0x54,0xC3,0x82,0x0D,0x7C,0x67,0x0C,0x88,0x90,0xDC,0x36,
+	0x84,0x3E,0x26,0x9A,0x2A,0xDD,0x88,0xD1,0x88,0xD0,0xCB,0x6A,0x4B,0x18,0x47,0xE9,0x53,0xF5,0x93,0x8B,
+	0xAB,0x1E,0xC1,0xD5,0x01,0xA3,0x2F,0x8A,0x1A,0x10,0xDF,0xD9,0x84,0xDF,0x27,0x9B,0xAA,0x5E,0x01,0x0C,
+	0x58,0x3F,0x40,0x42,0xA9,0x8F,0xD8,0x84,0x7A,0xC3,0x08,0xF2,0xBF,0xCF,0x8A,0xD5,0x30,0x4F,0x48,0x52,
+	0xAB,0x0C,0xC8,0x52,0x34,0x2C,0x58,0x92,0xF9,0xCC,0xAD,0xB2,0x34,0xDB,0x41,0x43,0x28,0x8D,0x99,0xD7,
+	0x4B,0xAD,0x09,0xF3,0x7B,0xCD,0x27,0xD4,0xE4,0x4D,0x51,0x91,0x84,0x6C,0xD1,0x30,0x36,0xA5,0x33,0x23,
+	0x66,0xCE,0x83,0xC4,0xE0,0xA1,0x63,0x30,0xA5,0xFF,0x54,0x24,0xC8,0x5B,0xC8,0xE0,0x64,0xF4,0xF7,0xD9,
+	0x82,0x55,0xB3,0xD1,0x01,0x2E,0xB1,0x52,0xC2,0xC9,0x18,0xD2,0x1B,0xCA,0xC2,0x85,0x2F,0x4A,0x69,0xB8,
+	0xF9,0x9A,0xDA,0xD9,0x61,0x5B,0x09,0x8B,0xC0,0x8B,0x56,0x5B,0x56,0x46,0xB7,0xD1,0x4E,0xBA,0x2D,0x09,
+	0x99,0xB9,0x91,0x72,0x42,0x87,0x6A,0xF3,0xA5,0x2D,0x1A,0x5A,0x04,0x87,0x2A,0xD2,0x5C,0xA7,0x78,0xC5,
+	0xEF,0xCE,0xEC,0xAF,0x5A,0x63,0x60,0x07,0x4C,0x80,0xD2,0x9C,0x18,0xF2,0x42,0xB8,0x6F,0x9C,0x82,0x8C,
+	0x51,0x89,0x43,0x4B,0x6A,0x87,0x17,0x6D,0xDD,0xEA,0x63,0xAB,0xAF,0x3A,0xE8,0xAD,0x01,0xE5,0x53,0x99,
+	0x8C,0xCC,0xF1,0x1E,0x3E,0xAD,0x03,0xEB,0x6E,0x43,0x57,0x3D,0xD5,0x87,0x5A,0x5A,0xAD,0x87,0x9F,0xB1,
+	0x9C,0xA4,0x12,0x2E,0x09,0x47,0xCC,0x57,0xFD,0x89,0x52,0x4A,0xAC,0x8B,0x55,0xBC,0x9D,0xA5,0xB3,0x98,
+	0xCD,0x85,0xDA,0x44,0x7D,0xEC,0xE1,0xC9,0x47,0x93,0x91,0x31,0x3D,0xCB,0xF7,0x89,0x4C,0x86,0xCD,0x53,
+	0x7D,0xBE,0x45,0x31,0x2E,0x08,0x1D,0xAF,0x97,0xA0,0x63,0x8B,0xB0,0xC0,0x7F,0xF2,0x5F,0xCF,0x04,0x60,
+	0xA6,0xD8,0xAE,0x82,0x97,0x4B,0x3C,0x40,0xE6,0xD3,0x74,0xF2,0x11,0xBE,0x4C,0xD6,0x32,0x9E,0xCC,0x23,
+	0x55,0x3C,0x44,0x95,0x06,0x21,0x6C,0x82,0x1E,0x92,0xEF,0x73,0xA8,0x9D,0x5C,0x03,0x9B,0x8C,0x33,0xC1,
+	0xA5,0xC2,0x33,0xA5,0xFE,0x59,0x4D,0xD7,0x84,0x18,0xD5,0xB0,0xD6,0x4C,0x45,0x31,0xC7,0xA3,0xAC,0x5A,
+	0x44,0x48,0xD0,0x20,0x20,0x86,0xB9,0xD2,0x8F,0xF6,0x0C,0x80,0x27,0xDC,0xC6,0xDF,0x89,0x59,0x37,0x51,
+	0x50,0xB3,0x8A,0x23,0x34,0x6D,0x44,0xA2,0x6F,0xDA,0x33,0x94,0x84,0x90,0x65,0xE7,0x91,0xB0,0xB6,0x28,
+	0x03,0xDA,0x0D,0x61,0xE3,0xF2,0x8D,0x5F,0xF0,0x65,0xAD,0x1B,0xA7,0xD6,0x50,0x28,0xC0,0xB7,0x1D,0xB7,
+	0x67,0xDA,0xC5,0x0C,0xF1,0x64,0xF9,0x68,0x80,0x13,0xDE,0xA9,0x5F,0x58,0x0E,0x7A,0xCF,0xD7,0x87,0x53,
+	0xEC,0xBA,0x9B,0xF8,0x6E,0x6E,0xD6,0x1C,0x1F,0xF8,0x79,0x58,0xEF,0x91,0x12,0xCD,0x11,0x5F,0xD8,0x69,
+	0x2E,0x99,0xDF,0xA8,0xDF,0x45,0x57,0x0B,0xE6,0x51,0x3D,0xDB,0x79,0x1A,0x57,0x19,0xA8,0xF1,0x95,0x7D,
+	0x3F,0xB3,0xF3,0xD9,0xAE,0x04,0x2A,0xCC,0x99,0x5D,0x76,0xCE,0x2A,0xB1,0xD1,0x3B,0x4D,0xBC,0x7C,0xE8,
+	0xCD,0x92,0x3C,0x94,0xA6,0xF3,0xEE,0xB9,0x64,0x9E,0x79,0x21,0xCE,0x6E,0x1E,0xBA,0xEE,0xD0,0xDE,0x3D,
+	0xE0,0x81,0x29,0xB8,0xDB,0x97,0x27,0xD6,0x40,0xE3,0x30,0xCB,0xBC,0x06,0x37,0xF3,0xAD,0xAE,0x68,0x5A,
+	0x2D,0x63,0x2F,0x67,0x33,0xB2,0x84,0xDC,0x4E,0x20,0x6F,0xFF,0xFF,0xFF,0xBF,0xC7,0xC2,0x00,0x59,0x72,
+	0xFB,0xD1,0xD0,0x9B,0xB7,0x25,0xF6,0x94,0x53,0x02,0x88,0x6F,0x07,0x83,0xCA,0xE7,0x73,0x8A,0xA3,0xAA,
+	0x9D,0x05,0xAF,0x4A,0xBA,0x42,0x09,0xA0,0xEB,0x0D,0x2D,0x81,0x87,0xB8,0x29,0x66,0x1A,0xBD,0x26,0x19,
+	0xD6,0xBB,0xEE,0x95,0x8B,0xEB,0x5D,0xEA,0xFA,0x20,0x67,0x36,0x35,0x3B,0x35,0xA6,0xFF,0x69,0x47,0x83,
+	0x31,0x4F,0x3F,0xBA,0xEF,0x85,0x8A,0x5F,0x25,0x9F,0x7A,0x42,0xF3,0xE3,0xAE,0x32,0x40,0xF5,0x33,0x27,
+	0x2F,0xD4,0x58,0xF4,0x1B,0xB2,0x97,0xF0,0x55,0x43,0xFE,0xA7,0x00,0x02,0xF9,0xBA,0x67,0x45,0x51,0x5A,
+	0xAD,0xDD,0x51,0x6D,0xD4,0x44,0x10,0xB4,0x24,0x01,0xB7,0x53,0x7A,0x76,0xE6,0x40,0x62,0xB8,0xD1,0x70,
+	0xB8,0x0F,0xFB,0x2F,0xA9,0x64,0x7D,0x7E,0xF3,0x99,0xA5,0x70,0xD5,0xB5,0x10,0x3F,0x72,0x0B,0x69,0xEB,
+	0x44,0xA2,0x1D,0x5C,0x1D,0x08,0xA3,0x9D,0x83,0x44,0x8D,0x2D,0x2D,0x48,0x64,0xFA,0x99,0x57,0xBD,0x34,
+	0x15,0x8C,0xBE,0x67,0x3D,0x16,0xB5,0x11,0xFA,0xCA,0x73,0x1D,0x74,0x49,0xEC,0x99,0x8E,0xC9,0x66,0xD3,
+	0x3D,0x73,0xD9,0xB9,0xCE,0xE3,0x62,0xD2,0xAB,0x1C,0x11,0xBF,0x96,0x21,0xE9,0xCD,0xBD,0xB1,0xD6,0xE8,
+	0x50,0x3B,0x32,0xB8,0x4B,0xF0,0xEC,0x71,0x9F,0x89,0xE1,0xC8,0xF5,0xE2,0x4F,0xFE,0x9E,0x55,0xBB,0x2F,
+	0x75,0x84,0x38,0x6A,0x3B,0xD1,0x41,0xE9,0x21,0xDE,0x0E,0x79,0xDC,0x4C,0x41,0x39,0x2C,0x09,0x5A,0x5A,
+	0x3A,0xB0,0xDE,0x5D,0x1F,0x1E,0x1B,0xFC,0x21,0x03,0xC1,0x04,0x62,0x5A,0x54,0x00,0x1B,0xF4,0xA3,0xA6,
+	0x66,0xD2,0x4F,0xFA,0x0F,0xDB,0x05,0xEA,0xB7,0xBE,0xF5,0x6E,0xCA,0xEE,0x74,0xD2,0x9E,0x5F,0x5C,0x45,
+	0x1E,0x3D,0xA9,0xFA,0x3E,0xBD,0x22,0x24,0x51,0x0D,0x20,0x25,0xEA,0x83,0x48,0xA8,0x11,0xCD,0x83,0xEE,
+	0xA7,0x31,0x4D,0x89,0x7E,0x28,0x25,0x4F,0x62,0x5E,0x0B,0xF3,0x95,0x75,0xAA,0x22,0xA0,0x10,0x23,0x3B,
+	0xD3,0xB2,0x9F,0x0F,0x8B,0xC5,0xEC,0x60,0x7C,0xEB,0x4E,0x52,0xE6,0x0B,0xDB,0x4B,0xC6,0xBC,0x66,0x63,
+	0x1B,0xFA,0x1C,0x18,0x92,0x0E,0xA0,0xA3,0xE1,0xE6,0xC5,0x3B,0x3F,0x9B,0x05,0x96,0xC6,0x3A,0xEF,0x08,
+	0xF6,0x34,0x35,0xA3,0x5C,0xEA,0xED,0x3F,0x5A,0xA6,0x4A,0x83,0x29,0xC6,0x59,0x71,0xFD,0x70,0x42,0x72,
+	0x84,0x08,0x00,0x08,0x3A,0x4A,0x69,0x6A,0xC9,0xC7,0xB6,0xF0,0xD9,0x87,0x31,0x17,0xC2,0x41,0x31,0xD3,
+	0x3F,0x63,0x16,0xBD,0x16,0x79,0x32,0x39,0x77,0x3F,0xC7,0x19,0xAF,0x76,0x2E,0xF3,0x2D,0x46,0xFB,0x2D,
+	0xB4,0xD5,0x53,0x2B,0xC0,0x87,0x34,0x17,0x42,0x23,0x49,0xF3,0x1A,0x5E,0x8F,0x44,0xE9,0x1A,0x8E,0x9D,
+	0xC1,0x3B,0x1D,0xC8,0x15,0x3C,0xDC,0xCE,0xA8,0x36,0x28,0xD0,0xE5,0xF1,0x16,0x6D,0x50,0x72,0x1C,0xDA,
+	0x9C,0x5F,0xCC,0x3A,0xD2,0x3E,0xCD,0x88,0xEB,0x42,0x25,0x3E,0xDA,0xC2,0x55,0x4E,0x11,0x83,0xC1,0x25,
+	0xC4,0x73,0x40,0x7A,0x96,0xF3,0xEF,0x12,0x79,0x73,0x48,0x30,0x40,0xEE,0x0F,0x3D,0x22,0x92,0x61,0xC1,
+	0x8A,0x5B,0xB7,0x9F,0x08,0x13,0x64,0x39,0xF7,0xE5,0x98,0xF8,0xB8,0xAD,0x87,0x6E,0x42,0x42,0x88,0xD9,
+	0xBD,0x83,0x6C,0x93,0xB2,0xE4,0xF1,0x83,0xB0,0x5E,0x03,0x70,0xE4,0x7C,0x78,0xFA,0x14,0x4C,0x19,0xF8,
+	0x79,0xC0,0x5C,0x49,0x61,0xFE,0x04,0xA7,0x90,0x2C,0x5D,0xB8,0xD5,0x22,0x11,0x54,0x5F,0x2C,0x97,0x2B,
+	0x18,0x55,0x11,0x51,0x30,0xCF,0x6D,0xD5,0x65,0x72,0x40,0xCC,0xA7,0x08,0x54,0x24,0x6A,0x0B,0xD7,0x4F,
+	0xA7,0x6B,0x30,0xE6,0x42,0xEE,0xC2,0x81,0xA4,0x83,0xFB,0xBE,0x85,0x68,0x1E,0x86,0x46,0x85,0x38,0xF7,
+	0xB3,0xA7,0x2B,0x5E,0xC6,0x80,0xF6,0x3D,0xE0,0x09,0x21,0x10,0xE4,0xAA,0x75,0x96,0xDB,0xC6,0x49,0xDD,
+	0x26,0x0D,0x16,0xAC,0x18,0x0A,0x65,0x9E,0x2E,0x2C,0x3D,0x94,0x2C,0xA5,0xAB,0x64,0xDE,0x27,0xAA,0x03,
+	0x3C,0x78,0x0A,0x55,0xCD,0xC5,0x08,0xD1,0xB5,0x8B,0x72,0x2E,0x0B,0xAB,0x3F,0xF1,0xFC,0xFA,0xFA,0xAA,
+	0xF5,0x8B,0x65,0xC1,0x79,0x2C,0x2E,0x09,0xB4,0x77,0xA2,0xE7,0x86,0xE7,0x80,0x7E,0x30,0xD2,0x5F,0xB0,
+	0xDD,0x8A,0xA0,0xE1,0x21,0x90,0x52,0x20,0xBB,0x0B,0x7F,0x9A,0x39,0xAF,0x6F,0x00,0xFF,0xAA,0xE5,0x5A,
+	0x8C,0x40,0xF5,0xD5,0x7D,0xA8,0x0D,0x92,0x4E,0xB7,0x2E,0x11,0xBF,0x73,0x8F,0x38,0xCE,0x07,0xE2,0x4E,
+	0x2C,0x05,0x24,0xD6,0x4B,0x38,0xC5,0x3C,0xFE,0x30,0x89,0xA9,0x0C,0x8A,0x9A,0x3E,0xEE,0xB8,0xE0,0x9A,
+	0xF4,0x5F,0x8C,0x15,0x5F,0xE3,0xEC,0x4B,0x0D,0x43,0xCB,0xD6,0x12,0x22,0xEE,0x45,0xFB,0x8D,0xD3,0x1D,
+	0x22,0xE3,0xE4,0x03,0x71,0x0F,0x19,0x64,0xDF,0x93,0x93,0x8E,0xBC,0xA1,0xB8,0x3D,0xF6,0xF4,0xEC,0x16,
+	0xD1,0xCE,0xF8,0x69,0x33,0xEB,0xAB,0x36,0x72,0x40,0x44,0x34,0xF5,0x56,0x91,0xE1,0x5F,0x6F,0x1E,0xE7,
+	0xB8,0x19,0x90,0x9B,0x87,0xD5,0xD4,0xC5,0xC7,0xB9,0x99,0xF1,0x28,0x25,0xE5,0xF5,0x4A,0x1E,0x05,0x40,
+	0xC3,0xBF,0x85,0xD7,0xBB,0xBE,0x2E,0xD7,0x07,0x74,0x77,0x24,0x9A,0x19,0x15,0xA2,0x22,0x70,0x34,0x66,
+	0x62,0xFE,0xEC,0x14,0x43,0x1E,0xB2,0x34,0x33,0x30,0xEB,0x1A,0xE9,0x18,0x9C,0xA0,0x55,0xF8,0x5B,0xFE,
+	0x45,0x9F,0x72,0x25,0x5F,0x5D,0x66,0xDF,0x2E,0x67,0x71,0x16,0xFB,0xD6,0x00,0xEE,0xA1,0xDC,0x5E,0x35,
+	0xDF,0xC6,0x82,0xB4,0x0E,0x26,0x02,0x73,0xFD,0xD5,0x58,0xD2,0x99,0x0E,0xF2,0x49,0xE2,0xB0,0x50,0xC2,
+	0x87,0x09,0x49,0x52,0x7C,0xF5,0x6A,0x1B,0xDE,0xFC,0x90,0x3F,0x9E,0x14,0x9C,0xCC,0x2F,0x70,0xB9,0x01,
+	0xFF,0xFD,0x59,0xC6,0x51,0xD8,0x25,0x0B,0xAB,0xB0,0x69,0x96,0xB0,0xC1,0xC8,0x57,0xFC,0xB8,0x17,0x60,
+	0x50,0xD9,0x3C,0xFF,0xAF,0xD7,0xAE,0x5B,0xA5,0xC0,0x73,0xDD,0x06,0xB9,0x86,0xB9,0x52,0x93,0x98,0xE3,
+	0xCB,0x1F,0x91,0x1A,0xEE,0xC3,0x8D,0xC9,0xDF,0x43,0x7E,0xEE,0x6F,0x10,0xBE,0x9F,0xD7,0xFC,0x62,0x89,
+	0x00,0x5C,0x07,0xD9,0xDE,0x82,0xE0,0x74,0xEE,0x70,0x76,0x3C,0x8A,0x1E,0x69,0xD7,0x7C,0xD4,0x97,0xB9,
+	0xB3,0xF3,0x36,0x3E,0x08,0x3D,0xD5,0x2C,0xB2,0xB9,0x80,0x04,0x0E,0x5C,0x53,0x84,0x61,0x62,0xE1,0xC0,
+	0x0C,0xAB,0xA3,0x44,0x44,0x6E,0x72,0x21,0x52,0x8D,0x0E,0x14,0xA3,0x22,0x38,0x72,0x8E,0x87,0xD1,0x1E,
+	0xF6,0x25,0x2C,0xB1,0x72,0x47,0x2F,0x90,0xA5,0x42,0x8D,0x00,0x02,0xCE,0xC5,0xC3,0xDE,0xAF,0x73,0x21,
+	0xC3,0x02,0x0C,0x7E,0x6D,0x6D,0x0B,0xD1,0xC5,0x66,0x8B,0xFD,0x01,0xE8,0xA3,0xCE,0x3A,0x58,0xAE,0x95,
+	0x21,0x92,0x94,0x42,0xB3,0x45,0x00,0xFD,0x5F,0x80,0xC5,0x93,0x7E,0xF9,0x10,0xDD,0xDE,0xB1,0x37,0x17,
+	0x30,0xCC,0xA8,0x56,0x4A,0x28,0x20,0x42,0xB7,0x4A,0xA7,0xF0,0x07,0x8B,0x18,0xA5,0x27,0xD9,0xB9,0xE1,
+	0x79,0x45,0x53,0x9F,0x3F,0x92,0x80,0x5A,0xE8,0xF9,0xF1,0xCA,0x85,0x4C,0x0D,0xD0,0x9D,0xAD,0x4F,0x4D,
+	0x28,0x96,0x62,0x37,0x72,0x9A,0x3A,0x78,0x04,0x01,0x86,0x88,0x66,0xBC,0x77,0x4E,0xFF,0x58,0xCB,0x2D,
+	0x5E,0x6A,0x6A,0x4E,0xDB,0x04,0x30,0x7C,0x1D,0x67,0x40,0x3A,0xFA,0x14,0xCE,0x27,0x7B,0xFD,0x87,0xF8,
+	0x85,0x2A,0x8B,0x1C,0xAB,0x3E,0xAB,0xC6,0x47,0xFC,0x56,0x32,0xFE,0xBE,0xCB,0x98,0xFF,0xD4,0x4F,0x99,
+	0xE7,0x20,0x01,0x3B,0x5B,0x43,0x0C,0x2C,0xF7,0x6F,0xA3,0x88,0x06,0xF7,0xC6,0x35,0x3B,0x7C,0xE9,0xD9,
+	0x32,0xE3,0xFA,0x0E,0xAE,0xAF,0x8B,0x26,0xF4,0x61,0x5D,0xED,0x28,0xB7,0x82,0x1E,0xBC,0xB0,0x7E,0xBE,
+	0xFA,0x92,0xBC,0x6D,0xAA,0xCF,0xE5,0x71,0xF8,0x8A,0x44,0x6B,0x9A,0x55,0x64,0xD8,0xDC,0xDD,0x12,0x15,
+	0x2E,0xF9,0xEB,0x55,0x53,0xFE,0xF7,0xE7,0xCA,0x2F,0xB3,0x1F,0x2C,0x2D,0x40,0x35,0xA2,0xDC,0xDE,0x85,
+	0x97,0x33,0xD2,0xFD,0x42,0x92,0x1C,0x20,0x4D,0xB5,0xC8,0x15,0xAC,0x6C,0x6F,0xEB,0x59,0x3C,0x42,0x52,
+	0x6D,0xD4,0x9A,0x30,0x4C,0xF6,0x2C,0x78,0xE4,0x50,0x02,0x48,0xB6,0xB9,0x07,0x49,0x62,0x9F,0x39,0x37,
+	0xBA,0x78,0xEA,0xFF,0x77,0x19,0x9B,0xF7,0xD1,0x0C,0xB1,0x34,0x1E,0x3D,0xBD,0x31,0x0C,0x1F,0x1D,0x34,
+	0x87,0xEB,0x96,0x57,0x54,0x3C,0xFD,0x9E,0xF7,0xD9,0xDC,0xE0,0x0D,0x14,0x8C,0x15,0xAF,0x29,0x33,0x27,
+	0x59,0x98,0xA3,0x32,0xC2,0x8A,0x19,0x8B,0xD0,0x6E,0x98,0xC0,0xD9,0xA6,0xC6,0xB6,0xDC,0xB7,0x28,0x0B,
+	0x61,0x5B,0x52,0xF8,0x70,0x75,0xF2,0x9A,0x2E,0x2A,0x1F,0x65,0x4C,0x98,0x9D,0xEC,0xC6,0x83,0xFF,0xE1,
+	0xC0,0xAC,0x82,0x79,0x25,0x38,0xF8,0x8A,0xD9,0xBB,0x4F,0x26,0xCD,0xAE,0xF4,0x81,0x7B,0x7A,0x4A,0xDE,
+	0x6B,0x55,0xCE,0xC5,0xE5,0x7A,0xF7,0xF8,0x6D,0x5D,0xC4,0x7A,0x0D,0xD6,0xB0,0xCC,0x8C,0x56,0x9B,0x7E,
+	0x34,0x78,0x4D,0xAB,0xEE,0x89,0x24,0x1C,0xB0,0xD9,0xCB,0xDF,0xB3,0x59,0x2C,0x3C,0x61,0x38,0x4F,0x51,
+	0x79,0x96,0x3F,0xCF,0x9B,0xD7,0x20,0xE4,0xA5,0x9A,0x94,0x8B,0xD3,0x9F,0x41,0xF7,0x1E,0x1D,0x6C,0x12,
+	0x99,0x75,0xB5,0xFC,0xCA,0xB2,0xA8,0x7C,0x38,0xFD,0x61,0x98,0x3F,0x46,0x21,0x82,0xA7,0x72,0xC3,0x89,
+	0xA6,0xE5,0xA1,0x6C,0x53,0xBD,0xF4,0xD5,0x36,0xAF,0x52,0x69,0xED,0xCA,0xDA,0x2A,0xDB,0xB0,0xE9,0x7D,
+	0xD9,0x9B,0x57,0x9F,0x00,0x4C,0xFD,0x15,0x3B,0xB0,0x94,0x60,0x89,0x36,0xFE,0xE4,0x10,0x25,0xB6,0x82,
+	0x4E,0x02,0x9A,0x54,0xBF,0x63,0x76,0x57,0x0D,0x7A,0x5D,0xEB,0x17,0x2C,0x87,0x75,0x4B,0x3E,0x67,0x8C,
+	0x6A,0x70,0x9A,0x99,0x85,0xE2,0x5C,0x29,0x37,0x79,0xD9,0xB3,0x44,0x80,0xCF,0x96,0xA3,0x4E,0x2D,0x97,
+	0xA4,0x19,0xD6,0x13,0xE0,0xD1,0xD5,0x5C,0x1B,0x48,0xE6,0xC8,0xD3,0x48,0x21,0x24,0xC4,0x84,0xB2,0x55,
+	0x6A,0x07,0xAF,0x9C,0x62,0x74,0x77,0x02,0x72,0xA6,0xF8,0xBA,0x60,0xC8,0x3A,0x5E,0xB2,0x0A,0x6F,0x4D,
+	0x33,0x48,0xA8,0x7F,0xF4,0xFE,0x69,0x46,0xF9,0x59,0xB8,0x8B,0x33,0x09,0x06,0x7F,0x3C,0x13,0x38,0x52,
+	0x77,0xE0,0x6B,0xA2,0x24,0x97,0x3F,0x10,0x7E,0x44,0x02,0x88,0xF4,0xA7,0x26,0xF3,0xC0,0xD6,0x9D,0x6A,
+	0x00,0x23,0x98,0xE6,0x5A,0xE7,0x12,0xC0,0x79,0xDE,0x6C,0x8E,0x0C,0x6B,0x2D,0x9E,0x03,0xF1,0x03,0x9D,
+	0xBC,0xC5,0xD2,0xBB,0x4B,0x3A,0xFA,0x58,0xA2,0x44,0xAF,0x0A,0x8A,0xA8,0xF3,0x17,0xCC,0xAC,0x3B,0x2F,
+	0x4B,0xF8,0x89,0xDC,0xF2,0xF1,0xEB,0xFE,0x70,0xC9,0xC9,0x8E,0x9C,0xCB,0x8E,0x7B,0x98,0xCA,0x6F,0x78,
+	0x03,0xE1,0x50,0xB5,0x2A,0x97,0x84,0xEB,0xF5,0x4F,0xB2,0xEA,0x3A,0x11,0xCA,0xEC,0x7C,0x1C,0x95,0x28,
+	0xF4,0xCF,0x94,0xEA,0x92,0x00,0x42,0x44,0x73,0x38,0xC2,0x2C,0x1C,0x1D,0xB9,0x2D,0x71,0xF5,0xDD,0xFB,
+	0x54,0xED,0x5B,0x09,0x33,0xC2,0x8B,0xED,0x5E,0x57,0xA7,0x5C,0x53,0xDE,0xBD,0xCC,0xF1,0x02,0x68,0x34,
+	0x32,0xB3,0x04,0xB8,0x1D,0x8F,0xEF,0xAE,0x22,0xD9,0x87,0xBB,0xD5,0x1F,0x98,0x30,0x60,0xDA,0xCA,0xA1,
+	0x89,0xFF,0x75,0x1D,0x80,0xFD,0xCA,0xE3,0x36,0x12,0x2D,0x5A,0xE7,0x1C,0x86,0x45,0x5B,0xEA,0xFD,0x07,
+	0xA7,0xEE,0x71,0xF4,0x9A,0xDE,0x26,0x57,0xE0,0xD6,0xB3,0x02,0x74,0x0E,0x4F,0x96,0xA6,0x03,0x93,0x33,
+	0xF6,0x93,0xC2,0xF4,0xE3,0x20,0xFD,0xD1,0x0A,0x5E,0x73,0x31,0x52,0x2B,0xB0,0x77,0xBB,0x19,0x75,0x84,
+	0x8D,0xE7,0xAD,0xF4,0x93,0x50,0xAC,0x52,0xBA,0xF0,0xBA,0xA5,0x55,0x13,0x7F,0x1A,0x1D,0x98,0x84,0x72,
+	0x60,0x36,0xA5,0x27,0x36,0x2B,0xB3,0x54,0x9C,0x19,0x15,0xE1,0xF9,0xD2,0x68,0x05,0x36,0x5B,0x55,0x2C,
+	0x5E,0xFB,0xBD,0x24,0xD5,0xDB,0x03,0x5B,0xF7,0x9A,0xC5,0x0D,0x5B,0xFA,0x76,0x1B,0x34,0x99,0x59,0xF1,
+	0x7C,0xC7,0x9D,0x2E,0x1A,0x86,0x62,0xE9,0xA2,0xF2,0xAA,0x1E,0x66,0x83,0x6E,0xF3,0xE4,0xC4,0xD9,0x3E,
+	0x1B,0x47,0x7E,0xD3,0x9F,0x56,0xE1,0x9F,0x8C,0x1A,0xFD,0x75,0xD4,0xD9,0x7F,0x26,0xEA,0x29,0x34,0x2B,
+	0xC1,0x3F,0xC3,0x73,0x71,0x56,0xD7,0xEC,0x93,0x1A,0x77,0x3E,0xEB,0x28,0x1B,0xC0,0x5E,0x5B,0x00,0xE6,
+	0x2F,0xFD,0xD8,0x7B,0xF4,0x9F,0x08,0x43,0xEC,0xD8,0x89,0xC9,0xDF,0x23,0xAD,0xA5,0x47,0x0C,0x88,0x7E,
+	0xD4,0x7E,0x29,0xAE,0xA7,0xD2,0x2E,0xAE,0x79,0xFF,0x58,0x0C,0x34,0x94,0x99,0x7A,0x57,0x7D,0x3C,0x89,
+	0x1D,0x9C,0x43,0x8D,0x01,0xF8,0x11,0xE3,0x4E,0x3C,0x5C,0x6F,0x43,0x1C,0x2F,0x08,0xC5,0x42,0xE2,0xFB,
+	0x94,0xDD,0x60,0x4A,0x53,0x0D,0x17,0x77,0x6C,0x4C,0x70,0x76,0xD6,0x4D,0x27,0x8C,0xA4,0x83,0x08,0x34,
+	0x83,0xCD,0xB6,0xB0,0x79,0x2C,0xFF,0xF0,0x25,0xEC,0x7C,0x4A,0xF6,0x71,0x11,0x62,0x8C,0xF9,0xE7,0xF1,
+	0x93,0x58,0xEE,0x52,0xF4,0x2E,0x51,0x38,0xF5,0x79,0xBD,0x73,0xE0,0x23,0x76,0x66,0xBB,0x40,0x88,0xB5,
+	0xBB,0xBA,0x26,0xD3,0xF5,0xCE,0x48,0x55,0xE3,0x1F,0x18,0x4E,0xAF,0x66,0x31,0xA0,0x1A,0xE9,0x47,0x82,
+	0x76,0xD0,0x5E,0xB8,0x57,0x48,0x59,0x73,0xB2,0x8A,0x4B,0x37,0x22,0x41,0x48,0x2F,0xAE,0xD9,0x41,0xA7,
+	0x7D,0x02,0x81,0x0A,0x33,0x89,0x46,0x5C,0x37,0xE5,0x46,0x0A,0xFC,0x20,0x11,0x74,0x01,0xEB,0x5C,0x12,
+	0x59,0xD6,0x3B,0x73,0xC0,0x44,0xE6,0x04,0xAF,0x6C,0x1A,0x0D,0x77,0x08,0x79,0x73,0x78,0x35,0x6C,0x2F,
+	0x7B,0xA1,0x0B,0xCC,0x10,0x2A,0xBE,0xFA,0x8B,0x15,0x71,0x6F,0x3B,0x56,0x99,0x4B,0x7D,0x0B,0xC3,0xAD,
+	0xFC,0x96,0x93,0x7B,0x0A,0xC6,0x7C,0x73,0xFA,0xAD,0xD3,0xE9,0x72,0x40,0xC9,0xD5,0x58,0x85,0x96,0x7B,
+	0xA8,0xEB,0x52,0x1D,0xE2,0x27,0x4C,0xD0,0x22,0x2F,0xA5,0x51,0x05,0x64,0x2E,0x2A,0x6A,0x2C,0xFC,0x70,
+	0x7B,0x28,0x0B,0x89,0xEF,0xB3,0x52,0x6F,0x0C,0x2E,0x13,0x58,0xAE,0x63,0xEA,0xD6,0x18,0xED,0xA2,0x1E,
+	0xC4,0xCB,0x9A,0x33,0xF7,0x60,0xBC,0x3B,0xA4,0xD1,0xBA,0x3E,0xAE,0xA7,0x0A,0x94,0x6F,0xBF,0x0B,0x67,
+	0x23,0x2C,0xAC,0x27,0xEA,0x0B,0xED,0x71,0xEF,0x8B,0x98,0x39,0xCE,0xE2,0xA6,0xF8,0xD5,0x0D,0xD8,0xFF,
+	0xAD,0xCD,0x28,0x6C,0xA6,0x7D,0x15,0xC6,0x9B,0x12,0x6C,0xC2,0xFF,0xF6,0x55,0x09,0x84,0xCE,0x4C,0x28,
+	0xA2,0x3B,0x7E,0xB5,0x45,0xDC,0xB5,0x52,0xF1,0xF1,0x67,0x84,0xA3,0xF0,0xE3,0x35,0x59,0x51,0xC9,0xDE,
+	0x6D,0x8F,0xBC,0xE5,0xE8,0xF9,0x0C,0xF7,0x5E,0x08,0x0B,0xE6,0x9F,0x7C,0x63,0x10,0x0A,0x10,0xA7,0x5D,
+	0xDA,0x3C,0x67,0xF8,0xFA,0xA5,0xFA,0xE9,0xF8,0x85,0xF8,0x93,0x5E,0xF2,0xAA,0xE2,0xE2,0x10,0xCC,0x91,
+	0x8A,0x0E,0xB5,0xA7,0x07,0xBC,0x3A,0xC8,0x94,0x4E,0x94,0x9F,0xA5,0x7D,0x1C,0x38,0x07,0x1F,0xFB,0xFD,
+	0xD3,0x32,0x42,0x1E,0x0B,0x07,0xA8,0xA2,0x2C,0x7C,0x95,0xB7,0xD4,0x17,0xED,0x5F,0xB2,0x67,0x85,0x97,
+	0x6E,0x35,0x91,0x55,0xD7,0xD7,0x1B,0xEE,0xDB,0x08,0x87,0xFF,0x5A,0x77,0x4F,0x23,0xCF,0x48,0xCF,0xB5,
+	0xDD,0xFF,0xB1,0xDF,0xDC,0x9F,0xF0,0x38,0xD8,0x9A,0x6D,0x55,0x2A,0x06,0x1D,0x5A,0x4A,0xC9,0xBF,0x72,
+	0xAE,0x71,0xB9,0x2D,0xD0,0x79,0xEF,0x55,0x5C,0xA1,0x17,0xB8,0x19,0x61,0x8B,0xD9,0xFF,0x96,0xDB,0x6E,
+	0x93,0x9B,0x60,0x3D,0x9C,0x29,0x67,0x55,0x6B,0xB6,0x50,0xF1,0xDF,0xBF,0xE0,0xE0,0x4A,0x98,0x29,0xAF,
+	0x97,0xEA,0xE9,0x7E,0x7E,0x76,0x2C,0xDA,0x28,0x3F,0x73,0x3A,0x3D,0x76,0x3F,0x38,0x2F,0xD0,0xE1,0x3B,
+	0xB9,0x0D,0x54,0x8E,0xCB,0x1A,0x52,0xF4,0x89,0x17,0x0D,0xEB,0x59,0x87,0xD2,0xCD,0xDE,0xCD,0x16,0x38,
+	0x0E,0xE0,0xEE,0xB2,0xBD,0x3D,0x06,0x05,0x4C,0x4F,0x97,0x48,0x46,0x80,0x1A,0xEA,0x7D,0xCF,0xFB,0xB8,
+	0x12,0x53,0x69,0x4B,0x42,0xCA,0x82,0xD9,0x67,0xC0,0x7F,0x26,0x04,0xC1,0x7F,0x91,0xE0,0xAE,0x61,0x4B,
+	0xE2,0x3E,0x2F,0xD0,0xB4,0x4E,0x59,0xFC,0xA0,0xC0,0xC8,0x74,0xE8,0xE0,0x44,0x63,0x80,0x4F,0x49,0xCF,
+	0x9C,0xAF,0x2D,0x24,0xB6,0x3A,0x1D,0x68,0x36,0x0E,0xA9,0x22,0xF1,0xC7,0x20,0x51,0x5A,0x65,0x19,0xB2,
+	0x86,0x92,0x75,0x7B,0xFF,0xF5,0x2D,0x53,0xE7,0x7B,0xBA,0xFB,0xA9,0x88,0xE5,0x30,0x24,0x25,0x96,0x7A,
+	0xFC,0xD4,0x22,0x30,0x3F,0x6A,0x3C,0xA6,0x29,0x3A,0x69,0x4E,0x04,0xA2,0xB1,0x30,0xDE,0x2B,0x4F,0x8B,
+	0xE8,0x59,0xCC,0xF8,0x29,0x84,0xB6,0x57,0x81,0x5E,0x05,0x24,0xAB,0x21,0xD9,0x83,0x4F,0x54,0xC6,0x5A,
+	0x3C,0xE4,0x9A,0xEA,0x08,0x8C,0xF2,0xF5,0x6F,0xA8,0x9D,0xC2,0x35,0x85,0xA8,0x6E,0x46,0xA5,0xD1,0x12,
+	0xA8,0x76,0xFF,0xE3,0x9C,0x72,0xAA,0x58,0xBA,0xAC,0xE6,0xCE,0x55,0xA6,0xB0,0xE3,0x92,0xC7,0x7E,0xAA,
+	0xF7,0xA2,0x31,0xCD,0xB3,0xEA,0xA1,0xB5,0x7B,0xF1,0xEB,0xA2,0x8F,0xC9,0x58,0x9B,0xA8,0xF8,0x03,0xC4,
+	0x68,0x54,0xE2,0x3F,0x78,0x6B,0x0D,0xEA,0x5A,0x6C,0x1D,0x3D,0x2A,0x25,0xC5,0x6C,0xB9,0x71,0xD4,0x63,
+	0xD2,0x48,0x33,0x5A,0xA8,0xCC,0x68,0xAF,0x2B,0x5D,0x28,0x75,0xBC,0xB6,0x7A,0xFA,0x5D,0x91,0x33,0x42,
+	0xCE,0x03,0xC3,0xDD,0x42,0xA6,0x61,0xE1,0x35,0x53,0xF0,0x69,0xB5,0xE1,0xC8,0x77,0x53,0xFE,0xB5,0x72,
+	0x60,0xC1,0x38,0x7F,0xEC,0x8A,0xC3,0x95,0x73,0xE2,0x7D,0xFB,0x83,0x8B,0x33,0x84,0xE2,0x6B,0x6D,0x39,
+	0xC1,0x7F,0x4B,0x61,0x47,0x08,0x94,0x7A,0x48,0x6D,0x76,0x6E,0x35,0xF3,0xB0,0x5F,0xD4,0x8A,0xC2,0x54,
+	0x67,0xBC,0xE0,0xE5,0x5B,0x82,0x14,0x7A,0x46,0x07,0xBD,0xAB,0x41,0x7D,0x0D,0x38,0x97,0xF6,0xD5,0x9B,
+	0x58,0xDC,0xB6,0x91,0x69,0xA0,0x4F,0x4A,0xE7,0x48,0xA7,0xB5,0x3F,0xFC,0x3D,0x3E,0x83,0x65,0x49,0xB5,
+	0x02,0xBB,0x8C,0xC6,0x87,0x7B,0x20,0x75,0xD7,0x2B,0xEC,0x92,0x40,0x91,0x69,0xB9,0x56,0x65,0xEF,0x01,
+	0x1B,0xAA,0xC6,0x4A,0x80,0x08,0x9D,0xA5,0x29,0x10,0x51,0xB4,0x8A,0xB9,0x66,0x10,0x9E,0x79,0xCB,0x47,
+	0x8A,0x09,0xBD,0x3B,0x80,0xDA,0xF5,0xD3,0xBE,0x2A,0xD2,0x9C,0x3A,0x95,0xEB,0x95,0x08,0x2A,0x7F,0x13,
+	0x89,0x67,0x05,0x3B,0xE4,0x7B,0x83,0x57,0xDD,0x03,0xFE,0x2E,0x4F,0xB3,0x81,0x7C,0x3D,0x64,0x19,0x77,
+	0x3B,0x4A,0x00,0x4F,0x0D,0x06,0x06,0x21,0x6F,0xB4,0x26,0xED,0x9F,0xA3,0x84,0x3E,0x48,0xA1,0x45,0x2F,
+	0x89,0x88,0x0F,0x50,0xCF,0x33,0xD7,0xE9,0x46,0xCA,0x01,0xED,0x06,0xA4,0x41,0x1B,0x0C,0x74,0xA5,0xBD,
+	0x37,0xF4,0xA2,0x4F,0x6D,0x6F,0xBF,0xBF,0xD7,0x2D,0xB9,0xB9,0x93,0xB2,0x22,0x10,0x97,0x6C,0x50,0xF7,
+	0xF1,0x16,0x16,0x36,0x1A,0x10,0x44,0x09,0x5B,0x72,0x7B,0x42,0x94,0x99,0x98,0x37,0xAE,0xF0,0x1F,0xC7,
+	0x57,0x0F,0x15,0xEE,0xEF,0x3E,0x60,0x1C,0x7A,0x53,0x4F,0x31,0xC6,0xCE,0x7C,0x39,0xAF,0x12,0xEA,0xF9,
+	0xF0,0x9D,0xC7,0x01,0x53,0xF2,0xFF,0x6B,0xEB,0x44,0x96,0x66,0xEF,0x8D,0x54,0x0D,0xC3,0x4D,0xA8,0xDB,
+	0xA1,0x03,0x52,0x12,0xB2,0xDC,0x48,0x90,0x6F,0xF3,0x70,0x52,0xBA,0x4F,0xE6,0x32,0xB8,0x90,0xAD,0x7E,
+	0x4A,0x46,0x53,0xA0,0x67,0xA9,0xEE,0xE3,0x61,0x9D,0x6A,0x56,0xF2,0x93,0x13,0x13,0x13,0x09,0xB2,0xF7,
+	0x3D,0x9E,0x21,0xCB,0x4C,0x01,0x4A,0xC6,0x5D,0x6E,0x3E,0xE9,0x8D,0xA2,0xBE,0x91,0xDA,0xCE,0x58,0x74,
+	0x29,0x47,0x74,0x06,0xA1,0x01,0x68,0xBA,0xEA,0x16,0x92,0x14,0x7B,0x3F,0x38,0x26,0x9A,0x07,0xC3,0x50,
+	0x8F,0x14,0x91,0x32,0xA8,0x8F,0x88,0xE5,0xD6,0xE6,0x52,0x90,0xE8,0x46,0xE9,0x9E,0xD4,0x0F,0x53,0x53,
+	0x11,0x46,0xB7,0x9D,0x7A,0x3D,0x16,0x24,0x42,0x4A,0xFE,0x4D,0x3A,0x16,0x05,0x33,0x2A,0x0C,0xFA,0x73,
+	0x78,0x48,0x52,0x24,0x4B,0xA8,0x22,0x5B,0x56,0x37,0x0C,0x77,0x71,0xB6,0xDE,0xE1,0x19,0xF2,0xC5,0x39,
+	0x6D,0x9C,0xA5,0x0D,0xF8,0x96,0x06,0x32,0xAA,0x0E,0x38,0xBD,0x90,0x85,0x2D,0x79,0xEB,0x2A,0x27,0x4F,
+	0xD6,0x15,0x17,0x03,0x54,0xB6,0xF3,0x99,0xE4,0xAD,0x91,0x06,0x84,0x30,0xA0,0xB9,0xA7,0x39,0x18,0xB2,
+	0x62,0xFF,0xD4,0x2E,0x7A,0x2D,0x6F,0x2A,0xEB,0x11,0x3E,0xFE,0x12,0x66,0x1C,0xE4,0xE0,0x69,0xFF,0xD8,
+	0x0C,0x86,0x62,0x46,0x69,0xB8,0xCA,0x5C,0x4B,0xC0,0x3D,0x4F,0xE9,0xF9,0xBD,0x4B,0x7B,0xAD,0x7B,0x0B,
+	0x77,0x42,0x4F,0x7E,0xE6,0xBF,0xDB,0xFC,0x7C,0x63,0xD9,0x1D,0x70,0x6B,0x0F,0x36,0x36,0x33,0x01,0xED,
+	0x56,0xC9,0xC4,0x04,0xD4,0x8F,0xFA,0x21,0x53,0x10,0x4D,0x3B,0xC5,0xFF,0xFF,0x64,0x58,0x6B,0xD0,0xEF,
+	0xF5,0xD9,0xB6,0xA5,0x5B,0x9E,0xCA,0x58,0xBD,0x91,0x18,0x74,0x7D,0xB1,0xB1,0xE3,0x5B,0x50,0xD3,0x21,
+	0x5B,0x71,0xC7,0xA9,0x45,0xFD,0xB4,0xD3,0x7D,0xF4,0xAA,0xC4,0x48,0xBB,0xDB,0x65,0xB9,0x90,0xA7,0x39,
+	0xC2,0x73,0xBD,0x21,0x76,0x51,0x7A,0x7C,0x40,0xEB,0x8D,0xF5,0x93,0xB5,0x1B,0xB5,0xE3,0x59,0x2B,0xDF,
+	0x02,0xEF,0x01,0xB6,0xE9,0x26,0x9E,0xFF,0x35,0x6F,0x74,0x92,0xDE,0x59,0x7F,0xC9,0xAF,0x76,0x3B,0x81,
+	0x86,0x0D,0xDD,0x36,0x36,0xBB,0x68,0xA3,0x43,0x0B,0xD5,0x61,0xA6,0xB7,0x73,0x79,0xC2,0x13,0x93,0xE5,
+	0x33,0x98,0x65,0xCF,0xC1,0xA2,0xEA,0xCC,0x0F,0xA6,0xC6,0x09,0x22,0xC7,0xD4,0x7F,0x5A,0x9A,0x94,0x40,
+	0xBC,0x95,0x7E,0x39,0x99,0x63,0x00,0x1C,0x2F,0xAE,0xD0,0xA1,0xDB,0x92,0x20,0x0D,0x01,0x54,0xBD,0x7C,
+	0x61,0x69,0xB3,0xEB,0x57,0xB7,0xD3,0x8F,0x73,0x7B,0x6C,0xA1,0x0D,0xE5,0xB6,0x5B,0xFE,0x89,0x74,0xBE,
+	0x08,0xA4,0xDF,0xF7,0x3C,0x99,0xE0,0xCA,0x8F,0x19,0xA5,0x89,0x1E,0x69,0x38,0x2A,0x38,0x51,0x66,0xBE,
+	0x58,0x09,0x02,0xA7,0x97,0x20,0x16,0x1D,0xAF,0x3E,0xDE,0xAB,0x44,0x9F,0xCA,0x30,0xF2,0x06,0x59,0x02,
+	0x90,0x82,0xF6,0xFA,0xF6,0x18,0x5D,0xCB,0x60,0x11,0x07,0x18,0xC5,0x45,0x97,0x30,0xC6,0xAB,0x84,0xFF,
+	0x7B,0x1A,0xB0,0xAA,0x9D,0x73,0x6C,0x59,0xAC,0x1B,0x9F,0xE5,0x24,0x51,0xE7,0x6E,0xD9,0x80,0x8F,0x26,
+	0xD8,0x08,0xFE,0xA2,0xA8,0x0B,0xB0,0xA6,0x42,0x2B,0x09,0x29,0xF7,0xA2,0x82,0x9C,0xA4,0x03,0xD0,0xE7,
+	0x7F,0xA1,0x02,0xD9,0xF6,0xAD,0xE0,0x69,0x53,0x12,0x1B,0xF0,0xCD,0x84,0x75,0x87,0xFF,0x21,0x84,0x25,
+	0x70,0xA6,0x32,0xFF,0x2D,0x7A,0xD6,0x60,0xCC,0xEF,0x97,0xB6,0xB4,0x42,0xF9,0xB3,0xD1,0xC9,0x0C,0x77,
+	0xBF,0xF8,0x5E,0xFF,0xD8,0x2B,0xDA,0xF6,0xAE,0xE6,0xB0,0xBB,0x6A,0x31,0x63,0x95,0x22,0x69,0x16,0xEE,
+	0x23,0x70,0x28,0x9A,0x09,0xA8,0xB8,0x6E,0x88,0xCB,0x54,0xE5,0x38,0xEF,0xB6,0x30,0xF0,0x50,0x2F,0xBA,
+	0x7F,0x4C,0xF2,0x99,0x3D,0x19,0x8F,0x5E,0x3F,0x57,0xB7,0xAF,0x87,0x7A,0x92,0x70,0x36,0xCB,0x41,0x9C,
+	0x44,0xCA,0x74,0x4C,0xAF,0x12,0xC5,0x4A,0x08,0xAC,0x98,0xE1,0xE4,0x0B,0x33,0x59,0x0D,0x4F,0xD2,0x58,
+	0xA3,0xAA,0x6E,0x47,0xFA,0xEC,0x19,0xBA,0x1B,0x90,0xAA,0x2B,0x04,0xED,0x53,0xFE,0x65,0xAB,0x54,0x78,
+	0xC5,0xC8,0x90,0xBF,0x60,0xC9,0x37,0x2E,0xB3,0xEA,0x64,0x71,0xDA,0x39,0x13,0xE4,0x64,0x23,0x8B,0x6D,
+	0xF5,0xC8,0xAD,0xC6,0xCD,0x8A,0x6C,0xA0,0xDB,0x38,0x74,0xF7,0xE5,0x7F,0x05,0x34,0xC8,0xA6,0x8B,0xA8,
+	0xEF,0xF3,0x67,0xEA,0x35,0x30,0xB9,0x7E,0xE6,0x7E,0x23,0xD3,0xEA,0xA2,0x55,0xFE,0x14,0x9C,0x84,0x43,
+	0xF3,0xE0,0xD8,0xFA,0xF8,0x21,0x62,0x3C,0xD1,0xEC,0x1B,0x09,0x4C,0x02,0x33,0xD7,0xFF,0xE3,0x79,0xA4,
+	0x64,0xA7,0x5F,0x20,0x3C,0x02,0x1B,0x2D,0x44,0x8D,0x85,0xDF,0x2B,0x1E,0xE4,0x67,0xD9,0x64,0xFD,0x99,
+	0xD1,0xA2,0xE3,0x2E,0x95,0xDF,0xEE,0xA7,0x12,0x3F,0xEC,0x63,0xD4,0x9D,0x34,0x72,0x33,0x52,0xEA,0x82,
+	0x6D,0x6E,0x6B,0x87,0xD4,0x0E,0x85,0x9D,0x28,0xD0,0x2F,0x67,0xA4,0xF0,0x81,0xD8,0x47,0x7F,0x35,0x77,
+	0x75,0x5F,0x15,0xE8,0x24,0x9E,0x16,0xB4,0x54,0xA8,0x07,0x02,0x83,0x4C,0x83,0x0B,0xDB,0x2C,0x83,0xE6,
+	0xCF,0x67,0x24,0xDA,0x11,0x0B,0x4C,0x0D,0xE5,0xD9,0xF2,0xE0,0xBD,0xB0,0x56,0xF6,0xD3,0x06,0x8A,0x34,
+	0x36,0x85,0x14,0x90,0xE5,0x19,0x5C,0x94,0xBD,0x04,0x77,0xC2,0x4D,0xBE,0x09,0xB8,0x6C,0x6B,0x8C,0x21,
+	0x47,0xE9,0x75,0x76,0x7A,0x54,0xDA,0x6A,0xD4,0x97,0x2D,0x1B,0x3F,0x6A,0x11,0x77,0xBC,0x86,0x95,0xF1,
+	0x74,0x93,0x9D,0xC8,0x8D,0x65,0xC1,0xE8,0xCB,0xA8,0xE9,0x2A,0x1B,0xAD,0xEC,0x2E,0x00,0x57,0x99,0xCF,
+	0xCC,0x06,0x85,0xE5,0x67,0xB2,0x04,0x25,0x96,0x54,0xC0,0xB9,0xDC,0xB8,0x0F,0xE9,0x58,0x52,0x1F,0x74,
+	0x6D,0x67,0xF7,0xD3,0x68,0xB6,0x17,0x5F,0x42,0x29,0x50,0x76,0xA1,0xD9,0xAB,0x07,0x44,0x1A,0xDC,0x41,
+	0x04,0x38,0xC1,0x17,0x51,0xF6,0xE6,0xD3,0xD0,0x48,0x41,0x2C,0x38,0x6C,0x16,0xBC,0xBF,0xD1,0x8E,0xC9,
+	0x83,0xF3,0x50,0x7B,0xED,0x9D,0x20,0x99,0xFD,0x4D,0xD4,0xB5,0xCE,0x7E,0x6E,0x7C,0x7E,0x90,0x37,0xD4,
+	0x84,0xF0,0x56,0xDE,0xF1,0x13,0x61,0x4A,0x4D,0xD8,0xF1,0xD6,0x7E,0x2B,0x51,0x7B,0x6D,0x0F,0xE7,0xCD,
+	0x9B,0x10,0x2F,0x19,0xCB,0x52,0x40,0x1D,0xDB,0xFF,0xA3,0x38,0xDC,0xB1,0x78,0x20,0xF1,0x3B,0x03,0xDD,
+	0xD2,0x9B,0x5B,0x42,0xA7,0x0E,0xA9,0xB0,0x9D,0x22,0x29,0x90,0x44,0xA1,0x08,0x19,0x45,0x60,0x19,0xB6,
+	0xC0,0xF8,0x22,0x3D,0x58,0xF3,0xD9,0xE3,0x96,0x8B,0xB4,0x25,0xF5,0x59,0xC8,0xA2,0x16,0x6A,0x69,0x47,
+	0xE5,0x0E,0x49,0x88,0x45,0x62,0x9E,0x91,0xF1,0xAB,0x22,0xD7,0x30,0x65,0xEF,0xC4,0x21,0x69,0xA7,0xAC,
+	0x80,0xE9,0xC0,0x91,0xE1,0x04,0x0F,0xE4,0xA2,0x85,0xDF,0xA3,0x87,0x88,0x70,0xCB,0x70,0x21,0xF8,0x63,
+	0xE0,0x21,0x01,0x74,0x55,0xAC,0x49,0x58,0xE1,0x60,0x3E,0x02,0xA1,0xDE,0x6F,0xB4,0x22,0xE9,0xE6,0x4D,
+	0x6E,0x8D,0x1B,0x7F,0x68,0x63,0x09,0xB5,0x04,0x2D,0xC9,0x02,0xAC,0xE6,0x6B,0x06,0xB7,0x6C,0x5A,0xD9,
+	0xE3,0x40,0xE2,0x46,0x69,0x25,0x4B,0xCC,0xED,0xB7,0xBB,0x40,0xFB,0x29,0x9D,0x36,0x7D,0xB2,0x06,0x7A,
+	0x3A,0x2B,0xFD,0xBC,0x6E,0x1F,0xA4,0xC8,0xE6,0x32,0x25,0xFC,0x85,0x7F,0x78,0x6D,0xD2,0x31,0xBF,0xC1,
+	0xAD,0x07,0x48,0x03,0xA7,0x2C,0x6A,0xE1,0x15,0x49,0xD2,0x49,0x3C,0xD4,0x13,0x90,0x4B,0xA7,0x9B,0x4F,
+	0x22,0x29,0x18,0x49,0xA9,0xFC,0xC4,0xA4,0x27,0x81,0xCF,0xF8,0x82,0x35,0x71,0x48,0x25,0x6E,0xDF,0x69,
+	0x73,0xAC,0x10,0x68,0x39,0x1C,0x24,0xD8,0xA0,0x6E,0xEC,0x81,0x59,0xB6,0x57,0x7B,0xAE,0xA3,0x56,0xAB,
+	0xBE,0x8A,0x2B,0x7B,0xEE,0xC3,0x08,0x42,0xDC,0x25,0x73,0x69,0xFA,0xA0,0x4B,0x4C,0xFF,0x8D,0x25,0x55,
+	0x22,0x1E,0x6E,0xF9,0xD2,0xA1,0x54,0x87,0x4B,0x1F,0xC3,0x6C,0x2F,0x72,0xB8,0xC7,0xBE,0x62,0xF5,0xE4,
+	0x73,0xFB,0xA1,0xEA,0xF9,0x1E,0xEC,0xBB,0x0D,0x3C,0x46,0x6C,0x55,0x4E,0xA6,0x04,0xC5,0xDE,0x85,0xFE,
+	0xA6,0x10,0x1C,0xF7,0xB3,0xF0,0xA9,0x3F,0xE1,0xC2,0x75,0x98,0x1B,0x36,0xCD,0x8D,0xF2,0xE3,0xF6,0xB2,
+	0x10,0x8C,0x27,0x57,0x63,0xBF,0x39,0x45,0xF9,0x7C,0x6A,0x33,0xAE,0x55,0xFB,0xB4,0x6E,0x3D,0xCD,0x4C,
+	0x8B,0xBF,0x54,0x64,0x4B,0x72,0x32,0xD6,0xC2,0x96,0x5E,0x36,0xD3,0x94,0x66,0x41,0x41,0xFA,0x5B,0x0B,
+	0x40,0xF5,0x1F,0x27,0xCA,0x47,0xCC,0xB6,0xDD,0x92,0x43,0x40,0x09,0x75,0x7F,0x86,0xF4,0x85,0x63,0x22,
+	0x2F,0x56,0xF5,0x2A,0x5A,0x38,0x0D,0xB6,0xD0,0xAF,0x1D,0x75,0xED,0x35,0x26,0x4E,0xDC,0x1B,0xE4,0x8C,
+	0xC9,0xBE,0x78,0xCA,0x2A,0x57,0x29,0xCC,0x66,0xD3,0x55,0x98,0xE1,0x7A,0xC1,0x18,0x0C,0xB4,0x46,0xDE,
+	0x4A,0x98,0x1D,0x38,0x5A,0x85,0xB0,0x28,0x50,0xF1,0x07,0xCD,0xF4,0x21,0x96,0xAB,0x3D,0x41,0xEF,0xA9,
+	0x18,0xFB,0x5A,0x68,0x9F,0x3B,0x87,0x89,0x3B,0x27,0x7F,0xEE,0x22,0x56,0x5F,0x5D,0x54,0x73,0x1C,0xB2,
+	0x42,0xCD,0x12,0x32,0xC7,0xBD,0xEE,0x7B,0x12,0xF1,0x01,0x57,0x7C,0x7E,0xE4,0x2B,0xA7,0x5C,0x6B,0x2F,
+	0x57,0xC9,0x16,0xE0,0x82,0xCC,0xDE,0x8E,0x48,0x09,0x39,0xCF,0x4B,0x9D,0xA6,0x32,0x4F,0xBD,0x44,0x6D,
+	0xC9,0x40,0xF3,0xED,0xFA,0x7E,0x71,0xB0,0x61,0x06,0xDE,0x23,0x42,0xBE,0xA7,0xF1,0x02,0xEE,0x25,0x7F,
+	0x3E,0xC1,0xBA,0x8E,0xE5,0x7F,0xF8,0x12,0x27,0x79,0x5E,0x40,0xFB,0x4D,0x2B,0xAB,0xB5,0x1F,0x60,0x3A,
+	0xCD,0x70,0xF1,0x42,0xE8,0xEE,0x70,0x0B,0xAC,0x0A,0xF0,0x4E,0xA8,0xA3,0x9E,0x44,0x4E,0x69,0x19,0x58,
+	0xC9,0x5E,0xC8,0x4D,0x49,0xB4,0x0E,0x60,0x1E,0x29,0x89,0x00,0xF1,0xE7,0xF0,0x52,0x30,0xAA,0x2B,0xCC,
+	0x3A,0x4E,0xE1,0x7C,0x74,0x7C,0xC0,0x30,0x64,0x28,0x72,0x35,0x72,0xC8,0xDC,0xF1,0x21,0xCE,0xA9,0x69,
+	0xB3,0x88,0xCC,0x24,0x67,0x82,0x48,0x24,0x75,0xA1,0x40,0x8D,0xAE,0xC6,0x7A,0xF4,0x92,0xC8,0x1F,0x44,
+	0xA2,0x9D,0x25,0x77,0x31,0x09,0x3A,0x10,0xEC,0x67,0x93,0xE7,0xD5,0x94,0x17,0x55,0x66,0x04,0x97,0x50,
+	0x36,0x18,0xAD,0x8D,0x3A,0x46,0xA0,0x78,0xD1,0x34,0x7C,0xE8,0x08,0x75,0x3A,0x8C,0xA0,0x09,0x60,0xD5,
+	0xBB,0x7D,0x06,0x4C,0xA7,0xF3,0x51,0x3D,0xAC,0x36,0xD5,0xD9,0xDF,0xA9,0x3D,0x85,0xF8,0x68,0x85,0xB1,
+	0x3E,0xED,0xE3,0x8B,0x11,0x87,0x9B,0xF5,0x30,0xA7,0xED,0xD3,0xCC,0x88,0xD2,0x59,0x63,0x84,0x0D,0xBA,
+	0x09,0x2F,0x90,0x8D,0x99,0xA3,0x03,0x0B,0xC6,0xF4,0xC2,0x45,0xBC,0xEF,0x4C,0xB9,0x82,0xCD,0xDC,0x7A,
+	0x3C,0xA1,0x32,0x95,0xBB,0x4F,0x4E,0x11,0x62,0x13,0x7C,0x38,0x6F,0x8E,0x6D,0xA5,0x9F,0x2D,0x21,0x7A,
+	0x70,0x5C,0xAF,0x85,0xAE,0xFE,0x5D,0x76,0xE6,0x83,0x65,0x34,0x5F,0x24,0x86,0x95,0x36,0x25,0x48,0xC3,
+	0x29,0x53,0x15,0x5D,0x6E,0x0C,0xC4,0x8F,0xC3,0x13,0x25,0x3B,0xBB,0x8D,0x80,0xFD,0x1A,0xC2,0x91,0x26,
+	0x22,0x4A,0x39,0x76,0x3C,0xBF,0x6C,0xB2,0x8D,0xDB,0xB3,0x56,0xFE,0x01,0x24,0xE0,0xDE,0x64,0x26,0xF0,
+	0xCA,0x3B,0x61,0x54,0x56,0x5A,0x0D,0x45,0xF9,0x7A,0xD8,0x81,0xAE,0xE9,0x1E,0xE7,0xA6,0xA9,0x2D,0xB3,
+	0x05,0xC9,0xCB,0xA1,0x15,0x71,0x79,0xAD,0x87,0xD1,0x2A,0xF7,0xF5,0x4F,0x85,0xE1,0xA6,0x23,0xB9,0x55,
+	0x1C,0x38,0x9B,0x2A,0x34,0xD9,0xA0,0x3D,0x01,0xC1,0x8C,0x0A,0x5B,0x79,0xAD,0x75,0x70,0x27,0xFC,0x23,
+	0x84,0x65,0xB2,0x73,0x37,0x1A,0x77,0x94,0xAD,0x24,0x7D,0xB6,0x6F,0xB7,0x9E,0x84,0x5B,0x40,0x38,0x47,
+	0x5F,0x5D,0xE4,0x05,0x69,0xCD,0x49,0x20,0xF0,0xF4,0x4F,0x25,0x4E,0x66,0xBF,0x53,0xD2,0xBE,0x43,0xCF,
+	0xE1,0xDC,0x2A,0xEF,0x08,0xEC,0x78,0x7F,0xAE,0x54,0xEC,0x6C,0xE1,0xA3,0xC9,0x42,0x57,0x95,0xF4,0x50,
+	0x81,0x94,0x10,0x6F,0x92,0xC2,0xB5,0x7C,0x0E,0x71,0x67,0x5B,0xC8,0x26,0xC6,0xBA,0x80,0x7C,0xB5,0xE9,
+	0xEE,0x95,0x6C,0xE9,0x3E,0xA6,0x9B,0x34,0xEF,0x8A,0x54,0x6F,0xAE,0x51,0x2F,0xA0,0xD5,0x0E,0x10,0x79,
+	0x99,0xA0,0x66,0x52,0x48,0x2A,0xAD,0x3B,0xFB,0xF0,0x38,0x28,0x72,0x18,0x3D,0xE1,0x41,0xBE,0x1F,0xAA,
+	0x7A,0x71,0x90,0x6A,0x7C,0x57,0x95,0xFD,0x8E,0x62,0xEE,0x27,0x7F,0xFF,0xE9,0x1C,0xA7,0x8C,0x79,0x16,
+	0xAD,0xB0,0xF7,0x38,0x22,0x93,0xD9,0x3A,0x01,0xE5,0xE4,0x0D,0xFE,0x73,0x37,0x8F,0xFE,0xF4,0x51,0x13,
+	0xC7,0x92,0x74,0x87,0xC8,0xCA,0xEA,0xEA,0xDB,0xDB,0xFD,0x19,0x5A,0x79,0x04,0x40,0x18,0x12,0xBB,0x74,
+	0x90,0x3F,0xD0,0x4D,0x9F,0x02,0xA8,0xF4,0xA7,0x6F,0x32,0xF8,0xD3,0x4E,0x18,0x96,0xD4,0x0F,0xA0,0xC1,
+	0xE2,0xB2,0xD2,0xCF,0xF2,0x23,0x5B,0x15,0x27,0x43,0x3A,0x75,0x10,0x34,0x88,0xC6,0xF3,0xE0,0xF1,0x64,
+	0x29,0x6F,0x99,0xED,0x01,0xF8,0xB1,0xEF,0x3D,0x2E,0x2B,0xCE,0x35,0x4C,0x87,0xF2,0x51,0x53,0x10,0xD8,
+	0xA1,0x02,0xE8,0x86,0xC6,0xA7,0xDB,0x80,0x52,0x06,0x7F,0x0A,0x8F,0x26,0x30,0xD2,0x83,0x9C,0xEF,0xE1,
+	0xFA,0x76,0xB0,0xF1,0x67,0xC8,0xF5,0x85,0xF0,0x25,0xC9,0x80,0xE1,0x66,0x66,0xF4,0x42,0xE5,0x86,0x7B,
+	0xC3,0x36,0x8F,0x0C,0x4B,0x9B,0x71,0xAE,0x42,0x65,0x97,0xB7,0x97,0xA2,0x00,0x6F,0x24,0x57,0x64,0xF7,
+	0x6F,0x16,0xA2,0x8A,0xCD,0xE9,0xFD,0x2B,0xB9,0xF7,0xD2,0xCD,0x46,0x0A,0xCB,0x35,0xFD,0xEF,0x24,0x76,
+	0xE0,0x10,0x4A,0x9C,0x20,0x2F,0xA2,0x6A,0x67,0x2A,0xBF,0xFA,0x5B,0x25,0x59,0x0B,0x2B,0x0C,0x37,0x6F,
+	0x67,0x6B,0x44,0xA1,0xFB,0x88,0x13,0x28,0xDE,0xC2,0x73,0xE0,0x81,0xB6,0x21,0x52,0x38,0xF4,0x51,0x7B,
+	0x88,0x48,0x1A,0x7B,0xD1,0x6A,0x86,0xCD,0x49,0x2C,0xD4,0xFD,0xE5,0x81,0xA8,0x2E,0x40,0x0D,0x12,0x00,
+	0xA8,0xB0,0xF5,0x0A,0x05,0x87,0x28,0x43,0xD5,0xA0,0x45,0x98,0x14,0x4B,0xB3,0x97,0xE4,0xC6,0x23,0x0D,
+	0xD9,0x01,0xBB,0xFC,0xF8,0x81,0x93,0xF9,0x82,0xC7,0x7F,0xE8,0x0F,0x0C,0xCF,0x7E,0x28,0x09,0xB5,0xCE,
+	0xF0,0xA9,0xF1,0xD9,0x6A,0xB0,0xA3,0x79,0x2A,0x69,0x3C,0x7A,0x43,0x2D,0xDE,0x3B,0x5A,0x81,0xEF,0xA8,
+	0xC5,0xAF,0x54,0x1D,0x46,0x6B,0x5E,0xC3,0xCA,0x75,0xF5,0xB3,0x90,0x0E,0xAD,0x32,0x43,0xE1,0x24,0x4B,
+	0x77,0x5A,0x12,0x72,0x24,0x9F,0xFB,0x82,0x94,0x3F,0xD5,0x40,0x43,0x1E,0x10,0xC3,0x07,0x62,0x35,0x7E,
+	0x2C,0x8E,0x39,0xF7,0x06,0x56,0x47,0xB0,0x42,0x11,0xE5,0x5D,0xFB,0x3E,0xBF,0xBF,0x11,0xF4,0xA6,0xC4,
+	0xD9,0xA0,0x88,0xBF,0xC1,0x31,0xEA,0x06,0x00,0xAB,0x88,0x1A,0x98,0xBA,0xAD,0x74,0xE5,0x8A,0x68,0x92,
+	0xD8,0xD4,0xB1,0xC8,0x75,0x3E,0xEE,0x86,0xAC,0xCA,0x9B,0xCA,0xBE,0x78,0xEA,0x03,0x60,0x9A,0x45,0x97,
+	0x05,0xFD,0x1A,0x3C,0xA1,0x4C,0xE4,0xBA,0x22,0xF2,0x51,0x02,0x67,0xDA,0x3D,0x97,0xD2,0x66,0xE3,0x72,
+	0x4B,0x45,0xBE,0x63,0x89,0x79,0x48,0x65,0xEA,0x5B,0x69,0x2E,0x5A,0x48,0x5C,0xCB,0xC2,0x7D,0x4E,0x78,
+	0x8A,0x3F,0xAA,0x48,0x49,0x56,0x9D,0xA4,0xDC,0x7F,0x10,0x7A,0x2C,0x97,0x58,0x8D,0xCF,0xBA,0x56,0x59,
+	0x50,0x55,0xEF,0x45,0xFE,0x79,0x34,0x7B,0xF1,0x90,0x87,0x3A,0xDA,0x1B,0x7F,0x19,0xE5,0xD0,0xCF,0xA0,
+	0x5A,0x7D,0xF3,0x31,0x2A,0x87,0xB4,0xC4,0xDE,0x9B,0x04,0xBE,0x81,0x38,0xC4,0x16,0x89,0x7F,0x4A,0xAA,
+	0xC2,0x1E,0xCF,0xEA,0xC3,0xC6,0xEA,0x9A,0x94,0x1F,0xE5,0x79,0x75,0x1F,0x3F,0x34,0xA2,0x5C,0xF6,0x64,
+	0x5E,0xAB,0x97,0x68,0xE8,0x81,0x69,0xE9,0x1B,0xE1,0x59,0xBB,0x54,0xB2,0xCF,0x1F,0x38,0x79,0x1B,0xCF,
+	0xED,0x3D,0x95,0x60,0x00,0x7C,0x8C,0x90,0x48,0x8A,0x14,0x64,0xAB,0xFC,0xCD,0x19,0x2B,0x3B,0xB4,0x2A,
+	0x52,0x6B,0x8C,0x35,0xA4,0x1E,0xD1,0x32,0xA6,0xDC,0x02,0xC1,0x52,0xB4,0xDA,0x3A,0x54,0x8E,0xAD,0x1C,
+	0x00,0x56,0x1A,0x49,0x75,0x9D,0x35,0xA7,0xAF,0x14,0xEA,0x54,0xE1,0x8E,0x73,0x26,0xFD,0x2C,0x3E,0xE8,
+	0x20,0x70,0xE7,0xC8,0xBA,0xE3,0x79,0xC6,0x28,0xA1,0x40,0xAB,0xA7,0x0E,0x60,0x55,0x74,0x72,0x10,0x34,
+	0x43,0xC9,0x45,0x4B,0x50,0xBD,0x10,0x76,0x34,0x33,0x8F,0xA7,0xC5,0xE5,0x87,0xF6,0x4D,0x3D,0x53,0xF3,
+	0xC4,0xDA,0xE7,0xC1,0x83,0xCF,0xC7,0xF6,0x48,0x09,0xEE,0x83,0x98,0xCB,0x82,0x39,0x5B,0x84,0xD1,0xA0,
+	0xFB,0x97,0x97,0x61,0x7C,0x42,0x06,0x54,0x66,0xC1,0x86,0x28,0x6A,0x1B,0x82,0x78,0x6E,0x44,0x59,0x65,
+	0x66,0x17,0xF2,0xDB,0xF8,0x8A,0x7F,0xBB,0x7E,0xE8,0x8D,0x1C,0xD9,0xED,0xEA,0x77,0x7E,0x36,0x82,0xB8,
+	0x6F,0xF9,0x7A,0x3E,0x19,0xAB,0x5D,0x0C,0x7D,0x85,0x9A,0xB7,0x6F,0xEA,0x64,0x87,0xFF,0xE8,0x37,0xAB,
+	0xBB,0x5A,0x9F,0x3C,0x2C,0x2A,0xBD,0x23,0x76,0xEF,0x43,0xD3,0xD1,0x86,0xF7,0x20,0x5D,0x15,0xDA,0xB9,
+	0x2C,0x2D,0xBC,0x7D,0x0E,0x03,0x5B,0x8B,0x97,0xC3,0x32,0x9F,0x67,0x11,0xBE,0xA4,0xF2,0x0C,0xD4,0xEB,
+	0xD5,0xFE,0xBA,0xFB,0x45,0x32,0xC9,0x9C,0xE6,0x42,0x5B,0xB4,0x67,0x7F,0xD1,0x09,0x0C,0xC2,0xC7,0x10,
+	0x6D,0x33,0x8D,0x8D,0x3E,0x51,0xCF,0xA4,0x6E,0x5C,0x95,0x44,0x76,0x6C,0xCF,0x19,0x4D,0xD3,0x83,0x4D,
+	0xA7,0x10,0xA0,0xBF,0xDB,0x1D,0xDC,0x6E,0x6C,0xFD,0x30,0x40,0xE3,0xA0,0xE4,0xBF,0x95,0xFF,0x4C,0xC1,
+	0x86,0x3C,0xA4,0x66,0x78,0xBE,0x83,0x83,0xC4,0x2E,0xDC,0x16,0x2D,0x7A,0xF6,0x7D,0x24,0x75,0xFD,0xAB,
+	0x36,0x96,0xDD,0x9C,0xC0,0x0D,0x95,0xAF,0x09,0xBD,0x30,0x71,0x96,0xD7,0x19,0x67,0xFC,0xBC,0x86,0x16,
+	0x12,0x58,0xB9,0x55,0x77,0xF7,0xF3,0x46,0x58,0xC6,0x53,0xE2,0xE7,0x09,0x98,0x22,0x28,0x5F,0x66,0x62,
+	0x36,0x6B,0x35,0xCC,0xFA,0x5A,0x51,0x52,0x02,0x72,0x46,0x42,0xA2,0x7A,0x43,0xB1,0xAD,0xFD,0x5D,0x3C,
+	0x0A,0x9B,0xCE,0x88,0x4B,0xCA,0x79,0xCA,0x0D,0x92,0xCA,0x87,0xFE,0x44,0x6C,0xAC,0x40,0x3A,0x46,0x90,
+	0xB9,0x6B,0xD9,0x91,0xE1,0xF5,0x78,0x88,0x78,0x61,0x9C,0x75,0x2A,0xB3,0x12,0x7E,0x33,0xB7,0x76,0x97,
+	0x87,0x9C,0x2B,0xCC,0x83,0x9A,0xD4,0xBE,0x1E,0x7D,0xF4,0x1E,0x9E,0xDC,0x9A,0xD8,0x49,0x06,0xDE,0xFA,
+	0x62,0xF6,0x85,0x63,0xD7,0x67,0x13,0x9F,0x1F,0xDF,0x6D,0x04,0x9A,0x75,0x73,0x2A,0xBF,0x9A,0x95,0x60,
+	0xD2,0xBB,0xD7,0x1D,0xB8,0xD3,0x8B,0xD9,0x62,0x6D,0x00,0x6F,0xB1,0xFD,0x36,0xFA,0x2A,0x23,0x22,0x04,
+	0x85,0xE3,0xF9,0x6E,0x2C,0x95,0xBE,0xFA,0xFE,0xEC,0xB1,0x5A,0x58,0xE8,0x45,0x99,0x31,0x61,0xC1,0x18,
+	0x4B,0xB3,0x7D,0x40,0x3F,0x81,0x5D,0x7A,0xD2,0x01,0xDC,0x4B,0x8B,0x79,0xC3,0x95,0x4D,0xBB,0x48,0x96,
+	0xDF,0x7E,0xAF,0xA3,0x2B,0x62,0x2B,0x15,0x04,0x00,0x3F,0xC4,0xE7,0xB3,0x50,0x81,0x22,0xBE,0xC0,0xBD,
+	0x50,0x81,0x34,0x6B,0xB3,0x62,0xA4,0x42,0xBF,0xED,0xEE,0xBB,0x3B,0xD6,0x88,0xEE,0xE0,0xB2,0xF0,0x33,
+	0xF8,0xF0,0x63,0x17,0xE0,0xFE,0x2A,0xC7,0xBD,0xCA,0x48,0xFE,0x75,0x81,0xD2,0x0A,0x79,0x93,0x9B,0xA5,
+	0xCA,0x60,0x90,0xD6,0x02,0xCD,0x76,0x63,0xF3,0x9C,0xF1,0x1C,0x89,0x27,0xD9,0xD4,0x3C,0x45,0xAF,0x39,
+	0x3A,0xE6,0xC6,0x40,0x02,0x04,0x6C,0xD6,0x5A,0x2C,0x42,0x9E,0xA9,0x87,0x8E,0x8B,0x54,0xCF,0x5B,0x50,
+	0x03,0x25,0x4D,0xD0,0x1D,0x68,0x0E,0x37,0x89,0x8E,0xDB,0xD4,0xE0,0xDA,0x07,0x41,0x82,0x06,0x6F,0x36,
+	0xD3,0x2F,0x6B,0x92,0xA8,0xEB,0x2C,0xF4,0xB9,0x19,0x50,0x51,0x83,0xC7,0xF7,0x05,0xEE,0x2C,0x11,0xD9,
+	0x2A,0x04,0x87,0x9A,0xC5,0xF3,0x5B,0x1F,0x0E,0xDB,0xB1,0x28,0xC4,0x99,0xB8,0x62,0x4E,0x6A,0x3A,0xA6,
+	0xA1,0xB4,0x8B,0x58,0x0D,0x67,0xBD,0x00,0xE5,0x99,0x12,0x3D,0x36,0x69,0x36,0x99,0x8C,0x0A,0xB8,0xCE,
+	0x8E,0x08,0xA4,0x31,0x04,0xDB,0x28,0xAD,0xC6,0x49,0xA8,0x73,0xEB,0xAA,0x9B,0x9B,0x4C,0xB5,0x4B,0xEC,
+	0x4C,0x97,0x8B,0x06,0x80,0x09,0x30,0xF7,0x62,0xC4,0x26,0x48,0x0A,0x5E,0xC6,0x32,0x39,0x4C,0x40,0x78,
+	0xB5,0xC1,0x29,0x77,0xA5,0xC7,0x21,0x58,0x0B,0x97,0xCE,0x78,0xCA,0xD0,0xD2,0x78,0x83,0x8E,0x5E,0x8D,
+	0xE4,0xED,0x33,0x49,0x8A,0x8C,0x1C,0x4D,0xBE,0xD5,0x05,0xC8,0x3D,0xE5,0x2E,0xC4,0xF8,0xB1,0x72,0xDB,
+	0x4E,0xA2,0xE0,0xD9,0xB0,0xEB,0xD7,0x56,0xA9,0x1A,0x85,0x92,0xDD,0xC4,0xD7,0xFE,0x26,0xE3,0x93,0x7F,
+	0xC5,0xA3,0xCA,0x60,0x35,0xFD,0x3F,0x66,0xF3,0x36,0x5F,0xD0,0x7D,0xBC,0x73,0xEE,0x37,0xAB,0x2E,0x4F,
+	0xD8,0xCA,0x98,0xB5,0x79,0x51,0x06,0xC6,0xA6,0xE1,0xFE,0xFE,0xD8,0x3F,0x80,0xB2,0x8F,0x5D,0x22,0x81,
+	0xF8,0x72,0x55,0x56,0x63,0x33,0xB2,0x6B,0x1D,0x3E,0x1D,0x8C,0x1E,0xCE,0x62,0xB4,0xF1,0x73,0x7C,0xF1,
+	0x83,0xEB,0xBC,0x2C,0x34,0xC9,0x2A,0x41,0x2A,0xF7,0x94,0x15,0x08,0x54,0x74,0x2B,0x54,0x95,0xB4,0x3C,
+	0x2F,0x78,0x22,0xA0,0x88,0x3D,0xE6,0x0B,0x75,0x55,0x7A,0xF0,0x03,0xB7,0x3D,0x47,0x90,0xC6,0x75,0xA2,
+	0xC6,0xDB,0x8A,0xE5,0x81,0x78,0x17,0x0D,0xDB,0x55,0x36,0xDD,0x16,0xC8,0x07,0x5C,0x8B,0x3F,0xE7,0x1D,
+	0x3F,0xBC,0x4E,0x9C,0x1B,0x90,0x79,0x4B,0xA6,0xE5,0x40,0x4A,0x9F,0xA5,0x96,0xAD,0x87,0x87,0xE2,0xBC,
+	0xA4,0x58,0x37,0xC2,0xE4,0x44,0xCA,0x42,0x6F,0xEA,0x61,0x43,0x8E,0x86,0xBF,0x3B,0xA0,0x5A,0x66,0xCD,
+	0xFC,0xE6,0x01,0xCB,0x13,0x87,0x97,0xAD,0x07,0x7A,0xA8,0xC9,0x40,0x93,0x20,0xEE,0xCD,0x9A,0x52,0xDB,
+	0x02,0xEA,0x9B,0xBD,0x06,0x84,0xDF,0x12,0x8B,0x83,0x06,0x2D,0x99,0x7E,0x28,0xEE,0x8B,0xDF,0xDF,0x6E,
+	0xC6,0x7E,0xA2,0x42,0x2A,0x9D,0x0F,0x1C,0x3F,0x71,0xA1,0x0A,0x4A,0x4D,0x86,0x5C,0xF9,0x08,0x87,0xA5,
+	0x31,0x13,0x91,0x81,0xBC,0xB5,0xFD,0x1A,0x66,0x53,0xEF,0x12,0x9B,0xB6,0x92,0xD8,0x2B,0x5F,0x09,0x5F,
+	0x3B,0x84,0x9F,0xB1,0xEB,0xA2,0x1F,0x9F,0x0C,0x82,0x18,0xE8,0xA8,0x8D,0x1F,0x5D,0xC5,0x7D,0x39,0x22,
+	0xB9,0x69,0x97,0x38,0x84,0x4B,0x9C,0x70,0xBA,0x9C,0x57,0x6C,0x13,0x3B,0xB2,0xB6,0x54,0xC1,0xE8,0xA8,
+	0xAE,0x4C,0x5C,0x24,0x25,0xDD,0x8A,0x7C,0xFC,0xAF,0x3B,0x43,0xD0,0x37,0x14,0x23,0x53,0xF4,0x01,0x71,
+	0xB6,0x25,0x96,0x31,0x78,0xC1,0x86,0x42,0x84,0xC8,0xCF,0x66,0x37,0xE8,0x58,0xD2,0xA5,0x0F,0xB9,0xBF,
+	0xEB,0x6B,0xA4,0x59,0x60,0x51,0x0D,0xF7,0x3D,0x9B,0x93,0xA2,0x50,0x74,0xEB,0x4B,0x24,0xB7,0x46,0xC6,
+	0x41,0x36,0xA6,0x99,0x05,0x4E,0xAA,0x7A,0x35,0xCB,0x4E,0x3D,0x4B,0xA5,0x25,0xE7,0xA3,0x94,0x72,0xC7,
+	0x65,0x59,0x10,0x35,0x0A,0x51,0x51,0x6F,0x68,0xA4,0x22,0x42,0xA5,0x68,0x04,0x72,0xBC,0x98,0xE2,0xB7,
+	0x0C,0x86,0x59,0x29,0xBD,0xCA,0xB6,0xD7,0x44,0x89,0x30,0xDE,0x8D,0xB7,0xEA,0xA7,0x7F,0x83,0x1D,0x27,
+	0xE0,0xCA,0xAF,0x21,0x3D,0x44,0x49,0x11,0xA3,0x15,0x1B,0xE1,0x01,0x77,0x5E,0x41,0x69,0xF6,0xEC,0x2B,
+	0xE8,0x3E,0x4E,0x2D,0x9C,0xBF,0xA8,0xF3,0x47,0xC9,0xCD,0x7D,0x6A,0x56,0x46,0x50,0x40,0x6D,0x06,0x60,
+	0x08,0xB6,0x2A,0x5E,0x6D,0x56,0x66,0x5B,0xCB,0x31,0x20,0x14,0x24,0xAF,0xA2,0xCE,0xED,0x53,0x30,0x86,
+	0x77,0x92,0x45,0xB6,0x15,0x30,0xA3,0x4B,0x69,0x62,0x92,0xBC,0xD9,0x18,0xF4,0xA1,0x7B,0xC1,0x48,0xB5,
+	0x43,0x73,0x0D,0xCE,0xC8,0x3D,0x40,0x91,0x22,0x11,0x51,0xBD,0x72,0x2E,0x13,0xDD,0xBD,0x9F,0xAB,0x05,
+	0xA5,0xEC,0x6B,0x93,0x63,0x94,0x56,0x83,0x38,0x96,0xA3,0x75,0x6C,0x1D,0x80,0xC0,0x8F,0x01,0xB4,0xA7,
+	0x74,0x0F,0x22,0x10,0xE0,0x07,0x2F,0x92,0x72,0xDA,0x44,0x80,0x9A,0xEC,0x43,0xB6,0x8A,0xF1,0x8F,0x23,
+	0x05,0x3D,0x32,0xB6,0xE0,0x1D,0x0B,0x9B,0x2C,0x39,0x4A,0x58,0xF4,0x0D,0x0D,0x9A,0x27,0x5F,0x41,0x17,
+	0x49,0x93,0xE4,0xB3,0x99,0x2C,0xBD,0xD6,0x30,0xDA,0xB9,0xC2,0xD3,0x1E,0xDC,0xE6,0xDF,0x14,0x62,0xB2,
+	0x8D,0x5C,0x6F,0x19,0xF4,0x81,0xAC,0xBE,0xBC,0x08,0x91,0xD2,0x5C,0x8A,0x02,0xF4,0x86,0x56,0xE8,0x74,
+	0xCB,0xD7,0x61,0xAE,0x87,0x36,0x3A,0xC3,0xB0,0x57,0x2F,0xA7,0x8E,0xBE,0xB7,0x85,0x8B,0xFD,0x15,0xCE,
+	0xFF,0x49,0x01,0x57,0x4B,0x97,0xD7,0x00,0x6B,0xDA,0xC5,0x08,0x15,0x9F,0xF4,0xE8,0xC7,0x30,0x0A,0xCC,
+	0xBF,0x6C,0x8F,0x1B,0xCF,0x9A,0x9B,0xCF,0xA5,0xD1,0x50,0xCE,0xC4,0x31,0xC8,0x9A,0x56,0x3F,0x8A,0xD8,
+	0xD2,0x9B,0x06,0xBE,0x7D,0xF9,0x47,0xDD,0x16,0x97,0x45,0x90,0x72,0x11,0x64,0xAC,0x4D,0x85,0x5F,0xCE,
+	0x67,0xD3,0xEF,0x1A,0xA7,0x44,0x2F,0xED,0x56,0x6D,0x68,0x72,0x58,0xD4,0xB9,0xBF,0xFD,0xFB,0x8B,0xEE,
+	0x45,0xBF,0x4A,0x8C,0xBD,0x68,0x89,0x18,0x4F,0xCC,0xB3,0x6C,0xC2,0x9E,0x30,0x7F,0xCD,0x36,0x13,0x77,
+	0x1D,0x62,0x68,0xAA,0x84,0x55,0x01,0x7C,0xC3,0x5F,0x43,0x3A,0x88,0x92,0x1C,0xD0,0x41,0x15,0xB7,0xA3,
+	0xEE,0x23,0xCF,0x11,0x03,0x27,0x3D,0xB1,0x46,0x74,0x6B,0x2E,0x00,0x3F,0x79,0xBE,0x06,0xB7,0xC7,0x82,
+	0xDC,0xAF,0x59,0x17,0xF5,0xCF,0x40,0xB9,0xF6,0x3B,0xFC,0xA4,0x32,0xAD,0x5E,0x2A,0xA8,0x31,0x95,0xCF,
+	0x25,0x9D,0xD1,0x0B,0xB6,0x31,0x60,0x35,0xA1,0x03,0x39,0x10,0xB0,0x7A,0x7E,0xFC,0x88,0x40,0xA4,0xF3,
+	0x80,0xED,0x19,0x3C,0x3D,0xE9,0x4E,0x21,0xD6,0x88,0xB6,0x4B,0xA3,0x33,0x71,0xFD,0x0F,0x6C,0x4E,0x41,
+	0x4C,0x3E,0x43,0xD3,0x3A,0x32,0xEC,0xD2,0x06,0x0E,0x79,0x15,0xB1,0xFB,0xE9,0x3E,0x9F,0x39,0x31,0x8A,
+	0xB3,0x52,0x24,0xAC,0x83,0xFE,0x40,0x56,0xE6,0x2A,0xEE,0x81,0xAB,0x41,0xE3,0xD4,0xBE,0x87,0xBD,0x50,
+	0xE6,0x02,0x7C,0x18,0x6D,0x20,0xFE,0x7F,0x26,0xB2,0xAC,0x17,0x40,0x79,0xC7,0xA9,0x3F,0xBC,0x7D,0x2A,
+	0x30,0x9A,0x07,0x43,0x83,0x0B,0x29,0xA6,0xD5,0x8E,0x8C,0xA8,0x08,0x80,0xDB,0x17,0xFF,0x33,0xD2,0x90,
+	0xA5,0x40,0xEC,0x01,0x6B,0x50,0x12,0xA4,0x0F,0xBA,0xD0,0x18,0xBE,0x39,0x40,0x3C,0xEA,0x4D,0x5A,0xD8,
+	0xC9,0x94,0x5A,0xF0,0x6D,0xB5,0x63,0xFB,0xAB,0x8E,0x12,0xAD,0xBA,0x1D,0x6B,0x25,0x7F,0x95,0x2C,0x0A,
+	0x2A,0x9A,0xD1,0xD5,0x3E,0xA6,0x99,0xBD,0xBB,0x1C,0x5B,0xBD,0x44,0x66,0x02,0xA5,0xB0,0x4E,0x06,0xC9,
+	0x59,0xDF,0x33,0x7B,0x64,0xD8,0xE7,0xE8,0x06,0x25,0x4A,0x7C,0x84,0x0F,0xAA,0x5E,0xD3,0x20,0xFF,0x6C,
+	0xCC,0x5B,0xE0,0xF2,0xEC,0xE0,0x1B,0x6F,0x8C,0x1C,0xA3,0x09,0xA7,0x21,0x75,0xD9,0x12,0xE5,0xE9,0x2A,
+	0x44,0x11,0xFC,0x58,0x06,0x03,0x34,0x1A,0x59,0x1F,0x0B,0xE7,0x30,0xB4,0xBE,0x96,0x3A,0x79,0xB1,0xB9,
+	0x94,0x81,0x14,0x06,0xB0,0x7A,0x95,0x48,0x72,0x1D,0xCD,0xE8,0xD5,0xC6,0x07,0x6C,0x9D,0xEA,0x0B,0x67,
+	0x05,0x2A,0xFB,0x43,0x55,0x6A,0x9A,0xCE,0xD6,0x61,0x5A,0x94,0xA6,0xCB,0xBD,0x7A,0x71,0xB8,0xEA,0xE6,
+	0x09,0x03,0xD4,0xC3,0x22,0x78,0x4D,0xBE,0xD9,0x46,0x96,0xF3,0x53,0x13,0x19,0xDA,0x6C,0xF5,0xA2,0x53,
+	0xAD,0x84,0xE7,0xF6,0xFE,0xF1,0x94,0xDC,0x4E,0xEF,0xB3,0x11,0xB8,0x44,0x8F,0xE4,0x74,0xC4,0xCC,0x96,
+	0xB1,0xB1,0x0E,0xB2,0x52,0x15,0xF7,0xAF,0x9A,0xA9,0x82,0xB4,0x33,0x81,0x3B,0xF2,0xC9,0x93,0xEB,0x38,
+	0x35,0x2D,0x2B,0x7B,0x37,0xCB,0xB9,0x9A,0x7D,0xD0,0xC5,0xCB,0x6B,0x7F,0xDF,0x2A,0x35,0x96,0xFE,0xC7,
+	0x3F,0xB2,0x83,0xF7,0xE3,0x8A,0x15,0x71,0xBA,0x83,0xC7,0xFF,0x5F,0x54,0x87,0x68,0x7A,0xA4,0x15,0xFA,
+	0x5C,0xF5,0x9E,0x70,0x2B,0x54,0x71,0xE2,0x7B,0x86,0x29,0xFF,0x94,0xFF,0x9E,0x5E,0x4E,0x0C,0xA2,0x0D,
+	0xCD,0xDF,0x43,0x73,0xD8,0xE5,0x2A,0xF6,0xEE,0x83,0xE9,0x99,0x7A,0x5E,0xF0,0xEB,0x5E,0xC6,0x4F,0xFD,
+	0x57,0x96,0x08,0xC7,0x23,0xCA,0x42,0x3D,0x92,0xC8,0x61,0x39,0xB6,0x7C,0x46,0xA4,0x3A,0x91,0x08,0xDB,
+	0x6E,0xF7,0x7A,0x7F,0x19,0x76,0x31,0x25,0x2B,0x13,0x86,0xC9,0x4C,0x91,0xFF,0xE2,0xF7,0xE9,0x00,0x07,
+	0x08,0x7D,0xAF,0x43,0x88,0xC8,0x5D,0x8A,0x70,0xA7,0x65,0xED,0x6F,0x48,0x57,0xF2,0x99,0xD3,0x27,0x5F,
+	0x57,0x5E,0x10,0x67,0xBD,0xE6,0x01,0xF6,0xEF,0x11,0x74,0x93,0x2E,0x83,0x5E,0x3B,0xF5,0x89,0xF9,0x0C,
+	0xF3,0xBB,0x6A,0x23,0xE7,0x10,0xCB,0x01,0xF5,0x5F,0x0E,0xE7,0x7D,0xDA,0xC9,0x60,0x26,0xA7,0xAD,0x33,
+	0x26,0x3E,0xDE,0x1A,0x54,0x83,0xA3,0xF2,0xF4,0x82,0x82,0xF3,0xB2,0xB9,0x15,0xFE,0xE0,0x69,0x5D,0xB4,
+	0xE8,0x7F,0x9C,0xFE,0x87,0x27,0x53,0x64,0xFA,0x22,0x47,0x0B,0x2E,0x72,0xE0,0x7E,0x3C,0xB2,0x08,0x5C,
+	0xC0,0x70,0xE8,0x52,0xEB,0xCA,0x70,0xA0,0xC5,0x82,0x89,0x64,0x5A,0xA6,0x36,0xC0,0x03,0x59,0x88,0x12,
+	0x2A,0xA8,0xCF,0x73,0xCA,0xC9,0xFF,0x04,0xDA,0x13,0x87,0x31,0x6D,0x20,0x83,0xAD,0x97,0x66,0xC6,0x47,
+	0x49,0xC4,0x76,0x03,0xF4,0x48,0x52,0x0D,0x5A,0x3A,0x7E,0xB5,0xB3,0xA4,0x11,0x0C,0xA7,0x87,0x06,0x05,
+	0x01,0x38,0x31,0xAF,0xC4,0x39,0x59,0xF1,0xF5,0x63,0x6B,0x3C,0xA9,0x63,0x4A,0x26,0xB5,0x99,0x8F,0x9E,
+	0x68,0x80,0xF3,0x85,0xF4,0xA6,0xE3,0x0E,0x2D,0xC6,0x2F,0xD6,0x3A,0x14,0x71,0xF6,0x1E,0x51,0x04,0xED,
+	0x7C,0x55,0x4B,0x36,0x2C,0xD1,0x4B,0x35,0xE8,0x5E,0xF0,0x34,0xF2,0x89,0x53,0x17,0x60,0xE4,0x45,0x17,
+	0xEF,0x5B,0x43,0x3D,0x81,0x87,0xCD,0x54,0xD8,0x78,0x65,0x6F,0x69,0x00,0x0C,0xFD,0xAF,0x1F,0xC8,0xF5,
+	0xA5,0x61,0x09,0x5E,0xDA,0xD0,0x52,0x6E,0xE0,0xEB,0xFA,0x8B,0x8D,0x4D,0x45,0x31,0xCA,0x30,0x84,0xB8,
+	0x54,0x25,0x3C,0xF5,0xAD,0x6C,0x0D,0xFD,0xA5,0x68,0x90,0x95,0xFA,0x92,0xC0,0x04,0x32,0x73,0xFD,0xDB,
+	0xAE,0xAF,0x41,0x88,0x19,0x60,0x52,0x0C,0xB0,0x50,0x88,0x1D,0x27,0xD8,0x7E,0xC1,0x3A,0x4F,0x7C,0xB6,
+	0xB0,0x41,0x34,0x5F,0x74,0x6B,0x2E,0xD5,0x2B,0x10,0x5A,0xE5,0x01,0xB8,0x39,0xB0,0xC0,0x7C,0xB8,0xC4,
+	0xF0,0x51,0x35,0x96,0xF8,0x6F,0xA7,0x7C,0xB2,0xBB,0x92,0x9A,0x7C,0xA3,0x8D,0xD5,0x0B,0xB0,0x29,0x68,
+	0x44,0xF0,0xEE,0xA7,0xA5,0x1C,0xA8,0x49,0x0C,0x42,0x66,0x98,0x8A,0xF1,0x88,0x42,0xDA,0xB4,0xBB,0x66,
+	0x66,0x64,0x15,0x42,0xB0,0x6B,0x49,0xB9,0x70,0x44,0x8E,0xCD,0xE9,0x3E,0xF3,0x16,0x7B,0x6E,0x9C,0xCD,
+	0x43,0x69,0x43,0x31,0xBD,0x9E,0xC9,0x81,0x25,0x42,0xDB,0xB3,0x3B,0x10,0xAA,0xE3,0x65,0xD8,0x99,0xB8,
+	0x0F,0x0A,0x0B,0xD7,0xCC,0x11,0xC3,0x2A,0x30,0xF5,0xC2,0xA8,0x1E,0x5D,0xF5,0xF2,0x2B,0x9C,0x8A,0x0E,
+	0x5E,0x35,0x37,0x0A,0x71,0x72,0xC9,0xD0,0x9B,0x99,0xE9,0x05,0x7A,0x01,0x3C,0xE5,0x6D,0xDB,0x6E,0x4B,
+	0xA9,0x0C,0x96,0x2F,0xE8,0x1B,0xAE,0xAF,0x2B,0xBB,0x2F,0x16,0x8E,0x7A,0x90,0xA3,0x5D,0x45,0x9F,0x2F,
+	0x69,0xC8,0x0A,0xD0,0xDD,0xD8,0x78,0xEB,0x58,0xE4,0x3E,0x62,0xB5,0xF9,0x97,0x2A,0x68,0x89,0xE1,0xC0,
+	0x14,0x3A,0xE6,0x95,0xD7,0x60,0x7D,0x37,0x1A,0xF0,0xF2,0x1B,0xCD,0xDE,0x66,0x91,0xF3,0x5A,0x89,0x2B,
+	0xF5,0xED,0x69,0x78,0xF4,0x30,0x5E,0x98,0xD8,0xB8,0x26,0xDA,0x3F,0x7D,0x39,0x55,0xAE,0x6A,0x89,0xA5,
+	0x9C,0x53,0x45,0x14,0x6C,0x96,0x2F,0x2F,0xFA,0x0A,0x55,0x28,0x7D,0x43,0x43,0x50,0x00,0x32,0x47,0x2B,
+	0x32,0xA0,0x7F,0xFB,0xF7,0xDF,0xA3,0xD5,0xDC,0x1A,0x37,0x20,0x9F,0x22,0x68,0x04,0x73,0x36,0x33,0x8C,
+	0x8C,0x53,0x94,0x12,0x4D,0x6D,0xE0,0x0A,0xD7,0xD5,0x7A,0x25,0x40,0xC1,0x70,0x87,0xD4,0x26,0x11,0x30,
+	0xC0,0xAF,0x36,0x04,0x1D,0x2E,0xA9,0x41,0xF6,0x2C,0xB2,0x89,0x08,0x11,0x50,0xE9,0x64,0xA5,0x6F,0x67,
+	0x7A,0x85,0xA1,0xA1,0x66,0x02,0x59,0xC4,0x37,0x2F,0x5A,0x6E,0x23,0x44,0xB8,0xC6,0x17,0x7E,0xB2,0x7F,
+	0x8C,0xC9,0xDA,0x60,0xB9,0xC2,0x8F,0xA0,0x31,0xF4,0xB0,0xD6,0x16,0x21,0xD8,0x83,0x95,0xEA,0x6A,0x6B,
+	0xBF,0xCE,0xED,0x65,0xFD,0x16,0xB9,0xC7,0x97,0xEC,0x2F,0xF2,0xA9,0xC0,0x8F,0xF7,0xD6,0xB2,0x37,0x57,
+	0x62,0x84,0xF1,0x85,0xEC,0x28,0xBE,0x80,0x19,0x57,0xEF,0x71,0xB8,0xE2,0x9E,0x98,0xC0,0xE1,0xDC,0x9E,
+	0x1C,0x87,0xC9,0x2B,0x37,0x44,0xE6,0xD1,0x5C,0x2A,0x90,0x33,0x64,0x34,0xED,0x14,0xF2,0xBF,0x3E,0xC5,
+	0xC8,0x0B,0x5A,0x38,0x37,0x9C,0x7B,0x3B,0x7B,0xDF,0x60,0xFE,0x46,0x81,0xD3,0xCD,0x20,0x91,0x13,0x98,
+	0xA7,0x4A,0x13,0x3D,0x60,0x11,0x20,0x67,0x4C,0xD7,0x17,0xEF,0xCF,0x98,0x4A,0xB9,0xDD,0x88,0x62,0xBB,
+	0x86,0x01,0x76,0x2E,0x59,0xF3,0x2C,0xF2,0x9F,0xD1,0x52,0x2A,0xC8,0x38,0x34,0x5E,0xEA,0x8E,0xF2,0x8C,
+	0xE5,0x22,0xF9,0x4E,0x97,0xA8,0x7F,0xF4,0xDC,0x7B,0xB8,0xB9,0xA8,0xFF,0xBB,0xCF,0x9B,0x4C,0xF8,0x36,
+	0x33,0xB2,0xF0,0x62,0x02,0xC5,0x6B,0xAA,0x07,0x02,0xF3,0x8D,0x44,0x20,0x25,0x4A,0xA0,0xCA,0x8B,0xE3,
+	0x20,0x94,0x94,0x9F,0x50,0x52,0x14,0x43,0x32,0xC5,0xC4,0x84,0xEF,0x52,0x2C,0xC4,0x42,0xFD,0x6C,0xBF,
+	0x49,0x53,0x2F,0x02,0xED,0xD7,0x74,0xAE,0xA7,0xA5,0x24,0x4B,0x98,0x20,0xD1,0x26,0x93,0x36,0x81,0xC2,
+	0x31,0x3C,0xA2,0xA0,0x6D,0x5E,0xEB,0x89,0xC3,0x1A,0x94,0xC7,0x92,0x77,0xB7,0x66,0x7B,0x98,0xFB,0xC3,
+	0x0A,0xF5,0x31,0x2A,0xF2,0x02,0x2C,0xDE,0xE4,0xE0,0xAA,0xA6,0xCD,0x99,0xAF,0xC7,0xC3,0x4F,0x44,0x9B,
+	0x0A,0xDB,0x12,0x42,0x27,0xBA,0x88,0x24,0x64,0x94,0x5D,0x96,0x9C,0xFE,0x78,0x86,0xFD,0xEA,0xA3,0xB3,
+	0x49,0xB0,0x54,0x82,0x6C,0x3C,0xD3,0xC5,0x47,0x89,0x75,0x97,0x84,0xD9,0xFF,0x22,0x4F,0xBC,0x5C,0x3F,
+	0x16,0x3E,0x25,0xF5,0x0A,0xC6,0x4D,0x06,0x77,0xFA,0x66,0xA7,0x14,0x5A,0xE4,0x88,0xD3,0xEE,0x48,0x3A,
+	0x6C,0xCC,0xA8,0x80,0x59,0x19,0xB6,0x63,0x4A,0x3A,0x8F,0x6F,0xEB,0xE5,0x79,0xB0,0x82,0xCF,0x86,0x25,
+	0x81,0x28,0x9E,0xDF,0x9B,0x1E,0xF9,0x12,0xD3,0x8C,0xF4,0xB2,0x36,0xF1,0x85,0x71,0x4B,0x37,0x19,0xA1,
+	0x42,0x5F,0xB4,0xC3,0x64,0x86,0xB4,0xD7,0x3C,0xA7,0xA5,0x42,0xFF,0x81,0x70,0xC0,0xC1,0x99,0xC0,0xF3,
+	0x0E,0x7E,0x96,0x68,0xF7,0x81,0x84,0xBF,0x91,0x18,0x69,0xC3,0x40,0x69,0xEE,0xAE,0x08,0xE6,0xCE,0x08,
+	0x3C,0xAC,0x8C,0xD2,0x90,0x19,0xEF,0x43,0x7A,0x8A,0x1D,0xC8,0xF2,0x6F,0x2F,0xCE,0x17,0x51,0x47,0x1E,
+	0x7E,0xF3,0x0E,0x1F,0x39,0x1C,0x15,0x22,0x39,0xD3,0x21,0xFF,0x0A,0xDC,0xE4,0x1F,0xDF,0xA3,0x33,0xF1,
+	0x80,0x0D,0x9F,0x59,0xC0,0x65,0xCB,0xCA,0x88,0x82,0x07,0x8B,0x52,0xA0,0x10,0xFD,0xE6,0x88,0x2C,0xE7,
+	0xF5,0x81,0xF6,0x40,0x76,0xB7,0x9E,0x9E,0xD9,0xEC,0x77,0xD6,0x6F,0xE6,0x06,0x30,0xFF,0x07,0x71,0xD2,
+	0xC2,0x5A,0x67,0x34,0xEE,0xA6,0xED,0x4C,0x38,0x7F,0x01,0x9D,0x01,0x37,0xC1,0xDB,0x5D,0x0C,0x0D,0xC8,
+	0xD3,0xA3,0xFB,0x22,0x02,0xE8,0xD8,0x96,0xA9,0xAB,0xF0,0x24,0xD4,0x90,0xF0,0xA4,0xD5,0xA2,0xB3,0x50,
+	0x78,0x86,0x88,0x17,0x9B,0xA8,0xDD,0x76,0xC0,0xD3,0xEE,0xD3,0xBC,0xA1,0xF1,0x3C,0xA5,0x8B,0xD9,0x97,
+	0x6D,0xA9,0x52,0x6C,0x1E,0x6D,0x46,0x43,0xB5,0xC0,0x36,0x43,0x74,0xC5,0xA3,0x28,0x34,0xE6,0x29,0xED,
+	0x3C,0x3C,0xC3,0xC7,0x42,0x48,0x78,0xF0,0x78,0xCA,0x07,0x15,0x77,0xDC,0x9A,0xA2,0x5C,0x07,0x64,0xE1,
+	0xEF,0xA4,0xEA,0xEA,0xF1,0xBB,0x49,0xE5,0x62,0xA9,0xC2,0xD2,0x95,0x06,0x66,0x02,0x5B,0x42,0xBE,0x50,
+	0x2D,0x35,0x23,0xC9,0x0E,0xA9,0x6A,0x34,0x6B,0xDA,0xC3,0xE9,0x76,0xA8,0x28,0x07,0x0D,0xF5,0xC3,0xDD,
+	0x1B,0x5E,0x93,0xB7,0xDF,0x00,0x13,0x1B,0xEE,0x31,0x79,0x4C,0xF3,0x54,0x3F,0x4B,0xFF,0x13,0x72,0xA8,
+	0xCD,0x8A,0x56,0x0C,0xA1,0xAD,0x86,0x7E,0x80,0x8F,0x2A,0xAF,0x70,0x20,0xFA,0xF8,0xF3,0x6C,0xA0,0xC4,
+	0x2B,0x42,0x7B,0x4F,0x03,0xCF,0x3C,0xEE,0xE9,0xDB,0xC4,0x4F,0xA5,0xC1,0x40,0xDF,0x96,0x6D,0xDC,0x5A,
+	0x02,0x83,0x95,0x73,0x1D,0x43,0xBB,0xFB,0x52,0xC2,0x5B,0x0D,0xBD,0x43,0x1E,0x32,0x98,0x3F,0x0B,0x98,
+	0xD0,0x44,0x89,0xFD,0xB0,0x15,0x2C,0x61,0x47,0x1A,0x3F,0x72,0x63,0x8A,0xF2,0xA4,0x31,0xFD,0x62,0x80,
+	0x61,0x9D,0x5F,0xF6,0x25,0x44,0x81,0xF8,0x07,0x3F,0x13,0x76,0x5C,0xF2,0x92,0x94,0x0F,0x77,0x0D,0x38,
+	0xE6,0xBF,0x09,0xF5,0x5E,0x83,0xCC,0x99,0x65,0xC7,0x5C,0xA0,0xC7,0x47,0x2C,0xC5,0x0A,0xB1,0x87,0x39,
+	0xB7,0xE9,0x8A,0xA4,0x17,0x74,0x5D,0x11,0xEA,0x95,0xCB,0xB8,0x8B,0x76,0xDE,0x61,0x97,0x9D,0x28,0x20,
+	0x13,0xDB,0x3D,0x94,0x05,0x0A,0xEF,0x74,0x76,0x96,0x4C,0xF5,0x44,0x86,0xB8,0xC4,0x1B,0xDA,0xCD,0xD3,
+	0xE6,0xA9,0xED,0xEE,0xB6,0xFD,0xDF,0xE9,0xB7,0x52,0xAD,0xE8,0xBF,0xDB,0x84,0xB4,0x1E,0xA1,0xC7,0x15,
+	0xD3,0xF1,0x9E,0x08,0xBD,0x82,0x81,0x7F,0xA0,0xF8,0x10,0x0B,0xB4,0x73,0x2E,0x37,0x9D,0x07,0x56,0x18,
+	0xBC,0xC3,0xD1,0x63,0x3D,0xB7,0x6E,0x24,0x96,0x22,0x2F,0xBC,0xE0,0xB8,0x08,0x69,0x00,0x27,0x4F,0x05,
+	0x9E,0x6C,0x92,0xAE,0x6B,0xCC,0x77,0x5B,0xF0,0x5A,0x94,0x79,0x01,0x66,0xC7,0x19,0x41,0xFA,0x3F,0x79,
+	0x6E,0x9D,0xDF,0xBD,0x9F,0xF6,0x51,0x37,0x2E,0x92,0xCE,0x0C,0xE2,0xF8,0x4D,0x64,0x4A,0xDA,0x7E,0x2B,
+	0xDF,0x76,0x82,0x5A,0xD3,0xBD,0x0C,0xCD,0xBB,0x5B,0x85,0x18,0xED,0x95,0x22,0x0E,0x77,0xF2,0x0F,0x4D,
+	0x52,0xDF,0x44,0xC8,0x76,0xDA,0xFF,0x2E,0x4F,0x54,0x18,0x0D,0x7C,0xB6,0xC3,0x99,0x2C,0x4B,0xD0,0x8D,
+	0xFC,0xB0,0x67,0x89,0x4C,0xBA,0x9F,0xBB,0x8E,0x72,0x78,0x82,0x05,0x39,0x7B,0x7A,0x33,0xA0,0x8A,0xAC,
+	0xCF,0x42,0xAF,0xC6,0x0C,0x64,0xE0,0x4F,0xF4,0xFD,0x33,0x64,0x19,0x28,0x70,0x2E,0x87,0xB5,0x23,0x73,
+	0x8F,0x6B,0x79,0x26,0x86,0xFB,0xDA,0x09,0x10,0xA0,0xA6,0x20,0x4D,0x4E,0xFC,0x01,0x31,0xBD,0xC9,0x65,
+	0x3C,0x05,0x0D,0xAB,0xDD,0xA3,0xFF,0xC0,0x0B,0x03,0x88,0x4B,0xD7,0x41,0x5D,0xFE,0x80,0xC8,0xFA,0xC6,
+	0xDB,0x53,0xF9,0x1E,0xD7,0xE9,0xD9,0x06,0xA1,0x08,0x4C,0x10,0x47,0x4B,0x08,0x11,0xB9,0x64,0xA7,0x8F,
+	0xA2,0xC6,0xE3,0x2B,0x86,0xD8,0x7F,0x23,0x0D,0x80,0xB9,0xBA,0xE5,0x64,0xCB,0x01,0x84,0xC7,0x36,0xA5,
+	0x96,0x9A,0x8A,0xA0,0xA0,0x47,0xA9,0x0A,0x30,0xAC,0xA6,0x8F,0x7E,0xB6,0x72,0x6C,0x53,0xF9,0x0A,0xAD,
+	0x6B,0x28,0xD9,0x18,0x98,0x38,0x4C,0xBA,0x4C,0xC5,0xD6,0xD6,0xF4,0x65,0xE9,0x67,0x61,0x04,0xB8,0xEE,
+	0x59,0xB6,0x44,0x0B,0x5D,0xE6,0xDE,0xD2,0xF5,0x64,0x7B,0x2D,0x8E,0x81,0x38,0xFC,0x3B,0x7A,0x6D,0x1F,
+	0x23,0xAF,0xEC,0x52,0xDE,0x48,0x19,0x62,0x62,0x4F,0x24,0x67,0x44,0x6A,0x29,0x7F,0x5B,0xDF,0x37,0xA6,
+	0x6C,0xFD,0xD2,0xB9,0x29,0x2C,0xC6,0xAE,0x98,0xD0,0x2C,0x6E,0xFF,0x9F,0x7D,0x12,0x87,0x2D,0x92,0x35,
+	0x2F,0x63,0xAA,0x03,0xFC,0x80,0x60,0x83,0x4D,0xC6,0x32,0xCF,0xDE,0x2A,0x83,0x80,0x88,0x4C,0xB9,0xBD,
+	0x49,0x21,0x2D,0x6E,0x6B,0xB1,0x70,0xC5,0x06,0x5D,0x0B,0x66,0x83,0x63,0x84,0xBF,0x37,0x82,0xEC,0x16,
+	0xA3,0x86,0x1B,0x8C,0x3D,0x23,0x3A,0xF5,0x58,0x91,0xEC,0xE6,0xCB,0x3E,0xBE,0x5E,0xBC,0x14,0x54,0xC9,
+	0xAF,0x6B,0x0B,0x92,0x8C,0x50,0xEB,0xEA,0xE3,0x39,0xD8,0x4B,0xCD,0x5C,0x4B,0x86,0x8E,0xA4,0x15,0x05,
+	0x9D,0xBC,0xBD,0x7F,0x3F,0xCF,0x6B,0xA6,0x41,0x3E,0xD3,0xC3,0x9B,0x7D,0xAE,0x39,0x7D,0x20,0x09,0x68,
+	0xB9,0x72,0x0A,0x4A,0x00,0x30,0xE5,0x31,0xDE,0x11,0xAC,0x4A,0x00,0xC2,0xBC,0x46,0x10,0x86,0xC1,0x1F,
+	0x64,0xCD,0xEC,0x34,0x85,0x7B,0x24,0x56,0xDF,0x54,0x9C,0x49,0x92,0xBD,0x63,0x0E,0xD6,0xFA,0x4C,0x96,
+	0x30,0xCA,0x3A,0x3C,0xA2,0x18,0x9F,0xC4,0x11,0x30,0x24,0xBA,0x1F,0xEA,0xED,0xB5,0xF6,0x79,0xA1,0x51,
+	0x5F,0x37,0xC9,0x37,0x31,0x34,0xFD,0x00,0x6F,0x57,0xA5,0x97,0xB2,0x57,0x38,0x7D,0xF0,0x17,0x59,0x8C,
+	0x1C,0x23,0x6D,0xB7,0xEC,0x8C,0xF6,0xEC,0x96,0xF3,0x30,0x7A,0x07,0xC6,0xEE,0xB2,0x5A,0x36,0xB2,0x3D,
+	0x1E,0x59,0x62,0xCE,0x92,0xB0,0x35,0xB8,0x09,0xE5,0x40,0xEB,0x35,0x58,0xB3,0x8E,0x44,0x57,0x93,0x4F,
+	0xFE,0x23,0xB0,0xA9,0xAB,0xB4,0x50,0x9C,0x44,0x57,0x08,0x46,0x1C,0xC8,0xE1,0xD8,0x7C,0xBB,0xEA,0x8A,
+	0xA9,0xA1,0x05,0xBE,0x99,0x3A,0x68,0xEE,0x95,0x32,0xAE,0xC8,0xD9,0x7A,0x4F,0x2B,0xE1,0xB6,0xB6,0x58,
+	0x50,0x3C,0xFE,0x06,0x92,0xA2,0x25,0x1E,0xDA,0xF7,0x6D,0x19,0x09,0x96,0x4F,0x19,0xD9,0x5E,0x30,0xA9,
+	0xA2,0xF3,0x5F,0x28,0x5B,0xF4,0x28,0xD1,0x7F,0xDA,0x14,0x8E,0xC4,0xA6,0xCF,0x11,0xBF,0x12,0xA0,0x1F,
+	0xDF,0x79,0x1A,0xB2,0x2D,0x2F,0x07,0x43,0x12,0x82,0x13,0x39,0x9C,0x6B,0xF8,0xA6,0xA1,0xA2,0x72,0x13,
+	0x8B,0x7E,0x68,0xDF,0x13,0xCA,0x68,0xAC,0xBE,0x34,0x80,0xF1,0x8F,0xBC,0x85,0x71,0x0A,0x5D,0x2A,0xEF,
+	0x8A,0xE0,0x94,0xAB,0x43,0xD4,0xF5,0x9B,0x63,0x87,0x13,0xE8,0x7C,0xEF,0x16,0x69,0x14,0xAE,0xCE,0x0D,
+	0x33,0x76,0xDA,0xF7,0xD9,0x18,0x48,0x80,0x6D,0x42,0x2B,0xA4,0xAB,0x28,0x0E,0x64,0xA7,0x97,0x84,0x9B,
+	0x76,0xA6,0x0E,0x5F,0xE6,0x2A,0xE7,0xA8,0xFE,0xFF,0x27,0x76,0x43,0x4E,0x38,0x72,0x39,0x10,0x61,0x58,
+	0x48,0x2D,0x35,0xE2,0xD5,0xAA,0x0F,0x64,0x67,0x39,0x71,0xD2,0xA9,0xC6,0x0B,0x4D,0x63,0x73,0xC3,0xF2,
+	0xD4,0xAA,0xCE,0x3C,0x3A,0xBB,0xA8,0xF3,0xD3,0x04,0x44,0x7F,0x0F,0x6A,0x1D,0x4C,0xBD,0x05,0x45,0x10,
+	0xBE,0xC6,0xB6,0x0A,0x08,0xEC,0x3A,0x23,0x0B,0xF0,0xF3,0x87,0x1B,0xEB,0xE1,0x3A,0x2E,0xB4,0x12,0xA7,
+	0x6E,0x0D,0xE3,0x66,0x05,0x01,0x2F,0x8B,0x96,0x88,0x5B,0xAD,0x30,0x8B,0x5F,0xD2,0xDC,0xAB,0x45,0x9F,
+	0xB0,0xA7,0x31,0x9B,0xB2,0x56,0xAC,0xC4,0x38,0x48,0x01,0xC4,0xA2,0xCB,0xD4,0xBB,0xE6,0xEC,0x69,0xB5,
+	0xD6,0x36,0xB2,0x12,0xFC,0x90,0x45,0xC7,0x58,0xAC,0x0B,0x54,0xDF,0xF9,0xB2,0xBC,0x9D,0xAE,0x7A,0x84,
+	0x6D,0x5D,0x8E,0xFA,0x70,0x3C,0x3D,0x79,0x86,0xC2,0x7B,0x60,0x81,0xEE,0xCC,0x25,0x7B,0x35,0x25,0x29,
+	0x7C,0xA0,0x4C,0xAA,0x13,0x9D,0x2C,0x3D,0xDE,0xEF,0xBC,0x93,0xDD,0x82,0x3B,0x8E,0x5A,0xAE,0xF1,0xFC,
+	0x46,0xE7,0xC2,0x73,0x37,0x91,0x98,0x27,0x93,0x2D,0x1C,0xBF,0x47,0x54,0xBB,0x61,0xA1,0x1A,0x14,0x68,
+	0x56,0x43,0xB8,0x4F,0x9A,0x90,0x3C,0x92,0xF7,0x1D,0x5B,0x2F,0xC7,0x9E,0xFF,0x1B,0xC8,0xAD,0xF1,0x5C,
+	0x11,0xDB,0x4F,0xE1,0xFC,0xBC,0x09,0x2F,0x59,0xD7,0x3A,0x7D,0x10,0xDF,0xAD,0x74,0x1C,0x5A,0xD3,0xD5,
+	0x77,0x3F,0xC3,0xF5,0x4D,0x31,0x39,0x96,0xD7,0x0B,0xEB,0x82,0x56,0x29,0xFC,0x43,0xD5,0xF2,0xC4,0x58,
+	0xB3,0x01,0x13,0xA4,0xC0,0x0A,0xC3,0x14,0x54,0x65,0x83,0x14,0x53,0x78,0xC5,0x32,0x46,0x16,0x65,0x36,
+	0xD9,0x4D,0x2D,0xEB,0xD5,0x06,0xF9,0xE1,0x57,0x7C,0xC8,0xC8,0xCC,0xE3,0xB4,0xC1,0x52,0x28,0x85,0xD7,
+	0x19,0x97,0x86,0x6E,0x0A,0x46,0xDD,0x7B,0x29,0x98,0x45,0x70,0x98,0x55,0x16,0x40,0x91,0x51,0x88,0x4C,
+	0x4F,0x90,0x7B,0xB4,0x1F,0x2C,0x39,0x6D,0xB9,0x34,0x81,0x21,0x9A,0xDD,0xE6,0xC1,0x5C,0xEB,0x01,0x7E,
+	0xA1,0xEF,0x63,0x74,0xDF,0x31,0x17,0x21,0xED,0x7A,0x4F,0x50,0x1D,0x55,0xFA,0xA1,0x9B,0xDB,0xFD,0xB1,
+	0x56,0xDF,0x3D,0xFC,0x14,0x2D,0x7F,0xD2,0xDF,0xB9,0x25,0x0C,0xBC,0x9F,0xD9,0x89,0xEC,0xB6,0xB7,0xAC,
+	0x22,0xC7,0x88,0xE8,0x9F,0x2F,0x06,0x18,0xA9,0x68,0xF1,0xBE,0x39,0x36,0x79,0x1C,0xED,0x11,0x85,0x85,
+	0x5C,0xD2,0x84,0x30,0xD1,0x9E,0x22,0x27,0x32,0x73,0xF4,0x94,0x49,0xC5,0x89,0xE8,0x5F,0x6F,0xFF,0x94,
+	0x52,0xE3,0x17,0xE6,0xB9,0xE5,0xED,0x0B,0xEB,0xD0,0x50,0x85,0x22,0xBE,0x28,0x62,0x81,0x0F,0x2F,0xEE,
+	0xF9,0x69,0xEB,0xC2,0xC2,0x08,0xF7,0xDB,0x74,0x9B,0x20,0xD2,0x6A,0x0F,0xD2,0x15,0xB2,0x22,0x48,0xAD,
+	0xE0,0xCB,0xC2,0x5A,0x25,0xCE,0x29,0x06,0x01,0x46,0xF9,0x87,0x91,0x5F,0xDB,0x53,0x63,0x44,0x91,0x01,
+	0xA7,0x42,0x48,0x95,0x81,0x41,0x76,0xEE,0x13,0x2B,0x66,0xD3,0x43,0x40,0x39,0x47,0xB3,0xCF,0x1D,0x48,
+	0x31,0x04,0xF8,0x14,0x1A,0x2B,0x79,0x18,0xE1,0x5F,0xD1,0x16,0xF5,0x7F,0x18,0xC4,0xE2,0x0A,0xF8,0xB6,
+	0x91,0x2D,0x7E,0x68,0xC7,0xE1,0xD9,0x84,0xAC,0x2A,0x81,0x34,0xAD,0x00,0xF9,0x95,0xCE,0xAE,0xDB,0x1E,
+	0x65,0x07,0x5C,0x95,0xAD,0x29,0xFD,0x2E,0x20,0x46,0xB9,0x2B,0x30,0x42,0xDC,0x76,0xA8,0x48,0xE3,0x9D,
+	0x9A,0x28,0xC2,0xF9,0xF5,0x0E,0x7D,0x6E,0x38,0x25,0x55,0x5A,0xEB,0x4E,0xEC,0x2B,0xF9,0xD7,0x6A,0x59,
+	0x85,0x04,0xD0,0x66,0x61,0x6B,0x30,0xE8,0x15,0x4F,0x98,0x20,0xAF,0xA9,0x0B,0xAE,0x69,0x05,0xFE,0x29,
+	0x79,0x95,0x33,0x50,0x69,0xB5,0x2C,0x6A,0x02,0x62,0x01,0x18,0x2A,0x05,0x42,0xCD,0x38,0x80,0x4B,0xB4,
+	0x6A,0x0B,0x26,0xCD,0xB5,0xBA,0x6E,0x5C,0x83,0xAC,0x7D,0xAE,0x3E,0x2A,0xD2,0x4C,0xA1,0x08,0x8B,0xD1,
+	0xFD,0x2D,0xD9,0x58,0x9A,0x25,0xAA,0x1C,0xFD,0x20,0xFE,0x5C,0x28,0x49,0xC9,0x87,0xBA,0xEE,0x6F,0x4F,
+	0x8F,0xC2,0xCB,0xFA,0x7B,0x21,0x69,0xD9,0x0F,0xE1,0xE9,0x92,0x27,0xEF,0xE1,0xD7,0x8B,0x27,0x81,0xA3,
+	0x38,0x22,0x25,0x9B,0xD9,0x02,0x0B,0x87,0x22,0xE6,0x93,0x7F,0x74,0xC7,0x44,0xC5,0xF7,0x72,0x42,0x9D,
+	0x8B,0x34,0xCA,0x99,0xF2,0xBC,0xD3,0xEA,0x1E,0xD7,0x4C,0x28,0x8E,0x2A,0x8C,0x41,0xC2,0x11,0x18,0x30,
+	0x0B,0x97,0x84,0xEB,0xD7,0xDE,0x56,0x7B,0x83,0x94,0xAA,0x43,0x60,0x1F,0x3C,0xC7,0x13,0x7B,0xD4,0x91,
+	0x40,0xAC,0x2B,0x11,0xC7,0x4C,0x2F,0x81,0xE3,0xFC,0x0D,0xFA,0x08,0x0F,0x7C,0x3B,0x8E,0x19,0xB6,0x42,
+	0x1E,0x78,0x95,0x27,0x60,0xA1,0x3C,0x60,0x56,0xD9,0x15,0x34,0x27,0x17,0x5C,0x56,0x11,0x27,0xE3,0x20,
+	0x6F,0x5C,0x94,0xEC,0x75,0x1E,0xBE,0xE6,0x03,0xE9,0xB5,0xE5,0x9E,0xFB,0x51,0xA6,0x63,0x58,0x4F,0xA2,
+	0x38,0x9F,0x02,0xAE,0xE1,0x1E,0x9D,0xC1,0xAB,0xBC,0xD8,0x01,0xEF,0xA6,0xD0,0x71,0x98,0x0D,0x86,0xF4,
+	0x36,0xC3,0x46,0x31,0xC2,0x7A,0xB6,0xDB,0xCB,0xDB,0x3F,0xD6,0xED,0xD5,0x7B,0x1C,0x54,0x64,0x8E,0x9C,
+	0xD8,0x22,0x04,0xBA,0x82,0x56,0xA6,0x42,0xA5,0x76,0x27,0x74,0xE5,0xA1,0xC7,0x8E,0xB8,0x3A,0xA2,0x5A,
+	0x64,0x1B,0x49,0x9D,0x0F,0xDB,0xB0,0xF9,0xE7,0x00,0x2A,0x6B,0x8A,0xAD,0x5E,0xDF,0x88,0x5F,0xAD,0x8D,
+	0xF9,0x84,0xC7,0x58,0x0B,0xAC,0xF3,0x2E,0x96,0xB7,0xA9,0x9A,0x1C,0x83,0x16,0x99,0x06,0x3E,0xCE,0xA8,
+	0xC8,0x1C,0x94,0xF7,0x98,0x58,0x36,0x3A,0xED,0xA8,0x4E,0x7E,0x7A,0x98,0x55,0xCD,0x89,0x5C,0xF7,0x2F,
+	0x3A,0xDE,0xF8,0x39,0x19,0xA2,0x89,0x6C,0xB2,0xB7,0x8F,0xC1,0xAF,0x74,0x95,0xFD,0x18,0x78,0xCF,0xBB,
+	0x4A,0x53,0xE7,0x03,0x79,0x77,0x48,0xC0,0x80,0x8E,0xD8,0x13,0xF4,0x75,0x6A,0x39,0x90,0x31,0xCE,0x20,
+	0xB5,0x63,0x10,0xB6,0xF9,0x98,0x04,0x93,0xC0,0xC3,0x1F,0x96,0xF8,0xC8,0x47,0x12,0xD7,0xC5,0x85,0xC1,
+	0x27,0x8C,0xD9,0xEF,0x98,0x7E,0x96,0x83,0x14,0xE1,0x1B,0xD4,0x58,0xEF,0x13,0xED,0xE6,0x84,0xC0,0xFC,
+	0x6A,0x28,0xFC,0xBE,0x2C,0x80,0x34,0x55,0xF4,0xA1,0xCA,0xF7,0x0A,0xAC,0xAA,0x5B,0x57,0xAC,0x6A,0x60,
+	0x8C,0xCB,0x74,0x95,0xD2,0x70,0xC2,0x75,0x07,0xA1,0x53,0xB4,0xBB,0x58,0x26,0xD3,0xCF,0x6E,0x0F,0xF6,
+	0xEA,0xA4,0xCB,0xF2,0x8A,0xAE,0x99,0xC5,0x97,0x21,0xE1,0xE7,0xB8,0x2A,0x55,0x15,0x75,0x16,0x63,0x53,
+	0x87,0x7A,0x91,0x73,0x12,0x80,0xA9,0x31,0xBC,0xC5,0xA0,0xF1,0x93,0xA5,0xB1,0x8E,0x1B,0x19,0x99,0x37,
+	0x1A,0xF2,0xA7,0xD9,0xC8,0x45,0x72,0x96,0xB0,0xEB,0xB9,0x9E,0x1A,0x91,0xDD,0x88,0xC6,0xE8,0x02,0xC5,
+	0xA4,0xCA,0x9A,0x3A,0x22,0xB6,0x9C,0xE9,0xEF,0xC5,0xE9,0x70,0x3F,0x1A,0x65,0x8A,0x27,0xAE,0xF4,0x3F,
+	0xA3,0x19,0x11,0xF9,0xEE,0x7B,0x70,0x1C,0xE2,0xA7,0xAE,0xC8,0x49,0x46,0x7B,0xDA,0x46,0xAB,0x74,0x28,
+	0x66,0x81,0x3D,0x5F,0x18,0xEC,0x29,0xC5,0x48,0x3F,0xA8,0x2C,0x6D,0xAA,0x50,0xEA,0x9E,0x22,0x9A,0x18,
+	0xBD,0x53,0x04,0x3F,0xB3,0x8E,0xF2,0x76,0x59,0x75,0x71,0x97,0x65,0xCA,0x35,0xB2,0xD2,0xE0,0x2B,0x78,
+	0x6D,0x86,0x49,0xA8,0x1C,0x6E,0xCF,0x39,0x7C,0xEA,0x12,0x99,0x3D,0xEA,0xC8,0xDA,0xCB,0x06,0x35,0xFB,
+	0xF4,0x7C,0x78,0xE4,0xDB,0x8B,0x5C,0xA2,0xDD,0x59,0x52,0x40,0x40,0xDD,0x8A,0x44,0x16,0xFF,0x94,0x55,
+	0xE7,0x13,0x96,0x33,0x82,0x4C,0x5E,0xBA,0x94,0x58,0xE2,0x0F,0x7D,0x0A,0xBA,0xE5,0xD8,0xDD,0x58,0xFC,
+	0x88,0xCD,0x4E,0x84,0x45,0xBC,0x9A,0xD8,0x2D,0x6D,0x25,0x8B,0x27,0xBB,0x01,0x18,0x00,0x3A,0x1D,0x21,
+	0x65,0x92,0xB9,0xB3,0xFD,0x7E,0x57,0x62,0x20,0x54,0x66,0xE2,0xB4,0xBC,0x0C,0xA0,0xEA,0xD8,0x42,0x84,
+	0xFB,0x22,0x75,0xD4,0x03,0x8E,0xE4,0x78,0x96,0x3F,0x14,0x72,0x61,0x1D,0x10,0xF4,0x7F,0x99,0xA5,0x53,
+	0x13,0xD4,0x10,0xB5,0x15,0xB0,0xD5,0xA1,0x65,0x7D,0x59,0x78,0xF7,0x96,0xE7,0xB5,0x58,0x1D,0x16,0x35,
+	0x16,0x3D,0x25,0x31,0x64,0xD9,0xB5,0x15,0xD3,0x99,0x82,0xE8,0x6D,0xB8,0x86,0x64,0x5F,0xBC,0x56,0xF5,
+	0xD3,0x25,0x8C,0x54,0x87,0x83,0xB1,0x7C,0x09,0x9F,0x30,0xBA,0xC0,0xD5,0x01,0x58,0xEF,0x25,0xC7,0x3A,
+	0x29,0x17,0x5F,0xAF,0x4D,0x81,0xC6,0xCF,0xB0,0x4F,0x4F,0x29,0x31,0x85,0xF7,0x43,0x90,0xC5,0x7F,0x06,
+	0x0C,0x11,0xC8,0xDF,0xFD,0x46,0x42,0xD4,0x4E,0xDD,0x62,0x86,0xCA,0x8C,0xE1,0xAA,0x2C,0x6E,0x61,0x2C,
+	0xBC,0xB4,0xD6,0x28,0xE2,0xD2,0x49,0x75,0x8B,0x6A,0x68,0x2B,0x0C,0xBD,0x51,0x3C,0x1B,0xA6,0x1E,0xBA,
+	0xC1,0x50,0x01,0x80,0xAD,0x22,0xD8,0x1B,0xF2,0x97,0x96,0xB1,0x1D,0xDB,0x0F,0x29,0x4F,0x9D,0xFF,0xFA,
+	0x03,0x48,0x4F,0xCA,0x4E,0x99,0x64,0x2F,0x3F,0xF0,0x07,0x79,0xEE,0x98,0x6F,0xB8,0x06,0x09,0xFF,0x7A,
+	0xD6,0xDF,0x10,0x80,0x3F,0x5B,0xBC,0x62,0xC3,0x40,0xE8,0x03,0xD0,0x8F,0xA4,0x82,0x57,0x0B,0x48,0x58,
+	0xC7,0x63,0x70,0xF2,0xC7,0xB4,0x22,0xB0,0x3A,0xB2,0x91,0xE9,0x4E,0xCF,0x5E,0x85,0xE7,0x55,0x4F,0x36,
+	0xC8,0x42,0x01,0xCD,0x1E,0xA0,0x0A,0xF9,0x4F,0xCE,0xC4,0x87,0x95,0x79,0x89,0xB3,0xC4,0xF8,0xA1,0xCB,
+	0x7D,0x6E,0x02,0xA6,0x26,0xF0,0x3F,0xBB,0xED,0xDB,0xAF,0x9F,0xBD,0xBB,0x2F,0x9B,0xAD,0x9B,0xFF,0x7D,
+	0x07,0x1C,0x37,0xAB,0xEC,0xDA,0xA7,0x8F,0xBC,0xBA,0x27,0x8B,0xAC,0x9A,0xD4,0xC5,0xA5,0xF7,0x3E,0xBA,
+	0x6D,0xD9,0xAE,0x9E,0x3D,0xB9,0x2E,0x9A,0x2D,0x99,0x45,0xF1,0x97,0xA7,0x36,0xAA,0x6C,0xD8,0xA6,0x8E,
+	0x3C,0xB8,0x26,0x8A,0x2C,0x98,0x80,0x8C,0x63,0xDB,0x64,0x8E,0x3A,0x48,0x48,0x2C,0xEB,0x4E,0x6D,0x08,
+	0xDA,0x60,0x72,0x3C,0x29,0xCB,0xF5,0x9E,0x3B,0x49,0x3E,0xA9,0x02,0xE3,0xFA,0x7C,0x4C,0xE4,0xB8,0xEB,
+	0x24,0xF7,0xB9,0xEF,0xBA,0xD5,0xC3,0x79,0xCE,0x48,0x1E,0xDD,0xD4,0x65,0x4B,0xDE,0xBA,0xCF,0xD1,0x1C,
+	0x3A,0x6A,0x55,0x1D,0x20,0xA2,0xE3,0x19,0x5B,0x97,0xEA,0x44,0x0C,0x7F,0x3D,0xB3,0xE5,0xD3,0xAD,0x97,
+	0xB5,0xB3,0x2D,0x93,0xA5,0x93,0x2A,0x0B,0xB5,0x00,0x35,0xA3,0xE4,0xD2,0xA5,0x87,0xB4,0xB2,0x25,0x83,
+	0xA4,0x92,0xC3,0x6D,0xC2,0x57,0x3C,0xB2,0x65,0xD1,0xAC,0x96,0x35,0xB1,0x2C,0x92,0x25,0x91,0x49,0xBB,
+	0xAF,0xF0,0x34,0xA2,0x64,0xD0,0xA4,0x86,0x34,0xB0,0x24,0x82,0x24,0x90,0x6C,0x06,0xDC,0x51,0x04,0xB6,
+	0x50,0x21,0xD4,0x1D,0x43,0x2F,0xE0,0x80,0xF5,0x57,0x96,0x70,0x3D,0xB3,0xDE,0x3A,0xDA,0x55,0x43,0xF2,
+	0x1E,0x47,0x4A,0xF2,0xD3,0x3F,0xC5,0x64,0xB9,0xBF,0xFB,0x83,0x59,0x3D,0xA4,0x43,0x93,0x76,0x4A,0xB5,
+	0xF6,0x32,0x97,0x15,0xDC,0x40,0x1D,0xE7,0x5A,0xFA,0xC6,0xBE,0xE5,0x0A,0xE9,0x91,0x0C,0xD7,0xBB,0x3F,
+	0xDD,0xEB,0x3B,0x3B,0xCD,0xCB,0xAB,0x1F,0x9D,0xAB,0x2B,0x1B,0x8D,0x8B,0xB3,0x2F,0xDC,0xEA,0x33,0x2B,
+	0xCC,0xCA,0xA3,0x0F,0x9C,0xAA,0x23,0x0B,0x8C,0x8A,0xBA,0x3E,0x5D,0xE9,0x3A,0x3A,0x4D,0xC9,0xAA,0x1E,
+	0x1D,0xA9,0x2A,0x1A,0x0D,0x89,0xB2,0x2E,0x5C,0xE8,0x32,0x2A,0x4C,0xC8,0xA2,0x0E,0x1C,0xA8,0x22,0x0A,
+	0x0C,0x88,0xC6,0x79,0x37,0x5A,0xF8,0xE9,0xBA,0x30,0x4F,0xEF,0x5B,0xC3,0x48,0x4E,0x98,0xC9,0x31,0xD7,
+	0x5E,0x19,0x66,0xB2,0x1D,0x3F,0x38,0xCD,0xCA,0xDC,0x65,0x98,0x90,0x90,0x88,0xAE,0x8C,0x66,0x72,0x6F,
+	0xF8,0x35,0xAD,0x3A,0xC5,0xD8,0x68,0xDF,0x92,0x75,0x54,0x99,0xD2,0xEB,0x07,0x9B,0x58,0x34,0x60,0x3D,
+	0xC2,0x12,0xB9,0xD8,0x5A,0xFE,0xB9,0x37,0xD5,0xE3,0x39,0x33,0xC5,0xC3,0xA9,0x17,0x95,0xA3,0x29,0x13,
+	0x85,0x83,0xB1,0x27,0xD4,0xE2,0x31,0x23,0xC4,0xC2,0xA1,0x07,0x94,0xA2,0x21,0x03,0x84,0x82,0xB8,0x36,
+	0x55,0xE1,0x38,0x32,0x45,0xC1,0xA8,0x16,0x15,0xA1,0x28,0x12,0x05,0x81,0xB0,0x26,0x54,0xE0,0x30,0x22,
+	0x44,0xC0,0xA0,0x06,0x14,0xA0,0x20,0x02,0x04,0x80,0x98,0x90,0x74,0x92,0x9A,0xF8,0xC9,0x7D,0x22,0xD9,
+	0xBB,0x6D,0xCA,0x54,0xF7,0x94,0x0C,0x52,0x01,0xEF,0xF2,0x29,0x41,0x76,0x30,0x22,0xB8,0xA3,0xE0,0xD4,
+	0xD7,0x1D,0x99,0x73,0x04,0x04,0x0E,0x75,0x6F,0xE0,0xAF,0xE4,0x06,0x42,0x29,0xCA,0xDC,0xA2,0xB9,0x54,
+	0xA1,0xED,0x3C,0xE5,0xB1,0xA5,0x3B,0xCC,0xE1,0x3F,0xC3,0xC7,0xDD,0xEC,0x9F,0xBD,0xF9,0x7B,0x1F,0xB9,
+	0xE9,0x5B,0x8F,0x9D,0xB9,0x3B,0x0F,0x99,0xA9,0x1B,0x97,0xAD,0xF8,0x7A,0x17,0xA9,0xE8,0x5A,0x87,0x8D,
+	0xB8,0x3A,0x07,0x89,0xA8,0x1A,0x9E,0xBC,0x79,0x79,0x1E,0xB8,0x69,0x59,0x8E,0x9C,0x39,0x39,0x0E,0x98,
+	0x29,0x19,0x96,0xAC,0x78,0x78,0x16,0xA8,0x68,0x58,0x86,0x8C,0x38,0x38,0x06,0x88,0x28,0x18,0x62,0x35,
+	0x04,0xE4,0xAE,0x75,0xBD,0x22,0x28,0x2F,0x91,0x45,0x94,0xE2,0x79,0xA8,0x12,0x0B,0x51,0x7E,0xE0,0xE0,
+	0x1B,0x3A,0xEA,0x25,0xC9,0x66,0x65,0x2A,0x5B,0xA9,0x0B,0xC9,0x71,0x89,0x58,0xED,0x30,0xA7,0xA4,0xD4,
+	0x2D,0x49,0xEB,0xCD,0x59,0xCD,0x2B,0x1A,0xD9,0x85,0x9C,0x3B,0xF6,0xA4,0x9F,0x40,0x6E,0x8A,0x6D,0x79,
+	0x7F,0xA5,0x9D,0xB5,0xF1,0x73,0x1D,0xB1,0xE1,0x53,0x8D,0x95,0xB1,0x33,0x0D,0x91,0xA1,0x13,0x95,0xA5,
+	0xF0,0x72,0x15,0xA1,0xE0,0x52,0x85,0x85,0xB0,0x32,0x05,0x81,0xA0,0x12,0x9C,0xB4,0x71,0x71,0x1C,0xB0,
+	0x61,0x51,0x8C,0x94,0x31,0x31,0x0C,0x90,0x21,0x11,0x94,0xA4,0x70,0x70,0x14,0xA0,0x60,0x50,0x84,0x84,
+	0x30,0x30,0x04,0x80,0x20,0x10,0xE4,0x9B,0xDA,0x6D,0xC4,0x22,0x31,0xBF,0xA4,0xE0,0xC5,0xDC,0xCB,0x22,
+	0x5F,0xB9,0xD7,0xB6,0xA8,0x4C,0x8B,0xE9,0xBA,0x07,0xE6,0x26,0xE6,0x95,0x63,0x42,0x02,0xB1,0xB0,0x7C,
+	0x55,0x41,0x11,0x65,0xB0,0x39,0x91,0xE1,0x60,0x90,0x25,0x23,0xB5,0x44,0x37,0x91,0x67,0x97,0xA5,0x87,
+	0x48,0x05,0x55,0xB4,0x66,0xDE,0x3D,0x52,0xD0,0xF5,0x9B,0x3D,0xD9,0x6B,0x1B,0x39,0xC9,0x4B,0x8B,0x1D,
+	0x99,0x2B,0x0B,0x19,0x89,0x0B,0x93,0x2D,0xD8,0x6A,0x13,0x29,0xC8,0x4A,0x83,0x0D,0x98,0x2A,0x03,0x09,
+	0x88,0x0A,0x9A,0x3C,0x59,0x69,0x1A,0x38,0x49,0x49,0x8A,0x1C,0x19,0x29,0x0A,0x18,0x09,0x09,0x92,0x2C,
+	0x58,0x68,0x12,0x28,0x48,0x48,0x82,0x0C,0x18,0x28,0x02,0x08,0x08,0x08,0x2E,0x8E,0xAC,0x78,0x59,0xAA,
+	0xB1,0x05,0xE6,0x28,0x69,0x22,0xBE,0x09,0xDD,0x07,0x14,0x04,0xDA,0xD8,0x0E,0x80,0xB1,0xC4,0x71,0xF8,
+	0xEF,0x91,0x2E,0xCC,0x96,0x70,0x8B,0xF9,0x72,0x65,0x40,0x70,0x98,0x4E,0x6D,0xAE,0x4F,0x98,0x8D,0x4D,
+	0x01,0xF5,0xC3,0x1B,0x51,0xBB,0xB7,0x8B,0xA3,0x06,0x9B,0x4B,0xAD,0xD4,0xE6,0x52,0x1A,0xE0,0x99,0x35,
+	0xD1,0x63,0x19,0x31,0xC1,0x43,0x89,0x15,0x91,0x23,0x09,0x11,0x81,0x03,0x91,0x25,0xD0,0x62,0x11,0x21,
+	0xC0,0x42,0x81,0x05,0x90,0x22,0x01,0x01,0x80,0x02,0x98,0x34,0x51,0x61,0x18,0x30,0x41,0x41,0x88,0x14,
+	0x11,0x21,0x08,0x10,0x01,0x01,0x90,0x24,0x50,0x60,0x10,0x20,0x40,0x40,0x80,0x04,0x10,0x20,0x00,0x00,
+	0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x7F,0xFB,0xEF,0xDF,0xEF,0xDF,0xBF,0xBF,0x6F,0xDB,0xAF,0x9F,0xF7,0xEF,
+	0xFE,0xFE,0x77,0xEB,0xEE,0xDE,0xE7,0xCF,0xBE,0xBE,0x67,0xCB,0xAE,0x9E,0xFE,0xFE,0x7F,0xFD,0x7E,0xFA,
+	0x6F,0xDD,0xEE,0xDE,0x3F,0xBD,0x6E,0xDA,0x2F,0x9D,0xF6,0xEE,0x7E,0xFC,0x76,0xEA,0x6E,0xDC,0xE6,0xCE,
+	0x3E,0xBC,0x66,0xCA,0x2E,0x9C,0xBF,0xBF,0xFD,0xFB,0x3F,0xBB,0xED,0xDB,0xAF,0x9F,0xBD,0xBB,0x2F,0x9B,
+	0xAD,0x9B,0xB7,0xAF,0xFC,0xFA,0x37,0xAB,0xEC,0xDA,0xA7,0x8F,0xBC,0xBA,0x27,0x8B,0xAC,0x9A,0xBE,0xBE,
+	0x7D,0xF9,0x3E,0xBA,0x6D,0xD9,0xAE,0x9E,0x3D,0xB9,0x2E,0x9A,0x2D,0x99,0xB6,0xAE,0x7C,0xF8,0x36,0xAA,
+	0x6C,0xD8,0xA6,0x8E,0x3C,0xB8,0x26,0x8A,0x2C,0x98,0xFD,0xF7,0xF7,0xF7,0x7D,0xF3,0xE7,0xD7,0xED,0xD7,
+	0xB7,0xB7,0x6D,0xD3,0xA7,0x97,0xF5,0xE7,0xF6,0xF6,0x75,0xE3,0xE6,0xD6,0xE5,0xC7,0xB6,0xB6,0x65,0xC3,
+	0xA6,0x96,0xFC,0xF6,0x77,0xF5,0x7C,0xF2,0x67,0xD5,0xEC,0xD6,0x37,0xB5,0x6C,0xD2,0x27,0x95,0xF4,0xE6,
+	0x76,0xF4,0x74,0xE2,0x66,0xD4,0xE4,0xC6,0x36,0xB4,0x64,0xC2,0x26,0x94,0xBD,0xB7,0xF5,0xF3,0x3D,0xB3,
+	0xE5,0xD3,0xAD,0x97,0xB5,0xB3,0x2D,0x93,0xA5,0x93,0xB5,0xA7,0xF4,0xF2,0x35,0xA3,0xE4,0xD2,0xA5,0x87,
+	0xB4,0xB2,0x25,0x83,0xA4,0x92,0xBC,0xB6,0x75,0xF1,0x3C,0xB2,0x65,0xD1,0xAC,0x96,0x35,0xB1,0x2C,0x92,
+	0x25,0x91,0xB4,0xA6,0x74,0xF0,0x34,0xA2,0x64,0xD0,0xA4,0x86,0x34,0xB0,0x24,0x82,0x24,0x90,0xFB,0x7F,
+	0xDF,0xEF,0x7B,0x7B,0xCF,0xCF,0xEB,0x5F,0x9F,0xAF,0x6B,0x5B,0x8F,0x8F,0xF3,0x6F,0xDE,0xEE,0x73,0x6B,
+	0xCE,0xCE,0xE3,0x4F,0x9E,0xAE,0x63,0x4B,0x8E,0x8E,0xFA,0x7E,0x5F,0xED,0x7A,0x7A,0x4F,0xCD,0xEA,0x5E,
+	0x1F,0xAD,0x6A,0x5A,0x0F,0x8D,0xF2,0x6E,0x5E,0xEC,0x72,0x6A,0x4E,0xCC,0xE2,0x4E,0x1E,0xAC,0x62,0x4A,
+	0x0E,0x8C,0xBB,0x3F,0xDD,0xEB,0x3B,0x3B,0xCD,0xCB,0xAB,0x1F,0x9D,0xAB,0x2B,0x1B,0x8D,0x8B,0xB3,0x2F,
+	0xDC,0xEA,0x33,0x2B,0xCC,0xCA,0xA3,0x0F,0x9C,0xAA,0x23,0x0B,0x8C,0x8A,0xBA,0x3E,0x5D,0xE9,0x3A,0x3A,
+	0x4D,0xC9,0xAA,0x1E,0x1D,0xA9,0x2A,0x1A,0x0D,0x89,0xB2,0x2E,0x5C,0xE8,0x32,0x2A,0x4C,0xC8,0xA2,0x0E,
+	0x1C,0xA8,0x22,0x0A,0x0C,0x88,0xF9,0x77,0xD7,0xE7,0x79,0x73,0xC7,0xC7,0xE9,0x57,0x97,0xA7,0x69,0x53,
+	0x87,0x87,0xF1,0x67,0xD6,0xE6,0x71,0x63,0xC6,0xC6,0xE1,0x47,0x96,0xA6,0x61,0x43,0x86,0x86,0xF8,0x76,
+	0x57,0xE5,0x78,0x72,0x47,0xC5,0xE8,0x56,0x17,0xA5,0x68,0x52,0x07,0x85,0xF0,0x66,0x56,0xE4,0x70,0x62,
+	0x46,0xC4,0xE0,0x46,0x16,0xA4,0x60,0x42,0x06,0x84,0xB9,0x37,0xD5,0xE3,0x39,0x33,0xC5,0xC3,0xA9,0x17,
+	0x95,0xA3,0x29,0x13,0x85,0x83,0xB1,0x27,0xD4,0xE2,0x31,0x23,0xC4,0xC2,0xA1,0x07,0x94,0xA2,0x21,0x03,
+	0x84,0x82,0xB8,0x36,0x55,0xE1,0x38,0x32,0x45,0xC1,0xA8,0x16,0x15,0xA1,0x28,0x12,0x05,0x81,0xB0,0x26,
+	0x54,0xE0,0x30,0x22,0x44,0xC0,0xA0,0x06,0x14,0xA0,0x20,0x02,0x04,0x80,0xDF,0xFD,0xFB,0x7F,0x5F,0xF9,
+	0xEB,0x5F,0xCF,0xDD,0xBB,0x3F,0x4F,0xD9,0xAB,0x1F,0xD7,0xED,0xFA,0x7E,0x57,0xE9,0xEA,0x5E,0xC7,0xCD,
+	0xBA,0x3E,0x47,0xC9,0xAA,0x1E,0xDE,0xFC,0x7B,0x7D,0x5E,0xF8,0x6B,0x5D,0xCE,0xDC,0x3B,0x3D,0x4E,0xD8,
+	0x2B,0x1D,0xD6,0xEC,0x7A,0x7C,0x56,0xE8,0x6A,0x5C,0xC6,0xCC,0x3A,0x3C,0x46,0xC8,0x2A,0x1C,0x9F,0xBD,
+	0xF9,0x7B,0x1F,0xB9,0xE9,0x5B,0x8F,0x9D,0xB9,0x3B,0x0F,0x99,0xA9,0x1B,0x97,0xAD,0xF8,0x7A,0x17,0xA9,
+	0xE8,0x5A,0x87,0x8D,0xB8,0x3A,0x07,0x89,0xA8,0x1A,0x9E,0xBC,0x79,0x79,0x1E,0xB8,0x69,0x59,0x8E,0x9C,
+	0x39,0x39,0x0E,0x98,0x29,0x19,0x96,0xAC,0x78,0x78,0x16,0xA8,0x68,0x58,0x86,0x8C,0x38,0x38,0x06,0x88,
+	0x28,0x18,0xDD,0xF5,0xF3,0x77,0x5D,0xF1,0xE3,0x57,0xCD,0xD5,0xB3,0x37,0x4D,0xD1,0xA3,0x17,0xD5,0xE5,
+	0xF2,0x76,0x55,0xE1,0xE2,0x56,0xC5,0xC5,0xB2,0x36,0x45,0xC1,0xA2,0x16,0xDC,0xF4,0x73,0x75,0x5C,0xF0,
+	0x63,0x55,0xCC,0xD4,0x33,0x35,0x4C,0xD0,0x23,0x15,0xD4,0xE4,0x72,0x74,0x54,0xE0,0x62,0x54,0xC4,0xC4,
+	0x32,0x34,0x44,0xC0,0x22,0x14,0x9D,0xB5,0xF1,0x73,0x1D,0xB1,0xE1,0x53,0x8D,0x95,0xB1,0x33,0x0D,0x91,
+	0xA1,0x13,0x95,0xA5,0xF0,0x72,0x15,0xA1,0xE0,0x52,0x85,0x85,0xB0,0x32,0x05,0x81,0xA0,0x12,0x9C,0xB4,
+	0x71,0x71,0x1C,0xB0,0x61,0x51,0x8C,0x94,0x31,0x31,0x0C,0x90,0x21,0x11,0x94,0xA4,0x70,0x70,0x14,0xA0,
+	0x60,0x50,0x84,0x84,0x30,0x30,0x04,0x80,0x20,0x10,0xDB,0x7D,0xDB,0x6F,0x5B,0x79,0xCB,0x4F,0xCB,0x5D,
+	0x9B,0x2F,0x4B,0x59,0x8B,0x0F,0xD3,0x6D,0xDA,0x6E,0x53,0x69,0xCA,0x4E,0xC3,0x4D,0x9A,0x2E,0x43,0x49,
+	0x8A,0x0E,0xDA,0x7C,0x5B,0x6D,0x5A,0x78,0x4B,0x4D,0xCA,0x5C,0x1B,0x2D,0x4A,0x58,0x0B,0x0D,0xD2,0x6C,
+	0x5A,0x6C,0x52,0x68,0x4A,0x4C,0xC2,0x4C,0x1A,0x2C,0x42,0x48,0x0A,0x0C,0x9B,0x3D,0xD9,0x6B,0x1B,0x39,
+	0xC9,0x4B,0x8B,0x1D,0x99,0x2B,0x0B,0x19,0x89,0x0B,0x93,0x2D,0xD8,0x6A,0x13,0x29,0xC8,0x4A,0x83,0x0D,
+	0x98,0x2A,0x03,0x09,0x88,0x0A,0x9A,0x3C,0x59,0x69,0x1A,0x38,0x49,0x49,0x8A,0x1C,0x19,0x29,0x0A,0x18,
+	0x09,0x09,0x92,0x2C,0x58,0x68,0x12,0x28,0x48,0x48,0x82,0x0C,0x18,0x28,0x02,0x08,0x08,0x08,0xD9,0x75,
+	0xD3,0x67,0x59,0x71,0xC3,0x47,0xC9,0x55,0x93,0x27,0x49,0x51,0x83,0x07,0xD1,0x65,0xD2,0x66,0x51,0x61,
+	0xC2,0x46,0xC1,0x45,0x92,0x26,0x41,0x41,0x82,0x06,0xD8,0x74,0x53,0x65,0x58,0x70,0x43,0x45,0xC8,0x54,
+	0x13,0x25,0x48,0x50,0x03,0x05,0xD0,0x64,0x52,0x64,0x50,0x60,0x42,0x44,0xC0,0x44,0x12,0x24,0x40,0x40,
+	0x02,0x04,0x99,0x35,0xD1,0x63,0x19,0x31,0xC1,0x43,0x89,0x15,0x91,0x23,0x09,0x11,0x81,0x03,0x91,0x25,
+	0xD0,0x62,0x11,0x21,0xC0,0x42,0x81,0x05,0x90,0x22,0x01,0x01,0x80,0x02,0x98,0x34,0x51,0x61,0x18,0x30,
+	0x41,0x41,0x88,0x14,0x11,0x21,0x08,0x10,0x01,0x01,0x90,0x24,0x50,0x60,0x10,0x20,0x40,0x40,0x80,0x04,
+	0x10,0x20,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x7F,0xFB,0xEF,0xDF,0xEF,0xDF,0xBF,0xBF,0x6F,0xDB,
+	0xAF,0x9F,0xF7,0xEF,0xFE,0xFE,0x77,0xEB,0xEE,0xDE,0xE7,0xCF,0xBE,0xBE,0x67,0xCB,0xAE,0x9E,0xFE,0xFE,
+	0x7F,0xFD,0x7E,0xFA,0x6F,0xDD,0xEE,0xDE,0x3F,0xBD,0x6E,0xDA,0x2F,0x9D,0xF6,0xEE,0x7E,0xFC,0x76,0xEA,
+	0x6E,0xDC,0xE6,0xCE,0x3E,0xBC,0x66,0xCA,0x2E,0x9C,0xBF,0xBF,0xFD,0xFB,0x3F,0xBB,0xED,0xDB,0xAF,0x9F,
+	0xBD,0xBB,0x2F,0x9B,0xAD,0x9B,0xB7,0xAF,0xFC,0xFA,0x37,0xAB,0xEC,0xDA,0xA7,0x8F,0xBC,0xBA,0x27,0x8B,
+	0xAC,0x9A,0xBE,0xBE,0x7D,0xF9,0x3E,0xBA,0x6D,0xD9,0xAE,0x9E,0x3D,0xB9,0x2E,0x9A,0x2D,0x99,0xB6,0xAE,
+	0x7C,0xF8,0x36,0xAA,0x6C,0xD8,0xA6,0x8E,0x3C,0xB8,0x26,0x8A,0x2C,0x98,0xFD,0xF7,0xF7,0xF7,0x7D,0xF3,
+	0xE7,0xD7,0xED,0xD7,0xB7,0xB7,0x6D,0xD3,0xA7,0x97,0xF5,0xE7,0xF6,0xF6,0x75,0xE3,0xE6,0xD6,0xE5,0xC7,
+	0xB6,0xB6,0x65,0xC3,0xA6,0x96,0xFC,0xF6,0x77,0xF5,0x7C,0xF2,0x67,0xD5,0xEC,0xD6,0x37,0xB5,0x6C,0xD2,
+	0x27,0x95,0xF4,0xE6,0x76,0xF4,0x74,0xE2,0x66,0xD4,0xE4,0xC6,0x36,0xB4,0x64,0xC2,0x26,0x94,0xBD,0xB7,
+	0xF5,0xF3,0x3D,0xB3,0xE5,0xD3,0xAD,0x97,0xB5,0xB3,0x2D,0x93,0xA5,0x93,0xB5,0xA7,0xF4,0xF2,0x35,0xA3,
+	0xE4,0xD2,0xA5,0x87,0xB4,0xB2,0x25,0x83,0xA4,0x92,0xBC,0xB6,0x75,0xF1,0x3C,0xB2,0x65,0xD1,0xAC,0x96,
+	0x35,0xB1,0x2C,0x92,0x25,0x91,0xB4,0xA6,0x74,0xF0,0x34,0xA2,0x64,0xD0,0xA4,0x86,0x34,0xB0,0x24,0x82,
+	0x24,0x90,0xFB,0x7F,0xDF,0xEF,0x7B,0x7B,0xCF,0xCF,0xEB,0x5F,0x9F,0xAF,0x6B,0x5B,0x8F,0x8F,0xF3,0x6F,
+	0xDE,0xEE,0x73,0x6B,0xCE,0xCE,0xE3,0x4F,0x9E,0xAE,0x63,0x4B,0x8E,0x8E,0xFA,0x7E,0x5F,0xED,0x7A,0x7A,
+	0x4F,0xCD,0xEA,0x5E,0x1F,0xAD,0x6A,0x5A,0x0F,0x8D,0xF2,0x6E,0x5E,0xEC,0x72,0x6A,0x4E,0xCC,0xE2,0x4E,
+	0x1E,0xAC,0x62,0x4A,0x0E,0x8C,0xBB,0x3F,0xDD,0xEB,0x3B,0x3B,0xCD,0xCB,0xAB,0x1F,0x9D,0xAB,0x2B,0x1B,
+	0x8D,0x8B,0xB3,0x2F,0xDC,0xEA,0x33,0x2B,0xCC,0xCA,0xA3,0x0F,0x9C,0xAA,0x23,0x0B,0x8C,0x8A,0xBA,0x3E,
+	0x5D,0xE9,0x3A,0x3A,0x4D,0xC9,0xAA,0x1E,0x1D,0xA9,0x2A,0x1A,0x0D,0x89,0xB2,0x2E,0x5C,0xE8,0x32,0x2A,
+	0x4C,0xC8,0xA2,0x0E,0x1C,0xA8,0x22,0x0A,0x0C,0x88,0xF9,0x77,0xD7,0xE7,0x79,0x73,0xC7,0xC7,0xE9,0x57,
+	0x97,0xA7,0x69,0x53,0x87,0x87,0xF1,0x67,0xD6,0xE6,0x71,0x63,0xC6,0xC6,0xE1,0x47,0x96,0xA6,0x61,0x43,
+	0x86,0x86,0xF8,0x76,0x57,0xE5,0x78,0x72,0x47,0xC5,0xE8,0x56,0x17,0xA5,0x68,0x52,0x07,0x85,0xF0,0x66,
+	0x56,0xE4,0x70,0x62,0x46,0xC4,0xE0,0x46,0x16,0xA4,0x60,0x42,0x06,0x84,0xB9,0x37,0xD5,0xE3,0x39,0x33,
+	0xC5,0xC3,0xA9,0x17,0x95,0xA3,0x29,0x13,0x85,0x83,0xB1,0x27,0xD4,0xE2,0x31,0x23,0xC4,0xC2,0xA1,0x07,
+	0x94,0xA2,0x21,0x03,0x84,0x82,0xB8,0x36,0x55,0xE1,0x38,0x32,0x45,0xC1,0xA8,0x16,0x15,0xA1,0x28,0x12,
+	0x05,0x81,0xB0,0x26,0x54,0xE0,0x30,0x22,0x44,0xC0,0xA0,0x06,0x14,0xA0,0x20,0x02,0x04,0x80,0xDF,0xFD,
+	0xFB,0x7F,0x5F,0xF9,0xEB,0x5F,0xCF,0xDD,0xBB,0x3F,0x4F,0xD9,0xAB,0x1F,0xD7,0xED,0xFA,0x7E,0x57,0xE9,
+	0xEA,0x5E,0xC7,0xCD,0xBA,0x3E,0x47,0xC9,0xAA,0x1E,0xDE,0xFC,0x7B,0x7D,0x5E,0xF8,0x6B,0x5D,0xCE,0xDC,
+	0x3B,0x3D,0x4E,0xD8,0x2B,0x1D,0xD6,0xEC,0x7A,0x7C,0x56,0xE8,0x6A,0x5C,0xC6,0xCC,0x3A,0x3C,0x46,0xC8,
+	0x2A,0x1C,0x9F,0xBD,0xF9,0x7B,0x1F,0xB9,0xE9,0x5B,0x8F,0x9D,0xB9,0x3B,0x0F,0x99,0xA9,0x1B,0x97,0xAD,
+	0xF8,0x7A,0x17,0xA9,0xE8,0x5A,0x87,0x8D,0xB8,0x3A,0x07,0x89,0xA8,0x1A,0x9E,0xBC,0x79,0x79,0x1E,0xB8,
+	0x69,0x59,0x8E,0x9C,0x39,0x39,0x0E,0x98,0x29,0x19,0x96,0xAC,0x78,0x78,0x16,0xA8,0x68,0x58,0x86,0x8C,
+	0x38,0x38,0x06,0x88,0x28,0x18,0xDD,0xF5,0xF3,0x77,0x5D,0xF1,0xE3,0x57,0xCD,0xD5,0xB3,0x37,0x4D,0xD1,
+	0xA3,0x17,0xD5,0xE5,0xF2,0x76,0x55,0xE1,0xE2,0x56,0xC5,0xC5,0xB2,0x36,0x45,0xC1,0xA2,0x16,0xDC,0xF4,
+	0x73,0x75,0x5C,0xF0,0x63,0x55,0xCC,0xD4,0x33,0x35,0x4C,0xD0,0x23,0x15,0xD4,0xE4,0x72,0x74,0x54,0xE0,
+	0x62,0x54,0xC4,0xC4,0x32,0x34,0x44,0xC0,0x22,0x14,0x9D,0xB5,0xF1,0x73,0x1D,0xB1,0xE1,0x53,0x8D,0x95,
+	0xB1,0x33,0x0D,0x91,0xA1,0x13,0x95,0xA5,0xF0,0x72,0x15,0xA1,0xE0,0x52,0x85,0x85,0xB0,0x32,0x05,0x81,
+	0xA0,0x12,0x9C,0xB4,0x71,0x71,0x1C,0xB0,0x61,0x51,0x8C,0x94,0x31,0x31,0x0C,0x90,0x21,0x11,0x94,0xA4,
+	0x70,0x70,0x14,0xA0,0x60,0x50,0x84,0x84,0x30,0x30,0x04,0x80,0x20,0x10,0xDB,0x7D,0xDB,0x6F,0x5B,0x79,
+	0xCB,0x4F,0xCB,0x5D,0x9B,0x2F,0x4B,0x59,0x8B,0x0F,0xD3,0x6D,0xDA,0x6E,0x53,0x69,0xCA,0x4E,0xC3,0x4D,
+	0x9A,0x2E,0x43,0x49,0x8A,0x0E,0xDA,0x7C,0x5B,0x6D,0x5A,0x78,0x4B,0x4D,0xCA,0x5C,0x1B,0x2D,0x4A,0x58,
+	0x0B,0x0D,0xD2,0x6C,0x5A,0x6C,0x52,0x68,0x4A,0x4C,0xC2,0x4C,0x1A,0x2C,0x42,0x48,0x0A,0x0C,0x9B,0x3D,
+	0xD9,0x6B,0x1B,0x39,0xC9,0x4B,0x8B,0x1D,0x99,0x2B,0x0B,0x19,0x89,0x0B,0x93,0x2D,0xD8,0x6A,0x13,0x29,
+	0xC8,0x4A,0x83,0x0D,0x98,0x2A,0x03,0x09,0x88,0x0A,0x9A,0x3C,0x59,0x69,0x1A,0x38,0x49,0x49,0x8A,0x1C,
+	0x19,0x29,0x0A,0x18,0x09,0x09,0x92,0x2C,0x58,0x68,0x12,0x28,0x48,0x48,0x82,0x0C,0x18,0x28,0x02,0x08,
+	0x08,0x08,0xD9,0x75,0xD3,0x67,0x59,0x71,0xC3,0x47,0xC9,0x55,0x93,0x27,0x49,0x51,0x83,0x07,0xD1,0x65,
+	0xD2,0x66,0x51,0x61,0xC2,0x46,0xC1,0x45,0x92,0x26,0x41,0x41,0x82,0x06,0xD8,0x74,0x53,0x65,0x58,0x70,
+	0x43,0x45,0xC8,0x54,0x13,0x25,0x48,0x50,0x03,0x05,0xD0,0x64,0x52,0x64,0x50,0x60,0x42,0x44,0xC0,0x44,
+	0x12,0x24,0x40,0x40,0x02,0x04,0x99,0x35,0xD1,0x63,0x19,0x31,0xC1,0x43,0x89,0x15,0x91,0x23,0x09,0x11,
+	0x81,0x03,0x91,0x25,0xD0,0x62,0x11,0x21,0xC0,0x42,0x81,0x05,0x90,0x22,0x01,0x01,0x80,0x02,0x98,0x34,
+	0x51,0x61,0x18,0x30,0x41,0x41,0x88,0x14,0x11,0x21,0x08,0x10,0x01,0x01,0x90,0x24,0x50,0x60,0x10,0x20,
+	0x40,0x40,0x80,0x04,0x10,0x20,0x00,0x00,0x84,0x4C,0x80,0x05,0x76,0x8D,0xDE,0x85,0xB1,0x8B,0x52,0x92,
+	0x14,0x40,0xCE,0xA1,0x58,0xCB,0xAC,0x72,0x40,0x81,0x90,0xE5,0x5B,0x21,0x24,0xB2,0x41,0xA7,0xC6,0xB5,
+	0xD3,0xCA,0x7F,0x19,0x02,0x2A,0x41,0x05,0xFB,0xA0,0x19,0x24,0xC4,0x62,0x90,0x05,0x50,0x48,0x71,0xEC,
+	0xC1,0x41,0xD7,0x1D,0xB1,0x88,0x47,0xD3,0xCD,0xC6,0x59,0x35,0xBA,0xE1,0x7E,0x48,0xC0,0x06,0x3F,0xBA,
+	0x14,0xE4,0x46,0xF1,0xA9,0xE6,0xF9,0x23,0x7C,0xE8,0xFB,0xC0,0x05,0xA5,0x08,0x40,0x82,0xA8,0x1A,0x03,
+	0x5F,0x4C,0xF1,0x73,0x52,0xE5,0x49,0xC5,0x7E,0xA4,0xD4,0xC1,0xD6,0xBB,0xEA,0xD0,0x80,0xE9,0x9B,0x78,
+	0x93,0x67,0x05,0x23,0xEB,0xA5,0x36,0xD1,0xD7,0xD2,0x2F,0xF3,0xCA,0x3A,0xA3,0xA1,0x53,0x47,0x80,0x6A,
+	0x73,0xDA,0x87,0x0C,0x9A,0x20,0x3C,0x2F,0x20,0x47,0x82,0xDD,0x12,0x68,0x7A,0x5E,0xF5,0x4B,0xEA,0x5C,
+	0x0C,0x26,0x1A,0x7B,0x4D,0x49,0x9B,0x1C,0xD9,0xA8,0xDC,0x08,0x8E,0x8A,0x0E,0xFD,0x90,0x25,0x3D,0x2E,
+	0xE7,0x0A,0xCD,0xA8,0xD0,0xC1,0x89,0x63,0x0B,0x23,0x0B,0x1C,0x30,0x80,0xF1,0x3D,0xC9,0xE4,0xC5,0xBC,
+	0x5B,0xC0,0xBD,0x3B,0x48,0x8F,0x02,0x5D,0x8D,0x6E,0x08,0x75,0xE9,0x4A,0x58,0x9A,0x85,0xE1,0x74,0x54,
+	0x6A,0xED,0xB5,0xA6,0xE4,0xF2,0xDA,0x9A,0xEA,0xB2,0xD8,0x74,0x59,0x6C,0x03,0xB7,0x0A,0x5E,0x41,0xF7,
+	0x7B,0x51,0x5F,0x07,0x6B,0xC6,0xF3,0x60,0xD2,0x2E,0x53,0x4C,0x77,0xAD,0x0B,0x4D,0xB1,0xA2,0x11,0x78,
+	0x28,0xC5,0xD3,0x7F,0x59,0x8F,0xBF,0xE2,0x61,0x50,0x03,0x75,0x3A,0x36,0xBA,0x51,0x6A,0x5C,0x95,0x84,
+	0x1B,0x40,0x74,0xE3,0x71,0x18,0xCE,0x1E,0x5A,0x93,0x62,0x20,0x8A,0xF3,0xD8,0x36,0x1A,0x33,0x7D,0xE3,
+	0xE3,0xCD,0xDB,0x01,0xB0,0x99,0x4B,0x25,0xE0,0xDF,0x95,0xA7,0xB2,0xD9,0x4C,0x6C,0xC7,0x51,0x8D,0x64,
+	0xA1,0x23,0x43,0xB9,0xC1,0xFC,0x9D,0x44,0xB3,0x7D,0x3A,0xCD,0xAD,0xB9,0x04,0xD0,0xC3,0x2F,0x6C,0xB0,
+	0x66,0x5B,0xEE,0x63,0xDE,0x2B,0x4D,0x42,0x23,0x1D,0xB3,0x56,0xB3,0x35,0x26,0x20,0x6B,0x8A,0xE6,0x73,
+	0xDF,0x69,0x40,0x53,0x22,0xBB,0x3A,0xB7,0x55,0x28,0x6D,0x1E,0xA1,0x76,0xEF,0x62,0x5E,0x69,0x09,0x20,
+	0xB7,0x13,0x12,0xD5,0xC4,0x3D,0xE2,0x21,0x14,0x8F,0xF3,0xF3,0x62,0x2B,0x84,0x62,0x57,0x10,0xD8,0x85,
+	0x38,0x78,0x13,0x2A,0x69,0x20,0xC8,0x3D,0x78,0xF5,0x70,0x1A,0x28,0xFE,0xEE,0x6D,0x3F,0x39,0x26,0x49,
+	0x6F,0x59,0xDE,0x4F,0x61,0x7F,0xDC,0x8D,0xAE,0xBA,0x83,0xEE,0xD3,0x18,0x37,0x3D,0x83,0x78,0xE9,0x28,
+	0x93,0x6A,0x55,0x98,0x0A,0xB4,0xD1,0x0D,0x19,0x90,0x41,0x29,0xC9,0xF0,0x97,0xF0,0x9A,0x1B,0x1C,0xCA,
+	0x42,0x2C,0xFC,0x2E,0x96,0xC2,0x2E,0x19,0x3A,0x7C,0xF8,0xEB,0xEF,0x73,0x18,0xD0,0xC0,0x0D,0xFE,0x62,
+	0x50,0x09,0x26,0x8B,0x3B,0x56,0xF7,0xB2,0xB2,0x19,0x39,0xC0,0xC9,0xE1,0xBC,0x13,0x0D,0x95,0x37,0x29,
+	0x24,0xD3,0x63,0xA7,0x33,0x3A,0x6F,0xCD,0x63,0x2F,0xCF,0x2C,0x33,0xC0,0x24,0x99,0xBC,0x54,0x76,0x22,
+	0x42,0xA1,0x9D,0xF2,0x58,0x8F,0xE4,0x84,0x7F,0xE2,0xB0,0x23,0x44,0x80,0x70,0x26,0x3F,0x62,0x22,0x16,
+	0xA6,0x8C,0xF6,0x87,0x15,0x0A,0x68,0x36,0x4D,0xE9,0xE6,0xB3,0x5D,0x4A,0x41,0x42,0x31,0x8F,0xA1,0xF6,
+	0xD6,0xA6,0x35,0xBE,0xC0,0xE2,0xB9,0xD6,0x9E,0xE2,0xD6,0xC3,0x8D,0x0C,0xA8,0x97,0x15,0xA2,0xB9,0x32,
+	0x82,0x83,0xB8,0x17,0x55,0xA1,0xD3,0xD2,0x00,0x24,0x1D,0xBD,0xE5,0x5B,0x74,0x9C,0xBB,0x4E,0xF2,0x14,
+	0x21,0xC4,0x32,0x4F,0xA4,0x83,0xD2,0xB9,0xEC,0x3A,0xF0,0x4E,0xA6,0xCA,0x07,0xA6,0x29,0xE6,0x2D,0xC1,
+	0x8F,0xFB,0x1A,0xC3,0x9A,0xCB,0x8A,0x3F,0x65,0xC0,0x15,0x07,0x24,0x83,0x65,0x3D,0x26,0x0F,0x16,0xA9,
+	0x91,0x27,0x19,0x33,0xDA,0x4C,0xC7,0x7E,0x94,0x15,0x68,0x0B,0xFB,0x75,0xFC,0x8F,0x9E,0x03,0x36,0x5A,
+	0x48,0xE8,0xEC,0xAF,0xDE,0x43,0x4A,0x5B,0xF0,0x02,0xCA,0xEF,0x57,0xA9,0xBA,0x3B,0x9F,0x89,0xA2,0xCF,
+	0x17,0xE9,0x69,0xF5,0xD9,0x85,0x63,0x0F,0xF7,0x28,0x6D,0x2F,0xC4,0xDE,0x73,0x2F,0xB7,0x68,0xAC,0xF9,
+	0x0F,0xA3,0xF5,0x17,0x8D,0xAF,0x3F,0x99,0xC9,0xEB,0xE5,0xBA,0xD5,0x40,0xE2,0xA8,0xAF,0x73,0x3A,0x3C,
+	0xE1,0x73,0xF6,0x88,0xCC,0xC4,0x09,0x1C,0xD0,0x89,0x6E,0xA4,0xF2,0x07,0x68,0xDE,0x19,0x6D,0x76,0x05,
+	0x2C,0x3D,0xB0,0x3C,0x37,0xE0,0x29,0x4A,0x6D,0x04,0x23,0x5E,0x95,0xEC,0xFA,0x19,0x6D,0xC8,0xEB,0x6E,
+	0x8A,0x12,0x90,0x07,0x2C,0x02,0x63,0x7B,0x1A,0x5A,0x03,0xF9,0xC6,0x12,0xE3,0x55,0xDE,0xF8,0x55,0x44,
+	0xD4,0xDE,0xE2,0x86,0xB4,0xD3,0x72,0xA2,0x0F,0xC0,0xCC,0x24,0x7D,0x8D,0x76,0x93,0x86,0x97,0x6C,0x96,
+	0x5E,0x33,0x5C,0xF2,0x78,0x5C,0xB0,0xD8,0xD4,0x79,0x92,0x01,0xA1,0x63,0xFB,0x06,0x36,0x19,0x25,0x52,
+	0xFC,0xD2,0xEF,0xBA,0x57,0xF4,0xA5,0xAF,0x06,0x95,0x85,0x66,0xFF,0xB3,0x45,0x31,0xE4,0x8B,0x3D,0x55,
+	0x54,0x0C,0xE5,0x33,0x3A,0xB4,0x64,0xC3,0xE0,0xF4,0x3F,0x0D,0x9D,0x2B,0x4A,0xE4,0x80,0x20,0x5F,0x42,
+	0xDB,0xD7,0x58,0x3C,0xD6,0xD3,0xBC,0xE6,0x44,0x97,0x7B,0xED,0x75,0xBB,0xD0,0xCF,0x5E,0x34,0xE5,0xC2,
+	0x57,0xD0,0x8E,0x67,0xA2,0x58,0xF2,0xF8,0xA2,0x62,0xDE,0x52,0xA1,0x17,0x59,0x97,0xBB,0x78,0x7B,0x0A,
+	0x98,0x87,0x8B,0xB1,0x51,0xBB,0x6E,0x1D,0x8D,0x91,0xF8,0x86,0x3E,0xBC,0x34,0x48,0x68,0xF8,0xFC,0xAF,
+	0x9F,0x72,0x16,0x69,0x39,0x14,0xF0,0x1A,0x3D,0x34,0x60,0x3E,0x6D,0x72,0x45,0xE2,0xDE,0x97,0xDE,0x09,
+	0xAF,0x7C,0xA8,0x7E,0xB6,0xBC,0x0B,0x5A,0xE6,0xD6,0xB3,0x51,0x01,0x70,0x51,0x1E,0x44,0xCB,0xD1,0x0F,
+	0x56,0x19,0x7D,0xFB,0x6D,0xEB,0x81,0xB6,0x3F,0xFB,0xBE,0xF5,0x3A,0x47,0xC6,0xCF,0x99,0xAC,0xB6,0xFE,
+	0x79,0x9E,0x82,0x13,0x40,0xBE,0x10,0x5E,0xDA,0x3E,0xD4,0x59,0x93,0xA2,0x7E,0x7E,0x2B,0x79,0x3E,0xEA,
+	0x83,0x08,0x67,0xB4,0xC6,0xDC,0x08,0x3D,0x3E,0x8F,0xF5,0x65,0xE8,0xDE,0x75,0xD0,0x02,0x9C,0x2B,0x28,
+	0xA5,0x62,0xA5,0xCA,0xDF,0x2F,0xBF,0xEA,0x3D,0x52,0xF8,0x7B,0xBB,0x0A,0xB7,0x1C,0x06,0xC0,0x24,0x66,
+	0x33,0x40,0x63,0x66,0xEA,0xBB,0x94,0x63,0xD2,0x68,0x78,0x56,0xA3,0xFF,0x68,0x1C,0x33,0x31,0xAF,0xB5,
+	0x47,0x81,0xBE,0xEF,0x05,0xC5,0xB6,0xFC,0x90,0x4C,0x6D,0x07,0x98,0x4E,0x91,0xA5,0x84,0xB7,0xA0,0x47,
+	0x3B,0xD2,0xF0,0x57,0x6B,0xA7,0x8C,0x06,0xDF,0x67,0xAE,0x0E,0x9D,0x01,0x72,0x28,0x19,0x9D,0x38,0x22,
+	0x41,0xF4,0x2F,0x36,0xB1,0x65,0xE3,0x79,0xBE,0x94,0xD0,0x64,0x52,0x64,0x40,0xE2,0xF6,0x0A,0xB0,0x73,
+	0x37,0x25,0x5C,0x37,0xC1,0x4D,0xD8,0x74,0x53,0x65,0x4B,0x01,0x21,0x00,0xC5,0x65,0x92,0x26,0xC1,0xA6,
+	0xC0,0xB3,0xD1,0x65,0xD2,0x66,0xFD,0x2E,0x20,0x46,0xC9,0x55,0x93,0x27,0xEB,0x13,0x28,0xF7,0xD9,0x75,
+	0xD3,0x67,0x42,0x0E,0xC0,0xF8,0xA4,0x98,0x94,0xA3,0x90,0x17,0xB4,0x4A,0xD2,0xAA,0xA4,0x9D,0x08,0xDE,
+	0xAB,0x4C,0x71,0x3A,0x09,0xA4,0x99,0x3E,0x81,0xF9,0x19,0x06,0x01,0x28,0xA7,0xF5,0x08,0xF1,0x87,0xEF,
+	0x9E,0xEA,0xD3,0x3D,0x34,0xEE,0xD3,0x13,0x84,0xDF,0x79,0xBC,0x2D,0xEC,0x5F,0xE2,0x1A,0x25,0xBF,0x5B,
+	0x65,0xB4,0x77,0xBD,0x25,0x4B,0xAA,0xFB,0x8F,0x4B,0xC2,0x4C,0x1A,0x2C,0x74,0xB7,0x1E,0x0A,0xD2,0x6C,
+	0x5A,0x6C,0x3E,0xA5,0x2A,0x4F,0xCA,0x5C,0x1B,0x2D,0xD9,0x5C,0xC4,0x4F,0xDA,0x7C,0x5B,0x6D,0x83,0x5D,
+	0x78,0x42,0xC3,0x4D,0x9A,0x2E,0xE4,0x57,0x92,0xBB,0xD3,0x6D,0xDA,0x6E,0xC9,0x66,0x0E,0x08,0xCB,0x5D,
+	0x9B,0x2F,0xEC,0x78,0x46,0x49,0xDB,0x7D,0xDB,0x6F,0x80,0x04,0x64,0xE5,0x0C,0x86,0xC5,0x3F,0x74,0xE4,
+	0x6F,0x5D,0xBC,0x66,0xF2,0x78,0xBB,0xAF,0x79,0x53,0x48,0x11,0x72,0xC2,0x94,0xC8,0x80,0x5E,0xFC,0xF4,
+	0x8A,0x7C,0x3F,0x7E,0xA6,0xD2,0x31,0xFA,0x13,0x8F,0x5F,0x7E,0x43,0x54,0x7A,0x55,0xA8,0x7D,0x8F,0xAE,
+	0x5D,0xC3,0xED,0xD1,0x8C,0x3C,0x7D,0xF5,0xD8,0x5C,0xEF,0xAC,0xB1,0x88,0x3C,0xE4,0xA7,0x33,0xC4,0xC4,
+	0x32,0x34,0x94,0xF4,0x9E,0x18,0xD4,0xE4,0x72,0x74,0xFB,0x2D,0x33,0x5B,0xCC,0xD4,0x33,0x35,0xF4,0x53,
+	0x1C,0xD5,0xDC,0xF4,0x73,0x75,0x9A,0xD0,0xA4,0xD6,0xC5,0xC5,0xB2,0x36,0x25,0x27,0x48,0x17,0xD5,0xE5,
+	0xF2,0x76,0x3D,0xF7,0x41,0x74,0xCD,0xD5,0xB3,0x37,0x9D,0xE5,0x1F,0x1B,0xDD,0xF5,0xF3,0x77,0xC6,0x9C,
+	0xD4,0xBC,0x16,0x92,0x60,0xCC,0xA2,0x4A,0xEA,0x10,0x92,0xAE,0x7C,0x83,0xAA,0x65,0xA9,0xC2,0x7E,0x18,
+	0x7D,0xAE,0x66,0xDA,0x2A,0xE6,0x29,0x98,0xFC,0x5E,0x47,0x8F,0x60,0xEA,0x04,0x4B,0x52,0x76,0xDB,0xCB,
+	0xAB,0x85,0x97,0x6F,0x7B,0x3C,0x0E,0x5F,0x0B,0x5E,0x27,0x3E,0xC6,0x3A,0x67,0xE6,0x1C,0xA7,0x40,0xAC,
+	0xFF,0xBB,0xEE,0x6A,0xF5,0xF3,0xC6,0xCC,0x3A,0x3C,0x26,0x2E,0xC0,0x1D,0xD6,0xEC,0x7A,0x7C,0xB1,0xFC,
+	0xA9,0x15,0xCE,0xDC,0x3B,0x3D,0xF2,0xBA,0xE8,0x53,0xDE,0xFC,0x7B,0x7D,0xEF,0x6B,0x2D,0x39,0xC7,0xCD,
+	0xBA,0x3E,0xBB,0x69,0x16,0x7E,0xD7,0xED,0xFA,0x7E,0xF9,0xBB,0x5C,0x19,0xCF,0xDD,0xBB,0x3F,0x37,0x7F,
+	0x17,0x1E,0xDF,0xFD,0xFB,0x7F,0xF4,0x44,0xA6,0x7E,0x40,0x39,0x30,0x1C,0xF0,0x36,0xB8,0xBE,0x1C,0xA4,
+	0x55,0x65,0xC3,0x69,0x9A,0xBC,0x2C,0xE7,0xB6,0xA3,0x4C,0xB6,0x0D,0x9F,0xD7,0x2A,0x9D,0x3F,0x5B,0x87,
+	0xC8,0x92,0x1E,0x5C,0x6D,0x28,0x48,0x65,0x66,0x8C,0x89,0xD4,0x8C,0x46,0x81,0xB1,0x02,0xA4,0x9B,0xE8,
+	0x17,0xEB,0xF9,0x27,0x54,0x82,0x3E,0x24,0x0A,0xE1,0x88,0xE1,0x00,0x24,0xE0,0x46,0x16,0xA4,0x78,0x50,
+	0xE7,0x6B,0xF0,0x66,0x56,0xE4,0xF8,0xD0,0x06,0xF2,0xE8,0x56,0x17,0xA5,0x98,0x4D,0xB3,0x75,0xF8,0x76,
+	0x57,0xE5,0x88,0xC7,0xC2,0x9A,0xE1,0x47,0x96,0xA6,0x76,0x70,0x1D,0x16,0xF1,0x67,0xD6,0xE6,0x53,0xB1,
+	0x05,0x8F,0xE9,0x57,0x97,0xA7,0xCE,0x6F,0xE3,0x3A,0xF9,0x77,0xD7,0xE7,0xB2,0x14,0x54,0x7C,0x82,0x6C,
+	0xAB,0xCD,0x99,0x51,0x99,0x35,0x52,0x11,0xA0,0xEA,0x6A,0xDC,0xE7,0xC5,0x13,0x4F,0xBE,0x76,0x62,0x07,
+	0xCF,0xC1,0x89,0x27,0x79,0x87,0xA0,0x11,0xD0,0x3E,0x9B,0xDF,0x41,0xD5,0x71,0x4B,0xD4,0x4A,0x00,0x32,
+	0x24,0x3A,0xDB,0x5D,0x27,0x70,0x16,0x42,0x62,0xAD,0xEF,0x49,0x6E,0x8A,0xFB,0x00,0xD5,0x87,0x93,0x28,
+	0x4D,0x53,0xE2,0x4E,0x1E,0xAC,0xAD,0x62,0x60,0x8A,0xF2,0x6E,0x5E,0xEC,0x12,0xD8,0x0E,0x9A,0xEA,0x5E,
+	0x1F,0xAD,0x0A,0xA5,0xA0,0x8C,0xFA,0x7E,0x5F,0xED,0x1B,0x29,0xCD,0x7E,0xE3,0x4F,0x9E,0xAE,0x81,0xAD,
+	0x6C,0x82,0xF3,0x6F,0xDE,0xEE,0xD0,0xB9,0x23,0x72,0xEB,0x5F,0x9F,0xAF,0xD3,0xD8,0xB0,0x0F,0xFB,0x7F,
+	0xDF,0xEF,0x56,0x27,0xA1,0x97,0x64,0x92,0xC8,0x45,0xF4,0xB3,0x48,0xD6,0x03,0x5B,0x38,0xBE,0x2D,0x4D,
+	0x86,0xEF,0x1B,0x8F,0x33,0x71,0x44,0x96,0xEA,0xD3,0x45,0x70,0xD7,0xB4,0xCE,0x74,0xA2,0x72,0x61,0x03,
+	0xF0,0x47,0x3D,0x06,0x87,0xF2,0xC5,0xE1,0x56,0x0C,0x16,0xD5,0x07,0xDD,0x1A,0xA8,0xE1,0xF1,0x8A,0xB2,
+	0x68,0xDF,0xCF,0x31,0xED,0xBF,0x6C,0xF5,0x87,0xF8,0xE4,0xC6,0x36,0xB4,0x14,0xA2,0x6A,0x29,0xF4,0xE6,
+	0x76,0xF4,0xE8,0x15,0xA7,0xB5,0xEC,0xD6,0x37,0xB5,0x26,0xF3,0xC4,0x94,0xFC,0xF6,0x77,0xF5,0x86,0x84,
+	0x78,0x9E,0xE5,0xC7,0xB6,0xB6,0x0D,0x61,0xE7,0x96,0xF5,0xE7,0xF6,0xF6,0xC1,0x13,0x04,0xD6,0xED,0xD7,
+	0xB7,0xB7,0x1D,0xB3,0xFA,0x5C,0xFD,0xF7,0xF7,0xF7,0x52,0xAE,0xF8,0x28,0x24,0xB1,0xB9,0xBF,0x5E,0xB4,
+	0x2A,0x2C,0xC6,0x8E,0x64,0x35,0x09,0x1A,0xAA,0x3E,0x47,0x1A,0x79,0xA5,0x81,0xDA,0xDA,0x7D,0x84,0x5C,
+	0xFF,0xF1,0x80,0x97,0x7C,0x6A,0x4F,0x2C,0xBA,0x1A,0xF1,0x2F,0xA4,0xAD,0x27,0x2D,0xFD,0x1D,0x87,0x3D,
+	0xAB,0x5B,0x3F,0x58,0xBF,0x4E,0xF9,0xBD,0x25,0x19,0x4D,0xDD,0xBE,0x24,0x8A,0x4A,0xD2,0xBC,0xE6,0xCE,
+	0x3E,0xBC,0xF2,0x08,0xEC,0xD4,0xF6,0xEE,0x7E,0xFC,0x56,0x29,0x77,0x39,0xEE,0xDE,0x3F,0xBD,0x1E,0xBA,
+	0xC2,0x20,0xFE,0xFE,0x7F,0xFD,0xCB,0x49,0xAF,0xCB,0xE7,0xCF,0xBE,0xBE,0xFE,0x99,0x4D,0x9F,0xF7,0xEF,
+	0xFE,0xFE,0x80,0xC7,0x29,0x6A,0xEF,0xDF,0xBF,0xBF,0x07,0xDF,0x6D,0xD7,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
+	0x00,0x00,0x80,0x04,0x10,0x20,0x10,0x20,0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,0x01,0x01,0x88,0x14,
+	0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,0x90,0x22,0x11,0x21,
+	0xC0,0x42,0x91,0x25,0xD0,0x62,0x09,0x11,0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,0xC1,0x43,0x99,0x35,
+	0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,0x52,0x64,0x48,0x50,
+	0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,0x82,0x06,0xC1,0x45,
+	0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,0x93,0x27,0x59,0x71,
+	0xC3,0x47,0xD9,0x75,0xD3,0x67,0x02,0x08,0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,0x48,0x48,0x92,0x2C,
+	0x58,0x68,0x0A,0x18,0x09,0x09,0x8A,0x1C,0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,0x59,0x69,0x03,0x09,
+	0x88,0x0A,0x83,0x0D,0x98,0x2A,0x13,0x29,0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,0x89,0x0B,0x8B,0x1D,
+	0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,0x1A,0x2C,0x52,0x68,
+	0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,0x4B,0x4D,0xDA,0x7C,
+	0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,0xDA,0x6E,0x4B,0x59,
+	0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,0x20,0x10,0x84,0x84,
+	0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,0x31,0x31,0x1C,0xB0,
+	0x61,0x51,0x9C,0xB4,0x71,0x71,0x05,0x81,0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,0xE0,0x52,0x95,0xA5,
+	0xF0,0x72,0x0D,0x91,0xA1,0x13,0x8D,0x95,0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,0xF1,0x73,0x44,0xC0,
+	0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,0x23,0x15,0xCC,0xD4,
+	0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,0xB2,0x36,0x55,0xE1,
+	0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,0xE3,0x57,0xDD,0xF5,
+	0xF3,0x77,0x06,0x88,0x28,0x18,0x86,0x8C,0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,0x78,0x78,0x0E,0x98,
+	0x29,0x19,0x8E,0x9C,0x39,0x39,0x1E,0xB8,0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,0xA8,0x1A,0x87,0x8D,
+	0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,0xB9,0x3B,0x1F,0xB9,
+	0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,0x6A,0x5C,0xD6,0xEC,
+	0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,0x7B,0x7D,0x47,0xC9,
+	0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,0xAB,0x1F,0xCF,0xDD,
+	0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,0x14,0xA0,0x30,0x22,
+	0x44,0xC0,0xB0,0x26,0x54,0xE0,0x28,0x12,0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,0x45,0xC1,0xB8,0x36,
+	0x55,0xE1,0x21,0x03,0x84,0x82,0xA1,0x07,0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,0xD4,0xE2,0x29,0x13,
+	0x85,0x83,0xA9,0x17,0x95,0xA3,0x39,0x33,0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,0x06,0x84,0xE0,0x46,
+	0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,0x17,0xA5,0x78,0x72,
+	0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,0xC6,0xC6,0xF1,0x67,
+	0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,0xD7,0xE7,0x22,0x0A,
+	0x0C,0x88,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,0x0D,0x89,0xAA,0x1E,
+	0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,0x9C,0xAA,0x33,0x2B,
+	0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x2B,0x1B,0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,0xCD,0xCB,0xBB,0x3F,
+	0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,0x5E,0xEC,0x6A,0x5A,
+	0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,0x8E,0x8E,0xE3,0x4F,
+	0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,0x9F,0xAF,0x7B,0x7B,
+	0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,0x64,0xD0,0xB4,0xA6,
+	0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,0x75,0xF1,0x25,0x83,
+	0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,0xA5,0x93,0xAD,0x97,
+	0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,0x36,0xB4,0x74,0xE2,
+	0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,0x67,0xD5,0xFC,0xF6,
+	0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,0xF6,0xF6,0x6D,0xD3,
+	0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,0x2C,0x98,0xA6,0x8E,
+	0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,0x3D,0xB9,0x3E,0xBA,
+	0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,0xEC,0xDA,0xB7,0xAF,
+	0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,0xFD,0xFB,0x66,0xCA,
+	0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,0x2F,0x9D,0xEE,0xDE,
+	0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,0xBE,0xBE,0x77,0xEB,
+	0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,0xEF,0xDF,0xFF,0xFF,
+	0xFF,0xFF,0x00,0x00,0x00,0x00,0x80,0x04,0x10,0x20,0x10,0x20,0x40,0x40,0x90,0x24,0x50,0x60,0x08,0x10,
+	0x01,0x01,0x88,0x14,0x11,0x21,0x18,0x30,0x41,0x41,0x98,0x34,0x51,0x61,0x01,0x01,0x80,0x02,0x81,0x05,
+	0x90,0x22,0x11,0x21,0xC0,0x42,0x91,0x25,0xD0,0x62,0x09,0x11,0x81,0x03,0x89,0x15,0x91,0x23,0x19,0x31,
+	0xC1,0x43,0x99,0x35,0xD1,0x63,0x40,0x40,0x02,0x04,0xC0,0x44,0x12,0x24,0x50,0x60,0x42,0x44,0xD0,0x64,
+	0x52,0x64,0x48,0x50,0x03,0x05,0xC8,0x54,0x13,0x25,0x58,0x70,0x43,0x45,0xD8,0x74,0x53,0x65,0x41,0x41,
+	0x82,0x06,0xC1,0x45,0x92,0x26,0x51,0x61,0xC2,0x46,0xD1,0x65,0xD2,0x66,0x49,0x51,0x83,0x07,0xC9,0x55,
+	0x93,0x27,0x59,0x71,0xC3,0x47,0xD9,0x75,0xD3,0x67,0x02,0x08,0x08,0x08,0x82,0x0C,0x18,0x28,0x12,0x28,
+	0x48,0x48,0x92,0x2C,0x58,0x68,0x0A,0x18,0x09,0x09,0x8A,0x1C,0x19,0x29,0x1A,0x38,0x49,0x49,0x9A,0x3C,
+	0x59,0x69,0x03,0x09,0x88,0x0A,0x83,0x0D,0x98,0x2A,0x13,0x29,0xC8,0x4A,0x93,0x2D,0xD8,0x6A,0x0B,0x19,
+	0x89,0x0B,0x8B,0x1D,0x99,0x2B,0x1B,0x39,0xC9,0x4B,0x9B,0x3D,0xD9,0x6B,0x42,0x48,0x0A,0x0C,0xC2,0x4C,
+	0x1A,0x2C,0x52,0x68,0x4A,0x4C,0xD2,0x6C,0x5A,0x6C,0x4A,0x58,0x0B,0x0D,0xCA,0x5C,0x1B,0x2D,0x5A,0x78,
+	0x4B,0x4D,0xDA,0x7C,0x5B,0x6D,0x43,0x49,0x8A,0x0E,0xC3,0x4D,0x9A,0x2E,0x53,0x69,0xCA,0x4E,0xD3,0x6D,
+	0xDA,0x6E,0x4B,0x59,0x8B,0x0F,0xCB,0x5D,0x9B,0x2F,0x5B,0x79,0xCB,0x4F,0xDB,0x7D,0xDB,0x6F,0x04,0x80,
+	0x20,0x10,0x84,0x84,0x30,0x30,0x14,0xA0,0x60,0x50,0x94,0xA4,0x70,0x70,0x0C,0x90,0x21,0x11,0x8C,0x94,
+	0x31,0x31,0x1C,0xB0,0x61,0x51,0x9C,0xB4,0x71,0x71,0x05,0x81,0xA0,0x12,0x85,0x85,0xB0,0x32,0x15,0xA1,
+	0xE0,0x52,0x95,0xA5,0xF0,0x72,0x0D,0x91,0xA1,0x13,0x8D,0x95,0xB1,0x33,0x1D,0xB1,0xE1,0x53,0x9D,0xB5,
+	0xF1,0x73,0x44,0xC0,0x22,0x14,0xC4,0xC4,0x32,0x34,0x54,0xE0,0x62,0x54,0xD4,0xE4,0x72,0x74,0x4C,0xD0,
+	0x23,0x15,0xCC,0xD4,0x33,0x35,0x5C,0xF0,0x63,0x55,0xDC,0xF4,0x73,0x75,0x45,0xC1,0xA2,0x16,0xC5,0xC5,
+	0xB2,0x36,0x55,0xE1,0xE2,0x56,0xD5,0xE5,0xF2,0x76,0x4D,0xD1,0xA3,0x17,0xCD,0xD5,0xB3,0x37,0x5D,0xF1,
+	0xE3,0x57,0xDD,0xF5,0xF3,0x77,0x06,0x88,0x28,0x18,0x86,0x8C,0x38,0x38,0x16,0xA8,0x68,0x58,0x96,0xAC,
+	0x78,0x78,0x0E,0x98,0x29,0x19,0x8E,0x9C,0x39,0x39,0x1E,0xB8,0x69,0x59,0x9E,0xBC,0x79,0x79,0x07,0x89,
+	0xA8,0x1A,0x87,0x8D,0xB8,0x3A,0x17,0xA9,0xE8,0x5A,0x97,0xAD,0xF8,0x7A,0x0F,0x99,0xA9,0x1B,0x8F,0x9D,
+	0xB9,0x3B,0x1F,0xB9,0xE9,0x5B,0x9F,0xBD,0xF9,0x7B,0x46,0xC8,0x2A,0x1C,0xC6,0xCC,0x3A,0x3C,0x56,0xE8,
+	0x6A,0x5C,0xD6,0xEC,0x7A,0x7C,0x4E,0xD8,0x2B,0x1D,0xCE,0xDC,0x3B,0x3D,0x5E,0xF8,0x6B,0x5D,0xDE,0xFC,
+	0x7B,0x7D,0x47,0xC9,0xAA,0x1E,0xC7,0xCD,0xBA,0x3E,0x57,0xE9,0xEA,0x5E,0xD7,0xED,0xFA,0x7E,0x4F,0xD9,
+	0xAB,0x1F,0xCF,0xDD,0xBB,0x3F,0x5F,0xF9,0xEB,0x5F,0xDF,0xFD,0xFB,0x7F,0x20,0x02,0x04,0x80,0xA0,0x06,
+	0x14,0xA0,0x30,0x22,0x44,0xC0,0xB0,0x26,0x54,0xE0,0x28,0x12,0x05,0x81,0xA8,0x16,0x15,0xA1,0x38,0x32,
+	0x45,0xC1,0xB8,0x36,0x55,0xE1,0x21,0x03,0x84,0x82,0xA1,0x07,0x94,0xA2,0x31,0x23,0xC4,0xC2,0xB1,0x27,
+	0xD4,0xE2,0x29,0x13,0x85,0x83,0xA9,0x17,0x95,0xA3,0x39,0x33,0xC5,0xC3,0xB9,0x37,0xD5,0xE3,0x60,0x42,
+	0x06,0x84,0xE0,0x46,0x16,0xA4,0x70,0x62,0x46,0xC4,0xF0,0x66,0x56,0xE4,0x68,0x52,0x07,0x85,0xE8,0x56,
+	0x17,0xA5,0x78,0x72,0x47,0xC5,0xF8,0x76,0x57,0xE5,0x61,0x43,0x86,0x86,0xE1,0x47,0x96,0xA6,0x71,0x63,
+	0xC6,0xC6,0xF1,0x67,0xD6,0xE6,0x69,0x53,0x87,0x87,0xE9,0x57,0x97,0xA7,0x79,0x73,0xC7,0xC7,0xF9,0x77,
+	0xD7,0xE7,0x22,0x0A,0x0C,0x88,0xA2,0x0E,0x1C,0xA8,0x32,0x2A,0x4C,0xC8,0xB2,0x2E,0x5C,0xE8,0x2A,0x1A,
+	0x0D,0x89,0xAA,0x1E,0x1D,0xA9,0x3A,0x3A,0x4D,0xC9,0xBA,0x3E,0x5D,0xE9,0x23,0x0B,0x8C,0x8A,0xA3,0x0F,
+	0x9C,0xAA,0x33,0x2B,0xCC,0xCA,0xB3,0x2F,0xDC,0xEA,0x2B,0x1B,0x8D,0x8B,0xAB,0x1F,0x9D,0xAB,0x3B,0x3B,
+	0xCD,0xCB,0xBB,0x3F,0xDD,0xEB,0x62,0x4A,0x0E,0x8C,0xE2,0x4E,0x1E,0xAC,0x72,0x6A,0x4E,0xCC,0xF2,0x6E,
+	0x5E,0xEC,0x6A,0x5A,0x0F,0x8D,0xEA,0x5E,0x1F,0xAD,0x7A,0x7A,0x4F,0xCD,0xFA,0x7E,0x5F,0xED,0x63,0x4B,
+	0x8E,0x8E,0xE3,0x4F,0x9E,0xAE,0x73,0x6B,0xCE,0xCE,0xF3,0x6F,0xDE,0xEE,0x6B,0x5B,0x8F,0x8F,0xEB,0x5F,
+	0x9F,0xAF,0x7B,0x7B,0xCF,0xCF,0xFB,0x7F,0xDF,0xEF,0x24,0x82,0x24,0x90,0xA4,0x86,0x34,0xB0,0x34,0xA2,
+	0x64,0xD0,0xB4,0xA6,0x74,0xF0,0x2C,0x92,0x25,0x91,0xAC,0x96,0x35,0xB1,0x3C,0xB2,0x65,0xD1,0xBC,0xB6,
+	0x75,0xF1,0x25,0x83,0xA4,0x92,0xA5,0x87,0xB4,0xB2,0x35,0xA3,0xE4,0xD2,0xB5,0xA7,0xF4,0xF2,0x2D,0x93,
+	0xA5,0x93,0xAD,0x97,0xB5,0xB3,0x3D,0xB3,0xE5,0xD3,0xBD,0xB7,0xF5,0xF3,0x64,0xC2,0x26,0x94,0xE4,0xC6,
+	0x36,0xB4,0x74,0xE2,0x66,0xD4,0xF4,0xE6,0x76,0xF4,0x6C,0xD2,0x27,0x95,0xEC,0xD6,0x37,0xB5,0x7C,0xF2,
+	0x67,0xD5,0xFC,0xF6,0x77,0xF5,0x65,0xC3,0xA6,0x96,0xE5,0xC7,0xB6,0xB6,0x75,0xE3,0xE6,0xD6,0xF5,0xE7,
+	0xF6,0xF6,0x6D,0xD3,0xA7,0x97,0xED,0xD7,0xB7,0xB7,0x7D,0xF3,0xE7,0xD7,0xFD,0xF7,0xF7,0xF7,0x26,0x8A,
+	0x2C,0x98,0xA6,0x8E,0x3C,0xB8,0x36,0xAA,0x6C,0xD8,0xB6,0xAE,0x7C,0xF8,0x2E,0x9A,0x2D,0x99,0xAE,0x9E,
+	0x3D,0xB9,0x3E,0xBA,0x6D,0xD9,0xBE,0xBE,0x7D,0xF9,0x27,0x8B,0xAC,0x9A,0xA7,0x8F,0xBC,0xBA,0x37,0xAB,
+	0xEC,0xDA,0xB7,0xAF,0xFC,0xFA,0x2F,0x9B,0xAD,0x9B,0xAF,0x9F,0xBD,0xBB,0x3F,0xBB,0xED,0xDB,0xBF,0xBF,
+	0xFD,0xFB,0x66,0xCA,0x2E,0x9C,0xE6,0xCE,0x3E,0xBC,0x76,0xEA,0x6E,0xDC,0xF6,0xEE,0x7E,0xFC,0x6E,0xDA,
+	0x2F,0x9D,0xEE,0xDE,0x3F,0xBD,0x7E,0xFA,0x6F,0xDD,0xFE,0xFE,0x7F,0xFD,0x67,0xCB,0xAE,0x9E,0xE7,0xCF,
+	0xBE,0xBE,0x77,0xEB,0xEE,0xDE,0xF7,0xEF,0xFE,0xFE,0x6F,0xDB,0xAF,0x9F,0xEF,0xDF,0xBF,0xBF,0x7F,0xFB,
+	0xEF,0xDF,0xFF,0xFF,0x90,0xAF
+
+};
+#endif
+#endif
diff --git a/drivers/input/touchscreen/gt915/gt9xx_openshort.c b/drivers/input/touchscreen/gt915/gt9xx_openshort.c
new file mode 100755
index 0000000..b35f63f
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx_openshort.c
@@ -0,0 +1,2186 @@
+/* drivers/input/touchscreen/gt9xx_shorttp.c
+ * 
+ * 2010 - 2012 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ * Version:1.0
+ * Author: meta@goodix.com
+ * Accomplished Date:2012/10/20
+ * Revision record:
+ *
+ */
+
+#include "gt9xx_openshort.h"
+
+//************** Customer Config Start ***********************//
+// short test
+#define GTP_SHORT_GND
+#define GTP_VDD         33      // 3.3V
+
+// open test
+#define DEFAULT_TEST_ITEMS  (_MAX_TEST | _MIN_TEST | _KEY_MAX_TEST | _KEY_MIN_TEST /*| _UNIFORMITY_TEST*/)
+
+u16 max_limit_value = 3915;     // screen max limit
+u16 min_limit_value = 1235;     // screen min limit
+u16 max_limit_key = 4050;       // key_val max limit
+u16 min_limit_key = 1170;        // key_val min limit
+u16 uniformity_lmt = 70;        // screen uniformity in percent
+
+#define DSP_SHORT_BURN_CHK          256 // burn short chuck size
+#define _SHORT_INFO_MAX             50  // short test max show 50 pairs short channels
+#define _BEYOND_INFO_MAX            20  // open test max show 20 infos for each test item
+#define GTP_OPEN_SAMPLE_NUM         16  // open test raw data sampled count
+#define GTP_TEST_INFO_MAX           200 // test info lines max count
+
+//****************** Customer Config End ***********************//
+
+extern s32 gtp_i2c_read(struct i2c_client *, u8 *, s32);
+extern s32 gtp_i2c_write(struct i2c_client *, u8 *, s32);
+extern s32 gup_i2c_read(struct i2c_client *, u8 *, s32);
+extern s32 gup_i2c_write(struct i2c_client *, u8 *, s32);
+extern void gtp_reset_guitar(struct i2c_client*, s32);
+extern s32 gup_enter_update_mode(struct i2c_client *);
+extern s32 gup_leave_update_mode(void);
+extern s32 gtp_send_cfg(struct i2c_client *client);
+extern s32 gtp_read_version(struct i2c_client *client, u16* version);
+extern void gtp_irq_disable(struct goodix_ts_data *ts);
+extern void gtp_irq_enable(struct goodix_ts_data *ts);
+
+extern struct i2c_client * i2c_connect_client;
+
+u8  gt9xx_drv_num = MAX_DRIVER_NUM; // default driver and sensor number
+u8  gt9xx_sen_num = MAX_SENSOR_NUM;
+u16 gt9xx_pixel_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
+u16 gt9xx_sc_pxl_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
+struct gt9xx_short_info *short_sum; 
+
+u8 chip_type_gt9f = 0;
+u8 have_key = 0;
+u8 gt9xx_sc_drv_num;
+u8 key_is_isolated; // 0: no, 1: yes
+u8 key_iso_pos[5];
+
+struct kobject *goodix_debug_kobj;
+static u8  rslt_buf_idx = 0;
+static s32 *test_rslt_buf;  
+static struct gt9xx_open_info *touchpad_sum;
+    
+#define _MIN_ERROR_NUM      (GTP_OPEN_SAMPLE_NUM * 9 / 10)
+
+static char *result_lines[GTP_TEST_INFO_MAX];
+
+static u16 RsltIndex;
+
+//+++
+#if GTP_TP_TEST
+#define SET_INFO_LINE_INFO(fmt, args...)		GTP_INFO(fmt,##args)
+#define SET_INFO_LINE_ERR(fmt, args...)			GTP_ERROR(fmt,##args)      
+extern u8 sensor_manufacture;
+//---
+#else
+static char tmp_info_line[80];
+
+static void append_info_line(void)
+{
+    if (strlen(tmp_info_line) != 0)
+    {
+        result_lines[RsltIndex] = (char *)kzalloc(strlen(tmp_info_line)+1, GFP_KERNEL);
+        memcpy(result_lines[RsltIndex], tmp_info_line, strlen(tmp_info_line));
+    }
+    if (RsltIndex != (GTP_TEST_INFO_MAX-1))
+        ++RsltIndex;
+    else {
+        kfree(result_lines[RsltIndex]);
+    }
+}
+
+
+#define SET_INFO_LINE_INFO(fmt, args...)       do{ memset(tmp_info_line, '\0', 80);\
+                                                   sprintf(tmp_info_line, "<Sysfs-INFO>"fmt"\n", ##args);\
+                                                   GTP_INFO(fmt, ##args);\
+                                                append_info_line();} while(0)
+                                                   
+#define SET_INFO_LINE_ERR(fmt, args...)        do { memset(tmp_info_line, '\0', 80);\
+                                                   sprintf(tmp_info_line, "<Sysfs-ERROR>"fmt"\n", ##args);\
+                                                   GTP_ERROR(fmt, ##args);\
+                                                   append_info_line();}while(0)
+#endif
+
+
+static u8 cfg_drv_order[MAX_DRIVER_NUM];
+static u8 cfg_sen_order[MAX_SENSOR_NUM];
+
+/*
+ * Initialize cfg_drv_order and cfg_sen_order, which is used for report short channels
+ *
+ */
+
+s32 gt9xx_short_parse_cfg(void)
+{
+    u8 i = 0;
+    u8 drv_num = 0, sen_num = 0;
+    
+    u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};
+    
+    if (gtp_i2c_read(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
+    {
+        SET_INFO_LINE_ERR("Failed to read config!");
+        return FAIL;
+    }
+    
+    drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
+                        + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
+    sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F) 
+                        + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);
+
+    if (drv_num < MIN_DRIVER_NUM || drv_num > MAX_DRIVER_NUM)
+    {
+        GTP_ERROR("driver number error!");
+        return FAIL;
+    }
+    if (sen_num < MIN_SENSOR_NUM || sen_num > MAX_SENSOR_NUM)
+    {
+        GTP_ERROR("sensor number error!");
+        return FAIL;
+    }
+    // get sensor and driver order 
+    memset(cfg_sen_order, 0xFF, MAX_SENSOR_NUM);
+    for (i = 0; i < sen_num; ++i)
+    {
+        cfg_sen_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_SEN_ORD - GT9_REG_CFG_BEG + i];
+    }
+
+    memset(cfg_drv_order, 0xFF, MAX_DRIVER_NUM);
+    for (i = 0; i < drv_num; ++i)
+    {
+        cfg_drv_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_DRV_ORD - GT9_REG_CFG_BEG + i];
+    }
+    
+    return SUCCESS;
+}
+
+/*
+ * @param:
+ *      phy_chnl: ic detected short channel, is_driver: it's driver or not
+ * @Return:
+ *      0xff: the ic channel is not used, otherwise: the tp short channel
+ */
+u8 gt9_get_short_tp_chnl(u8 phy_chnl, u8 is_driver)
+{
+    u8 i = 0;
+    if (is_driver) {
+        for (i = 0; i < MAX_DRIVER_NUM; ++i)
+        {
+            if (cfg_drv_order[i] == phy_chnl) {
+                return i;
+            }
+            else if (cfg_drv_order[i] == 0xFF) {
+                return 0xFF;
+            }
+        }
+    }
+    else 
+    {
+        for (i = 0; i < MAX_SENSOR_NUM; ++i)
+        {
+            if (cfg_sen_order[i] == phy_chnl) {
+                return i;
+            }
+            else if (cfg_sen_order[i] == 0xFF) {
+                return 0xFF;
+            }
+        }
+    }
+    return 0xFF;
+}
+
+
+static s32 gtp_i2c_end_cmd(struct i2c_client *client)
+{
+    u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
+    s32 ret = 0;
+    
+    ret = gtp_i2c_write(client, end_cmd, 3);
+    if (ret < 0)
+    {
+        SET_INFO_LINE_INFO("I2C write end_cmd  error!"); 
+    }
+    return ret;
+}
+
+static void gtp_hopping_switch(struct i2c_client *client, s32 on)
+{
+    s32 j = 0;
+    static u8 hopping_enabled = 0;
+    u8 chksum = 0;
+    u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};
+    struct goodix_ts_data *ts;
+    
+    ts = i2c_get_clientdata(client);
+    if (gtp_i2c_read(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
+    {
+        SET_INFO_LINE_ERR("Failed to read config!");
+        return;
+    }
+    if (!on)
+    {
+        // disable hopping
+        if (config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] & 0x80)
+        {
+            GTP_INFO("Disable hopping.");
+            config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] &= 0x7F;
+            // calculate checksum
+            for (j = 0; j < (ts->gtp_cfg_len-2); ++j)
+            {
+                chksum += config[GTP_ADDR_LENGTH + j];
+            }
+            config[ts->gtp_cfg_len] = (~chksum) + 1;
+            config[ts->gtp_cfg_len+1] = 0x01;
+            
+            gtp_i2c_write(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+            hopping_enabled = 1;
+        }
+    }
+    else if (hopping_enabled)
+    {
+        if (0x00 == (config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] & 0x80))
+        {
+            GTP_INFO("Enable hopping.");
+            config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] |= 0x80; 
+            // calculate checksum
+            for (j = 0; j < (ts->gtp_cfg_len-2); ++j)
+            {
+                chksum += config[GTP_ADDR_LENGTH + j];
+            }
+            config[ts->gtp_cfg_len] = (~chksum) + 1;
+            config[ts->gtp_cfg_len+1] = 0x01;
+            
+            gtp_i2c_write(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+            hopping_enabled = 0;
+        }
+    }
+}
+
+s32 gtp_parse_config(struct i2c_client *client)
+{
+    u8 i = 0;
+    u8 key_pos = 0;
+    u8 key_val = 0;
+    u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};
+    u8 type_buf[12] = {0x80, 0x00};
+    
+    if (gtp_i2c_read(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
+    {
+        SET_INFO_LINE_ERR("Failed to read config!");
+        return FAIL;
+    }
+    
+    gt9xx_drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
+                    + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
+    gt9xx_sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F) 
+                    + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);
+
+    GTP_INFO("Driver num: %d, Sensor Num: %d", gt9xx_drv_num, gt9xx_sen_num);
+    if (gt9xx_drv_num < MIN_DRIVER_NUM || gt9xx_drv_num > MAX_DRIVER_NUM)
+    {
+        SET_INFO_LINE_ERR("driver number error!");
+        return FAIL;
+    }
+    if (gt9xx_sen_num < MIN_SENSOR_NUM || gt9xx_sen_num > MAX_SENSOR_NUM)
+    {
+        SET_INFO_LINE_ERR("sensor number error!");
+        return FAIL;
+    }
+    gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt = gt9xx_drv_num * gt9xx_sen_num;
+    
+    gtp_i2c_read(client, type_buf, 12);
+    if (!memcmp(&type_buf[2], "GOODIX_GT9", 10))
+    {
+        chip_type_gt9f = 0;
+        GTP_INFO("Chip type: GT9XX");
+    }
+    else
+    {
+        chip_type_gt9f = 1;
+        GTP_INFO("Chip type: GT9XXF");
+    }
+    
+    have_key = config[0x804E - GT9_REG_CFG_BEG + GTP_ADDR_LENGTH] & 0x01;
+    
+    if (!have_key)
+    {
+        GTP_INFO("No key");
+        return SUCCESS;
+    }
+    GTP_INFO("Have Key");
+    gt9xx_sc_drv_num = gt9xx_drv_num - 1;
+    
+    for (i = 0; i < 5; ++i)
+    {
+        key_iso_pos[i] = 0;
+    }
+    
+    key_is_isolated = 0;
+    for (i = 0; i < 4; ++i)
+    {
+        // all keys are multiples of 0x08 -> isolated keys
+        key_val = config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i];
+        key_pos = key_val%0x08;
+        GTP_DEBUG("key_val[%d] = 0x%02x", i+1, key_val);
+        if ((key_pos != 0))
+        {
+            key_is_isolated = 0;
+            GTP_DEBUG("Key is not isolated!");
+            break;
+        }
+        else if (key_val == 0x00)       // no more key
+        {
+            continue;
+        }
+        else
+        {
+            key_iso_pos[0]++;       // isolated key count
+            key_iso_pos[i+1] = key_val/0x08 - 1;
+            key_is_isolated = 1;
+        }
+    }
+    
+    gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt - (gt9xx_drv_num-gt9xx_sc_drv_num) * gt9xx_sen_num;
+    GTP_DEBUG("drv num: %d, sen num: %d, sc drv num: %d", gt9xx_drv_num, gt9xx_sen_num, gt9xx_sc_drv_num);
+    if (key_is_isolated)
+    {
+        GTP_DEBUG("Isolated [%d key(s)]: %d, %d, %d, %d", key_iso_pos[0], key_iso_pos[1], key_iso_pos[2], key_iso_pos[3], key_iso_pos[4]);
+    }
+    
+    return SUCCESS;
+}
+
+
+
+/*
+ * Function:
+ *      write one byte to specified register
+ * Input:
+ *      reg: the register address
+ *      val: the value to write into
+ * Return:
+ *      i2c_write function return 
+ */
+s32 gtp_write_register(struct i2c_client * client, u16 reg, u8 val)
+{
+    u8 buf[3];
+    buf[0] = (u8) (reg >> 8);
+    buf[1] = (u8) reg;
+    buf[2] = val;
+    return gup_i2c_write(client, buf, 3);
+}
+/*
+ * Function: 
+ *      read one byte from specified register into buf
+ * Input:
+ *      reg: the register
+ *      buf: the buffer for one byte
+ * Return:
+ *      i2c_read function return
+ */
+s32 gtp_read_register(struct i2c_client * client, u16 reg, u8* buf)
+{
+    buf[0] = (u8)(reg >> 8);
+    buf[1] = (u8)reg;
+    return gup_i2c_read(client, buf, 3);
+}
+
+/* 
+ * Function:
+ *      burn dsp_short code
+ * Input:
+ *      i2c_client
+ * Return:
+ *      SUCCESS: burning succeed, FAIL: burning failed
+ */
+s32 gtp_burn_dsp_short(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8 *opr_buf;
+    u16 i = 0;
+    u16 addr = GTP_REG_DSP_SHORT;
+    u16 opr_len = 0;
+    u16 left = 0;
+    u16 retry = 0;
+    u8 read_buf[3] = {0x00};
+
+    GTP_DEBUG("Start writing dsp_short code");
+    opr_buf = (u8*)kmalloc(sizeof(u8) * (DSP_SHORT_BURN_CHK+2), GFP_KERNEL);
+    if (!opr_buf)
+    {
+        SET_INFO_LINE_ERR("failed to allocate memory for check buffer!");
+        return FAIL;
+    }
+    
+    left = sizeof(dsp_short);
+    while (left > 0)
+    {
+        opr_buf[0] = (u8)(addr >> 8);
+        opr_buf[1] = (u8)(addr);
+        if (left > DSP_SHORT_BURN_CHK)
+        {
+            opr_len = DSP_SHORT_BURN_CHK;
+        }
+        else
+        {
+            opr_len = left;
+        }
+        memcpy(&opr_buf[2], &dsp_short[addr-GTP_REG_DSP_SHORT], opr_len);
+       
+        ret = gtp_i2c_write(client, opr_buf, 2 + opr_len);
+        if ( ret < 0 )
+        {
+            GTP_ERROR("write dsp_short code failed!");
+            kfree(opr_buf);
+            return FAIL;
+        }
+        addr += opr_len;
+        left -= opr_len;
+    }
+    
+    // check code: 0xC000~0xCFFF
+    GTP_DEBUG("Start checking dsp_short code");
+    addr = GTP_REG_DSP_SHORT;
+    left = sizeof(dsp_short);
+    while (left > 0)
+    {
+        memset(opr_buf, 0, opr_len + 2);
+        opr_buf[0] = (u8)(addr >> 8);
+        opr_buf[1] = (u8)(addr);
+        
+        
+        if (left > DSP_SHORT_BURN_CHK)
+        {
+            opr_len = DSP_SHORT_BURN_CHK;
+        }
+        else
+        {
+            opr_len = left;
+        }
+        
+        ret = gtp_i2c_read(client, opr_buf, opr_len+2);
+        if (ret < 0)
+        {
+            kfree(opr_buf);
+            return FAIL;
+        }
+        for (i = 0; i < opr_len; ++i)
+        {
+            if (opr_buf[i+2] != dsp_short[addr-GTP_REG_DSP_SHORT+i]) 
+            {
+                GTP_ERROR("check dsp_short code failed!");
+                
+                gtp_write_register(client, addr + i, dsp_short[addr-GTP_REG_DSP_SHORT+i]);
+                
+                GTP_DEBUG("(%d)Location: %d, 0x%02X, 0x%02X", retry+1, addr - GTP_REG_DSP_SHORT + i, opr_buf[i+2], dsp_short[addr-GTP_REG_DSP_SHORT+i]);
+                
+                msleep(1);
+                gtp_read_register(client, addr + i, read_buf);
+                opr_buf[i+2] = read_buf[2];
+                i--;
+                retry++;
+                if (retry >= 200)
+                {
+                    GTP_DEBUG("Burn dsp retry timeout!");
+                    kfree(opr_buf);
+                    return FAIL;
+                }
+            }
+        }
+        
+        addr += opr_len;
+        left -= opr_len;
+    }
+    kfree(opr_buf);
+    return SUCCESS;
+}
+/*
+ * Function: 
+ *      check the resistor between shortlike channels if less than threshold confirm as short
+ * INPUT:
+ *      Short like Information struct pointer
+ * Returns:
+ *      SUCCESS: it's shorted FAIL: otherwise
+ */
+s32 gtp_short_resist_check(struct gt9xx_short_info *short_node)
+{
+    s32 short_resist = 0;
+    struct gt9xx_short_info *node = short_node;
+    u8 master = node->master;
+    u8 slave = node->slave;
+    u8 chnnl_tx[4] = { GT9_DRV_HEAD|13, GT9_DRV_HEAD|28,
+                    GT9_DRV_HEAD|29, GT9_DRV_HEAD|42 };
+    s32 numberator = 0;
+    u32 amplifier = 1000;  // amplify 1000 times to emulate float computing
+    
+    
+    // Tx-ABIST & Tx_ABIST
+    if ((((master > chnnl_tx[0]) && (master <= chnnl_tx[1])) &&
+        ((slave > chnnl_tx[0]) && (slave <= chnnl_tx[1])) ) ||
+        (((master >= chnnl_tx[2]) && (master <= chnnl_tx[3])) &&
+        ((slave >= chnnl_tx[2]) && (slave <= chnnl_tx[3]))))
+    {
+        numberator = node->self_data * 40 * amplifier;
+        short_resist = numberator/(node->short_code) - 40 * amplifier;
+    }
+    // Receiver is Rx-odd(1,3,5)
+    else if ((node->slave & (GT9_DRV_HEAD | 0x01)) == 0x01)
+    {
+        numberator = node->self_data * 60 * amplifier;
+        short_resist = numberator/node->short_code - 40 * amplifier; 
+    }
+    else
+    {
+        numberator = node->self_data * 60 * amplifier;
+        short_resist = numberator / node->short_code - 60 * amplifier;
+    }
+    GTP_DEBUG("self_data = %d" ,node->self_data);
+    GTP_DEBUG("master = 0x%02X, slave = 0x%02X", node->master, node->slave);
+    GTP_DEBUG("short_code = %d, short_resist = %d", node->short_code, short_resist);
+     
+ 
+    if (short_resist < 0)
+    {
+        short_resist = 0;
+    }
+    
+    if (short_resist < (gt900_resistor_threshold * amplifier))
+    {
+        node->impedance = short_resist / amplifier;
+        return SUCCESS;
+    }
+    else
+    {
+        return FAIL;
+    }
+}
+
+
+
+/*
+ * Function: 
+ *      compute the result, whether there are shorts or not
+ * Input:
+ *      i2c_client
+ * Return:
+ *      SUCCESS
+ */
+s32 gtp_compute_rslt(struct i2c_client *client)
+{
+    u16 short_code;
+    u8 i = 0, j = 0;
+    u16 result_addr;
+    u8 *result_buf;
+    u16 *self_data;
+    s32 ret = 0;
+    u16 data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2; // a short data frame length
+    struct gt9xx_short_info short_node;
+    u16 node_idx = 0; // short_sum index: 0~_SHORT_INFO_MAX
+    
+    u8 tx_short_num = 0;
+    u8 rx_short_num = 0;
+    
+    u8 master, slave;
+    
+    self_data = (u16*)kmalloc(sizeof(u16) * ((MAX_DRIVER_NUM + MAX_SENSOR_NUM)), GFP_KERNEL);
+    result_buf = (u8*)kmalloc(sizeof(u8) * (data_len+2), GFP_KERNEL);
+    short_sum = (struct gt9xx_short_info *) kmalloc(sizeof(struct gt9xx_short_info) * _SHORT_INFO_MAX, GFP_KERNEL);
+
+    if (!self_data || !result_buf || !short_sum)
+    {
+        SET_INFO_LINE_ERR("allocate memory for short result failed!");
+        if (self_data)
+        {
+            kfree(self_data);
+        }
+        if (result_buf)
+        {
+            kfree(self_data);
+        }
+        if (short_sum)
+        {
+            kfree(short_sum);
+        }
+        return FAIL;
+    }   
+    
+    // Get Selfdata
+    result_buf[0] = 0xA4;
+    result_buf[1] = 0xA1;
+    gtp_i2c_read(client, result_buf, 2 + 144);
+    for (i = 0, j = 0; i < 144; i += 2)
+    {
+        self_data[j++] = (u16)(result_buf[2+i] << 8) + (u16)(result_buf[2+i+1]);
+    }
+    GTP_DEBUG("Self Data:");
+    GTP_DEBUG_ARRAY(result_buf+2, 144);
+    
+    
+    // Get TxShortNum & RxShortNum
+    result_buf[0] = 0x88;
+    result_buf[1] = 0x02;
+    gtp_i2c_read(client, result_buf, 2 + 2);
+    tx_short_num = result_buf[2];
+    rx_short_num = result_buf[3];
+    
+    GTP_DEBUG("Tx Short Num: %d, Rx Short Num: %d", tx_short_num, rx_short_num);
+    
+    // 
+    result_addr = 0x8860;
+    data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2;
+    for (i = 0; i < tx_short_num; ++i)
+    {        
+        result_buf[0] = (u8) (result_addr >> 8);
+        result_buf[1] = (u8) (result_addr);
+        ret = gtp_i2c_read(client, result_buf, data_len+2);
+        if (ret < 0)
+        {
+            SET_INFO_LINE_ERR("read result data failed!");
+        }
+        GTP_DEBUG("Result Buffer: ");
+        GTP_DEBUG_ARRAY(result_buf+2, data_len);
+        
+        short_node.master_is_driver = 1;
+        short_node.master = result_buf[2];
+        
+        // Tx - Tx
+        for (j = i + 1; j < MAX_DRIVER_NUM; ++j)
+        {
+            short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];
+            if (short_code > gt900_short_threshold)
+            {
+                short_node.slave_is_driver = 1;
+                short_node.slave = ChannelPackage_TX[j] | GT9_DRV_HEAD;
+                short_node.self_data = self_data[j];
+                short_node.short_code = short_code;
+                
+                ret = gtp_short_resist_check(&short_node);  
+                if (ret == SUCCESS)
+                {
+                    if (node_idx < _SHORT_INFO_MAX)
+                    {
+                        short_sum[node_idx++] = short_node;
+                    }
+                }
+            }
+        }
+        // Tx - Rx
+        for (j = 0; j < MAX_SENSOR_NUM; ++j)
+        {
+            short_code = (result_buf[2+3+84+j*2] << 8) + result_buf[2+3+84+j*2+1];
+            
+            if (short_code > gt900_short_threshold)
+            {
+                short_node.slave_is_driver = 0;
+                short_node.slave = j | GT9_SEN_HEAD;
+                short_node.self_data = self_data[MAX_DRIVER_NUM + j];
+                short_node.short_code = short_code;
+                
+                ret = gtp_short_resist_check(&short_node);
+                if (ret == SUCCESS)
+                {
+                    if (node_idx < _SHORT_INFO_MAX)
+                    {
+                        short_sum[node_idx++] = short_node;
+                    }
+                }
+            }
+        }
+        
+        result_addr += data_len;
+    }
+    
+    result_addr = 0xA0D2;
+    data_len = 3 + MAX_SENSOR_NUM * 2 + 2;
+    for (i = 0; i < rx_short_num; ++i)
+    {
+        result_buf[0] = (u8) (result_addr >> 8);
+        result_buf[1] = (u8) (result_addr);
+        ret = gtp_i2c_read(client, result_buf, data_len + 2);
+        if (ret < 0)
+        {
+            SET_INFO_LINE_ERR("read result data failed!");
+        }
+        
+        GTP_DEBUG("Result Buffer: ");
+        GTP_DEBUG_ARRAY(result_buf+2, data_len);
+        
+        short_node.master_is_driver = 0;
+        short_node.master = result_buf[2];
+        
+        // Rx - Rx
+        for (j = 0; j < MAX_SENSOR_NUM; ++j)
+        {
+            if ((j == i) || ( (j < i) && (j & 0x01) == 0))
+            {
+                continue;
+            }
+            short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];
+            
+            if (short_code > gt900_short_threshold)
+            {
+                short_node.slave_is_driver = 0;
+                short_node.slave = j | GT9_SEN_HEAD;
+                short_node.self_data = self_data[MAX_DRIVER_NUM + j];
+                short_node.short_code = short_code;
+                
+                ret = gtp_short_resist_check(&short_node);
+                if (ret == SUCCESS)
+                {
+                    if (node_idx < _SHORT_INFO_MAX)
+                    {
+                        short_sum[node_idx++] = short_node;
+                    }
+                }
+            }
+        }
+        
+        result_addr += data_len;
+    }
+    
+    if (node_idx == 0)
+    {
+        ret = SUCCESS;
+    }
+    else
+    {
+        for (i = 0, j = 0; i < node_idx; ++i)
+        {
+            GTP_DEBUG("Orignal Shorted Channels: %s%d, %s%d",
+                (short_sum[i].master_is_driver) ? "Drv" : "Sen", short_sum[i].master & (~GT9_DRV_HEAD),
+                (short_sum[i].slave_is_driver) ? "Drv" : "Sen", short_sum[i].slave & (~GT9_DRV_HEAD));
+                    
+            if ((short_sum[i].master_is_driver))
+            {
+                master = gt9_get_short_tp_chnl(short_sum[i].master-GT9_DRV_HEAD, 1);
+            }
+            else
+            {
+                master = gt9_get_short_tp_chnl(short_sum[i].master, 0);
+            }
+            
+            if ((short_sum[i].slave_is_driver))
+            {
+                slave = gt9_get_short_tp_chnl(short_sum[i].slave-GT9_DRV_HEAD, 1);
+            }
+            else
+            {
+                slave = gt9_get_short_tp_chnl(short_sum[i].slave, 0);
+            }
+            
+            if (master == 0xFF && slave == 0xFF)
+            {
+                GTP_DEBUG("unbonded channel (%d, %d) shorted!", short_sum[i].master, short_sum[i].slave);
+                continue;
+            }
+            else
+            {
+                short_sum[j].slave = slave;
+                short_sum[j].master = master;
+                short_sum[j].slave_is_driver = short_sum[i].slave_is_driver;
+                short_sum[j].master_is_driver = short_sum[i].master_is_driver;
+                short_sum[j].impedance = short_sum[i].impedance;
+                short_sum[j].self_data = short_sum[i].self_data;
+                short_sum[j].short_code = short_sum[i].short_code;
+                ++j;
+            }
+        }
+        node_idx = j;
+        if (node_idx == 0)
+        {
+            ret = SUCCESS;
+        }
+        else
+        {
+            for (i = 0; i < node_idx; ++i)
+            {
+                SET_INFO_LINE_INFO("  %s%02d & %s%02d Shorted! (R = %dKOhm)",
+                (short_sum[i].master_is_driver) ? "Drv" : "Sen", short_sum[i].master,
+                (short_sum[i].slave_is_driver) ? "Drv" : "Sen", short_sum[i].slave,
+                short_sum[i].impedance);
+            }
+            ret = FAIL;
+        }
+    }
+    kfree(self_data);
+    kfree(short_sum);
+    kfree(result_buf);
+    return ret;
+}
+
+s32 gt9_test_gnd_vdd_short(struct i2c_client *client)
+{
+    u8 *data;
+    s32 ret = 0;
+    s32 i = 0;
+    u16 len = (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2;
+    u16 short_code = 0;
+    s32 r = -1;
+    u32 short_res = 0;
+    u8 short_chnl = 0;
+    u16 amplifier = 1000;
+    
+    data = (u8 *)kmalloc(sizeof(u8) * (len + 2), GFP_KERNEL);
+    if (NULL == data)
+    {
+       SET_INFO_LINE_ERR("failed to allocate memory for gnd vdd test data buffer");
+       return FAIL;
+    }
+    
+    data[0] = 0xA5;
+    data[1] = 0x31;
+    gtp_i2c_read(client, data, 2 + len);
+    
+    GTP_DEBUG_ARRAY(data+2, len);
+    ret = SUCCESS;
+    for (i = 0; i < len; i += 2)
+    {
+        short_code = (data[2+i] << 8) + (data[2 + i + 1]);
+        if (short_code == 0)
+        {
+            continue;
+        }
+        if ((short_code & 0x8000) == 0)        // short with GND
+        {
+        #ifdef GTP_SHORT_GND
+            r = 5266285 * 10 / (short_code & (~0x8000)) - 40 * amplifier;
+        #endif
+        }
+        else    // short with VDD
+        {
+            //r = ( 1/(((float)(short_code&(~0x8000)))/0.9*0.7/1024/(sys.avdd-0.9)/40) ) -40;
+        #ifdef GTP_VDD
+            r = 40*9*1024*(100*GTP_VDD - 900)/((short_code&(~0x8000))*7) - 40*1000;
+            GTP_DEBUG("vdd short_code: %d", short_code & (~0x8000));
+        #endif
+        }
+        GTP_DEBUG("resistor: %d, short_code: %d", r, short_code);
+        
+        short_res = (r >= 0) ? r : 0xFFFF;
+        if (short_res == 0xFFFF)
+        {
+        }
+        else 
+        {
+            if (short_res < (gt900_gnd_resistor_threshold * amplifier))
+            {
+                if (i < MAX_DRIVER_NUM * 2)       // driver 
+                {
+                    short_chnl = gt9_get_short_tp_chnl(ChannelPackage_TX[i/2], 1);
+                    GTP_INFO("driver%02d & gnd/vdd shorted!", short_chnl);
+                    if (short_chnl == 0xFF)
+                    {
+                        GTP_INFO("unbonded channel");
+                    }
+                    else
+                    {
+                        SET_INFO_LINE_INFO("  Drv%02d & GND/VDD Shorted! (R = %dKOhm)", short_chnl, short_res/amplifier);
+                    }
+                } 
+                else
+                {
+                    short_chnl = gt9_get_short_tp_chnl((i/2) - MAX_DRIVER_NUM, 0);
+                    GTP_INFO("sensor%02d & gnd/vdd shorted!", short_chnl);
+                    if (short_chnl == 0xFF)
+                    {
+                        GTP_INFO("unbonded channel");
+                    }
+                    else
+                    {
+                        SET_INFO_LINE_INFO("  Sen%02d & GND/VDD Shorted! (R = %dKOhm)", short_chnl, short_res/amplifier);
+                    }
+                }
+                ret = FAIL;
+            }
+        }
+    }
+    return ret;
+}
+
+
+/*
+ * leave short test 
+ */
+void gt9xx_leave_short_test(struct i2c_client *client)
+{
+    
+    gtp_reset_guitar(client, 20);
+    msleep(100);
+
+    gtp_send_cfg(client);
+    SET_INFO_LINE_INFO("");
+    SET_INFO_LINE_INFO("---gtp short test end---");
+}
+
+
+/*
+ * Function:
+ *      gt9 series ic short test function
+ * Input:
+ *      I2c_client, i2c device
+ * Return:
+ *      SUCCESS: test succeed, FAIL: test failed
+ */
+s32 gt9xx_short_test(struct i2c_client * client)
+{
+    s32 ret = 0;
+    s32 ret2 = 0;
+    u8 i = 0;
+    u8 opr_buf[60] = {0};
+    u8 retry = 0;
+    u8 drv_sen_chksum = 0;
+    struct goodix_ts_data *ts;
+    u8 retry_load = 0;
+    u8 old_i2c_addr = client->addr;
+    
+    ts = i2c_get_clientdata(i2c_connect_client);
+    //gtp_irq_disable(ts);
+    disable_irq(ts->client->irq);
+#if GTP_ESD_PROTECT
+    ts->gtp_is_suspend = 1;     // suspend esd
+#endif
+    // step 1: reset guitar, delay 1ms,  hang up ss51 and dsp
+    SET_INFO_LINE_INFO("---gtp short test---");
+    SET_INFO_LINE_INFO("Step 1: reset guitar, hang up ss51 dsp");
+    
+    ret = gt9xx_short_parse_cfg();
+    if (FAIL == ret)
+    {
+        SET_INFO_LINE_ERR("You May check your IIC connection.");
+        goto short_test_exit;
+    }
+    
+load_dsp_again:
+    // RST output low last at least 2ms
+    
+    
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
+    msleep(30);
+    
+    // select I2C slave addr,INT:0--0xBA;1--0x28.
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, client->addr == 0x14);
+    msleep(2);
+    
+    // RST output high reset guitar
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
+    msleep(6);
+    
+    msleep((retry_load)*10);
+    
+    for (i = 0; i < 200; ++i)
+    {
+        // Hold ss51 & dsp
+        ret = gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+        // DSP_CK and DSP_ALU_CK PowerOn
+        ret2 = gtp_write_register(client, 0x4010, 0x00);
+        
+        if ((ret > 0) && (ret2 > 0))
+        {
+            break;
+        }
+        msleep(2);
+    }
+    if (i >= 200)
+    {
+        SET_INFO_LINE_ERR("Failed to init short test mode");
+        goto short_test_exit;
+    }
+    msleep(10);
+    
+    while(retry++ < 200)
+    {        
+        // Confirm hold
+        opr_buf[GTP_ADDR_LENGTH] = 0x00;
+        ret = gtp_read_register(client, _rRW_MISCTL__SWRST_B0_, opr_buf);
+        if(ret <= 0)
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            gtp_reset_guitar(client, 10);
+            continue;
+        }
+        if(0x0C == opr_buf[GTP_ADDR_LENGTH])
+        {
+            GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
+            break;
+        }        
+        ret = gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+        if( (ret <= 0))
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            gtp_reset_guitar(client, 10);
+            continue;
+        }
+        GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", opr_buf[GTP_ADDR_LENGTH]);
+        msleep(2);
+    }
+    if(retry >= 200)
+    {
+        SET_INFO_LINE_ERR("Enter update Hold ss51 failed.");
+        goto short_test_exit;
+    }
+    
+    // step2: burn dsp_short code
+    GTP_INFO("step 2: burn dsp_short code");
+    gtp_write_register(client, _bRW_MISCTL__TMR0_EN, 0x00); // clear watchdog
+    gtp_write_register(client, _bRW_MISCTL__CACHE_EN, 0x00); // clear cache
+    gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02); // boot from sram
+    //gtp_write_register(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01); // reset software
+    
+    gtp_write_register(client, _bRW_MISCTL__SRAM_BANK, 0x00); // select bank 0
+    gtp_write_register(client, _bRW_MISCTL__MEM_CD_EN, 0x01); // allow AHB bus accessing code sram
+   
+    // ---: burn dsp_short code
+    ret = gtp_burn_dsp_short(client);
+    
+    if (ret != SUCCESS)
+    {
+        if(retry_load++ < 5)
+        {
+            GTP_ERROR("Load dsp failed,times %d retry load!", retry_load);
+            goto load_dsp_again;
+        }
+        else
+        {
+            SET_INFO_LINE_INFO("Step 2: burn dsp_short code");
+            SET_INFO_LINE_ERR("burn dsp_short Timeout!");
+            goto short_test_exit;
+        }
+    } 
+    
+    SET_INFO_LINE_INFO("Step 2: burn dsp_short code");
+    
+    // step3: run dsp_short, read results
+    SET_INFO_LINE_INFO("Step 3: run dsp_short code, confirm it's runnin'");
+    gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x00); // clear dsp_short running flag
+    gtp_write_register(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x03);//set scramble
+    
+    gtp_write_register(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01); // reset software
+    
+    gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x08);   // release dsp
+    
+    client->addr = 0x14;    // for constant iic address
+    msleep(50);
+    // confirm dsp is running
+    i = 0;
+    while (1)
+    {
+        opr_buf[2] = 0x00;
+        gtp_read_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, opr_buf);
+        if (opr_buf[2] == 0xAA)
+        {
+            break;
+        }
+        ++i;
+        if (i >= 20)
+        {
+            SET_INFO_LINE_ERR("step 3: dsp is not running!");
+            goto short_test_exit;
+        }
+        msleep(10);
+    }
+    // step4: host configure ic, get test result
+    SET_INFO_LINE_INFO("Step 4: host config ic, get test result");
+    // Short Threshold
+    GTP_DEBUG(" Short Threshold: 10");
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x04;  
+    opr_buf[2] = 0;
+    opr_buf[3] = 10;
+    gtp_i2c_write(client, opr_buf, 4);
+    
+    // ADC Read Delay
+    GTP_DEBUG(" ADC Read Delay: 150");
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x06;
+    opr_buf[2] = (u8)(150 >> 8);
+    opr_buf[3] = (u8)(150);
+    gtp_i2c_write(client, opr_buf, 4);
+    
+    // DiffCode Short Threshold
+    GTP_DEBUG(" DiffCode Short Threshold: 20");
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x51;
+    opr_buf[2] = (u8)(20 >> 8);
+    opr_buf[3] = (u8)(20);
+    gtp_i2c_write(client, opr_buf, 4);
+    
+    // Config Driver & Sensor Order
+#if GTP_DEBUG_ON
+    printk("<<-GTP-DEBUG->> Driver Map:\n");
+    printk("IC Driver:");
+    for (i = 0; i < MAX_DRIVER_NUM; ++i)
+    {
+        printk(" %2d", cfg_drv_order[i]);
+    }
+    printk("\n");
+    printk("TP Driver:");
+    for (i = 0; i < MAX_DRIVER_NUM; ++i)
+    {
+        printk(" %2d", i);
+    }
+    printk("\n");
+    
+    printk("<<-GTP-DEBUG->> Sensor Map:\n");
+    printk("IC Sensor:");
+    for (i = 0; i < MAX_SENSOR_NUM; ++i)
+    {
+        printk(" %2d", cfg_sen_order[i]);
+    }
+    printk("\n");
+    printk("TP Sensor:");
+    for (i = 0; i < MAX_SENSOR_NUM; ++i)
+    {
+        printk(" %2d", i);
+    }
+    printk("\n");
+#endif
+
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x08;
+    for (i = 0; i < MAX_DRIVER_NUM; ++i)
+    {
+        opr_buf[2 + i] = cfg_drv_order[i];
+        drv_sen_chksum += cfg_drv_order[i];
+    }
+    gtp_i2c_write(client, opr_buf, MAX_DRIVER_NUM + 2);
+    
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x32;
+    for (i = 0; i < MAX_SENSOR_NUM; ++i)
+    {
+        opr_buf[2+i] = cfg_sen_order[i];
+        drv_sen_chksum += cfg_sen_order[i];
+    }
+    gtp_i2c_write(client, opr_buf, MAX_SENSOR_NUM + 2);
+    
+    opr_buf[0] = 0x88;
+    opr_buf[1] = 0x50;
+    opr_buf[2] = 0 - drv_sen_chksum;
+    gtp_i2c_write(client, opr_buf, 2 + 1);
+    
+    // clear waiting flag, run dsp
+    gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x04);
+    
+    // inquirying test status until it's okay
+    for (i = 0;;++i)
+    {
+        gtp_read_register(client, 0x8800, opr_buf);
+        if (opr_buf[2] == 0x88)
+        {
+            break;
+        }
+        msleep(50);
+        if ( i > 100 )
+        {
+            SET_INFO_LINE_ERR("step 4: inquiry test status timeout!");
+            goto short_test_exit;
+        }
+    }
+    
+    // step 5: compute the result
+    /* short flag: 
+          bit0: Rx & Rx 
+          bit1: Tx & Tx 
+          bit2: Tx & Rx
+          bit3: Tx/Rx & GND/VDD
+    */
+    gtp_read_register(client, 0x8801, opr_buf);
+    GTP_DEBUG("short_flag = 0x%02X", opr_buf[2]);
+    SET_INFO_LINE_INFO("");
+    SET_INFO_LINE_INFO("Short Test Result:");
+    if ((opr_buf[2] & 0x0f) == 0)
+    {
+        SET_INFO_LINE_INFO("  PASS!");
+        ret = SUCCESS;
+    }
+    else 
+    {
+        ret2 = SUCCESS;
+        if ((opr_buf[2] & 0x08) == 0x08)
+        {
+            ret2 = gt9_test_gnd_vdd_short(client);
+        }
+        ret = gtp_compute_rslt(client);
+        if (ret == SUCCESS && ret2 == SUCCESS)
+        {
+            SET_INFO_LINE_INFO("  PASS!");
+            ret = SUCCESS;
+        }
+        else
+        {
+            ret = FAIL;
+        }
+    }
+    // boot from rom and download code from flash to ram
+    gtp_write_register(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+    gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x08);
+    
+    client->addr = old_i2c_addr;
+    gt9xx_leave_short_test(client);
+    //gtp_irq_enable(ts);
+    enable_irq(ts->client->irq);
+
+#if GTP_ESD_PROTECT
+    ts->gtp_is_suspend = 0;     // resume esd
+#endif
+    return ret;
+    
+short_test_exit:
+    // boot from rom and download code from flash to ram
+    gtp_write_register(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+    gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x08);
+    
+    client->addr = old_i2c_addr;
+    gt9xx_leave_short_test(client);
+    //gtp_irq_enable(ts);
+    enable_irq(ts->client->irq);
+#if GTP_ESD_PROTECT
+    ts->gtp_is_suspend = 0;     // resume esd
+#endif
+    return FAIL;    
+}
+
+u32 endian_mode(void)
+{
+    union {s32 i; s8 c;}endian;
+
+    endian.i = 1;
+
+    if (1 == endian.c)
+    {
+        return MYBIG_ENDIAN;
+    }
+    else
+    {
+        return MYLITLE_ENDIAN;
+    }
+}
+/*
+*********************************************************************************************************
+* Function: 
+*   send read rawdata cmd
+* Input:
+*   i2c_client* client: i2c device
+* Return:
+*   SUCCESS: send process succeed, FAIL: failed
+*********************************************************************************************************
+*/
+s32 gt9_read_raw_cmd(struct i2c_client* client)
+{
+    u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x01};
+    s32 ret = -1;
+    GTP_DEBUG("Send read raw data command");
+    ret = gtp_i2c_write(client, raw_cmd, 3);
+    if(ret <= 0)
+    {
+        SET_INFO_LINE_ERR("i2c write failed.");
+        return FAIL;
+    }
+    msleep(10); 
+    return SUCCESS;
+}
+
+s32 gt9_read_coor_cmd(struct i2c_client *client)
+{
+    u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x0};
+    s32 ret = -1;
+    
+    ret = gtp_i2c_write(client, raw_cmd, 3);
+    if (ret < 0)
+    {
+        SET_INFO_LINE_ERR("i2c write coor cmd failed!");
+        return FAIL;
+    }
+    msleep(10);
+    return SUCCESS;
+}
+/*
+*********************************************************************************************************
+* Function: 
+*   read rawdata from ic registers
+* Input:
+*   u16* data: rawdata buffer
+*   i2c_client* client: i2c device
+* Return:
+*   SUCCESS: read process succeed, FAIL:  failed
+*********************************************************************************************************
+*/
+s32 gtp_read_rawdata(struct i2c_client* client, u16* data)
+{
+    s32 ret = -1;
+    u16 retry = 0;
+    u8 read_state[3] = {(u8)(GTP_REG_RAW_READY>>8), (u8)GTP_REG_RAW_READY, 0};
+    u16 i = 0, j = 0;
+    u8 *read_rawbuf;
+    u8 tail, head;
+
+    read_rawbuf = (u8*)kmalloc(sizeof(u8) * (gt9xx_drv_num*gt9xx_sen_num * 2 + GTP_ADDR_LENGTH), GFP_KERNEL);
+
+    if (NULL == read_rawbuf)
+    {
+        SET_INFO_LINE_ERR("failed to allocate for read_rawbuf");
+        return FAIL;
+    }
+    
+    if(data == NULL)
+    {
+        SET_INFO_LINE_ERR("Invalid raw buffer.");
+        goto have_error;
+    }
+    
+    msleep(10);
+    while (retry++ < GTP_WAIT_RAW_MAX_TIMES)
+    {
+        ret = gtp_i2c_read(client, read_state, 3);
+        if(ret <= 0)
+        {
+            SET_INFO_LINE_ERR("i2c read failed.return: %d", ret);
+            continue;
+        }
+        if ((read_state[GTP_ADDR_LENGTH] & 0x80) == 0x80)
+        {
+            GTP_DEBUG("Raw data is ready.");
+            break;
+        } 
+        if ((retry%20) == 0)
+		{
+            GTP_DEBUG("(%d)read_state[2] = 0x%02X", retry, read_state[GTP_ADDR_LENGTH]);
+			if (retry == 100)
+			{
+				gt9_read_raw_cmd(client);
+			}
+		}
+        msleep(5);
+    }
+    if (retry >= GTP_WAIT_RAW_MAX_TIMES)
+    {
+        SET_INFO_LINE_ERR("Wait raw data ready timeout.");
+        goto have_error;
+    }
+    
+    if (chip_type_gt9f)
+    {
+        read_rawbuf[0] = (u8)( GTP_REG_RAW_DATA_GT9F >> 8);
+        read_rawbuf[1] = (u8)( GTP_REG_RAW_DATA_GT9F );
+    }
+    else
+    {
+        read_rawbuf[0] = (u8)( GTP_REG_RAW_DATA >> 8);
+        read_rawbuf[1] = (u8)( GTP_REG_RAW_DATA );
+    }
+    
+    ret = gtp_i2c_read(client, read_rawbuf, GTP_ADDR_LENGTH + ((gt9xx_drv_num*gt9xx_sen_num)*2));
+    if(ret <= 0)
+    {
+        SET_INFO_LINE_ERR("i2c read rawdata failed.");
+        goto have_error;
+    }
+    gtp_i2c_end_cmd(client);    // clear buffer state
+
+    if (endian_mode() == MYBIG_ENDIAN)
+    {
+        head = 0;
+        tail =1;
+        GTP_DEBUG("Big Endian.");
+    }
+    else
+    {
+        head = 1;
+        tail = 0;
+        GTP_DEBUG("Little Endian.");
+    }
+    
+    for(i=0,j = 0; i < ((gt9xx_drv_num*gt9xx_sen_num)*2); i+=2)
+    {
+        data[i/2] = (u16)(read_rawbuf[i+head+GTP_ADDR_LENGTH]<<8) + (u16)read_rawbuf[GTP_ADDR_LENGTH+i+tail];
+    #if GTP_DEBUG_ARRAY_ON
+        printk("%4d ", data[i/2]);
+        ++j;
+        if((j%10) == 0)
+            printk("\n");
+    #endif
+    }
+    
+    kfree(read_rawbuf);
+    return SUCCESS;
+have_error:
+    kfree(read_rawbuf);
+    return FAIL;
+}
+/*
+*********************************************************************************************************
+* Function: 
+*   rawdata test initilization function
+* Input:
+*   u32 check_types: test items
+*********************************************************************************************************
+*/
+static s32 gtp_raw_test_init(void)
+{
+    u16 i = 0;
+      
+    test_rslt_buf = (s32*) kmalloc(sizeof(s32)*GTP_OPEN_SAMPLE_NUM, GFP_ATOMIC);  
+    touchpad_sum = (struct gt9xx_open_info*) kmalloc(sizeof(struct gt9xx_open_info) * (4 * _BEYOND_INFO_MAX + 1), GFP_ATOMIC);
+    if (NULL == test_rslt_buf || NULL == touchpad_sum)
+    {
+        return FAIL;
+    }
+    memset(touchpad_sum, 0, sizeof(struct gt9xx_open_info) * (4 * _BEYOND_INFO_MAX + 1));
+    
+    for (i = 0; i < (4 * _BEYOND_INFO_MAX); ++i)
+    {
+        touchpad_sum[i].driver = 0xFF;
+    }
+        
+    for (i = 0; i < GTP_OPEN_SAMPLE_NUM; i++)
+    {
+        test_rslt_buf[i] = _CHANNEL_PASS;
+    }
+    return SUCCESS;
+}
+
+/*
+*********************************************************************************************************
+* Function: 
+*   touchscreen rawdata min limit test
+* Input:
+*   u16* raw_buf: rawdata buffer
+*********************************************************************************************************
+*/
+static void gtp_raw_min_test(u16 *raw_buf)
+{
+    u16 i, j=0;
+    u8 driver, sensor;
+    u8 sum_base = 1 * _BEYOND_INFO_MAX;
+    u8 new_flag = 0;
+    
+    for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
+    {
+        if (raw_buf[i] < min_limit_value)
+        {
+            test_rslt_buf[rslt_buf_idx] |= _BEYOND_MIN_LIMIT;       
+            driver = (i/gt9xx_sen_num); 
+            sensor = (i%gt9xx_sen_num);
+            new_flag = 0;
+            for (j = sum_base; j < (sum_base+_BEYOND_INFO_MAX); ++j)
+            {
+                if (touchpad_sum[j].driver == 0xFF)
+                {
+                    new_flag = 1;
+                    break;
+                }
+                if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
+                {
+                    touchpad_sum[j].times++;
+                    new_flag = 0;
+                    break;
+                }
+            }
+            if (new_flag)   // new one
+            {
+                touchpad_sum[j].driver = driver;
+                touchpad_sum[j].sensor = sensor;
+                touchpad_sum[j].beyond_type |= _BEYOND_MIN_LIMIT;
+                touchpad_sum[j].raw_val = raw_buf[i];
+                touchpad_sum[j].times = 1;    
+                GTP_DEBUG("[%d, %d]rawdata: %d, raw min limit: %d", driver, sensor, raw_buf[i], min_limit_value);
+            }
+            else
+            {
+                continue;
+            }
+        }
+    }
+}
+
+/*
+*********************************************************************************************************
+* Function: 
+*   touchscreen rawdata max limit test
+* Input:
+*   u16* raw_buf: rawdata buffer
+*********************************************************************************************************
+*/
+static void gtp_raw_max_test(u16 *raw_buf)
+{
+    u16 i, j;
+    u8 driver, sensor;
+    u8 sum_base = 0 * _BEYOND_INFO_MAX;
+    u8 new_flag = 0;
+    
+    for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
+    {
+        if (raw_buf[i] > max_limit_value)
+        {
+            test_rslt_buf[rslt_buf_idx] |= _BEYOND_MAX_LIMIT;
+            driver = (i/gt9xx_sen_num);
+            sensor = (i%gt9xx_sen_num);
+            new_flag = 0;
+            for (j = sum_base; j < (sum_base+_BEYOND_INFO_MAX); ++j)
+            {
+                if (touchpad_sum[j].driver == 0xFF)
+                {
+                    new_flag = 1;
+                    break;
+                }
+                if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
+                {
+                    touchpad_sum[j].times++;
+                    new_flag = 0;
+                    break;
+                }
+            }
+            if (new_flag)   // new one
+            {
+                touchpad_sum[j].driver = driver;
+                touchpad_sum[j].sensor = sensor;
+                touchpad_sum[j].beyond_type |= _BEYOND_MAX_LIMIT;
+                touchpad_sum[j].raw_val = raw_buf[i];
+                touchpad_sum[j].times = 1;    
+                GTP_DEBUG("[%d, %d]rawdata: %d, raw max limit: %d", driver, sensor, raw_buf[i], max_limit_value);
+            }
+            else
+            {
+                continue;
+            }
+        }
+    }
+}
+
+/*
+*********************************************************************************************************
+* Function: 
+*   key rawdata max limit test
+* Input:
+*   u16* raw_buf: rawdata buffer
+*********************************************************************************************************
+*/
+static void gtp_key_max_test(u16 *raw_buf)
+{
+    u16 i = 0, j = 1, k = 0;
+    u8 key_cnt = key_iso_pos[0];
+    u8 driver, sensor;
+    u8 sum_base = 2 * _BEYOND_INFO_MAX;
+    u8 new_flag = 0;
+    
+    driver = gt9xx_drv_num-1;
+    for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
+    {
+        sensor = ((i)%gt9xx_sen_num); 
+        if (key_is_isolated)
+        { 
+            if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
+            {
+                continue;
+            }
+            else    // only test key pixel rawdata
+            {
+                --key_cnt;
+                ++j;
+            }
+        }
+        if (raw_buf[i] > max_limit_key)
+        {
+            test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MAX_LMT;
+            new_flag = 0;
+            for (k = sum_base; k < (sum_base+_BEYOND_INFO_MAX); ++k)
+            {
+                if (touchpad_sum[k].driver == 0xFF)
+                {
+                    new_flag = 1;
+                    break;
+                }
+                if (touchpad_sum[k].sensor == sensor)
+                {
+                    touchpad_sum[k].times++;
+                    new_flag = 0;
+                    break;
+                }
+            }
+            if (new_flag)   // new one
+            {
+                touchpad_sum[k].driver = driver;
+                touchpad_sum[k].sensor = sensor;
+                touchpad_sum[k].beyond_type |= _BEYOND_KEY_MAX_LMT;
+                touchpad_sum[k].raw_val = raw_buf[i];
+                touchpad_sum[k].times = 1;
+                if (key_is_isolated)
+                {
+                    touchpad_sum[k].key = j-1;
+                }    
+                GTP_DEBUG("[%d, %d]key rawdata: %d, key max limit: %d", driver,sensor, raw_buf[i], max_limit_key);
+            }
+            else
+            {
+                continue;
+            }
+        }
+    }
+}
+/*
+*********************************************************************************************************
+* Function: 
+*   key rawdata min limit test
+* Input:
+*   u16* raw_buf: rawdata buffer
+*********************************************************************************************************
+*/
+static void gtp_key_min_test(u16 *raw_buf)
+{
+    u16 i = 0, j = 1, k = 0;
+    u8 key_cnt = key_iso_pos[0];
+    u8 driver, sensor;
+    u8 sum_base = 3 * _BEYOND_INFO_MAX;
+    u8 new_flag = 0;
+    
+    driver = gt9xx_drv_num-1;
+    for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
+    {
+        sensor = (i%gt9xx_sen_num); 
+        if (key_is_isolated)
+        {
+            //GTP_DEBUG("sensor: %d, key_iso_pos[j]: %d", sensor, key_iso_pos[j]);
+            if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
+            {
+                continue;
+            }
+            else    // only test key pixel rawdata
+            {
+                --key_cnt;
+                ++j;
+            }
+        }
+    
+        if (raw_buf[i] < min_limit_key)
+        {
+            test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MIN_LMT;
+            new_flag = 0;
+            for (k = sum_base; k < (sum_base + _BEYOND_INFO_MAX); ++k)
+            {
+                if (touchpad_sum[k].driver == 0xFF)
+                {
+                    new_flag = 1;
+                    break;
+                }
+                if (sensor == touchpad_sum[k].sensor)
+                {
+                    touchpad_sum[k].times++;
+                    break;
+                }
+            }
+            if (new_flag)   // new one
+            {
+                touchpad_sum[k].driver = driver;
+                touchpad_sum[k].sensor = sensor;
+                touchpad_sum[k].beyond_type |= _BEYOND_KEY_MIN_LMT;
+                touchpad_sum[k].raw_val = raw_buf[i];
+                touchpad_sum[k].times = 1;
+                if (key_is_isolated)
+                {
+                    touchpad_sum[k].key = j-1;
+                }            
+                GTP_DEBUG("[%d, %d]key rawdata: %d, key min limit: %d", driver, sensor, raw_buf[i], min_limit_key);
+
+            }
+            else
+            {
+                continue;
+            }
+        }
+    }
+}
+
+static void gtp_uniformity_test(u16 *raw_buf)
+{    
+    u16 i = 0;
+    u8 sum_base = 4 * _BEYOND_INFO_MAX;
+    u16 min_val = 0, max_val = 0;
+    u16 uniformity = 0;
+    
+    min_val = raw_buf[0];
+    max_val = raw_buf[0];
+    for (i = 1; i < gt9xx_sc_pxl_cnt; i++)
+    {
+        if (raw_buf[i] > max_val)
+        {
+            max_val = raw_buf[i];
+        }
+        if (raw_buf[i] < min_val)
+        {
+            min_val = raw_buf[i];
+        }
+    }
+    
+    if (0 == max_val)
+    {
+        uniformity = 0;
+    }
+    else
+    {
+        uniformity = (min_val * 100) / max_val;
+    }
+     GTP_DEBUG("min_val: %d, max_val: %d, tp uniformity: %d%%", min_val, max_val, uniformity);
+     if (uniformity < uniformity_lmt)  
+     {
+        test_rslt_buf[rslt_buf_idx] |= _BEYOND_UNIFORMITY_LMT;
+        touchpad_sum[sum_base].beyond_type |= _BEYOND_UNIFORMITY_LMT;
+        touchpad_sum[sum_base].times++;
+        touchpad_sum[sum_base].raw_val += uniformity;
+        GTP_INFO("min_val: %d, max_val: %d, uniformity: %d%%, times: %d", min_val, max_val, uniformity, touchpad_sum[sum_base].times);
+     }
+}
+
+
+/*
+*********************************************************************************************************
+* Function: 
+*   analyse rawdata retrived from ic registers
+* Input:
+*   u16 *raw_buf, buffer for rawdata, 
+*   u32 check_types, test items
+* Return:
+*   SUCCESS: test process succeed, FAIL: failed
+*********************************************************************************************************
+*/
+static u32 gtp_raw_test(u16 *raw_buf, u32 check_types)
+{   
+    if (raw_buf == NULL)
+    {
+        GTP_DEBUG("Invalid raw buffer pointer!");
+        return FAIL;
+    } 
+
+    if (check_types & _MAX_TEST)
+    {
+        gtp_raw_max_test(raw_buf);
+    }
+
+    if (check_types & _MIN_TEST)    
+    {
+        gtp_raw_min_test(raw_buf);
+    }
+    if (have_key)
+    {    
+        if (check_types & _KEY_MAX_TEST)
+        {
+            gtp_key_max_test(raw_buf);
+        }
+        if (check_types & _KEY_MIN_TEST)
+        {
+            gtp_key_min_test(raw_buf);
+        }
+    }
+    
+    if (check_types & _UNIFORMITY_TEST)     // 20130814, for acer
+    {
+        gtp_uniformity_test(raw_buf);
+    }
+    return SUCCESS;
+} 
+
+
+/*
+====================================================================================================
+* Function: 
+*   output the test result
+* Return: 
+*   return the result. if result == 0, the TP is ok, otherwise list the beyonds
+====================================================================================================
+*/
+
+static s32 gtp_get_test_result(void)
+{
+    u16 i = 0, j = 0;
+    u16 beyond_max_num = 0;         // beyond max limit test times
+    u16 beyond_min_num = 0;         // beyond min limit test times
+    u16 beyond_key_max = 0;         // beyond key max limit test times
+    u16 beyond_key_min = 0;         // beyond key min limit test times
+
+    u16 beyond_uniformity = 0;      // uniformity test failed times
+    
+    s32 result = _CHANNEL_PASS;
+    
+#if GTP_DEBUG_ON
+    for (i = 0; i < 4 * _BEYOND_INFO_MAX; ++i)
+    {
+        printk("(%2d, %2d)[%2d] ", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
+        if (i && ((i+1) % 5 == 0))
+        {
+            printk("\n");
+        }
+    }
+    printk("\n");
+#endif
+
+    for (i = 0; i < GTP_OPEN_SAMPLE_NUM; ++i)
+    {
+        if (test_rslt_buf[i] & _BEYOND_MAX_LIMIT) 
+        {
+            beyond_max_num++;
+        }
+        if (test_rslt_buf[i] & _BEYOND_MIN_LIMIT)
+        {
+            beyond_min_num++;
+        }
+        
+        if (have_key)
+        {
+            if (test_rslt_buf[i] & _BEYOND_KEY_MAX_LMT)
+            {
+                beyond_key_max++;
+            }
+            if (test_rslt_buf[i] & _BEYOND_KEY_MIN_LMT)
+            {
+                beyond_key_min++;
+            }
+        }
+        
+        if (test_rslt_buf[i] & _BEYOND_UNIFORMITY_LMT)
+        {
+            beyond_uniformity++;
+        }
+    }
+    if (beyond_max_num > _MIN_ERROR_NUM)
+    {
+        result |= _BEYOND_MAX_LIMIT;
+        j = 0;
+        SET_INFO_LINE_INFO("Beyond Max Limit Points Info: ");
+        for (i = 0; i < _BEYOND_INFO_MAX; ++i)
+        {
+            if (touchpad_sum[i].driver == 0xFF)
+            {
+                break;
+            }
+            SET_INFO_LINE_INFO("  Drv: %d, Sen: %d RawVal: %d", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].raw_val);
+        }
+    }
+    if (beyond_min_num > _MIN_ERROR_NUM)
+    {
+        result |= _BEYOND_MIN_LIMIT;
+        SET_INFO_LINE_INFO("Beyond Min Limit Points Info:");
+        j = 0;
+        for (i = _BEYOND_INFO_MAX; i < (2*_BEYOND_INFO_MAX); ++i)
+        {
+            if (touchpad_sum[i].driver == 0xFF)
+            {
+                break;
+            }
+            SET_INFO_LINE_INFO("  Drv: %d, Sen: %d RawVal: %d", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].raw_val);
+        }
+    }
+    
+    if (have_key)
+    {
+        if (beyond_key_max > _MIN_ERROR_NUM)
+        {
+            result |= _BEYOND_KEY_MAX_LMT;
+            SET_INFO_LINE_INFO("Beyond Key Max Limit Key Info:");
+            for (i = 2*_BEYOND_INFO_MAX; i < (3*_BEYOND_INFO_MAX); ++i)
+            {
+                if (touchpad_sum[i].driver == 0xFF)
+                {
+                    break;
+                }
+                SET_INFO_LINE_INFO("  Drv: %d, Sen: %d RawVal: %d", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].raw_val);
+            }
+        }
+        if (beyond_key_min > _MIN_ERROR_NUM)
+        {
+            result |= _BEYOND_KEY_MIN_LMT;       
+            SET_INFO_LINE_INFO("Beyond Key Min Limit Key Info:");
+            for (i = 3*_BEYOND_INFO_MAX; i < (4*_BEYOND_INFO_MAX); ++i)
+            {
+                if (touchpad_sum[i].driver == 0xFF)
+                {
+                    break;
+                }
+                SET_INFO_LINE_INFO("  Drv: %d, Sen: %d RawVal: %d", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].raw_val);
+            }
+        }      
+    }
+
+    if (beyond_uniformity > _MIN_ERROR_NUM)
+    {
+        result |= _BEYOND_UNIFORMITY_LMT;
+        SET_INFO_LINE_INFO("Beyond Uniformity Limit Info: ");
+        SET_INFO_LINE_INFO("  Uniformity Limit: %d%%, Tp Uniformity: %d%%", uniformity_lmt, touchpad_sum[4*_BEYOND_INFO_MAX].raw_val / touchpad_sum[4 * _BEYOND_INFO_MAX].times);
+    }
+    
+    if (result == 0)
+    {
+        SET_INFO_LINE_INFO("[TEST SUCCEED]: ");
+        SET_INFO_LINE_INFO("\tThe TP is OK!");
+        return result;
+    }
+    SET_INFO_LINE_INFO("[TEST FAILED]:");
+    if (result & _BEYOND_MAX_LIMIT)
+    {
+        SET_INFO_LINE_INFO("  Beyond Raw Max Limit [Max Limit: %d]", max_limit_value);
+    }
+    if (result & _BEYOND_MIN_LIMIT)
+    {
+        SET_INFO_LINE_INFO("  Beyond Raw Min Limit [Min Limit: %d]", min_limit_value);
+    }
+    
+    if (have_key)
+    {
+        if (result & _BEYOND_KEY_MAX_LMT)
+        {
+            SET_INFO_LINE_INFO("  Beyond KeyVal Max Limit [Key Max Limit: %d]", max_limit_key);
+        }
+        if (result & _BEYOND_KEY_MIN_LMT)
+        {
+            SET_INFO_LINE_INFO("  Beyond KeyVal Min Limit [Key Min Limit: %d]", min_limit_key);
+        }
+    }
+   
+    if (result & _BEYOND_UNIFORMITY_LMT)
+    {
+        SET_INFO_LINE_INFO("  Beyond Uniformity Limit [Uniformity Limit: %d%%]", uniformity_lmt);
+    }
+    return result;
+}
+
+/*
+ ===================================================
+ * Function: 
+ *      test gt9 series ic open test
+ * Input:
+ *      client, i2c_client
+ * Return:
+ *      SUCCESS: test process success, FAIL, test process failed
+ *
+ ===================================================
+*/
+s32 gt9xx_open_test(struct i2c_client * client)
+{
+    u16 i = 0;
+    s32 ret = FAIL; // SUCCESS, FAIL
+    struct goodix_ts_data *ts;
+    u16 *raw_buf = NULL;
+    
+    ts = i2c_get_clientdata(client);
+    gtp_irq_disable(ts);
+#if GTP_ESD_PROTECT
+    ts->gtp_is_suspend = 1;     // suspend esd
+#endif
+    ts->gtp_rawdiff_mode = 1;
+    
+    SET_INFO_LINE_INFO("---gtp open test---");
+    GTP_INFO("Parsing configuration...");
+    gtp_hopping_switch(client, 0);
+    ret = gtp_parse_config(client);
+    if (ret == FAIL)
+    {
+        SET_INFO_LINE_ERR("failed to parse config...");
+        ret = FAIL;
+        goto open_test_exit;
+    }
+    raw_buf = (u16*)kmalloc(sizeof(u16)* (gt9xx_drv_num*gt9xx_sen_num), GFP_KERNEL);
+    if (NULL == raw_buf)
+    {
+        SET_INFO_LINE_ERR("failed to allocate mem for raw_buf!");
+        ret = FAIL;
+        goto open_test_exit;
+    }
+
+    GTP_INFO("Step 1: Send Rawdata Cmd");
+    
+    ret = gtp_raw_test_init();
+    if (FAIL == ret)
+    {
+        SET_INFO_LINE_ERR("Allocate memory for open test failed!");
+        ret = FAIL;
+        goto open_test_exit;
+    }
+    ret = gt9_read_raw_cmd(client);
+    if (ret == FAIL)
+    {
+        SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
+        ret = FAIL;
+        goto open_test_exit;
+    }
+    GTP_INFO("Step 2: Sample Rawdata");
+    for (i = 0; i < GTP_OPEN_SAMPLE_NUM; ++i)
+    {   
+        rslt_buf_idx = i;
+        ret = gtp_read_rawdata(client, raw_buf);
+        if (ret == FAIL)
+        {
+            SET_INFO_LINE_ERR("Read Rawdata failed!");
+            ret = FAIL;
+            goto open_test_exit;
+        }
+        ret = gtp_raw_test(raw_buf, DEFAULT_TEST_ITEMS);
+        if (ret == FAIL)
+        {
+            gtp_i2c_end_cmd(client);
+            continue;
+        }
+    }
+    GTP_INFO("Step 3: Analyse Result");
+    SET_INFO_LINE_INFO("Total %d Sample Data, Max Show %d Info for each Test Item", GTP_OPEN_SAMPLE_NUM, _BEYOND_INFO_MAX);
+    if (0 == gtp_get_test_result())
+    {
+        ret = SUCCESS; 
+    }
+    else 
+    {
+        ret = FAIL;
+    }
+    
+open_test_exit:
+    if (raw_buf)
+    {
+        kfree(raw_buf);
+    }
+    if (test_rslt_buf)
+    {
+        kfree(test_rslt_buf);
+        test_rslt_buf = NULL;
+    }
+    if (touchpad_sum)
+    {
+        kfree(touchpad_sum);
+        touchpad_sum = NULL;
+    }
+    gtp_irq_enable(ts);
+#if GTP_ESD_PROTECT
+    ts->gtp_is_suspend = 0;     // resume esd
+#endif
+    ts->gtp_rawdiff_mode = 0;
+    gt9_read_coor_cmd(client);	// back to read coordinates data 
+    SET_INFO_LINE_INFO("---gtp open test end---");
+    gtp_hopping_switch(client, 1);
+    return ret;
+}
+
+static ssize_t gtp_sysfs_shorttest_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    u8 index;
+    ssize_t len;
+    
+
+    gt9xx_short_test(i2c_connect_client);
+    
+    for (index = 0, len = 0; index < RsltIndex; ++index)
+    {
+        sprintf(&buf[len], "%s", result_lines[index]);
+        len += strlen(result_lines[index]);
+        kfree(result_lines[index]);
+    }
+    RsltIndex = 0;
+    return len;
+}
+
+static ssize_t gtp_sysfs_shorttest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+static ssize_t gtp_sysfs_opentest_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    s32 index;
+    ssize_t len;
+    s32 ret;
+    ret = gt9xx_open_test(i2c_connect_client);
+
+    for (index = 0, len = 0; index < RsltIndex; ++index)
+    {
+#if GTP_TP_TEST
+
+#else
+        sprintf(&buf[len], "%s", result_lines[index]);
+#endif
+        len += strlen(result_lines[index]);
+        kfree(result_lines[index]);
+    }
+    RsltIndex = 0;
+#if GTP_TP_TEST
+		return snprintf(buf, PAGE_SIZE, "%u\n", (ret == SUCCESS)?0:1);
+#else
+    return len;
+#endif
+}
+
+static ssize_t gtp_sysfs_opentest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+    return -EPERM;
+}
+
+static ssize_t gtp_sysfs_id_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+    return snprintf(buf, PAGE_SIZE, "%u\n", sensor_manufacture);;
+}
+
+static DEVICE_ATTR(shorttest, S_IRUGO|S_IWUSR, gtp_sysfs_shorttest_show, gtp_sysfs_shorttest_store);
+static DEVICE_ATTR(opentest, S_IRUGO|S_IWUSR, gtp_sysfs_opentest_show, gtp_sysfs_opentest_store);
+static DEVICE_ATTR(sensor_id, S_IRUGO|S_IWUSR, gtp_sysfs_id_show, NULL);
+
+/*******************************************************
+Description:
+    Goodix debug sysfs init function.
+
+Parameter:
+    none.
+    
+return:
+    Executive outcomes. 0---succeed.
+*******************************************************/
+s32 gtp_test_sysfs_init(void)
+{
+    s32 ret ;
+
+    goodix_debug_kobj = kobject_create_and_add("gtp_test", NULL) ;
+    SET_INFO_LINE_INFO("Starting initializing gtp_debug_sysfs");
+    if (goodix_debug_kobj == NULL)
+    {
+        GTP_ERROR("%s: subsystem_register failed\n", __func__);
+        return -ENOMEM;
+    }
+
+    ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
+    if (ret)
+    {
+        GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
+        return ret;
+    }
+    ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_opentest.attr);
+    if (ret)
+    {
+        GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
+        return ret;
+    }
+	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_sensor_id.attr);
+    if (ret)
+    {
+        GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
+        return ret;
+    }
+
+    GTP_INFO("Goodix debug sysfs create success!\n");
+    return 0 ;
+}
+
+void gtp_test_sysfs_deinit(void)
+{
+    sysfs_remove_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
+    sysfs_remove_file(goodix_debug_kobj, &dev_attr_opentest.attr);
+	sysfs_remove_file(goodix_debug_kobj, &dev_attr_sensor_id.attr);
+    kobject_del(goodix_debug_kobj);
+}
diff --git a/drivers/input/touchscreen/gt915/gt9xx_openshort.h b/drivers/input/touchscreen/gt915/gt9xx_openshort.h
new file mode 100755
index 0000000..a339ce1
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx_openshort.h
@@ -0,0 +1,448 @@
+/* drivers/input/touchscreen/gt9xx_shorttp.h
+ * 
+ * 2010 - 2012 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ * Version:1.0
+ *      V1.0:2012/10/20
+ */
+
+
+#ifndef _GT9XX_OPEN_SHORT_H_
+#define _GT9XX_OPEN_SHORT_H_
+
+#include "gt9xx.h"
+
+const u8 dsp_short[] = {
+	0x02,0x09,0xac,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xe0,0x22,0x50,0x02,0xe7,0x22,
+	0xbb,0xfe,0x02,0xe3,0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0x22,0xa3,0xf8,0xe0,0xc5,
+	0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0xc8,0x38,0xf0,
+	0xe8,0x22,0xe8,0x8f,0xf0,0xa4,0xcc,0x8b,0xf0,0xa4,0x2c,0xfc,0xe9,0x8e,0xf0,0xa4,
+	0x2c,0xfc,0x8a,0xf0,0xed,0xa4,0x2c,0xfc,0xea,0x8e,0xf0,0xa4,0xcd,0xa8,0xf0,0x8b,
+	0xf0,0xa4,0x2d,0xcc,0x38,0x25,0xf0,0xfd,0xe9,0x8f,0xf0,0xa4,0x2c,0xcd,0x35,0xf0,
+	0xfc,0xeb,0x8e,0xf0,0xa4,0xfe,0xa9,0xf0,0xeb,0x8f,0xf0,0xa4,0xcf,0xc5,0xf0,0x2e,
+	0xcd,0x39,0xfe,0xe4,0x3c,0xfc,0xea,0xa4,0x2d,0xce,0x35,0xf0,0xfd,0xe4,0x3c,0xfc,
+	0x22,0x75,0xf0,0x08,0x75,0x82,0x00,0xef,0x2f,0xff,0xee,0x33,0xfe,0xcd,0x33,0xcd,
+	0xcc,0x33,0xcc,0xc5,0x82,0x33,0xc5,0x82,0x9b,0xed,0x9a,0xec,0x99,0xe5,0x82,0x98,
+	0x40,0x0c,0xf5,0x82,0xee,0x9b,0xfe,0xed,0x9a,0xfd,0xec,0x99,0xfc,0x0f,0xd5,0xf0,
+	0xd6,0xe4,0xce,0xfb,0xe4,0xcd,0xfa,0xe4,0xcc,0xf9,0xa8,0x82,0x22,0xb8,0x00,0xc1,
+	0xb9,0x00,0x59,0xba,0x00,0x2d,0xec,0x8b,0xf0,0x84,0xcf,0xce,0xcd,0xfc,0xe5,0xf0,
+	0xcb,0xf9,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,
+	0xeb,0x33,0xfb,0x10,0xd7,0x03,0x99,0x40,0x04,0xeb,0x99,0xfb,0x0f,0xd8,0xe5,0xe4,
+	0xf9,0xfa,0x22,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,
+	0xfc,0xc9,0x33,0xc9,0x10,0xd7,0x05,0x9b,0xe9,0x9a,0x40,0x07,0xec,0x9b,0xfc,0xe9,
+	0x9a,0xf9,0x0f,0xd8,0xe0,0xe4,0xc9,0xfa,0xe4,0xcc,0xfb,0x22,0x75,0xf0,0x10,0xef,
+	0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xcc,0x33,0xcc,0xc8,0x33,0xc8,0x10,0xd7,
+	0x07,0x9b,0xec,0x9a,0xe8,0x99,0x40,0x0a,0xed,0x9b,0xfd,0xec,0x9a,0xfc,0xe8,0x99,
+	0xf8,0x0f,0xd5,0xf0,0xda,0xe4,0xcd,0xfb,0xe4,0xcc,0xfa,0xe4,0xc8,0xf9,0x22,0xeb,
+	0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,0xf0,0x22,
+	0xe8,0x60,0x0f,0xec,0xc3,0x13,0xfc,0xed,0x13,0xfd,0xee,0x13,0xfe,0xef,0x13,0xff,
+	0xd8,0xf1,0x22,0xe8,0x60,0x0f,0xef,0xc3,0x33,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,
+	0xec,0x33,0xfc,0xd8,0xf1,0x22,0xec,0xf0,0xa3,0xed,0xf0,0xa3,0xee,0xf0,0xa3,0xef,
+	0xf0,0x22,0xa8,0x82,0x85,0x83,0xf0,0xd0,0x83,0xd0,0x82,0x12,0x01,0xa9,0x12,0x01,
+	0xa9,0x12,0x01,0xa9,0x12,0x01,0xa9,0xe4,0x73,0xe4,0x93,0xa3,0xc5,0x83,0xc5,0xf0,
+	0xc5,0x83,0xc8,0xc5,0x82,0xc8,0xf0,0xa3,0xc5,0x83,0xc5,0xf0,0xc5,0x83,0xc8,0xc5,
+	0x82,0xc8,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0x90,
+	0x50,0x96,0x74,0xaa,0xf0,0x90,0x41,0x83,0xe0,0x44,0x08,0xf0,0x7d,0x48,0x7f,0x01,
+	0x12,0x12,0x20,0x90,0x42,0x07,0x74,0x0f,0xf0,0x90,0x42,0x06,0xe0,0x44,0x02,0xf0,
+	0xe0,0x54,0xfe,0xf0,0x90,0x42,0x51,0x74,0x03,0xf0,0xc2,0xaf,0x12,0x14,0x43,0x12,
+	0x0d,0x3f,0x12,0x14,0x19,0x90,0xbf,0xfe,0xe4,0xf0,0x12,0x0c,0xdc,0x90,0x42,0x3a,
+	0xe4,0xf0,0xa3,0x04,0xf0,0x90,0x50,0x8b,0x74,0x14,0xf0,0x90,0x50,0x8a,0xf0,0x12,
+	0x07,0x21,0x90,0x60,0x2f,0x74,0x07,0xf0,0x7f,0x3b,0x12,0x14,0x67,0x90,0x50,0x96,
+	0xe0,0xb4,0xaa,0x03,0x00,0x80,0xf6,0x12,0x0a,0x51,0x90,0x88,0x04,0xe0,0x70,0x02,
+	0xa3,0xe0,0x60,0x03,0xd3,0x80,0x01,0xc3,0x40,0x08,0x90,0x88,0x01,0x74,0x10,0xf0,
+	0x80,0x75,0x90,0x88,0x04,0xe0,0xff,0xa3,0xe0,0x90,0x80,0x58,0xcf,0xf0,0xa3,0xef,
+	0xf0,0x7b,0x6a,0x7d,0x02,0x7f,0x1d,0x7e,0x00,0x12,0x0a,0xe1,0xe4,0x90,0x88,0x00,
+	0xf0,0x90,0x42,0x07,0x74,0x0f,0xf0,0x90,0x42,0x06,0xe0,0x44,0x02,0xf0,0xe0,0x44,
+	0x01,0xf0,0xe4,0xff,0xef,0x25,0xe0,0x24,0xa1,0xf5,0x82,0xe4,0x34,0xa4,0xf5,0x83,
+	0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0x31,0xf5,0x82,0xe4,0x34,0xa5,0xf5,0x83,
+	0xe4,0xf0,0xa3,0xf0,0x0f,0xbf,0x48,0xdc,0xe4,0x90,0x88,0x01,0xf0,0x12,0x04,0xb0,
+	0x12,0x03,0x50,0x12,0x08,0xfb,0x90,0x88,0x00,0xe0,0x44,0x08,0xf0,0x12,0x08,0x0e,
+	0x90,0x88,0x00,0xe0,0x44,0x80,0xf0,0x90,0x88,0x00,0x74,0x88,0xf0,0x90,0x41,0xef,
+	0x74,0x0f,0xf0,0x90,0x41,0xee,0xe0,0x44,0x02,0xf0,0xe0,0xff,0x54,0x01,0xf4,0x54,
+	0x01,0xfe,0xef,0x54,0xfe,0x4e,0xf0,0xe0,0xff,0x54,0x01,0xf4,0x54,0x01,0xfe,0xef,
+	0x54,0xfe,0x4e,0xf0,0xe0,0x54,0xfd,0xf0,0x90,0x42,0x07,0x74,0x0f,0xf0,0x90,0x42,
+	0x06,0xe0,0x44,0x02,0xf0,0xe0,0x54,0xfe,0xf0,0x70,0xfe,0x60,0xfc,0x60,0x40,0x70,
+	0x3e,0x12,0x13,0xa8,0x12,0x13,0xc1,0x12,0x14,0x73,0xe4,0xff,0x12,0x14,0x36,0x12,
+	0x13,0x8d,0x12,0x14,0x4f,0xe4,0xfb,0xfd,0xfc,0xff,0xfe,0x12,0x10,0xb4,0xe4,0xfb,
+	0xfd,0xfc,0xff,0xfe,0x12,0x10,0x66,0xe4,0xfb,0xfd,0xfc,0xff,0xfe,0x12,0x11,0x35,
+	0xe4,0xff,0xfe,0x12,0x12,0x7f,0x12,0x13,0xc1,0x12,0x13,0xa8,0x12,0x14,0x73,0x22,
+	0xe4,0xf5,0x0b,0xf5,0x0c,0x90,0x42,0x5d,0xe0,0xf5,0x09,0x90,0x42,0x62,0xe0,0xf5,
+	0x0a,0x12,0x0d,0x9f,0xc2,0x0b,0x12,0x12,0xd7,0xe4,0x90,0x88,0x03,0xf0,0xf5,0x08,
+	0xe5,0x08,0x30,0xe0,0x03,0x02,0x04,0x93,0x74,0x0b,0x25,0x08,0x12,0x06,0xa8,0xe0,
+	0x70,0x03,0x02,0x04,0x93,0x90,0x42,0x0f,0x74,0x0f,0xf0,0x90,0x42,0x0e,0x12,0x06,
+	0x07,0xc2,0x08,0xad,0x08,0x90,0x88,0x03,0xe0,0x75,0xf0,0x41,0xa4,0x24,0xd2,0xf5,
+	0x82,0xe5,0xf0,0x34,0xa0,0xaf,0x82,0xf5,0x0b,0x8f,0x0c,0xf5,0x83,0xe0,0x54,0x7f,
+	0xf0,0xed,0x54,0x7f,0xff,0xe0,0x54,0x80,0x4f,0xf0,0xed,0xc3,0x13,0xfc,0x12,0x06,
+	0x67,0x74,0x02,0xf0,0xed,0xc3,0x94,0x10,0x50,0x1a,0x90,0x32,0x46,0xc0,0x83,0xc0,
+	0x82,0x74,0x01,0x7e,0x00,0xc8,0xed,0xc8,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,
+	0xd8,0xf9,0x80,0x1c,0x90,0x32,0x44,0xc0,0x83,0xc0,0x82,0xed,0x24,0xf0,0xff,0x74,
+	0x01,0x7e,0x00,0xc8,0xef,0xc8,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,
+	0xff,0xe0,0x4e,0xfe,0xa3,0xe0,0x4f,0xff,0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,0xef,
+	0xf0,0xcf,0xec,0xcf,0x7d,0x01,0x12,0x0e,0xb8,0x12,0x06,0xf0,0xa3,0xee,0xf0,0xa3,
+	0xef,0xf0,0x12,0x06,0xf0,0xa3,0xa3,0xa3,0xe5,0x08,0x12,0x06,0xc4,0xee,0xf0,0xa3,
+	0xef,0xf0,0x90,0x32,0x44,0x12,0x01,0x92,0x00,0x00,0x00,0x00,0xc2,0x0b,0xe5,0x0c,
+	0x24,0x03,0xf5,0x12,0xe4,0x35,0x0b,0xf5,0x11,0x85,0x08,0x13,0x12,0x0b,0x68,0xaf,
+	0x0c,0xae,0x0b,0x12,0x0f,0xc1,0x12,0x06,0xf0,0x12,0x06,0x37,0xe5,0x08,0x25,0xe0,
+	0x24,0xf5,0xf5,0x82,0xe4,0x34,0xa4,0x12,0x06,0x2a,0x12,0x06,0xf0,0x12,0x06,0x37,
+	0xe5,0x08,0x25,0xe0,0x24,0xf7,0xf5,0x82,0xe4,0x34,0xa4,0x12,0x06,0x2a,0x30,0x08,
+	0x09,0x12,0x05,0xfe,0x90,0x88,0x03,0xe0,0x04,0xf0,0xe5,0x08,0xc3,0x13,0x12,0x06,
+	0x67,0xe4,0xf0,0x05,0x08,0xe5,0x08,0xc3,0x94,0x1d,0x50,0x03,0x02,0x03,0x70,0x90,
+	0x42,0x5d,0xe5,0x09,0xf0,0x90,0x42,0x62,0xe5,0x0a,0x12,0x06,0x7a,0x02,0x12,0xab,
+	0xe4,0xf5,0x0f,0xf5,0x10,0x90,0x42,0x5d,0xe0,0xf5,0x0a,0x90,0x42,0x62,0xe0,0xf5,
+	0x0b,0x12,0x0d,0x9f,0xc2,0x0b,0x12,0x12,0xd7,0xe4,0x90,0x88,0x02,0xf0,0xf5,0x08,
+	0x12,0x06,0xff,0x12,0x06,0x43,0xe0,0x70,0x03,0x02,0x05,0xd6,0xc2,0x08,0x12,0x06,
+	0xff,0xff,0x12,0x06,0x58,0x74,0x02,0xf0,0x8f,0x0c,0x90,0x88,0x02,0xe0,0x75,0xf0,
+	0x95,0xa4,0x24,0x60,0xf5,0x82,0xe5,0xf0,0x34,0x88,0xaf,0x82,0xf5,0x0f,0x8f,0x10,
+	0xf5,0x83,0xe0,0x44,0x80,0xf0,0xe5,0x0c,0x54,0x7f,0xff,0xe0,0x54,0x80,0x4f,0xf0,
+	0xaf,0x0c,0x12,0x05,0xef,0x12,0x07,0x06,0xa3,0xe5,0x0d,0xf0,0xa3,0xe5,0x0e,0xf0,
+	0x12,0x07,0x06,0xe5,0x08,0x12,0x06,0x21,0xe5,0x0d,0xf0,0xe5,0x0e,0x12,0x06,0x82,
+	0xf5,0x09,0xe5,0x08,0x24,0x01,0xff,0xe4,0x33,0xfe,0xc3,0xe5,0x09,0x9f,0xee,0x64,
+	0x80,0xf8,0x74,0x80,0x98,0x50,0x0b,0x12,0x06,0x19,0xe4,0xf0,0xa3,0xf0,0x05,0x09,
+	0x80,0xe0,0xe5,0x08,0x04,0xf5,0x09,0xe5,0x09,0xc3,0x94,0x2a,0x50,0x34,0xe5,0x09,
+	0x12,0x06,0x3e,0xe0,0x60,0x28,0x12,0x05,0xef,0x12,0x06,0x19,0xe5,0x0d,0xf0,0xa3,
+	0xe5,0x0e,0xf0,0xc3,0x90,0x88,0x05,0xe0,0x95,0x0e,0x90,0x88,0x04,0xe0,0x95,0x0d,
+	0x50,0x09,0xd2,0x08,0x90,0x88,0x01,0xe0,0x44,0x01,0xf0,0x12,0x06,0x84,0x05,0x09,
+	0x80,0xc5,0xd2,0x0b,0xe5,0x10,0x24,0x57,0xf5,0x12,0xe4,0x35,0x0f,0xf5,0x11,0x85,
+	0x08,0x13,0x12,0x0b,0x68,0xaf,0x10,0xae,0x0f,0x12,0x0f,0x6b,0x12,0x07,0x06,0x12,
+	0x06,0x37,0xe5,0x08,0x25,0xe0,0x24,0xa1,0xf5,0x82,0xe4,0x34,0xa4,0x12,0x06,0x2a,
+	0x30,0x08,0x09,0x12,0x05,0xfe,0x90,0x88,0x02,0xe0,0x04,0xf0,0x12,0x06,0xff,0x24,
+	0x00,0x12,0x06,0x69,0xe4,0xf0,0x05,0x08,0xe5,0x08,0xc3,0x94,0x2a,0x50,0x03,0x02,
+	0x04,0xd0,0xe5,0x0a,0x12,0x06,0xf7,0xe5,0x0b,0x12,0x06,0x7a,0x02,0x12,0xab,0x12,
+	0x0e,0x5d,0x8f,0x0c,0x7d,0x01,0x12,0x0e,0xb8,0x8e,0x0d,0x8f,0x0e,0x22,0x90,0x42,
+	0x0b,0x74,0x0f,0xf0,0x90,0x42,0x0a,0xe0,0x44,0x02,0xf0,0xe0,0xff,0x54,0x01,0xf4,
+	0x54,0x01,0xfe,0xef,0x54,0xfe,0x4e,0xf0,0x22,0x85,0x10,0x82,0x85,0x0f,0x83,0xe5,
+	0x09,0xa3,0xa3,0xa3,0x75,0xf0,0x02,0x02,0x01,0xc3,0xf5,0x83,0xee,0xf0,0xa3,0xef,
+	0xf0,0x22,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0x90,0x11,
+	0x85,0x93,0xff,0x24,0x29,0xf5,0x82,0xe4,0x34,0x80,0xf5,0x83,0x22,0x74,0x08,0x2c,
+	0xf5,0x82,0xe4,0x34,0x88,0xf5,0x83,0x22,0x24,0x00,0xfd,0xe4,0x34,0x32,0xfc,0xed,
+	0x64,0x03,0xf5,0x82,0x8c,0x83,0x22,0x24,0x2c,0xff,0xe4,0x34,0x32,0xfe,0xef,0x64,
+	0x03,0xf5,0x82,0x8e,0x83,0x22,0xe0,0x90,0x42,0x62,0xf0,0x90,0x42,0x7d,0x74,0x02,
+	0xf0,0x22,0xa3,0xf0,0x90,0x32,0x42,0xe4,0xf0,0xa3,0xf0,0x90,0x42,0x82,0xf0,0x22,
+	0xee,0xf0,0xa3,0xef,0xf0,0xee,0x54,0x7f,0xfe,0xc3,0x90,0x88,0x52,0xe0,0x9f,0x90,
+	0x88,0x51,0xe0,0x9e,0x22,0x74,0x0b,0x2f,0xf5,0x82,0xe4,0x34,0x80,0xf5,0x83,0x22,
+	0xf5,0x82,0xe4,0x35,0x83,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x22,0x85,0x12,0x82,0x85,
+	0x11,0x83,0xe5,0x14,0x75,0xf0,0x02,0x02,0x01,0xc3,0x74,0x32,0x2c,0xf5,0x82,0xe4,
+	0x34,0x88,0xf5,0x83,0x22,0xf8,0xeb,0x4f,0xff,0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,
+	0x4c,0xfc,0x22,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xe8,0x22,
+	0x85,0x0c,0x82,0x85,0x0b,0x83,0x22,0x90,0x42,0x5d,0xf0,0x90,0x42,0x62,0x22,0xe5,
+	0x08,0x90,0x11,0x85,0x93,0x22,0x85,0x10,0x82,0x85,0x0f,0x83,0x22,0x25,0xe0,0x24,
+	0x31,0xf5,0x82,0xe4,0x34,0xa5,0x22,0x25,0xe0,0x24,0x85,0xf5,0x82,0xe4,0x34,0xa5,
+	0x22,0x90,0x40,0x13,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0xfb,0xf0,0x90,0x30,0x10,0x74,
+	0x0f,0xf0,0x90,0x30,0xaa,0xe0,0x54,0xf0,0x44,0x07,0xf0,0x90,0x42,0x7d,0x74,0x02,
+	0xf0,0x90,0x42,0x82,0xe4,0xf0,0x90,0x32,0x42,0xf0,0xa3,0xf0,0xa3,0x12,0x01,0x92,
+	0x15,0x55,0x55,0x55,0x90,0x30,0x15,0x74,0x01,0xf0,0x90,0x30,0x13,0x74,0x07,0xf0,
+	0x90,0x30,0x0c,0x74,0x03,0xf0,0x90,0x42,0x5f,0x74,0x01,0xf0,0x90,0x30,0xab,0xe0,
+	0x44,0x40,0xf0,0x90,0x30,0x06,0x74,0x0f,0xf0,0x90,0x30,0x0b,0xe0,0x54,0xf0,0xf0,
+	0x90,0x30,0x1b,0x74,0x04,0xf0,0x90,0x30,0x11,0x74,0x1d,0x12,0x14,0x29,0x90,0x42,
+	0x56,0xe4,0xf0,0x90,0x42,0x5a,0xf0,0x90,0x42,0x62,0x74,0x04,0xf0,0x90,0x42,0x77,
+	0x74,0x2b,0xf0,0x90,0x30,0x1c,0xe4,0xf0,0x90,0x60,0x2f,0xe0,0x54,0xc7,0x44,0x08,
+	0xf0,0xe0,0x54,0xf8,0xf0,0x90,0x37,0x33,0xe0,0x54,0xdf,0xf0,0x90,0x42,0x5b,0xe4,
+	0xf0,0x90,0x42,0x60,0xf0,0xa3,0xf0,0x90,0x42,0x5e,0x04,0xf0,0x90,0x42,0x7a,0xf0,
+	0x90,0x42,0x79,0xf0,0x90,0x42,0x7f,0xe4,0xf0,0x90,0x42,0x7e,0x04,0xf0,0x90,0x42,
+	0x80,0xe0,0x54,0xdf,0xf0,0x90,0x37,0x33,0xe0,0x54,0xfb,0xf0,0xe0,0x44,0x01,0xf0,
+	0xe0,0x44,0x02,0xf0,0x7f,0xfa,0x12,0x13,0xd9,0x7f,0x08,0x12,0x0f,0x12,0x7f,0x0b,
+	0x12,0x0d,0xff,0x90,0x30,0x22,0xe4,0xf0,0x90,0x40,0x48,0x04,0xf0,0x22,0x90,0x42,
+	0x5d,0xe0,0x90,0x80,0x86,0xf0,0x90,0x42,0x62,0xe0,0x90,0x80,0x87,0xf0,0x12,0x0d,
+	0x9f,0xc2,0x0b,0x12,0x12,0xd7,0x12,0x06,0x7b,0xe4,0x90,0x80,0x84,0xf0,0x90,0x80,
+	0x84,0xe0,0xff,0xc3,0x94,0x1e,0x40,0x03,0x02,0x08,0xdf,0xef,0x12,0x07,0x17,0x12,
+	0x06,0xb5,0x12,0x06,0xa5,0xe0,0x70,0x03,0x02,0x08,0xd6,0x90,0x80,0x84,0xe0,0xa3,
+	0xf0,0x90,0x32,0x44,0xc0,0x83,0xc0,0x82,0x12,0x06,0xe3,0xc0,0xe0,0xe9,0xc0,0xe0,
+	0xe4,0x7f,0x01,0xfe,0xfd,0xfc,0x90,0x80,0x85,0xe0,0xf9,0xf8,0x12,0x01,0x73,0xd0,
+	0xe0,0xf9,0xd0,0xe0,0x12,0x06,0xd5,0xd0,0x82,0xd0,0x83,0x12,0x01,0x86,0x90,0x42,
+	0x81,0xe0,0x54,0x3f,0xf0,0x12,0x08,0xf0,0x90,0x80,0x88,0xee,0xf0,0xa3,0xef,0xf0,
+	0x90,0x32,0x44,0x12,0x01,0x92,0x00,0x00,0x00,0x00,0x12,0x08,0xf0,0x90,0x80,0x8a,
+	0xee,0xf0,0xfc,0xa3,0xef,0xf0,0x90,0x80,0x88,0x12,0x11,0xe8,0x90,0x80,0x8c,0x12,
+	0x06,0x90,0x50,0x09,0x90,0x88,0x01,0xe0,0x44,0x08,0xf0,0x80,0x07,0xe4,0x90,0x80,
+	0x8c,0xf0,0xa3,0xf0,0x90,0x80,0x8c,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x84,0xe0,
+	0x12,0x07,0x17,0x12,0x06,0x2a,0x90,0x80,0x84,0xe0,0x04,0xf0,0x02,0x08,0x2e,0x90,
+	0x80,0x86,0xe0,0x90,0x42,0x5d,0xf0,0x90,0x80,0x87,0x12,0x06,0x76,0x02,0x12,0xab,
+	0x90,0x80,0x85,0xe0,0xc3,0x13,0xff,0x12,0x0b,0xee,0x22,0x90,0x42,0x5d,0xe0,0x90,
+	0x80,0x86,0xf0,0x90,0x42,0x62,0xe0,0x90,0x80,0x87,0xf0,0x12,0x0d,0x9f,0xc2,0x0b,
+	0x12,0x12,0xd7,0x90,0x42,0x7d,0x74,0x01,0xf0,0xe4,0x90,0x80,0x84,0xf0,0x90,0x80,
+	0x84,0xe0,0xff,0xc3,0x94,0x2a,0x50,0x73,0xef,0x12,0x07,0x0d,0x12,0x06,0xb5,0xef,
+	0x12,0x06,0x3e,0xe0,0x60,0x5c,0x12,0x0e,0x5d,0x90,0x80,0x85,0xef,0xf0,0x90,0x42,
+	0x81,0xe0,0x54,0x3f,0xf0,0x12,0x0b,0xee,0x90,0x80,0x88,0xee,0xf0,0xef,0x12,0x06,
+	0x82,0x90,0x80,0x85,0xe0,0xff,0x12,0x0b,0xee,0x90,0x80,0x8a,0xee,0xf0,0xfc,0xa3,
+	0xef,0xf0,0x90,0x80,0x88,0x12,0x11,0xe8,0x90,0x80,0x8c,0x12,0x06,0x90,0x50,0x09,
+	0x90,0x88,0x01,0xe0,0x44,0x08,0xf0,0x80,0x07,0xe4,0x90,0x80,0x8c,0xf0,0xa3,0xf0,
+	0x90,0x80,0x8c,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x84,0xe0,0x12,0x07,0x0d,0x12,
+	0x06,0x2a,0x90,0x80,0x84,0xe0,0x04,0xf0,0x02,0x09,0x1e,0x90,0x80,0x86,0xe0,0x90,
+	0x42,0x5d,0xf0,0x90,0x80,0x87,0x12,0x06,0x76,0x02,0x12,0xab,0xc2,0xaf,0x12,0x14,
+	0x43,0x78,0xff,0xe4,0xf6,0xd8,0xfd,0x90,0x80,0x00,0x7f,0x00,0x7e,0x50,0xe4,0xf0,
+	0xa3,0xdf,0xfc,0xde,0xfa,0x75,0xa0,0xbe,0x75,0x89,0x00,0x75,0x81,0xff,0x02,0x0a,
+	0x0c,0x02,0x01,0xcf,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,0x03,0xf6,0x80,0x01,
+	0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x07,0x24,0x0c,0xc8,0xc3,
+	0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,0x04,0xf4,0x56,0x80,0x01,0x46,0xf6,
+	0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x13,0xef,0xe4,
+	0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x09,0x54,0x1f,0xfe,0xe4,
+	0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,0x40,0xb8,0xe4,0x93,
+	0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,
+	0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,0xe9,0xde,0xe7,0x80,
+	0xbe,0xe4,0xfe,0xfd,0xfc,0x12,0x06,0x4d,0xe0,0x2d,0xfd,0x0c,0xbc,0x2a,0xf6,0xe4,
+	0xfc,0x12,0x06,0xca,0xe0,0x2d,0xfd,0x0c,0xbc,0x1e,0xf6,0xed,0x70,0x02,0x7e,0x01,
+	0x90,0x88,0x50,0xe0,0x2d,0x60,0x02,0x7e,0x01,0xee,0x60,0x21,0xe4,0xfc,0x12,0x06,
+	0x4d,0xec,0xf0,0xd3,0x94,0x19,0x40,0x06,0x12,0x06,0x4d,0xe0,0x04,0xf0,0x0c,0xbc,
+	0x2a,0xec,0xe4,0xfc,0x12,0x06,0xca,0xec,0xf0,0x0c,0xbc,0x1e,0xf7,0x7c,0x2b,0x90,
+	0x80,0x29,0xe4,0xf0,0xa3,0xdc,0xfc,0x7c,0x1e,0x90,0x80,0x0b,0xe4,0xf0,0xa3,0xdc,
+	0xfc,0xe4,0xfc,0x12,0x06,0x4d,0xe0,0xff,0xc3,0x94,0x2b,0x50,0x09,0x74,0x29,0x2f,
+	0x12,0x06,0x45,0x74,0x01,0xf0,0x0c,0xbc,0x2a,0xe9,0xe4,0xfc,0x12,0x06,0xca,0xe0,
+	0xff,0xc3,0x94,0x1e,0x50,0x06,0x12,0x06,0xa5,0x74,0x01,0xf0,0x0c,0xbc,0x1e,0xec,
+	0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x80,0x54,0xee,0xf0,0xa3,0xef,0xf0,
+	0xa3,0xed,0xf0,0xa3,0xeb,0xf0,0x90,0x80,0x80,0x74,0x01,0xf0,0xa3,0x74,0x80,0xf0,
+	0xa3,0x74,0x58,0xf0,0x7f,0xfe,0x7e,0xbf,0x12,0x11,0xaf,0xef,0x60,0xf6,0x90,0x80,
+	0x56,0xe0,0x24,0xe3,0xff,0x90,0x80,0x83,0xf0,0x12,0x13,0x02,0x90,0x80,0x54,0xe0,
+	0xff,0x12,0x13,0x02,0x90,0x80,0x55,0xe0,0xff,0x12,0x13,0x02,0x90,0x80,0x57,0xe0,
+	0x80,0x1d,0x90,0x80,0x56,0xe0,0xff,0x14,0xf0,0xef,0x60,0x19,0x90,0x80,0x80,0xe0,
+	0xfb,0xa3,0xe4,0x75,0xf0,0x01,0x12,0x00,0x1c,0xa9,0xf0,0xfa,0x12,0x00,0x03,0xff,
+	0x12,0x13,0x02,0x80,0xdd,0x90,0x80,0x83,0xe0,0xf4,0xff,0x12,0x13,0x02,0x90,0xbf,
+	0xfe,0xe4,0xf0,0xd0,0xd0,0x92,0xaf,0x22,0xe4,0xf5,0x14,0x12,0x06,0xbc,0xe4,0xf0,
+	0xa3,0xf0,0x05,0x14,0xe5,0x14,0xb4,0x1e,0xf2,0xe4,0xf5,0x14,0x74,0x0b,0x25,0x14,
+	0x12,0x06,0xa8,0xe0,0x60,0x5e,0x20,0x0b,0x06,0xe5,0x13,0x65,0x14,0x60,0x55,0x20,
+	0x0b,0x0c,0xe5,0x14,0xc3,0x95,0x13,0x50,0x05,0xe5,0x14,0x30,0xe0,0x46,0xaf,0x14,
+	0x12,0x10,0xf5,0x7d,0x01,0x12,0x0e,0xb8,0x12,0x06,0xbc,0xee,0xf0,0xa3,0xef,0xf0,
+	0xc3,0x90,0x88,0x05,0xe0,0x9f,0x90,0x88,0x04,0xe0,0x9e,0x50,0x16,0xd2,0x08,0x90,
+	0x88,0x01,0xe0,0xff,0x30,0x0b,0x04,0x7e,0x04,0x80,0x02,0x7e,0x02,0xef,0x4e,0x90,
+	0x88,0x01,0xf0,0x90,0x42,0x7d,0xe0,0x54,0xfd,0xf0,0x90,0x32,0x44,0x12,0x01,0x92,
+	0x00,0x00,0x00,0x00,0x05,0x14,0xe5,0x14,0xc3,0x94,0x1e,0x40,0x8f,0x22,0xef,0x54,
+	0x0f,0xff,0x90,0x30,0x38,0xe0,0x54,0xf0,0x4f,0xf0,0xa3,0x74,0x01,0xf0,0x90,0x30,
+	0x18,0x74,0xc0,0xf0,0xa3,0xe4,0xf0,0x90,0x80,0x0a,0x04,0xf0,0x90,0x88,0x06,0xe0,
+	0xfe,0xa3,0xe0,0xff,0x12,0x13,0x2b,0x90,0x30,0x03,0xe4,0xf0,0x30,0xff,0xfd,0x90,
+	0x30,0x03,0x74,0x01,0xf0,0x7f,0x96,0x12,0x13,0xd9,0xe4,0xf5,0x1b,0xf5,0x1c,0xfd,
+	0x7c,0xc0,0x7b,0xc8,0xfa,0xeb,0x25,0xe0,0xff,0xea,0x33,0xfe,0xed,0x2f,0xf5,0x82,
+	0xec,0x3e,0xf5,0x83,0xe0,0xa2,0xe7,0x13,0xfe,0xa3,0xe0,0x13,0x25,0x1c,0xf5,0x1c,
+	0xee,0x35,0x1b,0xf5,0x1b,0x0b,0xbb,0x00,0x01,0x0a,0xba,0x01,0xd8,0xbb,0x08,0xd5,
+	0xe5,0x1c,0xae,0x1b,0x78,0x05,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xf5,0x1c,
+	0x8e,0x1b,0xff,0x22,0xcb,0xef,0xcb,0xca,0xee,0xca,0xe4,0xf5,0x0b,0xf5,0x0a,0xf5,
+	0x09,0xf5,0x08,0x8b,0x82,0x8a,0x83,0xe4,0x93,0xff,0x60,0x47,0xc3,0x94,0x30,0x40,
+	0x3b,0xef,0xd3,0x94,0x39,0x50,0x35,0xaf,0x0b,0xae,0x0a,0xad,0x09,0xac,0x08,0x78,
+	0x04,0x12,0x01,0x73,0x8f,0x0b,0x8e,0x0a,0x8d,0x09,0x8c,0x08,0xe4,0x93,0x24,0xd0,
+	0xff,0xe4,0x34,0xff,0xfe,0xe4,0xfc,0xfd,0xe5,0x0b,0x2f,0xf5,0x0b,0xe5,0x0a,0x3e,
+	0xf5,0x0a,0xed,0x35,0x09,0xf5,0x09,0xec,0x35,0x08,0xf5,0x08,0x0b,0xbb,0x00,0x01,
+	0x0a,0x80,0xb0,0xaf,0x0b,0xae,0x0a,0xad,0x09,0xac,0x08,0x22,0x7e,0x11,0x7f,0x73,
+	0x12,0x0c,0x74,0x90,0x80,0x02,0x12,0x01,0x86,0x7e,0x11,0x7f,0x7c,0x12,0x0c,0x74,
+	0x90,0x80,0x06,0x12,0x01,0x86,0x90,0x80,0x02,0x12,0x06,0x32,0x90,0x80,0x58,0x12,
+	0x01,0x86,0x90,0x80,0x06,0x12,0x06,0x32,0x90,0x80,0x5c,0x12,0x01,0x86,0x7b,0xfa,
+	0x7d,0x08,0x7f,0x01,0x7e,0x00,0x12,0x0a,0xe1,0x90,0x80,0x00,0xe0,0xfc,0xa3,0xe0,
+	0xfd,0xec,0xff,0x90,0x80,0x58,0xe4,0xf0,0xa3,0xef,0xf0,0xcf,0xed,0xcf,0xa3,0xe4,
+	0xf0,0xa3,0xef,0xf0,0x7b,0x5a,0x7d,0x04,0x7f,0x02,0x7e,0x00,0x02,0x0a,0xe1,0xae,
+	0x2d,0xaf,0x2e,0xe4,0xfc,0xfd,0x7b,0xfe,0x7a,0x04,0xf9,0xf8,0x12,0x00,0x32,0x7b,
+	0x00,0x7a,0xc2,0x79,0x01,0x78,0x00,0x12,0x00,0xbd,0x8f,0x0b,0x8e,0x0a,0x8d,0x09,
+	0x8c,0x08,0xe4,0x78,0x00,0xf2,0xe4,0xff,0x7e,0x01,0xfd,0xfc,0xab,0x0b,0xaa,0x0a,
+	0xa9,0x09,0xa8,0x08,0xc3,0x12,0x01,0x4f,0x40,0x1c,0xaf,0x0b,0xae,0x0a,0xad,0x09,
+	0xac,0x08,0x78,0x01,0x12,0x01,0x60,0x8f,0x0b,0x8e,0x0a,0x8d,0x09,0x8c,0x08,0x78,
+	0x00,0xe2,0x04,0xf2,0x80,0xd0,0x78,0x01,0xe5,0x0b,0xf2,0xe2,0x14,0xf2,0x22,0x90,
+	0x42,0x56,0xe4,0xf0,0x90,0x42,0x5a,0xf0,0x90,0x42,0x60,0xf0,0xa3,0xf0,0x74,0x03,
+	0x12,0x06,0xf7,0x04,0xf0,0x90,0x30,0x16,0xe4,0xf0,0xa3,0x74,0x75,0xf0,0x90,0x30,
+	0x09,0x74,0x06,0xf0,0x90,0x42,0x7d,0x74,0x01,0xf0,0x90,0x30,0x1f,0xe0,0x44,0x01,
+	0xf0,0x90,0x37,0x33,0xe0,0x44,0x04,0xf0,0x90,0x30,0x1e,0x74,0x05,0xf0,0x90,0x32,
+	0x42,0xe4,0xf0,0xa3,0xf0,0xa3,0x12,0x01,0x92,0x00,0x00,0x00,0x00,0x90,0x42,0x82,
+	0xe4,0xf0,0x90,0x42,0x5f,0x04,0xf0,0x90,0x42,0x81,0xe0,0x44,0x01,0xf0,0x22,0xef,
+	0xb4,0x0c,0x00,0x50,0x4b,0x90,0x0e,0x0c,0xf8,0x28,0x28,0x73,0x02,0x0e,0x30,0x02,
+	0x0e,0x30,0x02,0x0e,0x30,0x02,0x0e,0x30,0x02,0x0e,0x30,0x02,0x0e,0x30,0x02,0x0e,
+	0x30,0x02,0x0e,0x36,0x02,0x0e,0x3c,0x02,0x0e,0x42,0x02,0x0e,0x48,0x02,0x0e,0x4e,
+	0x7c,0x0f,0x7d,0xe0,0x80,0x1e,0x7c,0x07,0x7d,0xf0,0x80,0x18,0x7c,0x07,0x7d,0xf8,
+	0x80,0x12,0x7c,0x07,0x7d,0xfc,0x80,0x0c,0x7c,0x07,0x7d,0xfe,0x80,0x06,0x80,0x00,
+	0x7c,0x07,0x7d,0xff,0x90,0x37,0x26,0xec,0xf0,0xa3,0xed,0xf0,0x22,0xcd,0xef,0xcd,
+	0xed,0xd3,0x94,0x0e,0x50,0x2d,0x90,0x32,0x42,0xc0,0x83,0xc0,0x82,0x74,0x01,0x7e,
+	0x00,0xc8,0xed,0xc8,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe0,
+	0x4e,0xfe,0xa3,0xe0,0x4f,0xff,0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,0xef,0xf0,0xcf,
+	0xed,0xcf,0x22,0xed,0xd3,0x94,0x1c,0x50,0x0b,0x90,0x42,0x82,0x74,0x02,0xf0,0xed,
+	0x24,0xf2,0xff,0x22,0xed,0xd3,0x94,0x2a,0x50,0x0b,0x90,0x42,0x82,0x74,0x01,0xf0,
+	0xed,0x24,0xe3,0xff,0x22,0x7f,0xff,0x22,0x8f,0x15,0x8d,0x16,0xe4,0xf5,0x17,0xf5,
+	0x18,0xf5,0x19,0xf5,0x1a,0x12,0x0b,0xee,0x8e,0x17,0x8f,0x18,0xe5,0x16,0x60,0x0f,
+	0x90,0x30,0x1e,0x74,0x86,0xf0,0xaf,0x15,0x12,0x0b,0xee,0x8e,0x19,0x8f,0x1a,0xd3,
+	0xe5,0x18,0x95,0x1a,0xe5,0x19,0x64,0x80,0xf8,0xe5,0x17,0x64,0x80,0x98,0x40,0x0c,
+	0xe5,0x18,0x95,0x1a,0xff,0xe5,0x17,0x95,0x19,0xfe,0x80,0x0b,0xc3,0xe5,0x1a,0x95,
+	0x18,0xff,0xe5,0x19,0x95,0x17,0xfe,0x8e,0x17,0x8f,0x18,0x90,0x30,0x1e,0x74,0x05,
+	0xf0,0x22,0xef,0xb4,0x09,0x00,0x50,0x46,0x90,0x0f,0x1f,0xf8,0x28,0x28,0x73,0x02,
+	0x0f,0x3a,0x02,0x0f,0x3a,0x02,0x0f,0x3a,0x02,0x0f,0x3a,0x02,0x0f,0x40,0x02,0x0f,
+	0x46,0x02,0x0f,0x4c,0x02,0x0f,0x52,0x02,0x0f,0x58,0x7c,0x00,0x7d,0xe0,0x80,0x22,
+	0x7c,0x00,0x7d,0xf0,0x80,0x1c,0x7c,0x00,0x7d,0xf8,0x80,0x16,0x7c,0x00,0x7d,0xfc,
+	0x80,0x10,0x7c,0x00,0x7d,0xfe,0x80,0x0a,0x7c,0x00,0x7d,0xff,0x80,0x04,0x7c,0x0f,
+	0x7d,0xff,0x90,0x37,0x24,0xec,0xf0,0xa3,0xed,0xf0,0x22,0x8e,0x11,0x8f,0x12,0xe4,
+	0xf5,0x13,0xf5,0x14,0xca,0xee,0xca,0xc9,0xef,0xc9,0x75,0x15,0x01,0x8a,0x16,0x89,
+	0x17,0x8f,0x82,0x8e,0x83,0xe5,0x82,0x24,0x93,0x12,0x06,0xb0,0xff,0xab,0x15,0x05,
+	0x17,0xe5,0x17,0xaa,0x16,0x70,0x02,0x05,0x16,0x14,0xf9,0x12,0x00,0x03,0x25,0x14,
+	0xf5,0x14,0xe4,0x35,0x13,0xf5,0x13,0x0f,0xbf,0x95,0xe2,0xc3,0xe4,0x95,0x14,0xff,
+	0xe4,0x95,0x13,0xfe,0xe5,0x12,0x24,0x93,0xf5,0x82,0xe4,0x35,0x11,0x12,0x06,0x2a,
+	0x22,0x8e,0x0d,0x8f,0x0e,0xe4,0xf5,0x0f,0xf5,0x10,0xca,0xee,0xca,0xc9,0xef,0xc9,
+	0x75,0x11,0x01,0x8a,0x12,0x89,0x13,0x8f,0x82,0x8e,0x83,0xe5,0x82,0x24,0x3f,0x12,
+	0x06,0xb0,0xff,0xab,0x11,0x05,0x13,0xe5,0x13,0xaa,0x12,0x70,0x02,0x05,0x12,0x14,
+	0xf9,0x12,0x00,0x03,0x25,0x10,0xf5,0x10,0xe4,0x35,0x0f,0xf5,0x0f,0x0f,0xbf,0x41,
+	0xe2,0xc3,0xe4,0x95,0x10,0xff,0xe4,0x95,0x0f,0xfe,0xe5,0x0e,0x24,0x3f,0xf5,0x82,
+	0xe4,0x35,0x0d,0x12,0x06,0x2a,0x22,0x90,0x60,0x01,0xe4,0xf0,0x90,0x60,0x00,0xf0,
+	0x90,0x60,0x03,0xef,0xf0,0x90,0x60,0x02,0xed,0xf0,0x90,0x60,0x07,0x74,0x02,0xf0,
+	0x90,0x60,0x06,0x14,0xf0,0x90,0x60,0x12,0x74,0xbd,0xf0,0xa3,0x74,0xc0,0xf0,0x90,
+	0x60,0x22,0x74,0xbd,0xf0,0xa3,0x74,0xa0,0xf0,0x90,0x60,0x10,0xe4,0xf0,0xa3,0xf0,
+	0x90,0x60,0x20,0xf0,0xa3,0xf0,0x90,0xbf,0xfd,0xf0,0xf5,0x30,0x90,0x60,0x01,0x04,
+	0xf0,0x90,0x60,0x00,0xf0,0x22,0x8e,0x08,0x8f,0x09,0x8c,0x0a,0x8d,0x0b,0xd2,0xb5,
+	0xc2,0xb2,0xc2,0xb1,0x7f,0x3b,0x12,0x14,0x36,0xe4,0xff,0x12,0x14,0x36,0xaf,0x08,
+	0x12,0x14,0x36,0xaf,0x09,0x12,0x14,0x36,0x7f,0x08,0xd2,0xb0,0xc2,0xb0,0xdf,0xfa,
+	0xc2,0xb5,0x85,0x0b,0x82,0x85,0x0a,0x83,0x7e,0x80,0x7f,0x04,0xd2,0xb0,0xa2,0xb4,
+	0x33,0xa2,0xb7,0x33,0xc2,0xb0,0xdf,0xf4,0x12,0x14,0x73,0xde,0xed,0xdb,0xe9,0xc2,
+	0xb0,0xd2,0xb1,0x22,0x8e,0x08,0x8f,0x09,0x8c,0x0a,0x8d,0x0b,0xd2,0xb5,0xc2,0xb2,
+	0xc2,0xb1,0x7f,0x03,0x12,0x14,0x36,0xe4,0xff,0x12,0x14,0x36,0xaf,0x08,0x12,0x14,
+	0x36,0xaf,0x09,0x12,0x14,0x36,0x85,0x0b,0x82,0x85,0x0a,0x83,0x7f,0x80,0x7e,0x08,
+	0xd2,0xb0,0xa2,0xb4,0x33,0xc2,0xb0,0xde,0xf7,0x12,0x14,0x73,0xdf,0xf0,0xdb,0xec,
+	0xc2,0xb0,0xd2,0xb1,0x22,0x8f,0x15,0xe5,0x15,0x30,0xe0,0x07,0x90,0x42,0x7d,0xe0,
+	0x44,0x02,0xf0,0x90,0x32,0x44,0xc0,0x83,0xc0,0x82,0x12,0x06,0xe3,0xc0,0xe0,0xe9,
+	0xc0,0xe0,0xe4,0x7f,0x01,0xfe,0xfd,0xfc,0xa9,0x15,0xc8,0xe9,0xc8,0x12,0x01,0x73,
+	0xd0,0xe0,0xf9,0xd0,0xe0,0x12,0x06,0xd5,0xd0,0x82,0xd0,0x83,0x12,0x01,0x86,0xe5,
+	0x15,0xc3,0x13,0xff,0x22,0x8e,0x08,0x8f,0x09,0x8c,0x0a,0x8d,0x0b,0xd2,0xb5,0xc2,
+	0xb2,0x12,0x14,0x4f,0xc2,0xb1,0x7f,0x02,0x12,0x14,0x36,0xe4,0xff,0x12,0x14,0x36,
+	0xaf,0x0a,0x12,0x14,0x36,0xaf,0x0b,0x12,0x14,0x36,0x85,0x09,0x82,0x85,0x08,0x83,
+	0xe0,0xa3,0xff,0x12,0x14,0x36,0xdb,0xf8,0xc2,0xb0,0xd2,0xb1,0x12,0x13,0x8d,0x12,
+	0x14,0x5b,0x22,0x30,0x37,0x2f,0x31,0x39,0x2f,0x31,0x33,0x00,0x31,0x38,0x3a,0x30,
+	0x38,0x3a,0x34,0x36,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,
+	0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1b,
+	0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0xd3,
+	0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x8e,0x1d,0x8f,0x1e,0x12,0x13,0x6e,0xef,0x60,0xfa,
+	0x85,0x1e,0x82,0x85,0x1d,0x83,0xe0,0x70,0x03,0xd3,0x80,0x01,0xc3,0x92,0x0a,0x30,
+	0x0a,0x09,0x85,0x1e,0x82,0x85,0x1d,0x83,0x74,0x01,0xf0,0x12,0x14,0x6d,0xa2,0x0a,
+	0xe4,0x33,0xff,0xd0,0xd0,0x92,0xaf,0x22,0xfd,0xe0,0xfe,0xa3,0xe0,0xff,0xd3,0xef,
+	0x9d,0xec,0x64,0x80,0xf8,0xee,0x64,0x80,0x98,0x40,0x08,0xef,0x9d,0xfb,0xee,0x9c,
+	0xfa,0x80,0x07,0xc3,0xed,0x9f,0xfb,0xec,0x9e,0xfa,0xd3,0xef,0x94,0x00,0xee,0x64,
+	0x80,0x94,0x80,0x40,0x04,0xca,0x44,0x80,0xca,0xcf,0xeb,0xcf,0xce,0xea,0xce,0x22,
+	0xce,0xed,0xce,0xef,0x14,0x60,0x09,0x04,0x70,0x26,0x90,0x40,0x33,0xe4,0xf0,0x22,
+	0x90,0x42,0x53,0xe0,0x54,0xdf,0xf0,0x90,0x42,0x6c,0xe4,0xf0,0x90,0x42,0x69,0xf0,
+	0xa3,0x12,0x14,0x29,0xcf,0xee,0xcf,0x12,0x12,0x51,0x90,0x40,0x33,0x74,0x01,0xf0,
+	0x22,0xcd,0xef,0xcd,0xed,0x54,0x03,0x75,0xf0,0x10,0xa4,0xff,0x90,0x42,0x80,0xe0,
+	0xfa,0xa3,0xe0,0x54,0xcf,0xfb,0xea,0x45,0xf0,0xfe,0xeb,0x4f,0xff,0x90,0x42,0x80,
+	0xee,0xf0,0xa3,0xef,0xf0,0xed,0x13,0x13,0x54,0x3f,0x90,0x42,0x6b,0xf0,0x22,0x8e,
+	0x08,0x8f,0x09,0xd2,0xb5,0xc2,0xb2,0x12,0x14,0x4f,0xc2,0xb1,0x7f,0x20,0x12,0x14,
+	0x36,0xe4,0xff,0x12,0x14,0x36,0xaf,0x08,0x12,0x14,0x36,0xaf,0x09,0x12,0x14,0x36,
+	0xc2,0xb0,0xd2,0xb1,0x12,0x13,0x8d,0x12,0x14,0x5b,0x22,0x90,0x30,0x1f,0xe0,0x54,
+	0xfe,0xf0,0x90,0x37,0x33,0xe0,0x54,0xfb,0xf0,0x90,0x30,0x39,0xe4,0xf0,0x90,0x30,
+	0x05,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0xfb,0xf0,0x90,0x42,0x5f,0x74,0x03,0xf0,0x90,
+	0x42,0x81,0xe0,0x54,0xfe,0xf0,0x22,0xe4,0xff,0xa2,0x0b,0xe4,0x33,0xfe,0xef,0xc3,
+	0x13,0x24,0x2c,0x12,0x06,0x5a,0xee,0xf0,0x0f,0xbf,0x1e,0xed,0xe4,0xff,0xa2,0x0b,
+	0xe4,0x33,0xfe,0xef,0x90,0x11,0x85,0x93,0x12,0x06,0x58,0xee,0xf0,0x0f,0xbf,0x2a,
+	0xed,0x22,0x90,0x60,0x15,0xe0,0xc3,0x94,0x40,0x50,0xf7,0x90,0xbf,0xfd,0xe0,0x24,
+	0xc0,0xf5,0x82,0xe4,0x34,0xbd,0xf5,0x83,0xef,0xf0,0x90,0xbf,0xfd,0xe0,0x04,0xf0,
+	0xe0,0x54,0x3f,0xf0,0x90,0x60,0x1b,0x74,0x01,0xf0,0x22,0xcd,0xef,0xcd,0xcc,0xee,
+	0xcc,0xd3,0xed,0x94,0xfa,0xec,0x94,0x00,0x40,0x0f,0x7f,0xfa,0x12,0x13,0xd9,0x74,
+	0x06,0x2d,0xfd,0x74,0xff,0x3c,0xfc,0x80,0xe8,0xcf,0xed,0xcf,0x02,0x13,0xd9,0xd3,
+	0x10,0xaf,0x01,0xc3,0x90,0x40,0xa4,0xe0,0xf5,0x33,0x85,0xdd,0x34,0x85,0xde,0x35,
+	0x85,0xdf,0x36,0x92,0xaf,0xaf,0x36,0xae,0x35,0xad,0x34,0xac,0x33,0x22,0xd3,0x10,
+	0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x40,0xdf,0x74,0x0d,0xf0,0x90,0x40,0xfd,0xe0,0xb4,
+	0x0d,0x04,0x7f,0x01,0x80,0x02,0x7f,0x00,0xd0,0xd0,0x92,0xaf,0x22,0xc2,0xb1,0x7f,
+	0x05,0x12,0x14,0x36,0x7f,0x07,0xd2,0xb0,0xc2,0xb0,0xdf,0xfa,0xd2,0xb0,0xa2,0xb4,
+	0x92,0x0b,0xc2,0xb0,0x20,0x0b,0xe6,0x22,0xd2,0xb5,0xc2,0xb2,0x12,0x14,0x4f,0xc2,
+	0xb1,0x7f,0x60,0x12,0x14,0x36,0xc2,0xb0,0xd2,0xb1,0x12,0x13,0x8d,0x12,0x14,0x5b,
+	0x22,0xc2,0xb1,0x7f,0x05,0x12,0x14,0x36,0x7f,0x08,0xd2,0xb0,0xa2,0xb4,0x33,0xc2,
+	0xb0,0xdf,0xf7,0xc2,0xb0,0xd2,0xb1,0xff,0x22,0x90,0x40,0xa7,0xe0,0xfe,0x90,0x40,
+	0xa7,0xe0,0xc3,0x9e,0xc3,0x9f,0x40,0x03,0xd3,0x80,0x01,0xc3,0x50,0xf0,0x22,0x02,
+	0x2d,0xbb,0x80,0x01,0x20,0x00,0x4a,0x80,0x00,0x42,0x30,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0xd3,0x10,0xaf,0x01,0xc3,0x90,0x40,0xa6,0xe0,0xf5,0x37,0x85,
+	0xdf,0x38,0x92,0xaf,0xae,0x37,0xaf,0x38,0x22,0x78,0x00,0xe2,0xff,0x08,0xe2,0xfd,
+	0x12,0x10,0x17,0xe4,0xf5,0x22,0xf5,0x2f,0x22,0xf0,0x90,0x42,0x53,0xe0,0x54,0xfe,
+	0xf0,0xe0,0x54,0xfd,0xf0,0x22,0xef,0x7f,0x08,0x33,0x92,0xb6,0xd2,0xb0,0xc2,0xb0,
+	0xdf,0xf7,0x22,0x90,0x40,0x4b,0x74,0x03,0xf0,0x90,0x40,0x4a,0xe4,0xf0,0x22,0xc2,
+	0xb1,0x7f,0x06,0x12,0x14,0x36,0xc2,0xb0,0xd2,0xb1,0x22,0xc2,0xb1,0x7f,0x04,0x12,
+	0x14,0x36,0xc2,0xb0,0xd2,0xb1,0x22,0x90,0x40,0xe3,0xef,0xf0,0x22,0x90,0x40,0xdf,
+	0xe4,0xf0,0x22,0xf0,0xa3,0x22,
+};
+
+#define MIN_DRIVER_NUM            10
+#define MAX_DRIVER_NUM            42
+#define MIN_SENSOR_NUM            5
+#define MAX_SENSOR_NUM            30
+
+unsigned short gt900_short_threshold = 10;
+unsigned short gt900_resistor_threshold = 800;  // 1000;
+unsigned short gt900_resistor_warn_threshold = 500;
+unsigned short gt900_gnd_resistor_threshold = 400; 
+
+//QFN88 package TX Pin, used for get channel number from Chip to Pad
+const u8 ChannelPackage_TX[MAX_DRIVER_NUM] =  { 
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,
+    20,21,22,23,24,25,/*26,*/27,28,29,30,31,32,33,34,35,36,37,
+    38,39,40,41,42
+};	
+
+#define GT9_DRV_HEAD    0x80
+#define GT9_SEN_HEAD    0x00
+
+
+// register defines for burning of dsp_short
+#define _bRW_MISCTL__SRAM_BANK          0x4048 
+#define _bRW_MISCTL__MEM_CD_EN          0x4049
+#define _bRW_MISCTL__CACHE_EN           0x404b
+#define _bRW_MISCTL__TMR0_EN            0x40b0
+#define _rRW_MISCTL__SWRST_B0_          0x4180
+#define _bWO_MISCTL__CPU_SWRST_PULSE    0x4184
+#define _rRW_MISCTL__BOOTCTL_B0_        0x4190
+#define _rRW_MISCTL__BOOT_OPT_B0_       0x4218
+#define _bRW_MISCTL__RG_OSC_CALIB       0x4268
+#define _rRW_MISCTL__BOOT_CTL_          0x5094  
+#define _rRW_MISCTL__SHORT_BOOT_FLAG    0x5095
+
+
+#define GTP_REG_DSP_SHORT               0xc000
+
+#define GT9_REG_SEN_DRV_CNT             0x8062
+#define GT9_REG_CFG_BEG                 0x8047
+#define GT9_REG_KEY_VAL                 0x8093
+
+#define GT9_REG_SEN_ORD     0x80B7
+#define GT9_REG_DRV_ORD     0x80D5
+
+
+struct gt9xx_short_info
+{
+    u8 master;
+    u8 master_is_driver;          
+    u8 slave;
+    u8 slave_is_driver;           
+    u16 short_code;
+    u16 self_data;
+    u16 impedance;
+};
+
+#define MYBIG_ENDIAN                1
+#define MYLITLE_ENDIAN              0
+
+#define	_BEYOND_MAX_LIMIT           0x0001
+#define _BEYOND_MIN_LIMIT           0x0002
+#define _BEYOND_KEY_MAX_LMT         0x0004
+#define _BEYOND_KEY_MIN_LMT         0x0008
+#define _BEYOND_UNIFORMITY_LMT      0x0010 
+
+#define	_MAX_TEST                   0x0001
+#define _MIN_TEST                   0x0002
+#define _KEY_MAX_TEST               0x0004
+#define _KEY_MIN_TEST               0x0008
+#define _UNIFORMITY_TEST            0x0010
+
+#define _CHANNEL_PASS               0x0000
+
+#define GTP_WAIT_RAW_MAX_TIMES      200
+#define GTP_REG_RAW_DATA            0x8b98
+#define GTP_REG_READ_RAW            0x8040
+#define GTP_REG_RAW_READY           0x814E
+#define GTP_REG_RAW_DATA_GT9F       0x87C0
+
+struct gt9xx_open_info
+{
+    u8 driver;
+    u8 sensor;
+    u16 raw_val; 
+    s32 beyond_type;	// limit type
+    u8 times; 	// test fail times
+    u8 key;		// 0: nonekey, others: key_no(1-4)
+};
+
+
+#endif 
+
diff --git a/drivers/input/touchscreen/gt915/gt9xx_update.c b/drivers/input/touchscreen/gt915/gt9xx_update.c
new file mode 100755
index 0000000..8318f19
--- /dev/null
+++ b/drivers/input/touchscreen/gt915/gt9xx_update.c
@@ -0,0 +1,3684 @@
+/* drivers/input/touchscreen/gt9xx_update.c
+ * 
+ * 2010 - 2012 Goodix Technology.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be a reference 
+ * to you, when you are integrating the GOODiX's CTP IC into your system, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * General Public License for more details.
+ * 
+ * Latest Version: 2.2
+ * Author: andrew@goodix.com
+ * Revision Record: 
+ *      V1.0:
+ *          first release. By Andrew, 2012/08/31
+ *      V1.2:
+ *          add force update,GT9110P pid map. By Andrew, 2012/10/15
+ *      V1.4:
+ *          1. add config auto update function;
+ *          2. modify enter_update_mode;
+ *          3. add update file cal checksum.
+ *                          By Andrew, 2012/12/12
+ *      V1.6: 
+ *          1. replace guitar_client with i2c_connect_client;
+ *          2. support firmware header array update.
+ *                          By Meta, 2013/03/11
+ *      V2.2:
+ *          1. multi-system supported
+ *          2. flashless update no pid vid compare
+ *                          By Meta, 2014/01/14
+ */
+#include <linux/kthread.h>
+#include "gt9xx.h"
+
+#include <linux/namei.h>
+#include <linux/mount.h>
+#if ((GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE) || GTP_COMPATIBLE_MODE)
+    #include "gt9xx_firmware-1030.h"
+#endif
+#define GT915_FORCE_UPDATE			0
+
+#define GUP_REG_HW_INFO             0x4220
+#define GUP_REG_FW_MSG              0x41E4
+#define GUP_REG_PID_VID             0x8140
+
+#define GUP_SEARCH_FILE_TIMES       50
+
+#define UPDATE_FILE_PATH_1          "/system/etc/firmware/_goodix_update_.bin"
+#define UPDATE_FILE_PATH_2          "/sdcard/_goodix_update_.bin"
+
+#define CONFIG_FILE_PATH_1          "/system/etc/firmware/_goodix_config_.cfg"     
+#define CONFIG_FILE_PATH_2          "/sdcard/_goodix_config_.cfg"   
+
+#define FW_HEAD_LENGTH               14
+#define FW_SECTION_LENGTH            0x2000         // 8K
+#define FW_DSP_ISP_LENGTH            0x1000         // 4K
+#define FW_DSP_LENGTH                0x1000         // 4K
+#define FW_BOOT_LENGTH               0x800          // 2K
+#define FW_SS51_LENGTH               (4 * FW_SECTION_LENGTH)    // 32K
+#define FW_BOOT_ISP_LENGTH           0x800                     // 2k
+#define FW_GLINK_LENGTH              0x3000                    // 12k
+#define FW_GWAKE_LENGTH              (4 * FW_SECTION_LENGTH)   // 32k
+
+#define PACK_SIZE                    256
+#define MAX_FRAME_CHECK_TIME         5
+
+
+#define _bRW_MISCTL__SRAM_BANK       0x4048
+#define _bRW_MISCTL__MEM_CD_EN       0x4049
+#define _bRW_MISCTL__CACHE_EN        0x404B
+#define _bRW_MISCTL__TMR0_EN         0x40B0
+#define _rRW_MISCTL__SWRST_B0_       0x4180
+#define _bWO_MISCTL__CPU_SWRST_PULSE 0x4184
+#define _rRW_MISCTL__BOOTCTL_B0_     0x4190
+#define _rRW_MISCTL__BOOT_OPT_B0_    0x4218
+#define _rRW_MISCTL__BOOT_CTL_       0x5094
+
+#define AUTO_SEARCH_BIN           0x01
+#define AUTO_SEARCH_CFG           0x02
+#define BIN_FILE_READY            0x80
+#define CFG_FILE_READY            0x08
+#define HEADER_FW_READY           0x00
+
+#pragma pack(1)
+typedef struct 
+{
+    u8  hw_info[4];          //hardware info//
+    u8  pid[8];              //product id   //
+    u16 vid;                 //version id   //
+    u8  cfg;                 //Added by luochangyang, 2014/02/25
+}st_fw_head;
+#pragma pack()
+
+typedef struct
+{
+    u8 force_update;
+    u8 fw_flag;
+    struct file *file; 
+    struct file *cfg_file;
+    st_fw_head  ic_fw_msg;
+    st_fw_head  dr_fw_msg;	//Added by luochangyang, 2014/01/24
+    mm_segment_t old_fs;
+    u32 fw_total_len;
+    u32 fw_burned_len;
+}st_update_msg;
+
+st_update_msg update_msg;
+u16 show_len;
+u16 total_len;
+u8 got_file_flag = 0;  
+u8 searching_file = 0;
+
+extern u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH];
+extern void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+extern s32  gtp_send_cfg(struct i2c_client *client);
+extern s32 gtp_read_version(struct i2c_client *, u16* );
+extern struct i2c_client * i2c_connect_client;
+extern void gtp_irq_enable(struct goodix_ts_data *ts);
+extern void gtp_irq_disable(struct goodix_ts_data *ts);
+extern s32 gtp_i2c_read_dbl_check(struct i2c_client *, u16, u8 *, int);
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u32 len, u8 bank_cmd );
+
+#define _CLOSE_FILE(p_file) if (p_file && !IS_ERR(p_file)) \
+                            { \
+                                filp_close(p_file, NULL); \
+                            }
+
+#if GTP_ESD_PROTECT
+extern void gtp_esd_switch(struct i2c_client *, s32);
+#endif
+
+#if GTP_COMPATIBLE_MODE
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
+#endif
+/*******************************************************
+Function:
+    Read data from the i2c slave device.
+Input:
+    client:     i2c device.
+    buf[0~1]:   read start address.
+    buf[2~len-1]:   read data buffer.
+    len:    GTP_ADDR_LENGTH + read bytes count
+Output:
+    numbers of i2c_msgs to transfer: 
+      2: succeed, otherwise: failed
+*********************************************************/
+s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
+{
+    struct i2c_msg msgs[2];
+    s32 ret=-1;
+    s32 retries = 0;
+
+    GTP_DEBUG_FUNC();
+
+    msgs[0].flags = !I2C_M_RD;
+    msgs[0].addr  = client->addr;
+    msgs[0].len   = GTP_ADDR_LENGTH;
+    msgs[0].buf   = &buf[0];
+    //msgs[0].scl_rate = 300 * 1000;    // for Rockchip, etc
+    
+    msgs[1].flags = I2C_M_RD;
+    msgs[1].addr  = client->addr;
+    msgs[1].len   = len - GTP_ADDR_LENGTH;
+    msgs[1].buf   = &buf[GTP_ADDR_LENGTH];
+    //msgs[1].scl_rate = 300 * 1000;        // for Rockchip, etc.
+
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, msgs, 2);
+        if(ret == 2)break;
+        retries++;
+    }
+
+    return ret;
+}
+
+/*******************************************************
+Function:
+    Write data to the i2c slave device.
+Input:
+    client:     i2c device.
+    buf[0~1]:   write start address.
+    buf[2~len-1]:   data buffer
+    len:    GTP_ADDR_LENGTH + write bytes count
+Output:
+    numbers of i2c_msgs to transfer: 
+        1: succeed, otherwise: failed
+*********************************************************/
+s32 gup_i2c_write(struct i2c_client *client,u8 *buf,s32 len)
+{
+    struct i2c_msg msg;
+    s32 ret=-1;
+    s32 retries = 0;
+
+    GTP_DEBUG_FUNC();
+
+    msg.flags = !I2C_M_RD;
+    msg.addr  = client->addr;
+    msg.len   = len;
+    msg.buf   = buf;
+    //msg.scl_rate = 300 * 1000;    // for Rockchip, etc
+    
+    while(retries < 5)
+    {
+        ret = i2c_transfer(client->adapter, &msg, 1);
+        if (ret == 1)break;
+        retries++;
+    }
+
+    return ret;
+}
+
+static s32 gup_init_panel(struct goodix_ts_data *ts)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    u8 check_sum = 0;
+    u8 opr_buf[16];
+    u8 sensor_id = 0;
+    u16 version = 0;
+
+    u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+    u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+    u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+    u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+    u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+    u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+    u8 *send_cfg_buf[] = {cfg_info_group1, cfg_info_group2, cfg_info_group3,
+                        cfg_info_group4, cfg_info_group5, cfg_info_group6};
+    u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1),
+                          CFG_GROUP_LEN(cfg_info_group2),
+                          CFG_GROUP_LEN(cfg_info_group3),
+                          CFG_GROUP_LEN(cfg_info_group4),
+                          CFG_GROUP_LEN(cfg_info_group5),
+                          CFG_GROUP_LEN(cfg_info_group6)};
+                          
+    if ((!cfg_info_len[1]) && (!cfg_info_len[2]) && 
+        (!cfg_info_len[3]) && (!cfg_info_len[4]) && 
+        (!cfg_info_len[5]))
+    {
+        sensor_id = 0; 
+    }
+    else
+    {
+        ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID, &sensor_id, 1);
+        if (SUCCESS == ret)
+        {
+            if (sensor_id >= 0x06)
+            {
+                GTP_ERROR("Invalid sensor_id(0x%02X), No Config Sent!", sensor_id);
+                return -1;
+            }
+        }
+        else
+        {
+            GTP_ERROR("Failed to get sensor_id, No config sent!");
+            return -1;
+        }
+    }
+    
+    GTP_DEBUG("Sensor_ID: %d", sensor_id);
+    
+    ts->gtp_cfg_len = cfg_info_len[sensor_id];
+    
+    if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH)
+    {
+        GTP_ERROR("Sensor_ID(%d) matches with NULL or INVALID CONFIG GROUP! NO Config Sent! You need to check you header file CFG_GROUP section!", sensor_id);
+        return -1;
+    }
+    
+    ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA, &opr_buf[0], 1);
+    
+    if (ret == SUCCESS)
+    {
+        GTP_DEBUG("CFG_GROUP%d Config Version: %d, IC Config Version: %d", sensor_id+1, 
+                    send_cfg_buf[sensor_id][0], opr_buf[0]);
+        
+        send_cfg_buf[sensor_id][0] = opr_buf[0];
+        ts->fixed_cfg = 0;
+    }
+    else
+    {
+        GTP_ERROR("Failed to get ic config version!No config sent!");
+        return -1;
+    }
+    
+    memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+    memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id], ts->gtp_cfg_len);
+
+    GTP_DEBUG("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+        ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
+
+    config[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
+    config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
+    config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
+    config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
+    
+    if (GTP_INT_TRIGGER == 0)  //RISING
+    {
+        config[TRIGGER_LOC] &= 0xfe; 
+    }
+    else if (GTP_INT_TRIGGER == 1)  //FALLING
+    {
+        config[TRIGGER_LOC] |= 0x01;
+    }
+    
+    check_sum = 0;
+    for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
+    {
+        check_sum += config[i];
+    }
+    config[ts->gtp_cfg_len] = (~check_sum) + 1;
+
+    GTP_DEBUG_FUNC();
+    ret = gtp_send_cfg(ts->client);
+    if (ret < 0)
+    {
+        GTP_ERROR("Send config error.");
+    }
+    gtp_read_version(ts->client, &version);
+    msleep(10);
+    return 0;
+}
+
+
+static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8* msg, s32 len)
+{
+    s32 i = 0;
+
+    msg[0] = (addr >> 8) & 0xff;
+    msg[1] = addr & 0xff;
+
+    for (i = 0; i < 5; i++)
+    {
+        if (gup_i2c_read(client, msg, GTP_ADDR_LENGTH + len) > 0)
+        {
+            break;
+        }
+    }
+
+    if (i >= 5)
+    {
+        GTP_ERROR("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
+        return FAIL;
+    }
+
+    return SUCCESS;
+}
+
+static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
+{
+    s32 i = 0;
+    u8 msg[3];
+
+    msg[0] = (addr >> 8) & 0xff;
+    msg[1] = addr & 0xff;
+    msg[2] = val;
+
+    for (i = 0; i < 5; i++)
+    {
+        if (gup_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
+        {
+            break;
+        }
+    }
+
+    if (i >= 5)
+    {
+        GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
+        return FAIL;
+    }
+
+    return SUCCESS;
+}
+
+static u8 gup_get_ic_fw_msg(struct i2c_client *client)
+{
+    s32 ret = -1;
+    u8  retry = 0;
+    u8  buf[16];
+    u8  i;
+
+	/*ZTEMT Added by luochangyang, 2014/02/25*/
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    /*ZTEMT END*/
+	
+    // step1:get hardware info
+    ret = gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO, &buf[GTP_ADDR_LENGTH], 4);
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[get_ic_fw_msg]get hw_info failed,exit");
+        return FAIL;
+    }
+     
+    // buf[2~5]: 00 06 90 00
+    // hw_info: 00 90 06 00
+    for(i=0; i<4; i++)
+    {
+        update_msg.ic_fw_msg.hw_info[i] = buf[GTP_ADDR_LENGTH + 3 - i];
+    } 
+    GTP_DEBUG("IC Hardware info:%02x%02x%02x%02x", update_msg.ic_fw_msg.hw_info[0], update_msg.ic_fw_msg.hw_info[1],
+                                                   update_msg.ic_fw_msg.hw_info[2], update_msg.ic_fw_msg.hw_info[3]);
+    // step2:get firmware message
+    for(retry=0; retry<2; retry++)
+    {
+        ret = gup_get_ic_msg(client, GUP_REG_FW_MSG, buf, 1);
+        if(FAIL == ret)
+        {
+            GTP_ERROR("Read firmware message fail.");
+            return ret;
+        }
+        
+        update_msg.force_update = buf[GTP_ADDR_LENGTH];
+        if((0xBE != update_msg.force_update)&&(!retry))
+        {
+            GTP_INFO("The check sum in ic is error.");
+            GTP_INFO("The IC will be updated by force.");
+            continue;
+        }
+        break;
+    }
+    GTP_DEBUG("IC force update flag:0x%x", update_msg.force_update);
+    
+    // step3:get pid & vid
+    ret = gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID, &buf[GTP_ADDR_LENGTH], 6);
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[get_ic_fw_msg]get pid & vid failed,exit");
+        return FAIL;
+    }
+    
+    memset(update_msg.ic_fw_msg.pid, 0, sizeof(update_msg.ic_fw_msg.pid));
+    memcpy(update_msg.ic_fw_msg.pid, &buf[GTP_ADDR_LENGTH], 4);
+    GTP_DEBUG("IC Product id:%s", update_msg.ic_fw_msg.pid);
+    
+    //GT9XX PID MAPPING
+    /*|-----FLASH-----RAM-----|
+      |------918------918-----|
+      |------968------968-----|
+      |------913------913-----|
+      |------913P-----913P----|
+      |------927------927-----|
+      |------927P-----927P----|
+      |------9110-----9110----|
+      |------9110P----9111----|*/
+    if(update_msg.ic_fw_msg.pid[0] != 0)
+    {
+        if(!memcmp(update_msg.ic_fw_msg.pid, "9111", 4))
+        {
+            GTP_DEBUG("IC Mapping Product id:%s", update_msg.ic_fw_msg.pid);
+            memcpy(update_msg.ic_fw_msg.pid, "9110P", 5);
+        }
+    }
+    
+    update_msg.ic_fw_msg.vid = buf[GTP_ADDR_LENGTH+4] + (buf[GTP_ADDR_LENGTH+5]<<8);
+    GTP_DEBUG("IC version id:%04x", update_msg.ic_fw_msg.vid);
+
+    /*ZTEMT Added by luochangyang, 2014/02/25*/
+#if 0
+    ret = gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA, &update_msg.ic_fw_msg.cfg, 1);
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[get_ic_fw_msg] get IC Config Version failed.");
+        return FAIL;
+    }
+#endif
+	update_msg.ic_fw_msg.cfg = ts->ic_cfg_version;
+	
+    GTP_INFO("IC Config Version: %d", update_msg.ic_fw_msg.cfg);
+    /*ZTEMT END*/
+    
+    return SUCCESS;
+}
+
+s32 gup_enter_update_mode(struct i2c_client *client)
+{
+    s32 ret = -1;
+    s32 retry = 0;
+    u8 rd_buf[3];
+    
+    //step1:RST output low last at least 2ms
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
+    msleep(2);
+    
+    //step2:select I2C slave addr,INT:0--0xBA;1--0x28.
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, (client->addr == 0x14));
+    msleep(2);
+    
+    //step3:RST output high reset guitar
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
+    
+    //20121211 modify start
+    msleep(5);
+    while(retry++ < 200)
+    {
+        //step4:Hold ss51 & dsp
+        ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+        if(ret <= 0)
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            continue;
+        }
+        
+        //step5:Confirm hold
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            continue;
+        }
+        if(0x0C == rd_buf[GTP_ADDR_LENGTH])
+        {
+            GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
+            break;
+        }
+        GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", rd_buf[GTP_ADDR_LENGTH]);
+    }
+    if(retry >= 200)
+    {
+        GTP_ERROR("Enter update Hold ss51 failed.");
+        return FAIL;
+    }
+    
+    //step6:DSP_CK and DSP_ALU_CK PowerOn
+    ret = gup_set_ic_msg(client, 0x4010, 0x00);
+    
+    //20121211 modify end
+    return ret;
+}
+
+void gup_leave_update_mode(void)
+{
+    GTP_GPIO_AS_INT(GTP_INT_PORT);
+    
+    GTP_DEBUG("[leave_update_mode]reset chip.");
+    gtp_reset_guitar(i2c_connect_client, 20);
+}
+
+// Get the correct nvram data
+// The correct conditions: 
+//  1. the hardware info is the same
+//  2. the product id is the same
+//  3. the firmware version in update file is greater than the firmware version in ic 
+//      or the check sum in ic is wrong
+/* Update Conditions: 
+    1. Same hardware info
+    2. Same PID
+    3. File VID > IC VID
+   Force Update Conditions:
+    1. Wrong ic firmware checksum
+    2. INVALID IC PID or VID
+    3. (IC PID == 91XX || File PID == 91XX) && (File VID > IC VID)
+*/
+
+static u8 gup_enter_update_judge(st_fw_head *fw_head)
+{
+    u8 cfg_info = gtp_cfg_version;      //Added by luochangyang, 2014/02/25
+    u16 u16_tmp;
+    s32 i = 0;
+    u32 fw_len = 0;
+    s32 pid_cmp_len = 0;
+    u16_tmp = fw_head->vid;
+    fw_head->vid = (u16)(u16_tmp>>8) + (u16)(u16_tmp<<8);
+    
+    GTP_DEBUG("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0], fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+    GTP_DEBUG("FILE PID:%s", fw_head->pid);
+    GTP_DEBUG("FILE VID:%04x", fw_head->vid);
+
+    /*ZTEMT Added by luochangyang, 2014/01/23*/
+    memcpy(update_msg.dr_fw_msg.hw_info, fw_head->hw_info, sizeof(update_msg.dr_fw_msg.hw_info));
+    memcpy(update_msg.dr_fw_msg.pid, fw_head->pid, sizeof(update_msg.dr_fw_msg.pid));
+
+    update_msg.dr_fw_msg.cfg = cfg_info;
+    update_msg.dr_fw_msg.vid = fw_head->vid;
+    /*ZTEMT END*/
+
+    GTP_DEBUG("IC HARDWARE INFO:%02x%02x%02x%02x", update_msg.ic_fw_msg.hw_info[0], update_msg.ic_fw_msg.hw_info[1],
+                                                   update_msg.ic_fw_msg.hw_info[2], update_msg.ic_fw_msg.hw_info[3]);
+    GTP_DEBUG("IC PID:%s", update_msg.ic_fw_msg.pid);
+    GTP_DEBUG("IC VID:%04x", update_msg.ic_fw_msg.vid);
+
+    if (!memcmp(fw_head->pid, "9158", 4) && !memcmp(update_msg.ic_fw_msg.pid, "915S", 4))
+    {
+        GTP_INFO("Update GT915S to GT9158 directly!");
+        return SUCCESS;
+    }
+    //First two conditions
+    if (!memcmp(fw_head->hw_info, update_msg.ic_fw_msg.hw_info, sizeof(update_msg.ic_fw_msg.hw_info)))
+    {
+        fw_len = 42 * 1024;
+    }
+    else
+    {
+        fw_len = fw_head->hw_info[3];
+        fw_len += (((u32)fw_head->hw_info[2]) << 8);
+        fw_len += (((u32)fw_head->hw_info[1]) << 16);
+        fw_len += (((u32)fw_head->hw_info[0]) << 24);
+    }
+    if (update_msg.fw_total_len != fw_len)
+    {
+        GTP_ERROR("Inconsistent firmware size, Update aborted! Default size: %d(%dK), actual size: %d(%dK)", fw_len, fw_len/1024, update_msg.fw_total_len, update_msg.fw_total_len/1024);
+        return FAIL;
+    }
+    GTP_INFO("Firmware length:%d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
+    
+    if (update_msg.force_update != 0xBE)
+    {
+        GTP_INFO("FW chksum error,need enter update.");
+        return SUCCESS;
+    }
+    
+    // 20130523 start
+    if (strlen(update_msg.ic_fw_msg.pid) < 3)
+    {
+        GTP_INFO("Illegal IC pid, need enter update");
+        return SUCCESS;
+    }
+    else
+    {
+        for (i = 0; i < 3; i++)
+        {
+            if ((update_msg.ic_fw_msg.pid[i] < 0x30) || (update_msg.ic_fw_msg.pid[i] > 0x39))
+            {
+                GTP_INFO("Illegal IC pid, out of bound, need enter update");
+                return SUCCESS;
+            }
+        }
+    }
+    // 20130523 end
+    
+    pid_cmp_len = strlen(fw_head->pid);
+    if (pid_cmp_len < strlen(update_msg.ic_fw_msg.pid))
+    {
+        pid_cmp_len = strlen(update_msg.ic_fw_msg.pid);
+    }
+    
+    if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid, pid_cmp_len)) ||
+            (!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4))||
+            (!memcmp(fw_head->pid, "91XX", 4)))
+    {
+        if(!memcmp(fw_head->pid, "91XX", 4))
+        {
+            GTP_DEBUG("Force none same pid update mode.");
+        }
+        else
+        {
+            GTP_DEBUG("Get the same pid.");
+        }
+
+        //The third condition
+#if GT915_FORCE_UPDATE
+		GTP_INFO("Force update firmware.");
+        return SUCCESS;
+#else
+        if (fw_head->vid > update_msg.ic_fw_msg.vid)
+        {
+            GTP_INFO("Need enter update.");
+            return SUCCESS;
+        }
+        GTP_ERROR("Don't meet the third condition.");
+        GTP_ERROR("File VID <= Ic VID, update aborted!");
+#endif
+    }
+    else
+    {
+        GTP_ERROR("File PID != Ic PID, update aborted!");
+    }
+
+    return FAIL;
+}
+
+
+/*ZTEMT Added by luochangyang, 2014/01/23*/
+static int gt915_ic_ver_show (struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf,
+		"GT%s Firmware Version in  TP IC: 0x%04X_V%d\n"
+		"GT%s Firmware Version in Driver: 0x%04X_V%d\n",
+		update_msg.ic_fw_msg.pid,
+		update_msg.ic_fw_msg.vid,
+		update_msg.ic_fw_msg.cfg,
+		update_msg.dr_fw_msg.pid,
+		update_msg.dr_fw_msg.vid,
+		update_msg.dr_fw_msg.cfg);
+}
+
+static DEVICE_ATTR(ic_ver, 0664, gt915_ic_ver_show, NULL);
+/*ZTEMT END*/
+
+#if GTP_AUTO_UPDATE_CFG
+static u8 ascii2hex(u8 a)
+{
+    s8 value = 0;
+
+    if(a >= '0' && a <= '9')
+    {
+        value = a - '0';
+    }
+    else if(a >= 'A' && a <= 'F')
+    {
+        value = a - 'A' + 0x0A;
+    }
+    else if(a >= 'a' && a <= 'f')
+    {
+        value = a - 'a' + 0x0A;
+    }
+    else
+    {
+        value = 0xff;
+    }
+    
+    return value;
+}
+
+static s8 gup_update_config(struct i2c_client *client)
+{
+    s32 file_len = 0;
+    s32 ret = 0;
+    s32 i = 0;
+    s32 file_cfg_len = 0;
+    s32 chip_cfg_len = 0;
+    s32 count = 0;
+    u8 *buf;
+    u8 *pre_buf;
+    u8 *file_config;
+    //u8 checksum = 0;
+    struct goodix_ts_data *ts = i2c_get_clientdata(client);
+    
+    if(NULL == update_msg.cfg_file)
+    {
+        GTP_ERROR("[update_cfg]No need to upgrade config!");
+        return FAIL;
+    }
+    file_len = update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_END);
+    
+    chip_cfg_len = ts->gtp_cfg_len;
+    
+    GTP_DEBUG("[update_cfg]config file len:%d", file_len);
+    GTP_DEBUG("[update_cfg]need config len:%d", chip_cfg_len);
+    if((file_len+5) < chip_cfg_len*5)
+    {
+        GTP_ERROR("Config length error");
+        return -1;
+    }
+    
+    buf = (u8*)kzalloc(file_len, GFP_KERNEL);
+    pre_buf = (u8*)kzalloc(file_len, GFP_KERNEL);
+    file_config = (u8*)kzalloc(chip_cfg_len + GTP_ADDR_LENGTH, GFP_KERNEL);
+    update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_SET);
+    
+    GTP_DEBUG("[update_cfg]Read config from file.");
+    ret = update_msg.cfg_file->f_op->read(update_msg.cfg_file, (char*)pre_buf, file_len, &update_msg.cfg_file->f_pos);
+    if(ret<0)
+    {
+        GTP_ERROR("[update_cfg]Read config file failed.");
+        goto update_cfg_file_failed;
+    }
+    
+    GTP_DEBUG("[update_cfg]Delete illgal charactor.");
+    for(i=0,count=0; i<file_len; i++)
+    {
+        if (pre_buf[i] == ' ' || pre_buf[i] == '\r' || pre_buf[i] == '\n')
+        {
+            continue;
+        }
+        buf[count++] = pre_buf[i];
+    }
+    
+    GTP_DEBUG("[update_cfg]Ascii to hex.");
+    file_config[0] = GTP_REG_CONFIG_DATA >> 8;
+    file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
+    for(i=0,file_cfg_len=GTP_ADDR_LENGTH; i<count; i+=5)
+    {
+        if((buf[i]=='0') && ((buf[i+1]=='x') || (buf[i+1]=='X')))
+        {
+            u8 high,low;
+            high = ascii2hex(buf[i+2]);
+            low = ascii2hex(buf[i+3]);
+            
+            if((high == 0xFF) || (low == 0xFF))
+            {
+                ret = 0;
+                GTP_ERROR("[update_cfg]Illegal config file.");
+                goto update_cfg_file_failed;
+            }
+            file_config[file_cfg_len++] = (high<<4) + low;
+        }
+        else
+        {
+            ret = 0;
+            GTP_ERROR("[update_cfg]Illegal config file.");
+            goto update_cfg_file_failed;
+        }
+    }
+    
+    
+    GTP_DEBUG("config:");
+    GTP_DEBUG_ARRAY(file_config+2, file_cfg_len);
+    
+    i = 0;
+    while(i++ < 5)
+    {
+        ret = gup_i2c_write(client, file_config, file_cfg_len);
+        if(ret > 0)
+        {
+            GTP_INFO("[update_cfg]Send config SUCCESS.");
+            break;
+        }
+        GTP_ERROR("[update_cfg]Send config i2c error.");
+    }
+    
+update_cfg_file_failed:
+    kfree(pre_buf);
+    kfree(buf);
+    kfree(file_config);
+    return ret;
+}
+
+#endif 
+
+#if (GTP_AUTO_UPDATE && (!GTP_HEADER_FW_UPDATE || GTP_AUTO_UPDATE_CFG))
+static void gup_search_file(s32 search_type)
+{
+    s32 i = 0;
+    struct file *pfile = NULL;
+
+    got_file_flag = 0x00;
+    
+    searching_file = 1;
+    for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i)
+    {            
+        if (0 == searching_file)
+        {
+            GTP_INFO("Force exiting file searching");
+            got_file_flag = 0x00;
+            return;
+        }
+        
+        if (search_type & AUTO_SEARCH_BIN)
+        {
+            GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)", UPDATE_FILE_PATH_1, UPDATE_FILE_PATH_2, i+1, GUP_SEARCH_FILE_TIMES);
+            pfile = filp_open(UPDATE_FILE_PATH_1, O_RDONLY, 0);
+            if (IS_ERR(pfile))
+            {
+                pfile = filp_open(UPDATE_FILE_PATH_2, O_RDONLY, 0);
+                if (!IS_ERR(pfile))
+                {
+                    GTP_INFO("Bin file: %s for fw update.", UPDATE_FILE_PATH_2);
+                    got_file_flag |= BIN_FILE_READY;
+                    update_msg.file = pfile;
+                }
+            }
+            else
+            {
+                GTP_INFO("Bin file: %s for fw update.", UPDATE_FILE_PATH_1);
+                got_file_flag |= BIN_FILE_READY;
+                update_msg.file = pfile;
+            }
+            if (got_file_flag & BIN_FILE_READY)
+            {
+            #if GTP_AUTO_UPDATE_CFG
+                if (search_type & AUTO_SEARCH_CFG)
+                {
+                    i = GUP_SEARCH_FILE_TIMES;    // Bin & Cfg File required to be in the same directory
+                }
+                else
+            #endif
+                {
+                    searching_file = 0;
+                    return;
+                }
+            }
+        }
+    
+    #if GTP_AUTO_UPDATE_CFG
+        if ( (search_type & AUTO_SEARCH_CFG) && !(got_file_flag & CFG_FILE_READY) )
+        {
+            GTP_DEBUG("Search for %s, %s for config update.(%d/%d)", CONFIG_FILE_PATH_1, CONFIG_FILE_PATH_2, i+1, GUP_SEARCH_FILE_TIMES);
+            pfile = filp_open(CONFIG_FILE_PATH_1, O_RDONLY, 0);
+            if (IS_ERR(pfile))
+            {
+                pfile = filp_open(CONFIG_FILE_PATH_2, O_RDONLY, 0);
+                if (!IS_ERR(pfile))
+                {
+                    GTP_INFO("Cfg file: %s for config update.", CONFIG_FILE_PATH_2);
+                    got_file_flag |= CFG_FILE_READY;
+                    update_msg.cfg_file = pfile;
+                }
+            }
+            else
+            {
+                GTP_INFO("Cfg file: %s for config update.", CONFIG_FILE_PATH_1);
+                got_file_flag |= CFG_FILE_READY;
+                update_msg.cfg_file = pfile;
+            }
+            if (got_file_flag & CFG_FILE_READY)
+            {
+                searching_file = 0;
+                return;
+            }
+        }
+    #endif
+        msleep(3000);
+    }
+    searching_file = 0;
+}
+#endif
+
+
+static u8 gup_check_update_file(struct i2c_client *client, st_fw_head* fw_head, u8* path)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    s32 fw_checksum = 0;
+    u8 buf[FW_HEAD_LENGTH];
+    
+    got_file_flag = 0x00;
+    if (path)
+    {
+        GTP_DEBUG("Update File path:%s, %d", path, strlen(path));
+        update_msg.file = filp_open(path, O_RDONLY, 0);
+
+        if (IS_ERR(update_msg.file))
+        {
+            GTP_ERROR("Open update file(%s) error!", path);
+            return FAIL;
+        }
+        got_file_flag = BIN_FILE_READY;
+    }
+    else
+    {
+#if GTP_AUTO_UPDATE
+    #if GTP_HEADER_FW_UPDATE
+        GTP_INFO("Update by default firmware array");
+        update_msg.fw_total_len = sizeof(gtp_default_FW) - FW_HEAD_LENGTH;
+        if (sizeof(gtp_default_FW) < (FW_HEAD_LENGTH+FW_SECTION_LENGTH*4+FW_DSP_ISP_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH))
+        {
+            GTP_ERROR("INVALID gtp_default_FW, check your gt9xx_firmware.h file!");
+            return FAIL;           
+        }
+        GTP_DEBUG("Firmware actual size: %d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
+        memcpy(fw_head, &gtp_default_FW[0], FW_HEAD_LENGTH);
+    
+        //check firmware legality
+        fw_checksum = 0;
+        for(i=0; i< update_msg.fw_total_len; i+=2)
+        {
+            fw_checksum += (gtp_default_FW[FW_HEAD_LENGTH + i] << 8) + gtp_default_FW[FW_HEAD_LENGTH + i + 1];
+        }
+        
+        GTP_DEBUG("firmware checksum:%x", fw_checksum&0xFFFF);
+        if (fw_checksum&0xFFFF)
+        {
+            GTP_ERROR("Illegal firmware file.");
+            return FAIL;
+        }
+        got_file_flag = HEADER_FW_READY;
+        return SUCCESS;
+    #else
+
+    #if GTP_AUTO_UPDATE_CFG
+        gup_search_file(AUTO_SEARCH_BIN | AUTO_SEARCH_CFG);
+        if (got_file_flag & CFG_FILE_READY)
+        {
+            ret = gup_update_config(i2c_connect_client);
+            if(ret <= 0)
+            {
+                GTP_ERROR("Update config failed.");
+            }
+            _CLOSE_FILE(update_msg.cfg_file);
+            msleep(500);                //waiting config to be stored in FLASH.
+        }
+    #else
+        gup_search_file(AUTO_SEARCH_BIN);
+    #endif
+    
+        if ( !(got_file_flag & BIN_FILE_READY) )
+        {
+            GTP_ERROR("No bin file for fw update");
+            return FAIL;
+        }
+    #endif
+    
+#else
+        {
+            GTP_ERROR("NULL file for firmware update");
+            return FAIL;
+        }
+#endif
+    }
+    
+    update_msg.old_fs = get_fs();
+    set_fs(KERNEL_DS);
+
+    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+    update_msg.fw_total_len = update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+    if (update_msg.fw_total_len < (FW_HEAD_LENGTH + FW_SECTION_LENGTH*4+FW_DSP_ISP_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH))
+    {
+        GTP_ERROR("INVALID bin file(size: %d), update aborted.", update_msg.fw_total_len);
+        return FAIL;
+    }    
+    
+    update_msg.fw_total_len -= FW_HEAD_LENGTH;
+
+    GTP_DEBUG("Bin firmware actual size: %d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
+    
+    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+    ret = update_msg.file->f_op->read(update_msg.file, (char*)buf, FW_HEAD_LENGTH, &update_msg.file->f_pos);
+    if (ret < 0)
+    {
+        GTP_ERROR("Read firmware head in update file error.");
+        return FAIL;
+    }
+
+    memcpy(fw_head, buf, FW_HEAD_LENGTH);
+    
+    //check firmware legality
+    fw_checksum = 0;
+    for(i=0; i<update_msg.fw_total_len; i+=2)
+    {
+        u16 temp;
+        ret = update_msg.file->f_op->read(update_msg.file, (char*)buf, 2, &update_msg.file->f_pos);
+        if (ret < 0)
+        {
+            GTP_ERROR("Read firmware file error.");
+            return FAIL;
+        }
+        //GTP_DEBUG("BUF[0]:%x", buf[0]);
+        temp = (buf[0]<<8) + buf[1];
+        fw_checksum += temp;
+    }
+    
+    GTP_DEBUG("firmware checksum:%x", fw_checksum&0xFFFF);
+    if(fw_checksum&0xFFFF)
+    {
+        GTP_ERROR("Illegal firmware file.");
+        return FAIL;
+    }
+    
+    return SUCCESS;
+}
+
+static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr, u16 total_length)
+{
+    s32 ret = 0;
+    u16 burn_addr = start_addr;
+    u16 frame_length = 0;
+    u16 burn_length = 0;
+    u8  wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+    u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+    u8  retry = 0;
+    
+    GTP_DEBUG("Begin burn %dk data to addr 0x%x", (total_length/1024), start_addr);
+    while(burn_length < total_length)
+    {
+        GTP_DEBUG("B/T:%04d/%04d", burn_length, total_length);
+        frame_length = ((total_length - burn_length) > PACK_SIZE) ? PACK_SIZE : (total_length - burn_length);
+        wr_buf[0] = (u8)(burn_addr>>8);
+        rd_buf[0] = wr_buf[0];
+        wr_buf[1] = (u8)burn_addr;
+        rd_buf[1] = wr_buf[1];
+        memcpy(&wr_buf[GTP_ADDR_LENGTH], &burn_buf[burn_length], frame_length);
+        
+        for(retry = 0; retry < MAX_FRAME_CHECK_TIME; retry++)
+        {
+            ret = gup_i2c_write(client, wr_buf, GTP_ADDR_LENGTH + frame_length);
+            if(ret <= 0)
+            {
+                GTP_ERROR("Write frame data i2c error.");
+                continue;
+            }
+            ret = gup_i2c_read(client, rd_buf, GTP_ADDR_LENGTH + frame_length);
+            if(ret <= 0)
+            {
+                GTP_ERROR("Read back frame data i2c error.");
+                continue;
+            }
+            
+            if(memcmp(&wr_buf[GTP_ADDR_LENGTH], &rd_buf[GTP_ADDR_LENGTH], frame_length))
+            {
+                GTP_ERROR("Check frame data fail,not equal.");
+                GTP_DEBUG("write array:");
+                GTP_DEBUG_ARRAY(&wr_buf[GTP_ADDR_LENGTH], frame_length);
+                GTP_DEBUG("read array:");
+                GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
+                continue;
+            }
+            else
+            {
+                //GTP_DEBUG("Check frame data success.");
+                break;
+            }
+        }
+        if(retry >= MAX_FRAME_CHECK_TIME)
+        {
+            GTP_ERROR("Burn frame data time out,exit.");
+            return FAIL;
+        }
+        burn_length += frame_length;
+        burn_addr += frame_length;
+    }
+    return SUCCESS;
+}
+
+static u8 gup_load_section_file(u8 *buf, u32 offset, u16 length, u8 set_or_end)
+{
+#if (GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE)
+    if (got_file_flag == HEADER_FW_READY)
+    {
+        if(SEEK_SET == set_or_end)
+        {
+            memcpy(buf, &gtp_default_FW[FW_HEAD_LENGTH + offset], length);
+        }
+        else    //seek end
+        {
+            memcpy(buf, &gtp_default_FW[update_msg.fw_total_len + FW_HEAD_LENGTH - offset], length);
+        }
+        return SUCCESS;
+    }
+#endif
+    {
+        s32 ret = 0;
+    
+        if ( (update_msg.file == NULL) || IS_ERR(update_msg.file))
+        {
+            GTP_ERROR("cannot find update file,load section file fail.");
+            return FAIL;
+        }
+        
+        if(SEEK_SET == set_or_end)
+        {
+            update_msg.file->f_pos = FW_HEAD_LENGTH + offset;
+        }
+        else    //seek end
+        {
+            update_msg.file->f_pos = update_msg.fw_total_len + FW_HEAD_LENGTH - offset;
+        }
+    
+        ret = update_msg.file->f_op->read(update_msg.file, (char *)buf, length, &update_msg.file->f_pos);
+    
+        if (ret < 0)
+        {
+            GTP_ERROR("Read update file fail.");
+            return FAIL;
+        }
+    
+        return SUCCESS;
+    }
+}
+
+static u8 gup_recall_check(struct i2c_client *client, u8* chk_src, u16 start_rd_addr, u16 chk_length)
+{
+    u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+    s32 ret = 0;
+    u16 recall_addr = start_rd_addr;
+    u16 recall_length = 0;
+    u16 frame_length = 0;
+
+    while(recall_length < chk_length)
+    {
+        frame_length = ((chk_length - recall_length) > PACK_SIZE) ? PACK_SIZE : (chk_length - recall_length);
+        ret = gup_get_ic_msg(client, recall_addr, rd_buf, frame_length);
+        if(ret <= 0)
+        {
+            GTP_ERROR("recall i2c error,exit");
+            return FAIL;
+        }
+        
+        if(memcmp(&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length], frame_length))
+        {
+            GTP_ERROR("Recall frame data fail,not equal.");
+            GTP_DEBUG("chk_src array:");
+            GTP_DEBUG_ARRAY(&chk_src[recall_length], frame_length);
+            GTP_DEBUG("recall array:");
+            GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
+            return FAIL;
+        }
+        
+        recall_length += frame_length;
+        recall_addr += frame_length;
+    }
+    GTP_DEBUG("Recall check %dk firmware success.", (chk_length/1024));
+    
+    return SUCCESS;
+}
+
+static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u8 bank_cmd )
+{
+    s32 ret = 0;
+    u8  rd_buf[5];
+  
+    //step1:hold ss51 & dsp
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]hold ss51 & dsp fail.");
+        return FAIL;
+    }
+    
+    //step2:set scramble
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]set scramble fail.");
+        return FAIL;
+    }
+    
+    //step3:select bank
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4)&0x0F);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4)&0x0F);
+        return FAIL;
+    }
+    
+    //step4:enable accessing code
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]enable accessing code fail.");
+        return FAIL;
+    }
+    
+    //step5:burn 8k fw section
+    ret = gup_burn_proc(client, fw_section, start_addr, FW_SECTION_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_section]burn fw_section fail.");
+        return FAIL;
+    }
+    
+    //step6:hold ss51 & release dsp
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]hold ss51 & release dsp fail.");
+        return FAIL;
+    }
+    //must delay
+    msleep(1);
+    
+    //step7:send burn cmd to move data to flash from sram
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0f);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]send burn cmd fail.");
+        return FAIL;
+    }
+    GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
+    do{
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_ERROR("[burn_fw_section]Get burn state fail");
+            return FAIL;
+        }
+        msleep(10);
+        //GTP_DEBUG("[burn_fw_section]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+    }while(rd_buf[GTP_ADDR_LENGTH]);
+
+    //step8:select bank
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4)&0x0F);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4)&0x0F);
+        return FAIL;
+    }
+    
+    //step9:enable accessing code
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]enable accessing code fail.");
+        return FAIL;
+    }
+    
+    //step10:recall 8k fw section
+    ret = gup_recall_check(client, fw_section, start_addr, FW_SECTION_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_section]recall check %dk firmware fail.", FW_SECTION_LENGTH/1024);
+        return FAIL;
+    }
+    
+    //step11:disable accessing code
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]disable accessing code fail.");
+        return FAIL;
+    }
+    
+    return SUCCESS;
+}
+
+static u8 gup_burn_dsp_isp(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8* fw_dsp_isp = NULL;
+    u8  retry = 0;
+    
+    GTP_INFO("[burn_dsp_isp]Begin burn dsp isp---->>");
+    
+    //step1:alloc memory
+    GTP_DEBUG("[burn_dsp_isp]step1:alloc memory");
+    while(retry++ < 5)
+    {
+        fw_dsp_isp = (u8*)kzalloc(FW_DSP_ISP_LENGTH, GFP_KERNEL);
+        if(fw_dsp_isp == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_INFO("[burn_dsp_isp]Alloc %dk byte memory success.", (FW_DSP_ISP_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_dsp_isp]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load dsp isp file data
+    GTP_DEBUG("[burn_dsp_isp]step2:load dsp isp file data");
+    ret = gup_load_section_file(fw_dsp_isp, FW_DSP_ISP_LENGTH, FW_DSP_ISP_LENGTH, SEEK_END);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_dsp_isp]load firmware dsp_isp fail.");
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step3:disable wdt,clear cache enable
+    GTP_DEBUG("[burn_dsp_isp]step3:disable wdt,clear cache enable");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]disable wdt fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]clear cache enable fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step4:hold ss51 & dsp
+    GTP_DEBUG("[burn_dsp_isp]step4:hold ss51 & dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]hold ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step5:set boot from sram
+    GTP_DEBUG("[burn_dsp_isp]step5:set boot from sram");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]set boot from sram fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step6:software reboot
+    GTP_DEBUG("[burn_dsp_isp]step6:software reboot");
+    ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]software reboot fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step7:select bank2
+    GTP_DEBUG("[burn_dsp_isp]step7:select bank2");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]select bank2 fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step8:enable accessing code
+    GTP_DEBUG("[burn_dsp_isp]step8:enable accessing code");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]enable accessing code fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step9:burn 4k dsp_isp
+    GTP_DEBUG("[burn_dsp_isp]step9:burn 4k dsp_isp");
+    ret = gup_burn_proc(client, fw_dsp_isp, 0xC000, FW_DSP_ISP_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_dsp_isp]burn dsp_isp fail.");
+        goto exit_burn_dsp_isp;
+    }
+    
+    //step10:set scramble
+    GTP_DEBUG("[burn_dsp_isp]step10:set scramble");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_dsp_isp]set scramble fail.");
+        ret = FAIL;
+        goto exit_burn_dsp_isp;
+    }
+    update_msg.fw_burned_len += FW_DSP_ISP_LENGTH;
+    GTP_DEBUG("[burn_dsp_isp]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+
+exit_burn_dsp_isp:
+    kfree(fw_dsp_isp);
+    return ret;
+}
+
+static u8 gup_burn_fw_ss51(struct i2c_client *client)
+{
+    u8* fw_ss51 = NULL;
+    u8  retry = 0;
+    s32 ret = 0;
+    
+    GTP_INFO("[burn_fw_ss51]Begin burn ss51 firmware---->>");
+    
+    //step1:alloc memory
+    GTP_DEBUG("[burn_fw_ss51]step1:alloc memory");
+    while(retry++ < 5)
+    {
+        fw_ss51 = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+        if(fw_ss51 == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_ss51]Alloc %dk byte memory success.", (FW_SECTION_LENGTH / 1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_ss51]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load ss51 firmware section 1 file data
+//    GTP_DEBUG("[burn_fw_ss51]step2:load ss51 firmware section 1 file data");
+//    ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+//    if(FAIL == ret)
+//    {
+//        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 1 fail.");
+//        goto exit_burn_fw_ss51;
+//    }
+    
+    GTP_INFO("[burn_fw_ss51]Reset first 8K of ss51 to 0xFF.");
+    GTP_DEBUG("[burn_fw_ss51]step2: reset bank0 0xC000~0xD000");
+    memset(fw_ss51, 0xFF, FW_SECTION_LENGTH);
+    
+    //step3:clear control flag
+    GTP_DEBUG("[burn_fw_ss51]step3:clear control flag");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_ss51]clear control flag fail.");
+        ret = FAIL;
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step4:burn ss51 firmware section 1
+    GTP_DEBUG("[burn_fw_ss51]step4:burn ss51 firmware section 1");
+    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 1 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step5:load ss51 firmware section 2 file data
+    GTP_DEBUG("[burn_fw_ss51]step5:load ss51 firmware section 2 file data");
+    ret = gup_load_section_file(fw_ss51, FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 2 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step6:burn ss51 firmware section 2
+    GTP_DEBUG("[burn_fw_ss51]step6:burn ss51 firmware section 2");
+    ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x02);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 2 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step7:load ss51 firmware section 3 file data
+    GTP_DEBUG("[burn_fw_ss51]step7:load ss51 firmware section 3 file data");
+    ret = gup_load_section_file(fw_ss51, 2 * FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 3 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step8:burn ss51 firmware section 3
+    GTP_DEBUG("[burn_fw_ss51]step8:burn ss51 firmware section 3");
+    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x13);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 3 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step9:load ss51 firmware section 4 file data
+    GTP_DEBUG("[burn_fw_ss51]step9:load ss51 firmware section 4 file data");
+    ret = gup_load_section_file(fw_ss51, 3 * FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 4 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    //step10:burn ss51 firmware section 4
+    GTP_DEBUG("[burn_fw_ss51]step10:burn ss51 firmware section 4");
+    ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x14);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 4 fail.");
+        goto exit_burn_fw_ss51;
+    }
+    
+    update_msg.fw_burned_len += (FW_SECTION_LENGTH*4);
+    GTP_DEBUG("[burn_fw_ss51]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_ss51:
+    kfree(fw_ss51);
+    return ret;
+}
+
+static u8 gup_burn_fw_dsp(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8* fw_dsp = NULL;
+    u8  retry = 0;
+    u8  rd_buf[5];
+    
+    GTP_INFO("[burn_fw_dsp]Begin burn dsp firmware---->>");
+    //step1:alloc memory
+    GTP_DEBUG("[burn_fw_dsp]step1:alloc memory");
+    while(retry++ < 5)
+    {
+        fw_dsp = (u8*)kzalloc(FW_DSP_LENGTH, GFP_KERNEL);
+        if(fw_dsp == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_dsp]Alloc %dk byte memory success.", (FW_SECTION_LENGTH / 1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_dsp]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load firmware dsp
+    GTP_DEBUG("[burn_fw_dsp]step2:load firmware dsp");
+    ret = gup_load_section_file(fw_dsp, 4 * FW_SECTION_LENGTH, FW_DSP_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_dsp]load firmware dsp fail.");
+        goto exit_burn_fw_dsp;
+    }
+    
+    //step3:select bank3
+    GTP_DEBUG("[burn_fw_dsp]step3:select bank3");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_dsp]select bank3 fail.");
+        ret = FAIL;
+        goto exit_burn_fw_dsp;
+    }
+    
+    //step4:hold ss51 & dsp
+    GTP_DEBUG("[burn_fw_dsp]step4:hold ss51 & dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_dsp]hold ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_dsp;
+    }
+    
+    //step5:set scramble
+    GTP_DEBUG("[burn_fw_dsp]step5:set scramble");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_dsp]set scramble fail.");
+        ret = FAIL;
+        goto exit_burn_fw_dsp;
+    }
+    
+    //step6:release ss51 & dsp
+    GTP_DEBUG("[burn_fw_dsp]step6:release ss51 & dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);                 //20121211
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_dsp]release ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_dsp;
+    }
+    //must delay
+    msleep(1);
+    
+    //step7:burn 4k dsp firmware
+    GTP_DEBUG("[burn_fw_dsp]step7:burn 4k dsp firmware");
+    ret = gup_burn_proc(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_dsp]burn fw_section fail.");
+        goto exit_burn_fw_dsp;
+    }
+    
+    //step8:send burn cmd to move data to flash from sram
+    GTP_DEBUG("[burn_fw_dsp]step8:send burn cmd to move data to flash from sram");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x05);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_dsp]send burn cmd fail.");
+        goto exit_burn_fw_dsp;
+    }
+    GTP_DEBUG("[burn_fw_dsp]Wait for the burn is complete......");
+    do{
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_ERROR("[burn_fw_dsp]Get burn state fail");
+            goto exit_burn_fw_dsp;
+        }
+        msleep(10);
+        //GTP_DEBUG("[burn_fw_dsp]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+    }while(rd_buf[GTP_ADDR_LENGTH]);
+    
+    //step9:recall check 4k dsp firmware
+    GTP_DEBUG("[burn_fw_dsp]step9:recall check 4k dsp firmware");
+    ret = gup_recall_check(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_dsp]recall check 4k dsp firmware fail.");
+        goto exit_burn_fw_dsp;
+    }
+    
+    update_msg.fw_burned_len += FW_DSP_LENGTH;
+    GTP_DEBUG("[burn_fw_dsp]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_dsp:
+    kfree(fw_dsp);
+    return ret;
+}
+
+static u8 gup_burn_fw_boot(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8* fw_boot = NULL;
+    u8  retry = 0;
+    u8  rd_buf[5];
+    
+    GTP_INFO("[burn_fw_boot]Begin burn bootloader firmware---->>");
+    
+    //step1:Alloc memory
+    GTP_DEBUG("[burn_fw_boot]step1:Alloc memory");
+    while(retry++ < 5)
+    {
+        fw_boot = (u8*)kzalloc(FW_BOOT_LENGTH, GFP_KERNEL);
+        if(fw_boot == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_boot]Alloc %dk byte memory success.", (FW_BOOT_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_boot]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load firmware bootloader
+    GTP_DEBUG("[burn_fw_boot]step2:load firmware bootloader");
+    ret = gup_load_section_file(fw_boot, (4 * FW_SECTION_LENGTH + FW_DSP_LENGTH), FW_BOOT_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot]load firmware bootcode fail.");
+        goto exit_burn_fw_boot;
+    }
+    
+    //step3:hold ss51 & dsp
+    GTP_DEBUG("[burn_fw_boot]step3:hold ss51 & dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot]hold ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot;
+    }
+    
+    //step4:set scramble
+    GTP_DEBUG("[burn_fw_boot]step4:set scramble");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot]set scramble fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot;
+    }
+    
+    //step5:hold ss51 & release dsp
+    GTP_DEBUG("[burn_fw_boot]step5:hold ss51 & release dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);                 //20121211
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot]release ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot;
+    }
+    //must delay
+    msleep(1);
+    
+    //step6:select bank3
+    GTP_DEBUG("[burn_fw_boot]step6:select bank3");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot]select bank3 fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot;
+    }
+    
+    //step6:burn 2k bootloader firmware
+    GTP_DEBUG("[burn_fw_boot]step6:burn 2k bootloader firmware");
+    ret = gup_burn_proc(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot]burn fw_boot fail.");
+        goto exit_burn_fw_boot;
+    }
+    
+    //step7:send burn cmd to move data to flash from sram
+    GTP_DEBUG("[burn_fw_boot]step7:send burn cmd to move data to flash from sram");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x06);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot]send burn cmd fail.");
+        goto exit_burn_fw_boot;
+    }
+    GTP_DEBUG("[burn_fw_boot]Wait for the burn is complete......");
+    do{
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_ERROR("[burn_fw_boot]Get burn state fail");
+            goto exit_burn_fw_boot;
+        }
+        msleep(10);
+        //GTP_DEBUG("[burn_fw_boot]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+    }while(rd_buf[GTP_ADDR_LENGTH]);
+    
+    //step8:recall check 2k bootloader firmware
+    GTP_DEBUG("[burn_fw_boot]step8:recall check 2k bootloader firmware");
+    ret = gup_recall_check(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot]recall check 2k bootcode firmware fail.");
+        goto exit_burn_fw_boot;
+    }
+    
+    update_msg.fw_burned_len += FW_BOOT_LENGTH;
+    GTP_DEBUG("[burn_fw_boot]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_boot:
+    kfree(fw_boot);
+    return ret;
+}
+static u8 gup_burn_fw_boot_isp(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8* fw_boot_isp = NULL;
+    u8  retry = 0;
+    u8  rd_buf[5];
+    
+    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
+    {
+        GTP_DEBUG("No need to upgrade the boot_isp code!");
+        return SUCCESS;
+    }
+    GTP_INFO("[burn_fw_boot_isp]Begin burn boot_isp firmware---->>");
+    
+    //step1:Alloc memory
+    GTP_DEBUG("[burn_fw_boot_isp]step1:Alloc memory");
+    while(retry++ < 5)
+    {
+        fw_boot_isp = (u8*)kzalloc(FW_BOOT_ISP_LENGTH, GFP_KERNEL);
+        if(fw_boot_isp == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_boot_isp]Alloc %dk byte memory success.", (FW_BOOT_ISP_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load firmware bootloader
+    GTP_DEBUG("[burn_fw_boot_isp]step2:load firmware bootloader isp");
+    //ret = gup_load_section_file(fw_boot_isp, (4*FW_SECTION_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH+FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH, SEEK_SET);
+    ret = gup_load_section_file(fw_boot_isp, (update_msg.fw_burned_len - FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]load firmware boot_isp fail.");
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    //step3:hold ss51 & dsp
+    GTP_DEBUG("[burn_fw_boot_isp]step3:hold ss51 & dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]hold ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    //step4:set scramble
+    GTP_DEBUG("[burn_fw_boot_isp]step4:set scramble");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]set scramble fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    
+    //step5:hold ss51 & release dsp
+    GTP_DEBUG("[burn_fw_boot_isp]step5:hold ss51 & release dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);                 //20121211
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]release ss51 & dsp fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot_isp;
+    }
+    //must delay
+    msleep(1);
+    
+    //step6:select bank3
+    GTP_DEBUG("[burn_fw_boot_isp]step6:select bank3");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]select bank3 fail.");
+        ret = FAIL;
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    //step7:burn 2k bootload_isp firmware
+    GTP_DEBUG("[burn_fw_boot_isp]step7:burn 2k bootloader firmware");
+    ret = gup_burn_proc(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]burn fw_section fail.");
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    //step7:send burn cmd to move data to flash from sram
+    GTP_DEBUG("[burn_fw_boot_isp]step8:send burn cmd to move data to flash from sram");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x07);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]send burn cmd fail.");
+        goto exit_burn_fw_boot_isp;
+    }
+    GTP_DEBUG("[burn_fw_boot_isp]Wait for the burn is complete......");
+    do{
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_ERROR("[burn_fw_boot_isp]Get burn state fail");
+            goto exit_burn_fw_boot_isp;
+        }
+        msleep(10);
+        //GTP_DEBUG("[burn_fw_boot_isp]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+    }while(rd_buf[GTP_ADDR_LENGTH]);
+    
+    //step8:recall check 2k bootload_isp firmware
+    GTP_DEBUG("[burn_fw_boot_isp]step9:recall check 2k bootloader firmware");
+    ret = gup_recall_check(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_boot_isp]recall check 2k bootcode_isp firmware fail.");
+        goto exit_burn_fw_boot_isp;
+    }
+    
+    update_msg.fw_burned_len += FW_BOOT_ISP_LENGTH;
+    GTP_DEBUG("[burn_fw_boot_isp]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_boot_isp:
+    kfree(fw_boot_isp);
+    return ret;
+}
+
+static u8 gup_burn_fw_link(struct i2c_client *client)
+{
+    s32 ret = 0;
+    u8* fw_link = NULL;
+    u8  retry = 0;
+    u32 offset;
+    
+    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
+    {
+        GTP_DEBUG("No need to upgrade the link code!");
+        return SUCCESS;
+    }
+    GTP_INFO("[burn_fw_link]Begin burn link firmware---->>");
+    
+    //step1:Alloc memory
+    GTP_DEBUG("[burn_fw_link]step1:Alloc memory");
+    while(retry++ < 5)
+    {
+        fw_link = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+        if(fw_link == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_link]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_link]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load firmware link section 1
+    GTP_DEBUG("[burn_fw_link]step2:load firmware link section 1");
+    offset = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+    ret = gup_load_section_file(fw_link, offset, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_link]load firmware link section 1 fail.");
+        goto exit_burn_fw_link;
+    }
+    
+    //step3:burn link firmware section 1
+    GTP_DEBUG("[burn_fw_link]step3:burn link firmware section 1");
+    ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000, FW_SECTION_LENGTH, 0x38);
+
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_link]burn link firmware section 1 fail.");
+        goto exit_burn_fw_link;
+    }
+    
+    //step4:load link firmware section 2 file data
+    GTP_DEBUG("[burn_fw_link]step4:load link firmware section 2 file data");
+    offset += FW_SECTION_LENGTH;
+    ret = gup_load_section_file(fw_link, offset, FW_GLINK_LENGTH - FW_SECTION_LENGTH, SEEK_SET);
+
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_link]load link firmware section 2 fail.");
+        goto exit_burn_fw_link;
+    }
+    
+    //step5:burn link firmware section 2
+    GTP_DEBUG("[burn_fw_link]step4:burn link firmware section 2");
+    ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000, FW_GLINK_LENGTH - FW_SECTION_LENGTH, 0x39);
+
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_link]burn link firmware section 2 fail.");
+        goto exit_burn_fw_link;
+    }
+    
+    update_msg.fw_burned_len += FW_GLINK_LENGTH;
+    GTP_DEBUG("[burn_fw_link]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_link:
+    kfree(fw_link);
+    return ret;
+}
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u32 len, u8 bank_cmd )
+{
+    s32 ret = 0;
+    u8  rd_buf[5];
+  
+    //step1:hold ss51 & dsp
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_app_section]hold ss51 & dsp fail.");
+        return FAIL;
+    }
+    
+    //step2:set scramble
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_app_section]set scramble fail.");
+        return FAIL;
+    }
+        
+    //step3:hold ss51 & release dsp
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_app_section]hold ss51 & release dsp fail.");
+        return FAIL;
+    }
+    //must delay
+    msleep(1);
+    
+    //step4:select bank
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4)&0x0F);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4)&0x0F);
+        return FAIL;
+    }
+    
+    //step5:burn fw section
+    ret = gup_burn_proc(client, fw_section, start_addr, len);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_app_section]burn fw_section fail.");
+        return FAIL;
+    }
+    
+    //step6:send burn cmd to move data to flash from sram
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0F);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_app_section]send burn cmd fail.");
+        return FAIL;
+    }
+    GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
+    do{
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+        if(ret <= 0)
+        {
+            GTP_ERROR("[burn_fw_app_section]Get burn state fail");
+            return FAIL;
+        }
+        msleep(10);
+        //GTP_DEBUG("[burn_fw_app_section]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+    }while(rd_buf[GTP_ADDR_LENGTH]);
+    
+    //step7:recall fw section
+    ret = gup_recall_check(client, fw_section, start_addr, len);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_app_section]recall check %dk firmware fail.", len/1024);
+        return FAIL;
+    }
+    
+    return SUCCESS;
+}
+
+static u8 gup_burn_fw_gwake(struct i2c_client *client)
+{
+    u8* fw_gwake = NULL;
+    u8  retry = 0;
+    s32 ret = 0;
+    //u16 start_index = 4*FW_SECTION_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH + FW_DSP_ISP_LENGTH + FW_BOOT_ISP_LENGTH; // 32 + 4 + 2 + 4 = 42K
+    u16 start_index;
+    
+    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
+    {
+        GTP_DEBUG("No need to upgrade the gwake code!");
+        return SUCCESS;
+    }
+    start_index = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+    GTP_INFO("[burn_fw_gwake]Begin burn gwake firmware---->>");
+    
+    //step1:alloc memory
+    GTP_DEBUG("[burn_fw_gwake]step1:alloc memory");
+    while(retry++ < 5)
+    {
+        fw_gwake = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+        if(fw_gwake == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_gwake]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_gwake]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    //step2:load app_code firmware section 1 file data
+    GTP_DEBUG("[burn_fw_gwake]step2:load app_code firmware section 1 file data");
+    ret = gup_load_section_file(fw_gwake, start_index, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 1 fail.");
+        goto exit_burn_fw_gwake;
+    }
+  
+    //step3:burn app_code firmware section 1
+    GTP_DEBUG("[burn_fw_gwake]step3:burn app_code firmware section 1");
+    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3A);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 1 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step5:load app_code firmware section 2 file data
+    GTP_DEBUG("[burn_fw_gwake]step5:load app_code firmware section 2 file data");
+    ret = gup_load_section_file(fw_gwake, start_index+FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 2 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step6:burn app_code firmware section 2
+    GTP_DEBUG("[burn_fw_gwake]step6:burn app_code firmware section 2");
+    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3B);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 2 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step7:load app_code firmware section 3 file data
+    GTP_DEBUG("[burn_fw_gwake]step7:load app_code firmware section 3 file data");
+    ret = gup_load_section_file(fw_gwake, start_index+2*FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 3 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step8:burn app_code firmware section 3
+    GTP_DEBUG("[burn_fw_gwake]step8:burn app_code firmware section 3");
+    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3C);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 3 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step9:load app_code firmware section 4 file data
+    GTP_DEBUG("[burn_fw_gwake]step9:load app_code firmware section 4 file data");
+    ret = gup_load_section_file(fw_gwake, start_index + 3*FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 4 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    //step10:burn app_code firmware section 4
+    GTP_DEBUG("[burn_fw_gwake]step10:burn app_code firmware section 4");
+    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3D);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 4 fail.");
+        goto exit_burn_fw_gwake;
+    }
+    
+    update_msg.fw_burned_len += FW_GWAKE_LENGTH;
+    GTP_DEBUG("[burn_fw_gwake]Burned length:%d", update_msg.fw_burned_len);
+    ret = SUCCESS;
+    
+exit_burn_fw_gwake:
+    kfree(fw_gwake);
+    return ret;
+}
+
+static u8 gup_burn_fw_finish(struct i2c_client *client)
+{
+    u8* fw_ss51 = NULL;
+    u8  retry = 0;
+    s32 ret = 0;
+    
+    GTP_INFO("[burn_fw_finish]burn first 8K of ss51 and finish update.");
+    //step1:alloc memory
+    GTP_DEBUG("[burn_fw_finish]step1:alloc memory");
+    while(retry++ < 5)
+    {
+        fw_ss51 = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+        if(fw_ss51 == NULL)
+        {
+            continue;
+        }
+        else
+        {
+            GTP_DEBUG("[burn_fw_finish]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
+            break;
+        }
+    }
+    if(retry >= 5)
+    {
+        GTP_ERROR("[burn_fw_finish]Alloc memory fail,exit.");
+        return FAIL;
+    }
+    
+    GTP_DEBUG("[burn_fw_finish]step2: burn ss51 first 8K.");
+    ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_finish]load ss51 firmware section 1 fail.");
+        goto exit_burn_fw_finish;
+    }
+
+    GTP_DEBUG("[burn_fw_finish]step3:clear control flag");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_finish]clear control flag fail.");
+        goto exit_burn_fw_finish;
+    }
+    
+    GTP_DEBUG("[burn_fw_finish]step4:burn ss51 firmware section 1");
+    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[burn_fw_finish]burn ss51 firmware section 1 fail.");
+        goto exit_burn_fw_finish;
+    }
+    
+    //step11:enable download DSP code 
+    GTP_DEBUG("[burn_fw_finish]step5:enable download DSP code ");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_finish]enable download DSP code fail.");
+        goto exit_burn_fw_finish;
+    }
+    
+    //step12:release ss51 & hold dsp
+    GTP_DEBUG("[burn_fw_finish]step6:release ss51 & hold dsp");
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+    if(ret <= 0)
+    {
+        GTP_ERROR("[burn_fw_finish]release ss51 & hold dsp fail.");
+        goto exit_burn_fw_finish;
+    }
+
+    if (fw_ss51)
+    {
+        kfree(fw_ss51);
+    }
+    return SUCCESS;
+    
+exit_burn_fw_finish:
+    if (fw_ss51)
+    {
+        kfree(fw_ss51);
+    }
+    return FAIL;
+}
+s32 gup_update_proc(void *dir)
+{
+    s32 ret = 0;
+    s32 update_ret = FAIL;
+    u8  retry = 0;
+    st_fw_head fw_head;
+    struct goodix_ts_data *ts = NULL;
+    
+    GTP_DEBUG("[update_proc]Begin update ......");
+    
+    ts = i2c_get_clientdata(i2c_connect_client);
+    
+    /*ZTEMT Added by luochangyang, 2014/01/24*/
+    ret = device_create_file(&(i2c_connect_client->dev), &dev_attr_ic_ver);
+	if (ret) {
+		GTP_ERROR("%s: Error, could not create ic_ver", __func__);
+	}
+    /*ZTEMT END*/
+    
+#if GTP_AUTO_UPDATE
+    if (searching_file)
+    {
+        u8 timeout = 0;
+        searching_file = 0;     // exit .bin update file searching 
+        GTP_INFO("Exiting searching .bin update file...");
+        while ((show_len != 200) && (show_len != 100) && (timeout++ < 100))     // wait for auto update quitted completely
+        {
+            msleep(100);
+        }
+    }
+#endif
+
+    show_len = 1;
+    total_len = 100;
+    
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        return gup_fw_download_proc(dir, GTP_FL_FW_BURN);
+    }
+#endif
+
+    update_msg.file = NULL;
+    ret = gup_check_update_file(i2c_connect_client, &fw_head, (u8*)dir);     //20121211
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[update_proc]check update file fail.");
+        goto file_fail;
+    }
+    
+    ret = gup_get_ic_fw_msg(i2c_connect_client);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[update_proc]get ic message fail.");
+        goto file_fail;
+    }
+    
+    ret = gup_enter_update_judge(&fw_head);
+    if(FAIL == ret)
+    {
+        GTP_ERROR("[update_proc]Check *.bin file fail.");
+        goto file_fail;
+    }
+    
+    ts->enter_update = 1;
+    gtp_irq_disable(ts);
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+    ret = gup_enter_update_mode(i2c_connect_client);
+    if(FAIL == ret)
+    {
+         GTP_ERROR("[update_proc]enter update mode fail.");
+         goto update_fail;
+    }
+    
+    while(retry++ < 5)
+    {
+        show_len = 10;
+        total_len = 100;
+        update_msg.fw_burned_len = 0;
+        ret = gup_burn_dsp_isp(i2c_connect_client);
+        if(FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn dsp isp fail.");
+            continue;
+        }
+        
+        show_len = 20;
+        ret = gup_burn_fw_ss51(i2c_connect_client);
+        if(FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn ss51 firmware fail.");
+            continue;
+        }
+        
+        show_len = 30;
+        ret = gup_burn_fw_dsp(i2c_connect_client);
+        if(FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn dsp firmware fail.");
+            continue;
+        }
+        
+        show_len = 40;
+        ret = gup_burn_fw_boot(i2c_connect_client);
+        if(FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn bootloader firmware fail.");
+            continue;
+        }
+        show_len = 50;
+        
+        ret = gup_burn_fw_boot_isp(i2c_connect_client);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn boot_isp firmware fail.");
+            continue;
+        }
+        
+        show_len = 60;
+        ret = gup_burn_fw_link(i2c_connect_client);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn link firmware fail.");
+            continue;
+        }
+        
+        show_len = 70;
+        ret = gup_burn_fw_gwake(i2c_connect_client);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn app_code firmware fail.");
+            continue;
+        }       
+        show_len = 80;
+        
+        ret = gup_burn_fw_finish(i2c_connect_client);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[update_proc]burn finish fail.");
+            continue;
+        }
+        show_len = 90;
+        GTP_INFO("[update_proc]UPDATE SUCCESS.");
+
+        retry = 0;
+        break;
+    }
+
+    if (retry >= 5)
+    {
+        GTP_ERROR("[update_proc]retry timeout,UPDATE FAIL.");
+        update_ret = FAIL;
+    }
+    else
+    {
+        update_ret = SUCCESS;
+    }
+        
+update_fail:
+    GTP_DEBUG("[update_proc]leave update mode.");
+    gup_leave_update_mode();
+
+    msleep(100);
+    
+    if (SUCCESS == update_ret)
+    {
+        if (ts->fw_error)
+        {
+            GTP_INFO("firmware error auto update, resent config!");
+            gup_init_panel(ts);
+        }
+        else
+        {
+            GTP_DEBUG("[update_proc]send config.");
+            ret = gtp_send_cfg(i2c_connect_client);
+            if (ret < 0)
+            {
+                GTP_ERROR("[update_proc]send config fail.");
+            }
+            else
+            {
+                msleep(100);
+            }
+        }
+    }
+    ts->enter_update = 0;
+    gtp_irq_enable(ts);
+     
+    
+    /*ZTEMT Added by luochangyang, 2014/01/24*/
+        gup_get_ic_fw_msg(i2c_connect_client);
+#if 0
+        ret = gtp_i2c_read_dbl_check(i2c_connect_client, GUP_REG_PID_VID, &buf[GTP_ADDR_LENGTH], 6);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[get_ic_fw_msg]get pid & vid failed,exit");
+        }
+        
+        GTP_DEBUG("XXX IC Product id:%x%x%x%x", buf[GTP_ADDR_LENGTH + 0], buf[GTP_ADDR_LENGTH + 1], buf[GTP_ADDR_LENGTH + 2], buf[GTP_ADDR_LENGTH + 3]);
+        GTP_DEBUG("XXX IC Version id:%x%x", buf[GTP_ADDR_LENGTH + 5], buf[GTP_ADDR_LENGTH + 4]);
+#endif
+    /*ZTEMT END*/
+
+#if GTP_ESD_PROTECT
+    gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+
+file_fail:
+	if (update_msg.file && !IS_ERR(update_msg.file))
+	{
+        if (update_msg.old_fs)
+        {
+            set_fs(update_msg.old_fs);
+        }
+		filp_close(update_msg.file, NULL);
+	}
+#if (GTP_AUTO_UPDATE && GTP_AUTO_UPDATE_CFG && GTP_HEADER_FW_UPDATE)
+    if (NULL == dir)
+    {
+        gup_search_file(AUTO_SEARCH_CFG);
+        if (got_file_flag & CFG_FILE_READY)
+        {
+            ret = gup_update_config(i2c_connect_client);
+            if(ret <= 0)
+            {
+                GTP_ERROR("Update config failed.");
+            }
+            _CLOSE_FILE(update_msg.cfg_file);
+            msleep(500);                //waiting config to be stored in FLASH.
+        }
+    }
+#endif
+   
+
+    total_len = 100;
+    if (SUCCESS == update_ret)
+    {
+        show_len = 100;
+        return SUCCESS;
+    }
+    else
+    {
+        show_len = 200;
+        return FAIL;
+    }
+}
+
+#if GTP_AUTO_UPDATE
+u8 gup_init_update_proc(struct goodix_ts_data *ts)
+{
+    struct task_struct *thread = NULL;
+
+    GTP_INFO("Ready to run update thread.");
+
+#if GTP_COMPATIBLE_MODE
+    if (CHIP_TYPE_GT9F == ts->chip_type)
+    {
+        thread = kthread_run(gup_update_proc, "update", "fl update");
+    }
+    else
+#endif
+    {    
+        thread = kthread_run(gup_update_proc, (void*)NULL, "guitar_update");
+    }
+    if (IS_ERR(thread))
+    {
+        GTP_ERROR("Failed to create update thread.\n");
+        return -1;
+    }
+
+    return 0;
+}
+#endif
+
+
+//************************** For GT9XXF Start ***********************//
+#define FW_DOWNLOAD_LENGTH           0x4000
+#define FW_SS51_SECTION_LEN          0x2000     // 4 section, each 8k
+#define FL_PACK_SIZE                 1024
+#define GUP_FW_CHK_SIZE              FL_PACK_SIZE    //FL_PACK_SIZE
+
+#define FL_UPDATE_PATH              "/data/_fl_update_.bin"
+#define FL_UPDATE_PATH_SD           "/sdcard/_fl_update_.bin"
+//for clk cal
+#define PULSE_LENGTH      (200)
+#define INIT_CLK_DAC      (50)
+#define MAX_CLK_DAC       (120)
+#define CLK_AVG_TIME      (1)
+#define MILLION           1000000
+
+#define _wRW_MISCTL__RG_DMY                       0x4282
+#define _bRW_MISCTL__RG_OSC_CALIB                 0x4268
+#define _fRW_MISCTL__GIO0                         0x41e9
+#define _fRW_MISCTL__GIO1                         0x41ed
+#define _fRW_MISCTL__GIO2                         0x41f1
+#define _fRW_MISCTL__GIO3                         0x41f5
+#define _fRW_MISCTL__GIO4                         0x41f9
+#define _fRW_MISCTL__GIO5                         0x41fd
+#define _fRW_MISCTL__GIO6                         0x4201
+#define _fRW_MISCTL__GIO7                         0x4205
+#define _fRW_MISCTL__GIO8                         0x4209
+#define _fRW_MISCTL__GIO9                         0x420d
+#define _fRW_MISCTL__MEA                          0x41a0
+#define _bRW_MISCTL__MEA_MODE                     0x41a1
+#define _wRW_MISCTL__MEA_MAX_NUM                  0x41a4
+#define _dRO_MISCTL__MEA_VAL                      0x41b0
+#define _bRW_MISCTL__MEA_SRCSEL                   0x41a3
+#define _bRO_MISCTL__MEA_RDY                      0x41a8
+#define _rRW_MISCTL__ANA_RXADC_B0_                0x4250
+#define _bRW_MISCTL__RG_LDO_A18_PWD               0x426f
+#define _bRW_MISCTL__RG_BG_PWD                    0x426a
+#define _bRW_MISCTL__RG_CLKGEN_PWD                0x4269
+#define _fRW_MISCTL__RG_RXADC_PWD                 0x426a
+#define _bRW_MISCTL__OSC_CK_SEL                   0x4030
+#define _rRW_MISCTL_RG_DMY83                      0x4283
+#define _rRW_MISCTL__GIO1CTL_B2_                  0x41ee
+#define _rRW_MISCTL__GIO1CTL_B1_                  0x41ed
+
+
+#if GTP_COMPATIBLE_MODE
+
+u8 i2c_opr_buf[GTP_ADDR_LENGTH + FL_PACK_SIZE] = {0};
+u8 chk_cmp_buf[FL_PACK_SIZE] = {0};
+
+extern s32 gtp_fw_startup(struct i2c_client *client);
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode);
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr, s32 start_index, s32 burn_len);
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr, s32 start_index, s32 chk_len);
+
+
+u8 gup_check_fs_mounted(char *path_name)
+{
+    struct path root_path;
+    struct path path;
+    int err;
+    err = kern_path("/", LOOKUP_FOLLOW, &root_path);
+
+    if (err)
+    {
+        GTP_DEBUG("\"/\" NOT Mounted: %d", err);
+        return FAIL;
+    }
+    err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+
+    if (err)
+    {
+        GTP_DEBUG("%s NOT Mounted: %d", path_name, err);
+        return FAIL;
+    }
+
+#if 1
+    path_put(&path);
+    return SUCCESS;
+#else
+    if (path.mnt->mnt_sb == root_path.mnt->mnt_sb)
+    {
+        //-- not mounted
+        path_put(&path);
+        return FAIL;
+    }
+    else
+    {
+        path_put(&path);
+        return SUCCESS;
+    }
+#endif
+}
+
+s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+    s32 ret = 0;
+    s32 write_bytes = 0;
+    s32 retry = 0;
+    u8 *tx_buf = buf;
+    
+    while (len > 0)
+    {
+        i2c_opr_buf[0] = (u8)(addr >> 8);
+        i2c_opr_buf[1] = (u8)(addr & 0xFF);
+        if (len > FL_PACK_SIZE)
+        {
+            write_bytes = FL_PACK_SIZE;
+        }
+        else
+        {
+            write_bytes = len;
+        }
+        memcpy(i2c_opr_buf + 2, tx_buf, write_bytes);
+        for (retry = 0; retry < 5; ++retry)
+        {
+            ret = gup_i2c_write(client, i2c_opr_buf, write_bytes + GTP_ADDR_LENGTH);
+            if (ret == 1)
+            {
+                break;
+            }
+        }
+        if (retry >= 5)
+        {
+            GTP_ERROR("retry timeout, I2C write 0x%04X %d bytes failed!", addr, write_bytes);
+            return -1;
+        }
+        addr += write_bytes;
+        len -= write_bytes;
+        tx_buf += write_bytes;
+    }
+    
+    return 1;
+}
+
+s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+    s32 ret = 0;
+    s32 read_bytes = 0;
+    s32 retry = 0;
+    u8 *tx_buf = buf;
+    
+    while (len > 0)
+    {
+        i2c_opr_buf[0] = (u8)(addr >> 8);
+        i2c_opr_buf[1] = (u8)(addr & 0xFF);
+        if (len > FL_PACK_SIZE)
+        {
+            read_bytes = FL_PACK_SIZE;
+        }
+        else
+        {
+            read_bytes = len;
+        }
+        for (retry = 0; retry < 5; ++retry)
+        {
+            ret = gup_i2c_read(client, i2c_opr_buf, read_bytes + GTP_ADDR_LENGTH);
+            if (ret == 2)
+            {
+                break;
+            }
+        }
+        if (retry >= 5)
+        {
+            GTP_ERROR("retry timeout, I2C read 0x%04X %d bytes failed!", addr, read_bytes);
+            return -1;
+        }
+        memcpy(tx_buf, i2c_opr_buf + 2, read_bytes);
+        addr += read_bytes;
+        len -= read_bytes;
+        tx_buf += read_bytes;
+    }
+    return 2;
+}
+
+
+
+// main clock calibration
+// bit: 0~7, val: 0/1
+static void gup_bit_write(s32 addr, s32 bit, s32 val)
+{
+    u8 buf;
+    i2c_read_bytes(i2c_connect_client, addr, &buf, 1);
+
+    buf = (buf & (~((u8)1 << bit))) | ((u8)val << bit);
+
+    i2c_write_bytes(i2c_connect_client, addr, &buf, 1);
+}
+
+static void gup_clk_count_init(s32 bCh, s32 bCNT)
+{
+    u8 buf;
+    
+    //_fRW_MISCTL__MEA_EN = 0; //Frequency measure enable
+    gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+    //_fRW_MISCTL__MEA_CLR = 1; //Frequency measure clear
+    gup_bit_write(_fRW_MISCTL__MEA, 1, 1);
+    //_bRW_MISCTL__MEA_MODE = 0; //Pulse mode
+    buf = 0;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_MODE, &buf, 1);
+    //_bRW_MISCTL__MEA_SRCSEL = 8 + bCh; //From GIO1
+    buf = 8 + bCh;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_SRCSEL, &buf, 1);
+    //_wRW_MISCTL__MEA_MAX_NUM = bCNT; //Set the Measure Counts = 1
+    buf = bCNT;
+    i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__MEA_MAX_NUM, &buf, 1);
+    //_fRW_MISCTL__MEA_CLR = 0; //Frequency measure not clear
+    gup_bit_write(_fRW_MISCTL__MEA, 1, 0);
+    //_fRW_MISCTL__MEA_EN = 1;
+    gup_bit_write(_fRW_MISCTL__MEA, 0, 1);
+}
+
+static u32 gup_clk_count_get(void)
+{
+    s32 ready = 0;
+    s32 temp;
+    s8  buf[4];
+
+    while ((ready == 0)) //Wait for measurement complete
+    {
+        i2c_read_bytes(i2c_connect_client, _bRO_MISCTL__MEA_RDY, buf, 1);
+        ready = buf[0];
+    }
+
+    msleep(50);
+
+    //_fRW_MISCTL__MEA_EN = 0;
+    gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+    i2c_read_bytes(i2c_connect_client, _dRO_MISCTL__MEA_VAL, buf, 4);
+    GTP_DEBUG("Clk_count 0: %2X", buf[0]);
+    GTP_DEBUG("Clk_count 1: %2X", buf[1]);
+    GTP_DEBUG("Clk_count 2: %2X", buf[2]);
+    GTP_DEBUG("Clk_count 3: %2X", buf[3]);
+
+    temp = (s32)buf[0] + ((s32)buf[1] << 8) + ((s32)buf[2] << 16) + ((s32)buf[3] << 24);
+    GTP_INFO("Clk_count : %d", temp);
+    return temp;
+}
+u8 gup_clk_dac_setting(int dac)
+{
+    s8 buf1, buf2;
+    
+    i2c_read_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+    i2c_read_bytes(i2c_connect_client, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
+
+    buf1 = (buf1 & 0xFFCF) | ((dac & 0x03) << 4);
+    buf2 = (dac >> 2) & 0x3f;
+
+    i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
+    
+    return 0;
+}
+
+static u8 gup_clk_calibration_pin_select(s32 bCh)
+{
+    s32 i2c_addr;
+
+    switch (bCh)
+    {
+        case 0:
+            i2c_addr = _fRW_MISCTL__GIO0;
+            break;
+
+        case 1:
+            i2c_addr = _fRW_MISCTL__GIO1;
+            break;
+
+        case 2:
+            i2c_addr = _fRW_MISCTL__GIO2;
+            break;
+
+        case 3:
+            i2c_addr = _fRW_MISCTL__GIO3;
+            break;
+
+        case 4:
+            i2c_addr = _fRW_MISCTL__GIO4;
+            break;
+
+        case 5:
+            i2c_addr = _fRW_MISCTL__GIO5;
+            break;
+
+        case 6:
+            i2c_addr = _fRW_MISCTL__GIO6;
+            break;
+
+        case 7:
+            i2c_addr = _fRW_MISCTL__GIO7;
+            break;
+
+        case 8:
+            i2c_addr = _fRW_MISCTL__GIO8;
+            break;
+
+        case 9:
+            i2c_addr = _fRW_MISCTL__GIO9;
+            break;
+    }
+
+    gup_bit_write(i2c_addr, 1, 0);
+    
+    return 0;
+}
+
+void gup_output_pulse(int t)
+{
+    unsigned long flags;
+    //s32 i;
+    
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+    msleep(10);
+    
+    local_irq_save(flags);
+
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+    msleep(50);
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+    msleep(t - 50);
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+
+    local_irq_restore(flags);
+
+    msleep(20);
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+}
+
+static void gup_sys_clk_init(void)
+{
+    u8 buf;
+    
+    //_fRW_MISCTL__RG_RXADC_CKMUX = 0;
+    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 5, 0);
+    //_bRW_MISCTL__RG_LDO_A18_PWD = 0; //DrvMISCTL_A18_PowerON
+    buf = 0;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_LDO_A18_PWD, &buf, 1);
+    //_bRW_MISCTL__RG_BG_PWD = 0; //DrvMISCTL_BG_PowerON
+    buf = 0;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_BG_PWD, &buf, 1);
+    //_bRW_MISCTL__RG_CLKGEN_PWD = 0; //DrvMISCTL_CLKGEN_PowerON
+    buf = 0;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_CLKGEN_PWD, &buf, 1);
+    //_fRW_MISCTL__RG_RXADC_PWD = 0; //DrvMISCTL_RX_ADC_PowerON
+    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 0, 0);
+    //_fRW_MISCTL__RG_RXADC_REF_PWD = 0; //DrvMISCTL_RX_ADCREF_PowerON
+    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 1, 0);
+    //gup_clk_dac_setting(60);
+    //_bRW_MISCTL__OSC_CK_SEL = 1;;
+    buf = 1;
+    i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__OSC_CK_SEL, &buf, 1);
+}
+
+s32 gup_clk_calibration(void)
+{
+    u8 buf;
+    //u8 trigger;
+    s32 i;
+    struct timeval start, end;
+    s32 count;
+    s32 count_ref;
+    s32 sec;
+    s32 usec;
+    //unsigned long flags;
+    struct goodix_ts_data *ts;
+
+    buf = 0x0C; // hold ss51 and dsp
+    i2c_write_bytes(i2c_connect_client, _rRW_MISCTL__SWRST_B0_, &buf, 1);
+
+    //_fRW_MISCTL__CLK_BIAS = 0; //disable clock bias
+    gup_bit_write(_rRW_MISCTL_RG_DMY83, 7, 0);
+
+    //_fRW_MISCTL__GIO1_PU = 0; //set TOUCH INT PIN MODE as input
+    gup_bit_write(_rRW_MISCTL__GIO1CTL_B2_, 0, 0);
+
+    //_fRW_MISCTL__GIO1_OE = 0; //set TOUCH INT PIN MODE as input
+    gup_bit_write(_rRW_MISCTL__GIO1CTL_B1_, 1, 0);
+
+    //buf = 0x00;
+    //i2c_write_bytes(i2c_connect_client, _rRW_MISCTL__SWRST_B0_, &buf, 1);
+    //msleep(1000);
+
+    GTP_INFO("CLK calibration GO");
+    gup_sys_clk_init();
+    gup_clk_calibration_pin_select(1);//use GIO1 to do the calibration
+
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+ 
+    ts = i2c_get_clientdata(i2c_connect_client);
+    
+    for (i = INIT_CLK_DAC; i < MAX_CLK_DAC; i++)
+    {
+        GTP_INFO("CLK calibration DAC %d", i);
+        
+        if (ts->gtp_is_suspend)
+        {
+            i = 72; // 80;    // if sleeping while calibrating main clock, set it default 72
+            break;
+        }
+        
+        gup_clk_dac_setting(i);
+        gup_clk_count_init(1, CLK_AVG_TIME);
+
+    #if 0
+        gup_output_pulse(PULSE_LENGTH);
+        count = gup_clk_count_get();
+  
+        if (count > PULSE_LENGTH * 60)//60= 60Mhz * 1us
+        {
+            break;
+        }
+        
+    #else
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+        
+        //local_irq_save(flags);
+        do_gettimeofday(&start);
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+        //local_irq_restore(flags);
+        
+        msleep(1);
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+        msleep(1);
+        
+        //local_irq_save(flags);
+        do_gettimeofday(&end);
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
+        //local_irq_restore(flags);
+        
+        count = gup_clk_count_get();
+        msleep(20);
+        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
+        
+        usec = end.tv_usec - start.tv_usec;
+        sec = end.tv_sec - start.tv_sec;
+        count_ref = 60 * (usec+ sec * MILLION);//60= 60Mhz * 1us
+        
+        GTP_DEBUG("== time %d, %d, %d", sec, usec, count_ref);
+        
+        if (count > count_ref)
+        {
+            GTP_DEBUG("== count_diff %d", count - count_ref);
+            break;
+        }
+
+    #endif
+    }
+
+    //clk_dac = i;
+
+    gtp_reset_guitar(i2c_connect_client, 20);
+
+#if 0//for debug
+    //-- ouput clk to GPIO 4
+    buf = 0x00;
+    i2c_write_bytes(i2c_connect_client, 0x41FA, &buf, 1);
+    buf = 0x00;
+    i2c_write_bytes(i2c_connect_client, 0x4104, &buf, 1);
+    buf = 0x00;
+    i2c_write_bytes(i2c_connect_client, 0x4105, &buf, 1);
+    buf = 0x00;
+    i2c_write_bytes(i2c_connect_client, 0x4106, &buf, 1);
+    buf = 0x01;
+    i2c_write_bytes(i2c_connect_client, 0x4107, &buf, 1);
+    buf = 0x06;
+    i2c_write_bytes(i2c_connect_client, 0x41F8, &buf, 1);
+    buf = 0x02;
+    i2c_write_bytes(i2c_connect_client, 0x41F9, &buf, 1);
+#endif
+
+    GTP_GPIO_AS_INT(GTP_INT_PORT);
+    return i;
+}
+
+
+
+s32 gup_hold_ss51_dsp(struct i2c_client *client)
+{
+    s32 ret = -1;
+    s32 retry = 0;
+    u8 rd_buf[3];
+    
+    while(retry++ < 200)
+    {
+        // step4:Hold ss51 & dsp
+        ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+        if(ret <= 0)
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            continue;
+        }
+        
+        // step5:Confirm hold
+        ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
+        if (ret <= 0)
+        {
+            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+            continue;
+        }
+        if (0x0C == rd_buf[GTP_ADDR_LENGTH])
+        {
+            GTP_DEBUG("[enter_update_mode]Hold ss51 & dsp confirm SUCCESS");
+            break;
+        }
+        GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", rd_buf[GTP_ADDR_LENGTH]);
+    }
+    if(retry >= 200)
+    {
+        GTP_ERROR("Enter update Hold ss51 failed.");
+        return FAIL;
+    }
+        //DSP_CK and DSP_ALU_CK PowerOn
+    ret = gup_set_ic_msg(client, 0x4010, 0x00);
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]DSP_CK and DSP_ALU_CK PowerOn fail.");
+        return FAIL;
+    }
+    
+    //disable wdt
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]disable wdt fail.");
+        return FAIL;
+    }
+    
+    //clear cache enable
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]clear cache enable fail.");
+        return FAIL;
+    }
+    
+    //set boot from sram
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]set boot from sram fail.");
+        return FAIL;
+    }
+
+	//software reboot    
+	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
+	if (ret <= 0)
+	{    
+	    GTP_ERROR("[enter_update_mode]software reboot fail.");
+	    return FAIL;
+	}
+    
+    return SUCCESS;
+}
+
+s32 gup_enter_update_mode_fl(struct i2c_client *client)
+{
+    s32 ret = -1;
+    //s32 retry = 0;
+    //u8 rd_buf[3];
+    
+    //step1:RST output low last at least 2ms
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
+    msleep(2);
+    
+    //step2:select I2C slave addr,INT:0--0xBA;1--0x28.
+    GTP_GPIO_OUTPUT(GTP_INT_PORT, (client->addr == 0x14));
+    msleep(2);
+    
+    //step3:RST output high reset guitar
+    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
+    
+    msleep(5);
+    
+    //select addr & hold ss51_dsp
+    ret = gup_hold_ss51_dsp(client);
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]hold ss51 & dsp failed.");
+        return FAIL;
+    }
+    
+    //clear control flag
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]clear control flag fail.");
+        return FAIL;
+    }
+    
+    //set scramble
+    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]set scramble fail.");
+        return FAIL;
+    }
+    
+    //enable accessing code
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+
+    if (ret <= 0)
+    {
+        GTP_ERROR("[enter_update_mode]enable accessing code fail.");
+        return FAIL;
+    }
+    
+    return SUCCESS;
+}
+
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode)
+{
+    s32 ret = 0;
+    
+    //step1:select bank2
+    GTP_DEBUG("[download_fw_dsp]step1:select bank2");
+    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
+    if (ret == FAIL)
+    {
+        GTP_ERROR("select bank 2 fail");
+        return FAIL;
+    }
+    
+    if (GTP_FL_FW_BURN == dwn_mode)
+    {
+        GTP_INFO("[download_fw_dsp]Begin download dsp fw---->>");
+    
+        if (ret <= 0)
+        {
+            GTP_ERROR("[download_fw_dsp]select bank2 fail.");
+            return FAIL;
+        }
+        GTP_DEBUG("burn fw dsp");
+        ret = gup_burn_fw_proc(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH); // write the second ban
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[download_fw_dsp]download FW dsp fail.");
+            return FAIL;
+        }
+        GTP_INFO("check firmware dsp");
+        ret = gup_check_and_repair(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("check fw dsp failed!");
+            return FAIL;
+        }
+    }
+    else if (GTP_FL_ESD_RECOVERY == dwn_mode)
+    {
+        GTP_INFO("[download_fw_dsp]Begin esd check dsp fw---->>");
+        //GTP_INFO("esd recovery: check fw dsp");
+        //ret = gup_check_and_repair(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+        
+        //if(FAIL == ret)
+        {
+            //GTP_ERROR("[download_fw_dsp]Checked FW dsp fail, redownload fw dsp");
+            GTP_INFO("esd recovery redownload firmware dsp code");
+            ret = gup_burn_fw_proc(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+            if (FAIL == ret)
+            {
+                GTP_ERROR("redownload fw dsp failed!");
+                return FAIL;
+            }
+        }
+    }
+    else
+    {
+        GTP_INFO("check firmware dsp");
+        ret = gup_check_and_repair(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+        if (FAIL == ret)
+        {
+            GTP_ERROR("check fw dsp failed!");
+            return FAIL;
+        }
+    }
+    return SUCCESS;
+}
+
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr, s32 start_index, s32 burn_len)
+{
+    s32 ret = 0;
+    
+    GTP_DEBUG("burn firmware: 0x%04X, %d bytes, start_index: 0x%04X", start_addr, burn_len, start_index);
+    
+    ret = i2c_write_bytes(client, start_addr, (u8*)&gtp_default_FW_fl[FW_HEAD_LENGTH + start_index], burn_len);
+    if (ret < 0)
+    {
+        GTP_ERROR("burn 0x%04X, %d bytes failed!", start_addr, burn_len);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr, s32 start_index, s32 chk_len)
+{
+    s32 ret = 0;
+    s32 cmp_len = 0;
+    u16 cmp_addr = start_addr;
+    s32 i = 0;
+    s32 chked_times = 0;
+    u8 chk_fail = 0;
+    
+    GTP_DEBUG("check firmware: start 0x%04X, %d bytes", start_addr, chk_len);
+    while ((chk_len > 0) && (chked_times < GTP_CHK_FW_MAX))
+    {
+        if (chk_len >= GUP_FW_CHK_SIZE)
+        {
+            cmp_len = GUP_FW_CHK_SIZE;
+        }
+        else
+        {
+            cmp_len = chk_len;
+        }
+        ret = i2c_read_bytes(client, cmp_addr, chk_cmp_buf, cmp_len);
+        if (ret < 0)
+        {
+            chk_fail = 1;
+            break;
+        }
+        for (i = 0; i < cmp_len; ++i)
+        {
+            if (chk_cmp_buf[i] != gtp_default_FW_fl[FW_HEAD_LENGTH + start_index +i])
+            {
+                chk_fail = 1;
+                i2c_write_bytes(client, cmp_addr+i, &gtp_default_FW_fl[FW_HEAD_LENGTH + start_index + i], cmp_len-i);
+                GTP_ERROR("Check failed index: %d(%d != %d), redownload chuck", i, chk_cmp_buf[i], 
+                        gtp_default_FW_fl[FW_HEAD_LENGTH + start_index +i]);
+                break;
+            }
+        }
+        if (chk_fail == 1)
+        {
+            chk_fail = 0;
+            chked_times++;
+        }
+        else
+        {
+            cmp_addr += cmp_len;
+            start_index += cmp_len;
+            chk_len -= cmp_len;
+        }
+    }
+    if (chk_len > 0)
+    {
+        GTP_ERROR("cmp_addr: 0x%04X, start_index: 0x%02X, chk_len: 0x%04X", cmp_addr,
+                start_index, chk_len);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+static u8 gup_download_fw_ss51(struct i2c_client *client, u8 dwn_mode)
+{
+    s32 section = 0;
+    s32 ret = 0;
+    s32 start_index = 0;
+    u8  bank = 0;
+    u16 burn_addr = 0xC000;
+    
+    if (GTP_FL_FW_BURN == dwn_mode)
+    {
+        GTP_INFO("download firmware ss51");
+    }
+    else
+    {
+        GTP_INFO("check firmware ss51");
+    }    
+    for (section = 1; section <= 4; section += 2)
+    {
+        switch (section)
+        {
+        case 1:
+            bank = 0x00;
+            burn_addr = (section - 1) * FW_SS51_SECTION_LEN + 0xC000;
+            break;
+        case 3:
+            bank = 0x01;
+            burn_addr = (section - 3) * FW_SS51_SECTION_LEN + 0xC000;
+            break;
+        }
+        start_index = (section - 1) * FW_SS51_SECTION_LEN;
+        
+        GTP_DEBUG("download firmware ss51: select bank%d", bank);
+        ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, bank);
+        if (GTP_FL_FW_BURN == dwn_mode)
+        {
+            GTP_INFO("download firmware ss51 section%d & %d", section, section+1);
+            ret = gup_burn_fw_proc(client, burn_addr, start_index, 2 * FW_SS51_SECTION_LEN);
+            if (ret == FAIL)
+            {
+                GTP_ERROR("download fw ss51 section%d & %d failed!", section, section+1);
+                return FAIL;
+            }
+            GTP_INFO("check firmware ss51 section%d & %d", section, section+1);
+            ret = gup_check_and_repair(client, burn_addr, start_index, 2 * FW_SS51_SECTION_LEN);
+            if (ret == FAIL)
+            {
+                GTP_ERROR("check ss51 section%d & %d failed!", section, section+1);
+                return FAIL;
+            }
+        }
+        else if (GTP_FL_ESD_RECOVERY == dwn_mode)// esd recovery mode
+        {
+            // GTP_INFO("esd recovery check ss51 section%d & %d", section, section+1);
+            // ret = gup_check_and_repair(client, burn_addr, start_index, FW_SS51_SECTION_LEN);
+            // if (ret == FAIL)
+            {
+                // GTP_ERROR("check ss51 section%d failed, redownload section%d", section, section);
+                GTP_INFO("esd recovery redownload ss51 section%d & %d", section, section+1); 
+                ret = gup_burn_fw_proc(client, burn_addr, start_index, 2 * FW_SS51_SECTION_LEN);
+                if (ret == FAIL)
+                {
+                    GTP_ERROR("download fw ss51 section%d failed!", section);
+                    return FAIL;
+                }
+            }
+        }
+        else
+        {
+            GTP_INFO("check firmware ss51 section%d & %d", section, section+1);
+            ret = gup_check_and_repair(client, burn_addr, start_index, 2 * FW_SS51_SECTION_LEN);
+            if (ret == FAIL)
+            {
+                GTP_ERROR("check ss51 section%d & %d failed!", section, section+1);
+                return FAIL;
+            }
+        }
+    }
+    
+    return SUCCESS;
+}
+
+
+static s32 gup_prepare_fl_fw(char *path, st_fw_head *fw_head)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    s32 timeout = 0;
+    struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+    
+    if (!memcmp(path, "update", 6))
+    {
+        GTP_INFO("Search for GT9XXF firmware file to update");
+        
+        searching_file = 1;
+        for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i)
+        {
+            if (0 == searching_file)
+            {
+                GTP_INFO("Force terminate auto update for GT9XXF...");
+                return FAIL;
+            }
+            GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)", FL_UPDATE_PATH, FL_UPDATE_PATH_SD, i+1, GUP_SEARCH_FILE_TIMES);
+            update_msg.file = filp_open(FL_UPDATE_PATH, O_RDONLY, 0);
+            if (IS_ERR(update_msg.file))
+            {
+                update_msg.file = filp_open(FL_UPDATE_PATH_SD, O_RDONLY, 0);
+                if (IS_ERR(update_msg.file))
+                {
+                    msleep(3000);
+                    continue;
+                }
+                else
+                {
+                    path = FL_UPDATE_PATH_SD;
+                    break;
+                }
+            }
+            else
+            {
+                path = FL_UPDATE_PATH;
+                break;
+            }
+        }
+        searching_file = 0;
+        if (i == 50)
+        {
+            GTP_INFO("Search timeout, update aborted");
+            return FAIL;
+        }
+        else
+        {
+            GTP_INFO("GT9XXF firmware file %s found!", path);
+            _CLOSE_FILE(update_msg.file);
+        }
+        while (ts->rqst_processing && (timeout++ < 5))
+        {
+            GTP_DEBUG("request processing, waiting for accomplishment");
+            msleep(1000);
+        }
+    }
+    GTP_INFO("Firmware update file path: %s", path);
+    
+    update_msg.file = filp_open(path, O_RDONLY, 0);
+
+    if (IS_ERR(update_msg.file))
+    {
+        GTP_ERROR("Open update file(%s) error!", path);
+        return FAIL;
+    }
+    
+    update_msg.old_fs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+    update_msg.fw_total_len = update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+    
+    update_msg.force_update = 0xBE;     // GT9XXF ignore the 0xBE 
+    if (update_msg.fw_total_len != sizeof(gtp_default_FW_fl))
+    {
+        GTP_ERROR("Inconsistent fw size. default size: %d(%dK), file size: %d(%dK)", sizeof(gtp_default_FW_fl), sizeof(gtp_default_FW_fl)/1024, update_msg.fw_total_len, update_msg.fw_total_len/1024);
+        set_fs(update_msg.old_fs);
+        _CLOSE_FILE(update_msg.file);
+        return FAIL;
+    }
+    
+    update_msg.fw_total_len -= FW_HEAD_LENGTH;
+    GTP_DEBUG("Fimrware size: %d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len / 1024);
+     
+    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+    ret = update_msg.file->f_op->read(update_msg.file, (char*)gtp_default_FW_fl, 
+                             update_msg.fw_total_len + FW_HEAD_LENGTH,
+                                &update_msg.file->f_pos);
+    set_fs(update_msg.old_fs);
+    _CLOSE_FILE(update_msg.file);
+    
+    if (ret < 0)
+    {
+        GTP_ERROR("read %s failed, err-code: %d", path, ret);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+static u8 gup_check_update_file_fl(struct i2c_client *client, st_fw_head* fw_head, char* path)
+{
+    s32 ret = 0;
+    s32 i = 0;
+    s32 fw_checksum = 0;
+    
+    if (NULL != path)
+    {
+        ret = gup_prepare_fl_fw(path, fw_head);
+        if (FAIL == ret)
+        {
+            return FAIL;
+        }
+    }
+
+    memcpy(fw_head, gtp_default_FW_fl, FW_HEAD_LENGTH);
+    GTP_INFO("FILE HARDWARE INFO: %02x%02x%02x%02x", fw_head->hw_info[0], fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+    GTP_INFO("FILE PID: %s", fw_head->pid);
+    fw_head->vid = ((fw_head->vid & 0xFF00) >> 8) + ((fw_head->vid & 0x00FF) << 8);
+    GTP_INFO("FILE VID: %04x", fw_head->vid);
+    
+    //check firmware legality
+    fw_checksum = 0;
+    for(i = FW_HEAD_LENGTH; i < (FW_HEAD_LENGTH + update_msg.fw_total_len); i += 2)
+    {
+        fw_checksum += (gtp_default_FW_fl[i] << 8) + gtp_default_FW_fl[i+1];
+    }
+    ret = SUCCESS;
+    
+    GTP_DEBUG("firmware checksum: %x", fw_checksum&0xFFFF);
+    if (fw_checksum & 0xFFFF)
+    {
+        GTP_ERROR("Illegal firmware file.");
+        ret = FAIL;
+    }
+    
+    return ret;
+}
+
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode)
+{
+    s32 ret = 0;
+    u8  retry = 0;
+    st_fw_head fw_head;
+    struct goodix_ts_data *ts;
+    
+    ts = i2c_get_clientdata(i2c_connect_client);
+    if (NULL == dir)
+    {
+        if(GTP_FL_FW_BURN == dwn_mode)       // GT9XXF firmware burn mode
+        {
+            GTP_INFO("[fw_download_proc]Begin fw download ......");
+        }
+        else if (GTP_FL_ESD_RECOVERY == dwn_mode)       // GTP_FL_ESD_RECOVERY: GT9XXF esd recovery mode
+        {
+            GTP_INFO("[fw_download_proc]Begin fw esd recovery check ......");
+        }       
+        else
+        {
+            GTP_INFO("[fw_download_proc]Being fw repair check......");
+        }
+    }  
+    else
+    {
+        GTP_INFO("[fw_download_proc]Begin firmware update by bin file");
+    }  
+    
+    total_len = 100;
+    show_len = 0;
+    
+    ret = gup_check_update_file_fl(i2c_connect_client, &fw_head, (char *)dir);
+    show_len = 10;
+    
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[fw_download_proc]check update file fail.");
+        goto file_fail;
+    }
+    
+    if (!memcmp(fw_head.pid, "950", 3))
+    {
+        ts->is_950 = 1;
+        GTP_DEBUG("GT9XXF Ic Type: gt950");
+    }
+    else
+    {
+        ts->is_950 = 0;
+    }
+    
+    if (NULL != dir)
+    {
+        gtp_irq_disable(ts);
+#if GTP_ESD_PROTECT
+        gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+    }
+    
+    ret = gup_enter_update_mode_fl(i2c_connect_client);
+    show_len = 20;
+    if (FAIL == ret)
+    {
+        GTP_ERROR("[fw_download_proc]enter update mode fail.");
+        goto download_fail;
+    }
+
+    while (retry++ < 5)
+    {
+        ret = gup_download_fw_ss51(i2c_connect_client, dwn_mode);
+        show_len = 60;
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[fw_download_proc]burn ss51 firmware fail.");
+            continue;
+        }
+
+        ret = gup_download_fw_dsp(i2c_connect_client, dwn_mode);
+        show_len = 80;
+        if (FAIL == ret)
+        {
+            GTP_ERROR("[fw_download_proc]burn dsp firmware fail.");
+            continue;
+        }
+
+        GTP_INFO("[fw_download_proc]UPDATE SUCCESS.");
+        break;
+    }
+
+    if (retry >= 5)
+    {
+        GTP_ERROR("[fw_download_proc]retry timeout,UPDATE FAIL.");
+        goto download_fail;
+    }
+
+    if (NULL != dir)
+    {
+        gtp_irq_enable(ts);
+        gtp_fw_startup(ts->client);     
+    #if GTP_ESD_PROTECT
+        gtp_esd_switch(ts->client, SWITCH_ON);
+    #endif
+    }
+    show_len = 100;
+    return SUCCESS;
+    
+download_fail:
+    if (NULL != dir)
+    {
+        gtp_irq_enable(ts);
+        gtp_fw_startup(ts->client);
+    #if GTP_ESD_PROTECT
+        gtp_esd_switch(ts->client, SWITCH_ON);
+    #endif
+    }
+file_fail:
+    show_len = 200;
+    
+    return FAIL;
+}
+
+#endif
+
+//**************** For GT9XXF End ********************//
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
old mode 100644
new mode 100755
index 159c6f6..9f95630
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -575,6 +575,20 @@ config LEDS_TRIGGER_SLEEP
 	help
 	  This turns LEDs on when the screen is off but the cpu still running.
 
+config ZTEMT_RGB_BREATH_LEDS
+  tristate "ZTEMT Support for rgb breath leds "
+	depends on LEDS_QPNP
+	default n
+	help
+	  This option enables support for rgb breath leds .  
+
+config ZTEMT_RGB_BREATH_LEDS_DEBUG
+  tristate "ZTEMT Support for rgb breath leds debug"
+	depends on ZTEMT_RGB_BREATH_LEDS
+	default n
+	help
+	  This option enables support for rgb breath leds debug.
+
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
old mode 100644
new mode 100755
index f20a0d0..9445745
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -67,3 +67,5 @@ obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
 obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o
+#add by ttwang for rgb breath leds
+obj-$(CONFIG_ZTEMT_RGB_BREATH_LEDS)	+= ztemt-leds-qpnp.o
diff --git a/drivers/leds/ztemt-leds-qpnp.c b/drivers/leds/ztemt-leds-qpnp.c
new file mode 100755
index 0000000..6624673
--- /dev/null
+++ b/drivers/leds/ztemt-leds-qpnp.c
@@ -0,0 +1,4101 @@
+
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/leds.h>
+#include <linux/err.h>
+#include <linux/spinlock.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/spmi.h>
+#include <linux/qpnp/pwm.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+
+#define WLED_MOD_EN_REG(base, n)	(base + 0x60 + n*0x10)
+#define WLED_IDAC_DLY_REG(base, n)	(WLED_MOD_EN_REG(base, n) + 0x01)
+#define WLED_FULL_SCALE_REG(base, n)	(WLED_IDAC_DLY_REG(base, n) + 0x01)
+#define WLED_MOD_SRC_SEL_REG(base, n)	(WLED_FULL_SCALE_REG(base, n) + 0x01)
+
+/* wled control registers */
+#define WLED_BRIGHTNESS_CNTL_LSB(base, n)	(base + 0x40 + 2*n)
+#define WLED_BRIGHTNESS_CNTL_MSB(base, n)	(base + 0x41 + 2*n)
+#define WLED_MOD_CTRL_REG(base)			(base + 0x46)
+#define WLED_SYNC_REG(base)			(base + 0x47)
+#define WLED_FDBCK_CTRL_REG(base)		(base + 0x48)
+#define WLED_SWITCHING_FREQ_REG(base)		(base + 0x4C)
+#define WLED_OVP_CFG_REG(base)			(base + 0x4D)
+#define WLED_BOOST_LIMIT_REG(base)		(base + 0x4E)
+#define WLED_CURR_SINK_REG(base)		(base + 0x4F)
+#define WLED_HIGH_POLE_CAP_REG(base)		(base + 0x58)
+#define WLED_CURR_SINK_MASK		0xE0
+#define WLED_CURR_SINK_SHFT		0x05
+#define WLED_DISABLE_ALL_SINKS		0x00
+#define WLED_SWITCH_FREQ_MASK		0x0F
+#define WLED_OVP_VAL_MASK		0x03
+#define WLED_OVP_VAL_BIT_SHFT		0x00
+#define WLED_BOOST_LIMIT_MASK		0x07
+#define WLED_BOOST_LIMIT_BIT_SHFT	0x00
+#define WLED_BOOST_ON			0x80
+#define WLED_BOOST_OFF			0x00
+#define WLED_EN_MASK			0x80
+#define WLED_NO_MASK			0x00
+#define WLED_CP_SELECT_MAX		0x03
+#define WLED_CP_SELECT_MASK		0x02
+#define WLED_USE_EXT_GEN_MOD_SRC	0x01
+#define WLED_CTL_DLY_STEP		200
+#define WLED_CTL_DLY_MAX		1400
+#define WLED_MAX_CURR			25
+#define WLED_NO_CURRENT			0x00
+#define WLED_OVP_DELAY			1000
+#define WLED_MSB_MASK			0x0F
+#define WLED_MAX_CURR_MASK		0x1F
+#define WLED_OP_FDBCK_MASK		0x07
+#define WLED_OP_FDBCK_BIT_SHFT		0x00
+#define WLED_OP_FDBCK_DEFAULT		0x00
+
+#define WLED_MAX_LEVEL			4095
+#define WLED_8_BIT_MASK			0xFF
+#define WLED_4_BIT_MASK			0x0F
+#define WLED_8_BIT_SHFT			0x08
+#define WLED_MAX_DUTY_CYCLE		0xFFF
+
+#define WLED_SYNC_VAL			0x07
+#define WLED_SYNC_RESET_VAL		0x00
+
+#define PMIC_VER_8026			0x04
+#define PMIC_VERSION_REG		0x0105
+
+#define WLED_DEFAULT_STRINGS		0x01
+#define WLED_DEFAULT_OVP_VAL		0x02
+#define WLED_BOOST_LIM_DEFAULT		0x03
+#define WLED_CP_SEL_DEFAULT		0x00
+#define WLED_CTRL_DLY_DEFAULT		0x00
+#define WLED_SWITCH_FREQ_DEFAULT	0x0B
+
+#define FLASH_SAFETY_TIMER(base)	(base + 0x40)
+#define FLASH_MAX_CURR(base)		(base + 0x41)
+#define FLASH_LED_0_CURR(base)		(base + 0x42)
+#define FLASH_LED_1_CURR(base)		(base + 0x43)
+#define FLASH_CLAMP_CURR(base)		(base + 0x44)
+#define FLASH_LED_TMR_CTRL(base)	(base + 0x48)
+#define FLASH_HEADROOM(base)		(base + 0x4A)
+#define FLASH_STARTUP_DELAY(base)	(base + 0x4B)
+#define FLASH_MASK_ENABLE(base)		(base + 0x4C)
+#define FLASH_VREG_OK_FORCE(base)	(base + 0x4F)
+#define FLASH_ENABLE_CONTROL(base)	(base + 0x46)
+#define FLASH_LED_STROBE_CTRL(base)	(base + 0x47)
+#define FLASH_LED_UNLOCK_SECURE(base)	(base + 0xD0)
+#define FLASH_LED_TORCH(base)		(base + 0xE4)
+#define FLASH_FAULT_DETECT(base)	(base + 0x51)
+#define FLASH_PERIPHERAL_SUBTYPE(base)	(base + 0x05)
+#define FLASH_CURRENT_RAMP(base)	(base + 0x54)
+
+#define FLASH_MAX_LEVEL			0x4F
+#define TORCH_MAX_LEVEL			0x0F
+#define	FLASH_NO_MASK			0x00
+
+#define FLASH_MASK_1			0x20
+#define FLASH_MASK_REG_MASK		0xE0
+#define FLASH_HEADROOM_MASK		0x03
+#define FLASH_SAFETY_TIMER_MASK		0x7F
+#define FLASH_CURRENT_MASK		0xFF
+#define FLASH_MAX_CURRENT_MASK		0x7F
+#define FLASH_TMR_MASK			0x03
+#define FLASH_TMR_WATCHDOG		0x03
+#define FLASH_TMR_SAFETY		0x00
+#define FLASH_FAULT_DETECT_MASK		0X80
+#define FLASH_HW_VREG_OK		0x40
+#define FLASH_VREG_MASK			0xC0
+#define FLASH_STARTUP_DLY_MASK		0x02
+#define FLASH_CURRENT_RAMP_MASK		0xBF
+
+#define FLASH_ENABLE_ALL		0xE0
+#define FLASH_ENABLE_MODULE		0x80
+#define FLASH_ENABLE_MODULE_MASK	0x80
+#define FLASH_DISABLE_ALL		0x00
+#define FLASH_ENABLE_MASK		0xE0
+#define FLASH_ENABLE_LED_0		0xC0
+#define FLASH_ENABLE_LED_1		0xA0
+#define FLASH_INIT_MASK			0xE0
+#define	FLASH_SELFCHECK_ENABLE		0x80
+#define FLASH_RAMP_STEP_27US		0xBF
+
+#define FLASH_HW_SW_STROBE_SEL_MASK	0x04
+#define FLASH_STROBE_MASK		0xC7
+#define FLASH_LED_0_OUTPUT		0x80
+#define FLASH_LED_1_OUTPUT		0x40
+#define FLASH_TORCH_OUTPUT		0xC0
+
+#define FLASH_CURRENT_PRGM_MIN		1
+#define FLASH_CURRENT_PRGM_SHIFT	1
+#define FLASH_CURRENT_MAX		0x4F
+#define FLASH_CURRENT_TORCH		0x07
+
+#define FLASH_DURATION_200ms		0x13
+#define FLASH_CLAMP_200mA		0x0F
+
+#define FLASH_TORCH_MASK		0x03
+#define FLASH_LED_TORCH_ENABLE		0x00
+#define FLASH_LED_TORCH_DISABLE		0x03
+#define FLASH_UNLOCK_SECURE		0xA5
+#define FLASH_SECURE_MASK		0xFF
+
+#define FLASH_SUBTYPE_DUAL		0x01
+#define FLASH_SUBTYPE_SINGLE		0x02
+
+#define FLASH_RAMP_UP_DELAY_US		1000
+#define FLASH_RAMP_DN_DELAY_US		2160
+
+#define LED_TRIGGER_DEFAULT		"none"
+
+#define RGB_LED_SRC_SEL(base)		(base + 0x45)
+#define RGB_LED_EN_CTL(base)		(base + 0x46)
+#define RGB_LED_ATC_CTL(base)		(base + 0x47)
+
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+#define ZTEMT_RGB_BREATH_LED_FULL    255
+#define RGB_MAX_LEVEL			ZTEMT_RGB_BREATH_LED_FULL
+#else
+#define RGB_MAX_LEVEL			LED_FULL
+#endif
+#define RGB_LED_ENABLE_RED		0x80
+#define RGB_LED_ENABLE_GREEN		0x40
+#define RGB_LED_ENABLE_BLUE		0x20
+#define RGB_LED_SOURCE_VPH_PWR		0x01
+#define RGB_LED_ENABLE_MASK		0xE0
+#define RGB_LED_SRC_MASK		0x03
+#define QPNP_LED_PWM_FLAGS	(PM_PWM_LUT_LOOP | PM_PWM_LUT_RAMP_UP)
+#define QPNP_LUT_RAMP_STEP_DEFAULT	255
+#define	PWM_LUT_MAX_SIZE		63
+#define	PWM_GPLED_LUT_MAX_SIZE		31
+#define RGB_LED_DISABLE			0x00
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+static u32 ztemt_lpg_pm_pwm_period=1000;
+//static u32 ztemt_lpg_pm_pwm_period=7;
+static u32 ztemt_lpg_brightness_step=4;
+#endif
+
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+//#define ZTEMT_RGB_BREATH_LED_FULL    255
+#define MPP_MAX_LEVEL			ZTEMT_RGB_BREATH_LED_FULL
+#else
+#define MPP_MAX_LEVEL			LED_FULL
+#endif
+
+#define LED_MPP_MODE_CTRL(base)		(base + 0x40)
+#define LED_MPP_VIN_CTRL(base)		(base + 0x41)
+#define LED_MPP_EN_CTRL(base)		(base + 0x46)
+#define LED_MPP_SINK_CTRL(base)		(base + 0x4C)
+
+#define LED_MPP_CURRENT_MIN		5
+#define LED_MPP_CURRENT_MAX		40
+#define LED_MPP_VIN_CTRL_DEFAULT	0
+#define LED_MPP_CURRENT_PER_SETTING	5
+#define LED_MPP_SOURCE_SEL_DEFAULT	LED_MPP_MODE_ENABLE
+
+#define LED_MPP_SINK_MASK		0x07
+#define LED_MPP_MODE_MASK		0x7F
+#define LED_MPP_VIN_MASK		0x03
+#define LED_MPP_EN_MASK			0x80
+#define LED_MPP_SRC_MASK		0x0F
+#define LED_MPP_MODE_CTRL_MASK		0x70
+
+#define LED_MPP_MODE_SINK		(0x06 << 4)
+#define LED_MPP_MODE_ENABLE		0x01
+#define LED_MPP_MODE_OUTPUT		0x10
+#define LED_MPP_MODE_DISABLE		0x00
+#define LED_MPP_EN_ENABLE		0x80
+#define LED_MPP_EN_DISABLE		0x00
+
+#define MPP_SOURCE_DTEST1		0x08
+
+#define KPDBL_MAX_LEVEL			LED_FULL
+#define KPDBL_ROW_SRC_SEL(base)		(base + 0x40)
+#define KPDBL_ENABLE(base)		(base + 0x46)
+#define KPDBL_ROW_SRC(base)		(base + 0xE5)
+
+#define KPDBL_ROW_SRC_SEL_VAL_MASK	0x0F
+#define KPDBL_ROW_SCAN_EN_MASK		0x80
+#define KPDBL_ROW_SCAN_VAL_MASK		0x0F
+#define KPDBL_ROW_SCAN_EN_SHIFT		7
+#define KPDBL_MODULE_EN			0x80
+#define KPDBL_MODULE_DIS		0x00
+#define KPDBL_MODULE_EN_MASK		0x80
+
+/**
+ * enum qpnp_leds - QPNP supported led ids
+ * @QPNP_ID_WLED - White led backlight
+ */
+enum qpnp_leds {
+	QPNP_ID_WLED = 0,
+	QPNP_ID_FLASH1_LED0,
+	QPNP_ID_FLASH1_LED1,
+	QPNP_ID_RGB_RED,
+	QPNP_ID_RGB_GREEN,
+	QPNP_ID_RGB_BLUE,
+	QPNP_ID_LED_MPP,
+	QPNP_ID_KPDBL,
+	QPNP_ID_MAX,
+};
+
+/* current boost limit */
+enum wled_current_boost_limit {
+	WLED_CURR_LIMIT_105mA,
+	WLED_CURR_LIMIT_385mA,
+	WLED_CURR_LIMIT_525mA,
+	WLED_CURR_LIMIT_805mA,
+	WLED_CURR_LIMIT_980mA,
+	WLED_CURR_LIMIT_1260mA,
+	WLED_CURR_LIMIT_1400mA,
+	WLED_CURR_LIMIT_1680mA,
+};
+
+/* over voltage protection threshold */
+enum wled_ovp_threshold {
+	WLED_OVP_35V,
+	WLED_OVP_32V,
+	WLED_OVP_29V,
+	WLED_OVP_27V,
+};
+
+enum flash_headroom {
+	HEADROOM_250mV = 0,
+	HEADROOM_300mV,
+	HEADROOM_400mV,
+	HEADROOM_500mV,
+};
+
+enum flash_startup_dly {
+	DELAY_10us = 0,
+	DELAY_32us,
+	DELAY_64us,
+	DELAY_128us,
+};
+
+enum led_mode {
+	PWM_MODE = 0,
+	LPG_MODE,
+	MANUAL_MODE,
+};
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+enum rgb_led_mode {	
+    RGB_LED_MODE_CLOSED = 0,
+    RGB_LED_MODE_NORMAL,
+    RGB_LED_MODE_OFF,
+    RGB_LED_MODE_CHARGE_BREATH,
+    RGB_LED_MODE_POWER_ON,
+    RGB_LED_MODE_POWER_OFF,
+    RGB_LED_MODE_BREATH_BLINK,	
+};
+
+struct pwm_device   *pwm_dev_red=NULL;
+struct pwm_device   *pwm_dev_green=NULL;
+struct pwm_device   *pwm_dev_blue=NULL;
+
+enum channel_num{ 
+//	CHANNEL_RED=16,
+//	CHANNEL_GREEN=32,
+//	CHANNEL_BULE=8,
+	CHANNEL_RED=116,
+	CHANNEL_GREEN=132,
+	CHANNEL_BULE=18,
+	CHANNEL_MPP=16,
+};
+
+static int  ztemt_channel;
+
+#define GRADE_PARAM_LEN 20
+#define CONST_MIN_GRADE  10
+#define CONST_MAX_GRADE  200
+static int min_grade = CONST_MIN_GRADE;
+static int max_grade = CONST_MAX_GRADE;
+static char grade_parameter[GRADE_PARAM_LEN];
+
+#define FADE_PARAM_LEN 20
+static int fade_time= 2;
+static int fullon_time= 0;
+static int fulloff_time= 0;
+static char fade_parameter[FADE_PARAM_LEN];
+
+#endif
+
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS_DEBUG
+#define ztemt_rgb_led_debug(fmt, args...) printk(KERN_DEBUG "[ztemt_rgb_led_debug]"fmt, ##args)
+#else
+#define ztemt_rgb_led_debug(fmt, args...) do {} while(0)
+#endif
+
+static u8 wled_debug_regs[] = {
+	/* common registers */
+	0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+	/* LED1 */
+	0x60, 0x61, 0x62, 0x63, 0x66,
+	/* LED2 */
+	0x70, 0x71, 0x72, 0x73, 0x76,
+	/* LED3 */
+	0x80, 0x81, 0x82, 0x83, 0x86,
+};
+
+static u8 flash_debug_regs[] = {
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x48, 0x49, 0x4b, 0x4c,
+	0x4f, 0x46, 0x47,
+};
+
+static u8 rgb_pwm_debug_regs[] = {
+	0x45, 0x46, 0x47,
+};
+
+static u8 mpp_debug_regs[] = {
+	0x40, 0x41, 0x42, 0x45, 0x46, 0x4c,
+};
+
+static u8 kpdbl_debug_regs[] = {
+	0x40, 0x46, 0xb1, 0xb3, 0xb4, 0xe5,
+};
+
+/**
+ *  pwm_config_data - pwm configuration data
+ *  @lut_params - lut parameters to be used by pwm driver
+ *  @pwm_device - pwm device
+ *  @pwm_channel - pwm channel to be configured for led
+ *  @pwm_period_us - period for pwm, in us
+ *  @mode - mode the led operates in
+ *  @old_duty_pcts - storage for duty pcts that may need to be reused
+ *  @default_mode - default mode of LED as set in device tree
+ *  @use_blink - use blink sysfs entry
+ *  @blinking - device is currently blinking w/LPG mode
+ */
+struct pwm_config_data {
+	struct lut_params	lut_params;
+	struct pwm_device	*pwm_dev;
+	int			pwm_channel;
+	u32			pwm_period_us;
+	struct pwm_duty_cycles	*duty_cycles;
+	int	*old_duty_pcts;
+	u8	mode;
+	u8	default_mode;
+	bool use_blink;
+	bool blinking;
+};
+
+/**
+ *  wled_config_data - wled configuration data
+ *  @num_strings - number of wled strings supported
+ *  @ovp_val - over voltage protection threshold
+ *  @boost_curr_lim - boot current limit
+ *  @cp_select - high pole capacitance
+ *  @ctrl_delay_us - delay in activation of led
+ *  @dig_mod_gen_en - digital module generator
+ *  @cs_out_en - current sink output enable
+ *  @op_fdbck - selection of output as feedback for the boost
+ */
+struct wled_config_data {
+	u8	num_strings;
+	u8	ovp_val;
+	u8	boost_curr_lim;
+	u8	cp_select;
+	u8	ctrl_delay_us;
+	u8	switch_freq;
+	u8	op_fdbck;
+	u8	pmic_version;
+	bool	dig_mod_gen_en;
+	bool	cs_out_en;
+};
+
+/**
+ *  mpp_config_data - mpp configuration data
+ *  @pwm_cfg - device pwm configuration
+ *  @current_setting - current setting, 5ma-40ma in 5ma increments
+ *  @source_sel - source selection
+ *  @mode_ctrl - mode control
+ *  @vin_ctrl - input control
+ *  @min_brightness - minimum brightness supported
+ *  @pwm_mode - pwm mode in use
+ */
+struct mpp_config_data {
+	struct pwm_config_data	*pwm_cfg;
+	u8	current_setting;
+	u8	source_sel;
+	u8	mode_ctrl;
+	u8	vin_ctrl;
+	u8	min_brightness;
+	u8 pwm_mode;
+};
+
+/**
+ *  flash_config_data - flash configuration data
+ *  @current_prgm - current to be programmed, scaled by max level
+ *  @clamp_curr - clamp current to use
+ *  @headroom - headroom value to use
+ *  @duration - duration of the flash
+ *  @enable_module - enable address for particular flash
+ *  @trigger_flash - trigger flash
+ *  @startup_dly - startup delay for flash
+ *  @strobe_type - select between sw and hw strobe
+ *  @peripheral_subtype - module peripheral subtype
+ *  @current_addr - address to write for current
+ *  @second_addr - address of secondary flash to be written
+ *  @safety_timer - enable safety timer or watchdog timer
+ *  @torch_enable - enable flash LED torch mode
+ *  @flash_reg_get - flash regulator attached or not
+ *  @flash_on - flash status, on or off
+ *  @torch_on - torch status, on or off
+ *  @flash_boost_reg - boost regulator for flash
+ *  @torch_boost_reg - boost regulator for torch
+ */
+struct flash_config_data {
+	u8	current_prgm;
+	u8	clamp_curr;
+	u8	headroom;
+	u8	duration;
+	u8	enable_module;
+	u8	trigger_flash;
+	u8	startup_dly;
+	u8	strobe_type;
+	u8	peripheral_subtype;
+	u16	current_addr;
+	u16	second_addr;
+	bool	safety_timer;
+	bool	torch_enable;
+	bool	flash_reg_get;
+	bool	flash_on;
+	bool	torch_on;
+	struct regulator *flash_boost_reg;
+	struct regulator *torch_boost_reg;
+};
+
+/**
+ *  kpdbl_config_data - kpdbl configuration data
+ *  @pwm_cfg - device pwm configuration
+ *  @mode - running mode: pwm or lut
+ *  @row_id - row id of the led
+ *  @row_src_vbst - 0 for vph_pwr and 1 for vbst
+ *  @row_src_en - enable row source
+ *  @always_on - always on row
+ *  @lut_params - lut parameters to be used by pwm driver
+ *  @duty_cycles - duty cycles for lut
+ */
+struct kpdbl_config_data {
+	struct pwm_config_data	*pwm_cfg;
+	u32	row_id;
+	bool	row_src_vbst;
+	bool	row_src_en;
+	bool	always_on;
+	struct pwm_duty_cycles  *duty_cycles;
+	struct lut_params	lut_params;
+};
+
+/**
+ *  rgb_config_data - rgb configuration data
+ *  @pwm_cfg - device pwm configuration
+ *  @enable - bits to enable led
+ */
+struct rgb_config_data {
+	struct pwm_config_data	*pwm_cfg;
+	u8	enable;
+};
+
+/**
+ * struct qpnp_led_data - internal led data structure
+ * @led_classdev - led class device
+ * @delayed_work - delayed work for turning off the LED
+ * @work - workqueue for led
+ * @id - led index
+ * @base_reg - base register given in device tree
+ * @lock - to protect the transactions
+ * @reg - cached value of led register
+ * @num_leds - number of leds in the module
+ * @max_current - maximum current supported by LED
+ * @default_on - true: default state max, false, default state 0
+ * @turn_off_delay_ms - number of msec before turning off the LED
+ */
+struct qpnp_led_data {
+	struct led_classdev	cdev;
+	struct spmi_device	*spmi_dev;
+	struct delayed_work	dwork;
+	struct work_struct	work;
+	int			id;
+	u16			base;
+	u8			reg;
+	u8			num_leds;
+	struct mutex		lock;
+	struct wled_config_data *wled_cfg;
+	struct flash_config_data	*flash_cfg;
+	struct kpdbl_config_data	*kpdbl_cfg;
+	struct rgb_config_data	*rgb_cfg;
+	struct mpp_config_data	*mpp_cfg;
+	int			max_current;
+	bool			default_on;
+	int			turn_off_delay_ms;
+};
+
+static int num_kpbl_leds_on;
+
+static int
+qpnp_led_masked_write(struct qpnp_led_data *led, u16 addr, u8 mask, u8 val)
+{
+	int rc;
+	u8 reg;
+
+	rc = spmi_ext_register_readl(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		addr, &reg, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read from addr=%x, rc(%d)\n", addr, rc);
+	}
+
+	reg &= ~mask;
+	reg |= val;
+
+	rc = spmi_ext_register_writel(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		addr, &reg, 1);
+	if (rc)
+		dev_err(&led->spmi_dev->dev,
+			"Unable to write to addr=%x, rc(%d)\n", addr, rc);
+	return rc;
+}
+
+static void qpnp_dump_regs(struct qpnp_led_data *led, u8 regs[], u8 array_size)
+{
+	int i;
+	u8 val;
+
+	pr_debug("===== %s LED register dump start =====\n", led->cdev.name);
+	for (i = 0; i < array_size; i++) {
+		spmi_ext_register_readl(led->spmi_dev->ctrl,
+					led->spmi_dev->sid,
+					led->base + regs[i],
+					&val, sizeof(val));
+		pr_debug("%s: 0x%x = 0x%x\n", led->cdev.name,
+					led->base + regs[i], val);
+	}
+	pr_debug("===== %s LED register dump end =====\n", led->cdev.name);
+}
+
+static int qpnp_wled_sync(struct qpnp_led_data *led)
+{
+	int rc;
+	u8 val;
+
+	/* sync */
+	val = WLED_SYNC_VAL;
+	rc = spmi_ext_register_writel(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		WLED_SYNC_REG(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED set sync reg failed(%d)\n", rc);
+		return rc;
+	}
+
+	val = WLED_SYNC_RESET_VAL;
+	rc = spmi_ext_register_writel(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		WLED_SYNC_REG(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED reset sync reg failed(%d)\n", rc);
+		return rc;
+	}
+	return 0;
+}
+
+static int qpnp_wled_set(struct qpnp_led_data *led)
+{
+	int rc, duty, level;
+	u8 val, i, num_wled_strings, sink_val;
+
+	num_wled_strings = led->wled_cfg->num_strings;
+
+	level = led->cdev.brightness;
+
+	if (level > WLED_MAX_LEVEL)
+		level = WLED_MAX_LEVEL;
+	if (level == 0) {
+		for (i = 0; i < num_wled_strings; i++) {
+			rc = qpnp_led_masked_write(led,
+				WLED_FULL_SCALE_REG(led->base, i),
+				WLED_MAX_CURR_MASK, WLED_NO_CURRENT);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Write max current failure (%d)\n",
+					rc);
+				return rc;
+			}
+		}
+
+		rc = qpnp_wled_sync(led);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED sync failed(%d)\n", rc);
+			return rc;
+		}
+
+		rc = spmi_ext_register_readl(led->spmi_dev->ctrl,
+			led->spmi_dev->sid, WLED_CURR_SINK_REG(led->base),
+			&sink_val, 1);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED read sink reg failed(%d)\n", rc);
+			return rc;
+		}
+
+		if (led->wled_cfg->pmic_version == PMIC_VER_8026) {
+			val = WLED_DISABLE_ALL_SINKS;
+			rc = spmi_ext_register_writel(led->spmi_dev->ctrl,
+				led->spmi_dev->sid,
+				WLED_CURR_SINK_REG(led->base), &val, 1);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"WLED write sink reg failed(%d)\n", rc);
+				return rc;
+			}
+
+			usleep(WLED_OVP_DELAY);
+		}
+
+		val = WLED_BOOST_OFF;
+		rc = spmi_ext_register_writel(led->spmi_dev->ctrl,
+			led->spmi_dev->sid, WLED_MOD_CTRL_REG(led->base),
+			&val, 1);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED write ctrl reg failed(%d)\n", rc);
+			return rc;
+		}
+
+		for (i = 0; i < num_wled_strings; i++) {
+			rc = qpnp_led_masked_write(led,
+				WLED_FULL_SCALE_REG(led->base, i),
+				WLED_MAX_CURR_MASK, led->max_current);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Write max current failure (%d)\n",
+					rc);
+				return rc;
+			}
+		}
+
+		rc = qpnp_wled_sync(led);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED sync failed(%d)\n", rc);
+			return rc;
+		}
+
+		rc = spmi_ext_register_writel(led->spmi_dev->ctrl,
+			led->spmi_dev->sid, WLED_CURR_SINK_REG(led->base),
+			&sink_val, 1);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED write sink reg failed(%d)\n", rc);
+			return rc;
+		}
+
+	} else {
+		val = WLED_BOOST_ON;
+		rc = spmi_ext_register_writel(led->spmi_dev->ctrl,
+			led->spmi_dev->sid, WLED_MOD_CTRL_REG(led->base),
+			&val, 1);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED write ctrl reg failed(%d)\n", rc);
+			return rc;
+		}
+	}
+
+	duty = (WLED_MAX_DUTY_CYCLE * level) / WLED_MAX_LEVEL;
+
+	/* program brightness control registers */
+	for (i = 0; i < num_wled_strings; i++) {
+		rc = qpnp_led_masked_write(led,
+			WLED_BRIGHTNESS_CNTL_MSB(led->base, i), WLED_MSB_MASK,
+			(duty >> WLED_8_BIT_SHFT) & WLED_4_BIT_MASK);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED set brightness MSB failed(%d)\n", rc);
+			return rc;
+		}
+		val = duty & WLED_8_BIT_MASK;
+		rc = spmi_ext_register_writel(led->spmi_dev->ctrl,
+			led->spmi_dev->sid,
+			WLED_BRIGHTNESS_CNTL_LSB(led->base, i), &val, 1);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED set brightness LSB failed(%d)\n", rc);
+			return rc;
+		}
+	}
+
+	rc = qpnp_wled_sync(led);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev, "WLED sync failed(%d)\n", rc);
+		return rc;
+	}
+	return 0;
+}
+
+static int qpnp_mpp_set(struct qpnp_led_data *led)
+{
+	int rc;
+	u8 val;
+	int duty_us, duty_ns, period_us;
+
+	if (led->cdev.brightness) {
+		if (led->cdev.brightness < led->mpp_cfg->min_brightness) {
+			dev_warn(&led->spmi_dev->dev,
+				"brightness is less than supported..." \
+				"set to minimum supported\n");
+			led->cdev.brightness = led->mpp_cfg->min_brightness;
+		}
+
+		if (led->mpp_cfg->pwm_mode != MANUAL_MODE) {
+			if (!led->mpp_cfg->pwm_cfg->blinking) {
+				led->mpp_cfg->pwm_cfg->mode =
+					led->mpp_cfg->pwm_cfg->default_mode;
+				led->mpp_cfg->pwm_mode =
+					led->mpp_cfg->pwm_cfg->default_mode;
+			}
+		}
+		if (led->mpp_cfg->pwm_mode == PWM_MODE) {
+			/*config pwm for brightness scaling*/
+			period_us = led->mpp_cfg->pwm_cfg->pwm_period_us;
+			if (period_us > INT_MAX / NSEC_PER_USEC) {
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+                duty_us = (period_us * led->cdev.brightness) /
+	                ZTEMT_RGB_BREATH_LED_FULL;
+#else
+				duty_us = (period_us * led->cdev.brightness) /
+					LED_FULL;
+#endif				
+				rc = pwm_config_us(
+					led->mpp_cfg->pwm_cfg->pwm_dev,
+					duty_us,
+					period_us);
+			} else {
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS			
+				duty_ns = ((period_us * NSEC_PER_USEC) /
+					ZTEMT_RGB_BREATH_LED_FULL) * led->cdev.brightness;
+#else
+                duty_ns = ((period_us * NSEC_PER_USEC) /
+	                LED_FULL) * led->cdev.brightness;
+#endif
+				rc = pwm_config(
+					led->mpp_cfg->pwm_cfg->pwm_dev,
+					duty_ns,
+					period_us * NSEC_PER_USEC);
+			}
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev, "Failed to " \
+					"configure pwm for new values\n");
+				return rc;
+			}
+		}
+
+		if (led->mpp_cfg->pwm_mode != MANUAL_MODE)
+			pwm_enable(led->mpp_cfg->pwm_cfg->pwm_dev);
+		else {
+			if (led->cdev.brightness < LED_MPP_CURRENT_MIN)
+				led->cdev.brightness = LED_MPP_CURRENT_MIN;
+
+			val = (led->cdev.brightness / LED_MPP_CURRENT_MIN) - 1;
+
+			rc = qpnp_led_masked_write(led,
+					LED_MPP_SINK_CTRL(led->base),
+					LED_MPP_SINK_MASK, val);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Failed to write sink control reg\n");
+				return rc;
+			}
+		}
+
+		val = (led->mpp_cfg->source_sel & LED_MPP_SRC_MASK) |
+			(led->mpp_cfg->mode_ctrl & LED_MPP_MODE_CTRL_MASK);
+
+		rc = qpnp_led_masked_write(led,
+			LED_MPP_MODE_CTRL(led->base), LED_MPP_MODE_MASK,
+			val);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+					"Failed to write led mode reg\n");
+			return rc;
+		}
+
+		rc = qpnp_led_masked_write(led,
+				LED_MPP_EN_CTRL(led->base), LED_MPP_EN_MASK,
+				LED_MPP_EN_ENABLE);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+					"Failed to write led enable " \
+					"reg\n");
+			return rc;
+		}
+	} else {
+		if (led->mpp_cfg->pwm_mode != MANUAL_MODE) {
+			led->mpp_cfg->pwm_cfg->mode =
+				led->mpp_cfg->pwm_cfg->default_mode;
+			led->mpp_cfg->pwm_mode =
+				led->mpp_cfg->pwm_cfg->default_mode;
+			pwm_disable(led->mpp_cfg->pwm_cfg->pwm_dev);
+		}
+		rc = qpnp_led_masked_write(led,
+					LED_MPP_MODE_CTRL(led->base),
+					LED_MPP_MODE_MASK,
+					LED_MPP_MODE_DISABLE);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+					"Failed to write led mode reg\n");
+			return rc;
+		}
+
+		rc = qpnp_led_masked_write(led,
+					LED_MPP_EN_CTRL(led->base),
+					LED_MPP_EN_MASK,
+					LED_MPP_EN_DISABLE);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+					"Failed to write led enable reg\n");
+			return rc;
+		}
+	}
+
+	if (led->mpp_cfg->pwm_mode != MANUAL_MODE)
+		led->mpp_cfg->pwm_cfg->blinking = false;
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+   if(0){
+	qpnp_dump_regs(led, mpp_debug_regs, ARRAY_SIZE(mpp_debug_regs));
+    }
+#else
+	qpnp_dump_regs(led, mpp_debug_regs, ARRAY_SIZE(mpp_debug_regs));
+#endif
+	return 0;
+}
+
+static int qpnp_flash_regulator_operate(struct qpnp_led_data *led, bool on)
+{
+	int rc, i;
+	struct qpnp_led_data *led_array;
+	bool regulator_on = false;
+
+	led_array = dev_get_drvdata(&led->spmi_dev->dev);
+	if (!led_array) {
+		dev_err(&led->spmi_dev->dev,
+				"Unable to get LED array\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < led->num_leds; i++)
+		regulator_on |= led_array[i].flash_cfg->flash_on;
+
+	if (!on)
+		goto regulator_turn_off;
+
+	if (!regulator_on && !led->flash_cfg->flash_on) {
+		for (i = 0; i < led->num_leds; i++) {
+			if (led_array[i].flash_cfg->flash_reg_get) {
+				rc = regulator_enable(
+					led_array[i].flash_cfg->\
+					flash_boost_reg);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+						"Regulator enable failed(%d)\n",
+									rc);
+					return rc;
+				}
+				led->flash_cfg->flash_on = true;
+			}
+			break;
+		}
+	}
+
+	return 0;
+
+regulator_turn_off:
+	if (regulator_on && led->flash_cfg->flash_on) {
+		for (i = 0; i < led->num_leds; i++) {
+			if (led_array[i].flash_cfg->flash_reg_get) {
+				rc = qpnp_led_masked_write(led,
+					FLASH_ENABLE_CONTROL(led->base),
+					FLASH_ENABLE_MASK,
+					FLASH_DISABLE_ALL);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+						"Enable reg write failed(%d)\n",
+						rc);
+				}
+
+				rc = regulator_disable(led_array[i].flash_cfg->\
+							flash_boost_reg);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+						"Regulator disable failed(%d)\n",
+									rc);
+					return rc;
+				}
+				led->flash_cfg->flash_on = false;
+			}
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int qpnp_torch_regulator_operate(struct qpnp_led_data *led, bool on)
+{
+	int rc;
+
+	if (!on)
+		goto regulator_turn_off;
+
+	if (!led->flash_cfg->torch_on) {
+		rc = regulator_enable(led->flash_cfg->torch_boost_reg);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Regulator enable failed(%d)\n", rc);
+				return rc;
+		}
+		led->flash_cfg->torch_on = true;
+	}
+	return 0;
+
+regulator_turn_off:
+	if (led->flash_cfg->torch_on) {
+		rc = qpnp_led_masked_write(led,	FLASH_ENABLE_CONTROL(led->base),
+				FLASH_ENABLE_MODULE_MASK, FLASH_DISABLE_ALL);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Enable reg write failed(%d)\n", rc);
+		}
+
+		rc = regulator_disable(led->flash_cfg->torch_boost_reg);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Regulator disable failed(%d)\n", rc);
+			return rc;
+		}
+		led->flash_cfg->torch_on = false;
+	}
+	return 0;
+}
+
+static int qpnp_flash_set(struct qpnp_led_data *led)
+{
+	int rc, error;
+	int val = led->cdev.brightness;
+
+	if (led->flash_cfg->torch_enable)
+		led->flash_cfg->current_prgm =
+			(val * TORCH_MAX_LEVEL / led->max_current);
+	else
+		led->flash_cfg->current_prgm =
+			(val * FLASH_MAX_LEVEL / led->max_current);
+
+	/* Set led current */
+	if (val > 0) {
+		if (led->flash_cfg->torch_enable) {
+			if (led->flash_cfg->peripheral_subtype ==
+							FLASH_SUBTYPE_DUAL) {
+				rc = qpnp_torch_regulator_operate(led, true);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+					"Torch regulator operate failed(%d)\n",
+					rc);
+					return rc;
+				}
+			} else if (led->flash_cfg->peripheral_subtype ==
+							FLASH_SUBTYPE_SINGLE) {
+				rc = qpnp_flash_regulator_operate(led, true);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+					"Flash regulator operate failed(%d)\n",
+					rc);
+					goto error_flash_set;
+				}
+			}
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_LED_UNLOCK_SECURE(led->base),
+				FLASH_SECURE_MASK, FLASH_UNLOCK_SECURE);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Secure reg write failed(%d)\n", rc);
+				goto error_reg_write;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_LED_TORCH(led->base),
+				FLASH_TORCH_MASK, FLASH_LED_TORCH_ENABLE);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Torch reg write failed(%d)\n", rc);
+				goto error_reg_write;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				led->flash_cfg->current_addr,
+				FLASH_CURRENT_MASK,
+				led->flash_cfg->current_prgm);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Current reg write failed(%d)\n", rc);
+				goto error_reg_write;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				led->flash_cfg->second_addr,
+				FLASH_CURRENT_MASK,
+				led->flash_cfg->current_prgm);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"2nd Current reg write failed(%d)\n",
+					rc);
+				goto error_reg_write;
+			}
+
+			qpnp_led_masked_write(led, FLASH_MAX_CURR(led->base),
+				FLASH_CURRENT_MASK,
+				TORCH_MAX_LEVEL);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Max current reg write failed(%d)\n",
+					rc);
+				goto error_reg_write;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_ENABLE_CONTROL(led->base),
+				FLASH_ENABLE_MASK,
+				led->flash_cfg->enable_module);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Enable reg write failed(%d)\n",
+					rc);
+				goto error_reg_write;
+			}
+
+			if (!led->flash_cfg->strobe_type)
+				led->flash_cfg->trigger_flash &=
+						~FLASH_HW_SW_STROBE_SEL_MASK;
+			else
+				led->flash_cfg->trigger_flash |=
+						FLASH_HW_SW_STROBE_SEL_MASK;
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_LED_STROBE_CTRL(led->base),
+				led->flash_cfg->trigger_flash,
+				led->flash_cfg->trigger_flash);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"LED %d strobe reg write failed(%d)\n",
+					led->id, rc);
+				goto error_reg_write;
+			}
+		} else {
+			rc = qpnp_flash_regulator_operate(led, true);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Flash regulator operate failed(%d)\n",
+					rc);
+				goto error_flash_set;
+			}
+
+			/* Set flash safety timer */
+			rc = qpnp_led_masked_write(led,
+				FLASH_SAFETY_TIMER(led->base),
+				FLASH_SAFETY_TIMER_MASK,
+				led->flash_cfg->duration);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Safety timer reg write failed(%d)\n",
+					rc);
+				goto error_flash_set;
+			}
+
+			/* Set max current */
+			rc = qpnp_led_masked_write(led,
+				FLASH_MAX_CURR(led->base), FLASH_CURRENT_MASK,
+				FLASH_MAX_LEVEL);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Max current reg write failed(%d)\n",
+					rc);
+				goto error_flash_set;
+			}
+
+			/* Set clamp current */
+			rc = qpnp_led_masked_write(led,
+				FLASH_CLAMP_CURR(led->base),
+				FLASH_CURRENT_MASK,
+				led->flash_cfg->clamp_curr);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Clamp current reg write failed(%d)\n",
+					rc);
+				goto error_flash_set;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				led->flash_cfg->current_addr,
+				FLASH_CURRENT_MASK,
+				led->flash_cfg->current_prgm);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Current reg write failed(%d)\n", rc);
+				goto error_flash_set;
+			}
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_ENABLE_CONTROL(led->base),
+				led->flash_cfg->enable_module,
+				led->flash_cfg->enable_module);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Enable reg write failed(%d)\n", rc);
+				goto error_flash_set;
+			}
+
+			/*
+			 * Add 1ms delay for bharger enter stable state
+			 */
+			usleep(FLASH_RAMP_UP_DELAY_US);
+
+			if (!led->flash_cfg->strobe_type)
+				led->flash_cfg->trigger_flash &=
+						~FLASH_HW_SW_STROBE_SEL_MASK;
+			else
+				led->flash_cfg->trigger_flash |=
+						FLASH_HW_SW_STROBE_SEL_MASK;
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_LED_STROBE_CTRL(led->base),
+				led->flash_cfg->trigger_flash,
+				led->flash_cfg->trigger_flash);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+				"LED %d strobe reg write failed(%d)\n",
+				led->id, rc);
+				goto error_flash_set;
+			}
+		}
+	} else {
+		rc = qpnp_led_masked_write(led,
+			FLASH_LED_STROBE_CTRL(led->base),
+			led->flash_cfg->trigger_flash,
+			FLASH_DISABLE_ALL);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"LED %d flash write failed(%d)\n", led->id, rc);
+			if (led->flash_cfg->torch_enable)
+				goto error_torch_set;
+			else
+				goto error_flash_set;
+		}
+
+		if (led->flash_cfg->torch_enable) {
+			rc = qpnp_led_masked_write(led,
+				FLASH_LED_UNLOCK_SECURE(led->base),
+				FLASH_SECURE_MASK, FLASH_UNLOCK_SECURE);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Secure reg write failed(%d)\n", rc);
+				goto error_torch_set;
+			}
+
+			rc = qpnp_led_masked_write(led,
+					FLASH_LED_TORCH(led->base),
+					FLASH_TORCH_MASK,
+					FLASH_LED_TORCH_DISABLE);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Torch reg write failed(%d)\n", rc);
+				goto error_torch_set;
+			}
+
+			if (led->flash_cfg->peripheral_subtype ==
+							FLASH_SUBTYPE_DUAL) {
+				rc = qpnp_torch_regulator_operate(led, false);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+						"Torch regulator operate failed(%d)\n",
+						rc);
+					return rc;
+				}
+			} else if (led->flash_cfg->peripheral_subtype ==
+							FLASH_SUBTYPE_SINGLE) {
+				rc = qpnp_flash_regulator_operate(led, false);
+				if (rc) {
+					dev_err(&led->spmi_dev->dev,
+						"Flash regulator operate failed(%d)\n",
+						rc);
+					return rc;
+				}
+			}
+		} else {
+			/*
+			 * Disable module after ramp down complete for stable
+			 * behavior
+			 */
+			usleep(FLASH_RAMP_DN_DELAY_US);
+
+			rc = qpnp_led_masked_write(led,
+				FLASH_ENABLE_CONTROL(led->base),
+				led->flash_cfg->enable_module &
+				~FLASH_ENABLE_MODULE_MASK,
+				FLASH_DISABLE_ALL);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Enable reg write failed(%d)\n", rc);
+				if (led->flash_cfg->torch_enable)
+					goto error_torch_set;
+				else
+					goto error_flash_set;
+			}
+
+			rc = qpnp_flash_regulator_operate(led, false);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Flash regulator operate failed(%d)\n",
+					rc);
+				return rc;
+			}
+		}
+	}
+
+	qpnp_dump_regs(led, flash_debug_regs, ARRAY_SIZE(flash_debug_regs));
+
+	return 0;
+
+error_reg_write:
+	if (led->flash_cfg->peripheral_subtype == FLASH_SUBTYPE_SINGLE)
+		goto error_flash_set;
+
+error_torch_set:
+	error = qpnp_torch_regulator_operate(led, false);
+	if (error) {
+		dev_err(&led->spmi_dev->dev,
+			"Torch regulator operate failed(%d)\n", rc);
+		return error;
+	}
+	return rc;
+
+error_flash_set:
+	error = qpnp_flash_regulator_operate(led, false);
+	if (error) {
+		dev_err(&led->spmi_dev->dev,
+			"Flash regulator operate failed(%d)\n", rc);
+		return error;
+	}
+	return rc;
+}
+
+static int qpnp_kpdbl_set(struct qpnp_led_data *led)
+{
+	int rc;
+	int duty_us, duty_ns, period_us;
+
+	if (led->cdev.brightness) {
+		if (!led->kpdbl_cfg->pwm_cfg->blinking)
+			led->kpdbl_cfg->pwm_cfg->mode =
+				led->kpdbl_cfg->pwm_cfg->default_mode;
+		if (!num_kpbl_leds_on) {
+			rc = qpnp_led_masked_write(led, KPDBL_ENABLE(led->base),
+					KPDBL_MODULE_EN_MASK, KPDBL_MODULE_EN);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Enable reg write failed(%d)\n", rc);
+				return rc;
+			}
+		}
+
+		if (led->kpdbl_cfg->pwm_cfg->mode == PWM_MODE) {
+			period_us = led->kpdbl_cfg->pwm_cfg->pwm_period_us;
+			if (period_us > INT_MAX / NSEC_PER_USEC) {
+				duty_us = (period_us * led->cdev.brightness) /
+					KPDBL_MAX_LEVEL;
+				rc = pwm_config_us(
+					led->kpdbl_cfg->pwm_cfg->pwm_dev,
+					duty_us,
+					period_us);
+			} else {
+				duty_ns = ((period_us * NSEC_PER_USEC) /
+					KPDBL_MAX_LEVEL) * led->cdev.brightness;
+				rc = pwm_config(
+					led->kpdbl_cfg->pwm_cfg->pwm_dev,
+					duty_ns,
+					period_us * NSEC_PER_USEC);
+			}
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev, "pwm config failed\n");
+				return rc;
+			}
+		}
+
+		rc = pwm_enable(led->kpdbl_cfg->pwm_cfg->pwm_dev);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev, "pwm enable failed\n");
+			return rc;
+		}
+
+		num_kpbl_leds_on++;
+
+	} else {
+		led->kpdbl_cfg->pwm_cfg->mode =
+			led->kpdbl_cfg->pwm_cfg->default_mode;
+
+		if (led->kpdbl_cfg->always_on) {
+			rc = pwm_config_us(led->kpdbl_cfg->pwm_cfg->pwm_dev, 0,
+				led->kpdbl_cfg->pwm_cfg->pwm_period_us);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+						"pwm config failed\n");
+				return rc;
+			}
+
+			rc = pwm_enable(led->kpdbl_cfg->pwm_cfg->pwm_dev);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev, "pwm enable failed\n");
+				return rc;
+			}
+		} else
+			pwm_disable(led->kpdbl_cfg->pwm_cfg->pwm_dev);
+
+		if (num_kpbl_leds_on > 0)
+			num_kpbl_leds_on--;
+
+		if (!num_kpbl_leds_on) {
+			rc = qpnp_led_masked_write(led, KPDBL_ENABLE(led->base),
+					KPDBL_MODULE_EN_MASK, KPDBL_MODULE_DIS);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+					"Failed to write led enable reg\n");
+				return rc;
+			}
+		}
+	}
+
+	led->kpdbl_cfg->pwm_cfg->blinking = false;
+
+	qpnp_dump_regs(led, kpdbl_debug_regs, ARRAY_SIZE(kpdbl_debug_regs));
+
+	return 0;
+}
+
+static int qpnp_rgb_set(struct qpnp_led_data *led)
+{
+	int rc;
+	int duty_us, duty_ns, period_us;
+
+	if (led->cdev.brightness) {
+		if (!led->rgb_cfg->pwm_cfg->blinking)
+			led->rgb_cfg->pwm_cfg->mode =
+				led->rgb_cfg->pwm_cfg->default_mode;
+		if (led->rgb_cfg->pwm_cfg->mode == PWM_MODE) {
+			period_us = led->rgb_cfg->pwm_cfg->pwm_period_us;
+			if (period_us > INT_MAX / NSEC_PER_USEC) {
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+                duty_us = (period_us * led->cdev.brightness) /
+	                ZTEMT_RGB_BREATH_LED_FULL;
+                ztemt_rgb_led_debug("%s : %d : duty_us=%d\n",__func__,__LINE__,duty_us);
+#else
+				duty_us = (period_us * led->cdev.brightness) /
+					LED_FULL;
+#endif
+				rc = pwm_config_us(
+					led->rgb_cfg->pwm_cfg->pwm_dev,
+					duty_us,
+					period_us);
+			} else {
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+                duty_ns = ((period_us * NSEC_PER_USEC) /
+	                ZTEMT_RGB_BREATH_LED_FULL) * led->cdev.brightness;
+                ztemt_rgb_led_debug("%s : %d : duty_ns=%d\n",__func__,__LINE__,duty_ns);
+#else
+				duty_ns = ((period_us * NSEC_PER_USEC) /
+					LED_FULL) * led->cdev.brightness;
+#endif
+				rc = pwm_config(
+					led->rgb_cfg->pwm_cfg->pwm_dev,
+					duty_ns,
+					period_us * NSEC_PER_USEC);
+			}
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+					"pwm config failed\n");
+				return rc;
+			}
+		}
+		rc = qpnp_led_masked_write(led,
+			RGB_LED_EN_CTL(led->base),
+			led->rgb_cfg->enable, led->rgb_cfg->enable);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Failed to write led enable reg\n");
+			return rc;
+		}
+
+		rc = pwm_enable(led->rgb_cfg->pwm_cfg->pwm_dev);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev, "pwm enable failed\n");
+			return rc;
+		}
+	} else {
+		led->rgb_cfg->pwm_cfg->mode =
+			led->rgb_cfg->pwm_cfg->default_mode;
+		pwm_disable(led->rgb_cfg->pwm_cfg->pwm_dev);
+		rc = qpnp_led_masked_write(led,
+			RGB_LED_EN_CTL(led->base),
+			led->rgb_cfg->enable, RGB_LED_DISABLE);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Failed to write led enable reg\n");
+			return rc;
+		}
+	}
+
+	led->rgb_cfg->pwm_cfg->blinking = false;
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+    if(0){
+	qpnp_dump_regs(led, rgb_pwm_debug_regs, ARRAY_SIZE(rgb_pwm_debug_regs));
+    }
+#else
+	qpnp_dump_regs(led, rgb_pwm_debug_regs, ARRAY_SIZE(rgb_pwm_debug_regs));
+#endif
+	return 0;
+}
+
+static void qpnp_led_set(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	struct qpnp_led_data *led;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+	if (value < LED_OFF) {
+		dev_err(&led->spmi_dev->dev, "Invalid brightness value\n");
+		return;
+	}
+
+	if (value > led->cdev.max_brightness)
+		value = led->cdev.max_brightness;
+
+	led->cdev.brightness = value;
+	schedule_work(&led->work);
+}
+
+static void __qpnp_led_work(struct qpnp_led_data *led,
+				enum led_brightness value)
+{
+	int rc;
+
+	mutex_lock(&led->lock);
+
+	switch (led->id) {
+	case QPNP_ID_WLED:
+		rc = qpnp_wled_set(led);
+		if (rc < 0)
+			dev_err(&led->spmi_dev->dev,
+				"WLED set brightness failed (%d)\n", rc);
+		break;
+	case QPNP_ID_FLASH1_LED0:
+	case QPNP_ID_FLASH1_LED1:
+		rc = qpnp_flash_set(led);
+		if (rc < 0)
+			dev_err(&led->spmi_dev->dev,
+				"FLASH set brightness failed (%d)\n", rc);
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		rc = qpnp_rgb_set(led);
+		if (rc < 0)
+			dev_err(&led->spmi_dev->dev,
+				"RGB set brightness failed (%d)\n", rc);
+		break;
+	case QPNP_ID_LED_MPP:
+		rc = qpnp_mpp_set(led);
+		if (rc < 0)
+			dev_err(&led->spmi_dev->dev,
+					"MPP set brightness failed (%d)\n", rc);
+		break;
+	case QPNP_ID_KPDBL:
+		rc = qpnp_kpdbl_set(led);
+		if (rc < 0)
+			dev_err(&led->spmi_dev->dev,
+				"KPDBL set brightness failed (%d)\n", rc);
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev, "Invalid LED(%d)\n", led->id);
+		break;
+	}
+	mutex_unlock(&led->lock);
+
+}
+
+static void qpnp_led_work(struct work_struct *work)
+{
+	struct qpnp_led_data *led = container_of(work,
+					struct qpnp_led_data, work);
+
+	__qpnp_led_work(led, led->cdev.brightness);
+
+	return;
+}
+
+static int __devinit qpnp_led_set_max_brightness(struct qpnp_led_data *led)
+{
+	switch (led->id) {
+	case QPNP_ID_WLED:
+		led->cdev.max_brightness = WLED_MAX_LEVEL;
+		break;
+	case QPNP_ID_FLASH1_LED0:
+	case QPNP_ID_FLASH1_LED1:
+		led->cdev.max_brightness = led->max_current;
+		break;
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+	case QPNP_ID_RGB_RED:
+	    led->cdev.max_brightness = RGB_MAX_LEVEL;
+	    pwm_dev_red=led->rgb_cfg->pwm_cfg->pwm_dev;
+		break;
+	case QPNP_ID_RGB_GREEN:
+		led->cdev.max_brightness = RGB_MAX_LEVEL;
+		pwm_dev_green=led->rgb_cfg->pwm_cfg->pwm_dev;
+		break;
+	case QPNP_ID_RGB_BLUE:
+		led->cdev.max_brightness = RGB_MAX_LEVEL;
+		pwm_dev_blue=led->rgb_cfg->pwm_cfg->pwm_dev;
+		break;
+#else
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		led->cdev.max_brightness = RGB_MAX_LEVEL;
+		break;
+#endif	
+	case QPNP_ID_LED_MPP:
+		if (led->mpp_cfg->pwm_mode == MANUAL_MODE)
+			led->cdev.max_brightness = led->max_current;
+		else
+			led->cdev.max_brightness = MPP_MAX_LEVEL;
+		break;
+	case QPNP_ID_KPDBL:
+		led->cdev.max_brightness = KPDBL_MAX_LEVEL;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev, "Invalid LED(%d)\n", led->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum led_brightness qpnp_led_get(struct led_classdev *led_cdev)
+{
+	struct qpnp_led_data *led;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	return led->cdev.brightness;
+}
+
+static void qpnp_led_turn_off_delayed(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct qpnp_led_data *led
+		= container_of(dwork, struct qpnp_led_data, dwork);
+
+	led->cdev.brightness = LED_OFF;
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+}
+
+static void qpnp_led_turn_off(struct qpnp_led_data *led)
+{
+	INIT_DELAYED_WORK(&led->dwork, qpnp_led_turn_off_delayed);
+	schedule_delayed_work(&led->dwork,
+		msecs_to_jiffies(led->turn_off_delay_ms));
+}
+
+static int __devinit qpnp_wled_init(struct qpnp_led_data *led)
+{
+	int rc, i;
+	u8 num_wled_strings;
+
+	num_wled_strings = led->wled_cfg->num_strings;
+
+	/* verify ranges */
+	if (led->wled_cfg->ovp_val > WLED_OVP_27V) {
+		dev_err(&led->spmi_dev->dev, "Invalid ovp value\n");
+		return -EINVAL;
+	}
+
+	if (led->wled_cfg->boost_curr_lim > WLED_CURR_LIMIT_1680mA) {
+		dev_err(&led->spmi_dev->dev, "Invalid boost current limit\n");
+		return -EINVAL;
+	}
+
+	if (led->wled_cfg->cp_select > WLED_CP_SELECT_MAX) {
+		dev_err(&led->spmi_dev->dev, "Invalid pole capacitance\n");
+		return -EINVAL;
+	}
+
+	if ((led->max_current > WLED_MAX_CURR)) {
+		dev_err(&led->spmi_dev->dev, "Invalid max current\n");
+		return -EINVAL;
+	}
+
+	if ((led->wled_cfg->ctrl_delay_us % WLED_CTL_DLY_STEP) ||
+		(led->wled_cfg->ctrl_delay_us > WLED_CTL_DLY_MAX)) {
+		dev_err(&led->spmi_dev->dev, "Invalid control delay\n");
+		return -EINVAL;
+	}
+
+	/* program over voltage protection threshold */
+	rc = qpnp_led_masked_write(led, WLED_OVP_CFG_REG(led->base),
+		WLED_OVP_VAL_MASK,
+		(led->wled_cfg->ovp_val << WLED_OVP_VAL_BIT_SHFT));
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED OVP reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* program current boost limit */
+	rc = qpnp_led_masked_write(led, WLED_BOOST_LIMIT_REG(led->base),
+		WLED_BOOST_LIMIT_MASK, led->wled_cfg->boost_curr_lim);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED boost limit reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* program output feedback */
+	rc = qpnp_led_masked_write(led, WLED_FDBCK_CTRL_REG(led->base),
+		WLED_OP_FDBCK_MASK,
+		(led->wled_cfg->op_fdbck << WLED_OP_FDBCK_BIT_SHFT));
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED fdbck ctrl reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* program switch frequency */
+	rc = qpnp_led_masked_write(led,
+		WLED_SWITCHING_FREQ_REG(led->base),
+		WLED_SWITCH_FREQ_MASK, led->wled_cfg->switch_freq);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"WLED switch freq reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* program current sink */
+	if (led->wled_cfg->cs_out_en) {
+		rc = qpnp_led_masked_write(led, WLED_CURR_SINK_REG(led->base),
+			WLED_CURR_SINK_MASK,
+			(((1 << led->wled_cfg->num_strings) - 1)
+			<< WLED_CURR_SINK_SHFT));
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED curr sink reg write failed(%d)\n", rc);
+			return rc;
+		}
+	}
+
+	/* program high pole capacitance */
+	rc = qpnp_led_masked_write(led, WLED_HIGH_POLE_CAP_REG(led->base),
+		WLED_CP_SELECT_MASK, led->wled_cfg->cp_select);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+				"WLED pole cap reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* program modulator, current mod src and cabc */
+	for (i = 0; i < num_wled_strings; i++) {
+		rc = qpnp_led_masked_write(led, WLED_MOD_EN_REG(led->base, i),
+			WLED_NO_MASK, WLED_EN_MASK);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED mod enable reg write failed(%d)\n", rc);
+			return rc;
+		}
+
+		if (led->wled_cfg->dig_mod_gen_en) {
+			rc = qpnp_led_masked_write(led,
+				WLED_MOD_SRC_SEL_REG(led->base, i),
+				WLED_NO_MASK, WLED_USE_EXT_GEN_MOD_SRC);
+			if (rc) {
+				dev_err(&led->spmi_dev->dev,
+				"WLED dig mod en reg write failed(%d)\n", rc);
+			}
+		}
+
+		rc = qpnp_led_masked_write(led,
+			WLED_FULL_SCALE_REG(led->base, i), WLED_MAX_CURR_MASK,
+			led->max_current);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"WLED max current reg write failed(%d)\n", rc);
+			return rc;
+		}
+
+	}
+
+	/* Reset WLED enable register */
+	rc = qpnp_led_masked_write(led, WLED_MOD_CTRL_REG(led->base),
+		WLED_8_BIT_MASK, WLED_BOOST_OFF);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"WLED write ctrl reg failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* dump wled registers */
+	qpnp_dump_regs(led, wled_debug_regs, ARRAY_SIZE(wled_debug_regs));
+
+	return 0;
+}
+
+static ssize_t led_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	unsigned long state;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret = -EINVAL;
+
+	ret = kstrtoul(buf, 10, &state);
+	if (ret)
+		return ret;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	/* '1' to enable torch mode; '0' to switch to flash mode */
+	if (state == 1)
+		led->flash_cfg->torch_enable = true;
+	else
+		led->flash_cfg->torch_enable = false;
+
+	return count;
+}
+
+static ssize_t led_strobe_type_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	unsigned long state;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret = -EINVAL;
+
+	ret = kstrtoul(buf, 10, &state);
+	if (ret)
+		return ret;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	/* '0' for sw strobe; '1' for hw strobe */
+	if (state == 1)
+		led->flash_cfg->strobe_type = 1;
+	else
+		led->flash_cfg->strobe_type = 0;
+
+	return count;
+}
+
+static int qpnp_pwm_init(struct pwm_config_data *pwm_cfg,
+					struct spmi_device *spmi_dev,
+					const char *name)
+{
+	int rc, start_idx, idx_len;
+
+	if (pwm_cfg->pwm_channel != -1) {
+		pwm_cfg->pwm_dev =
+			pwm_request(pwm_cfg->pwm_channel, name);
+
+		if (IS_ERR_OR_NULL(pwm_cfg->pwm_dev)) {
+			dev_err(&spmi_dev->dev,
+				"could not acquire PWM Channel %d, " \
+				"error %ld\n",
+				pwm_cfg->pwm_channel,
+				PTR_ERR(pwm_cfg->pwm_dev));
+			pwm_cfg->pwm_dev = NULL;
+			return -ENODEV;
+		}
+
+		if (pwm_cfg->mode == LPG_MODE) {
+			start_idx =
+			pwm_cfg->duty_cycles->start_idx;
+			idx_len =
+			pwm_cfg->duty_cycles->num_duty_pcts;
+
+			if (idx_len >= PWM_LUT_MAX_SIZE &&
+					start_idx) {
+				dev_err(&spmi_dev->dev,
+					"Wrong LUT size or index\n");
+				return -EINVAL;
+			}
+			if ((start_idx + idx_len) >
+					PWM_LUT_MAX_SIZE) {
+				dev_err(&spmi_dev->dev,
+					"Exceed LUT limit\n");
+				return -EINVAL;
+			}
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+            ztemt_rgb_led_debug("%s : %d : ztemt_lpg_pm_pwm_period=%d\n",__func__,__LINE__,ztemt_lpg_pm_pwm_period);
+			rc = pwm_lut_config(pwm_cfg->pwm_dev,
+				ztemt_lpg_pm_pwm_period, /* refer kernel/include/linux/qpnp/pwm.h */ 
+				pwm_cfg->duty_cycles->duty_pcts,
+				pwm_cfg->lut_params);			
+#else
+			rc = pwm_lut_config(pwm_cfg->pwm_dev,
+				PM_PWM_PERIOD_MIN, /* ignored by hardware */
+				pwm_cfg->duty_cycles->duty_pcts,
+				pwm_cfg->lut_params);
+#endif
+			if (rc < 0) {
+				dev_err(&spmi_dev->dev, "Failed to " \
+					"configure pwm LUT\n");
+				return rc;
+			}
+		}
+	} else {
+		dev_err(&spmi_dev->dev,
+			"Invalid PWM channel\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ssize_t pwm_us_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 pwm_us;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_pwm_us;
+	struct pwm_config_data *pwm_cfg;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	ret = kstrtou32(buf, 10, &pwm_us);
+	if (ret)
+		return ret;
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for pwm_us\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_pwm_us = pwm_cfg->pwm_period_us;
+
+	pwm_cfg->pwm_period_us = pwm_us;
+	pwm_free(pwm_cfg->pwm_dev);
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->pwm_period_us = previous_pwm_us;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new pwm_us value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t pause_lo_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 pause_lo;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_pause_lo;
+	struct pwm_config_data *pwm_cfg;
+
+	ret = kstrtou32(buf, 10, &pause_lo);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for pause lo\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_pause_lo = pwm_cfg->lut_params.lut_pause_lo;
+
+	pwm_free(pwm_cfg->pwm_dev);
+	pwm_cfg->lut_params.lut_pause_lo = pause_lo;
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->lut_params.lut_pause_lo = previous_pause_lo;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new pause lo value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t pause_hi_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 pause_hi;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_pause_hi;
+	struct pwm_config_data *pwm_cfg;
+
+	ret = kstrtou32(buf, 10, &pause_hi);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for pause hi\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_pause_hi = pwm_cfg->lut_params.lut_pause_hi;
+
+	pwm_free(pwm_cfg->pwm_dev);
+	pwm_cfg->lut_params.lut_pause_hi = pause_hi;
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->lut_params.lut_pause_hi = previous_pause_hi;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new pause hi value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t start_idx_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 start_idx;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_start_idx;
+	struct pwm_config_data *pwm_cfg;
+
+	ret = kstrtou32(buf, 10, &start_idx);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for start idx\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_start_idx = pwm_cfg->duty_cycles->start_idx;
+	pwm_cfg->duty_cycles->start_idx = start_idx;
+	pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+	pwm_free(pwm_cfg->pwm_dev);
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->duty_cycles->start_idx = previous_start_idx;
+		pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new start idx value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t ramp_step_ms_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 ramp_step_ms;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_ramp_step_ms;
+	struct pwm_config_data *pwm_cfg;
+
+	ret = kstrtou32(buf, 10, &ramp_step_ms);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for ramp step\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_ramp_step_ms = pwm_cfg->lut_params.ramp_step_ms;
+
+	pwm_free(pwm_cfg->pwm_dev);
+	pwm_cfg->lut_params.ramp_step_ms = ramp_step_ms;
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->lut_params.ramp_step_ms = previous_ramp_step_ms;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new ramp step value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t lut_flags_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	u32 lut_flags;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u32 previous_lut_flags;
+	struct pwm_config_data *pwm_cfg;
+
+	ret = kstrtou32(buf, 10, &lut_flags);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for lut flags\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	previous_lut_flags = pwm_cfg->lut_params.flags;
+
+	pwm_free(pwm_cfg->pwm_dev);
+	pwm_cfg->lut_params.flags = lut_flags;
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+		pwm_cfg->lut_params.flags = previous_lut_flags;
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm with new lut flags value\n");
+		return ret;
+	}
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+}
+
+static ssize_t duty_pcts_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	int num_duty_pcts = 0;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	char *buffer;
+	ssize_t ret;
+	int i = 0;
+	int max_duty_pcts;
+	struct pwm_config_data *pwm_cfg;
+	u32 previous_num_duty_pcts;
+	int value;
+	int *previous_duty_pcts;
+
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		pwm_cfg = led->mpp_cfg->pwm_cfg;
+		max_duty_pcts = PWM_LUT_MAX_SIZE;
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		pwm_cfg = led->rgb_cfg->pwm_cfg;
+		max_duty_pcts = PWM_LUT_MAX_SIZE;
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev,
+			"Invalid LED id type for duty pcts\n");
+		return -EINVAL;
+	}
+
+	if (pwm_cfg->mode == LPG_MODE)
+		pwm_cfg->blinking = true;
+
+	buffer = (char *)buf;
+
+	for (i = 0; i < max_duty_pcts; i++) {
+		if (buffer == NULL)
+			break;
+		ret = sscanf((const char *)buffer, "%u,%s", &value, buffer);
+		pwm_cfg->old_duty_pcts[i] = value;
+		num_duty_pcts++;
+		if (ret <= 1)
+			break;
+	}
+
+	if (num_duty_pcts >= max_duty_pcts) {
+		dev_err(&led->spmi_dev->dev,
+			"Number of duty pcts given exceeds max (%d)\n",
+			max_duty_pcts);
+		return -EINVAL;
+	}
+
+	previous_num_duty_pcts = pwm_cfg->duty_cycles->num_duty_pcts;
+	previous_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+
+	pwm_cfg->duty_cycles->num_duty_pcts = num_duty_pcts;
+	pwm_cfg->duty_cycles->duty_pcts = pwm_cfg->old_duty_pcts;
+	pwm_cfg->old_duty_pcts = previous_duty_pcts;
+	pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+
+	pwm_free(pwm_cfg->pwm_dev);
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret)
+		goto restore;
+
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return count;
+
+restore:
+	dev_err(&led->spmi_dev->dev,
+		"Failed to initialize pwm with new duty pcts value\n");
+	pwm_cfg->duty_cycles->num_duty_pcts = previous_num_duty_pcts;
+	pwm_cfg->old_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+	pwm_cfg->duty_cycles->duty_pcts = previous_duty_pcts;
+	pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+	pwm_free(pwm_cfg->pwm_dev);
+	qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	qpnp_led_set(&led->cdev, led->cdev.brightness);
+	return ret;
+}
+
+static void led_blink(struct qpnp_led_data *led,
+			struct pwm_config_data *pwm_cfg)
+{
+	if (pwm_cfg->use_blink) {
+		if (led->cdev.brightness) {
+			pwm_cfg->blinking = true;
+			if (led->id == QPNP_ID_LED_MPP)
+				led->mpp_cfg->pwm_mode = LPG_MODE;
+			pwm_cfg->mode = LPG_MODE;
+		} else {
+			pwm_cfg->blinking = false;
+			pwm_cfg->mode = pwm_cfg->default_mode;
+			if (led->id == QPNP_ID_LED_MPP)
+				led->mpp_cfg->pwm_mode = pwm_cfg->default_mode;
+		}
+		pwm_free(pwm_cfg->pwm_dev);
+		qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+		qpnp_led_set(&led->cdev, led->cdev.brightness);
+	}
+}
+
+static ssize_t blink_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct qpnp_led_data *led;
+	unsigned long blinking;
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	ssize_t ret = -EINVAL;
+
+	ret = kstrtoul(buf, 10, &blinking);
+	if (ret)
+		return ret;
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+	led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;
+
+	switch (led->id) {
+	case QPNP_ID_LED_MPP:
+		led_blink(led, led->mpp_cfg->pwm_cfg);
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		led_blink(led, led->rgb_cfg->pwm_cfg);
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev, "Invalid LED id type for blink\n");
+		return -EINVAL;
+	}
+	return count;
+}
+
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+static int fade_parameter_convert(int temp_start)
+{
+	 int temp_end;
+	 int grade=256;
+	 
+	 if(temp_start<=0)
+	     temp_end=0;
+	 else
+	     temp_end=(1<<(temp_start-1))*grade;
+	 
+	 ztemt_rgb_led_debug("%s,%d,%d",__func__,__LINE__,temp_end);
+	 return temp_end;
+}
+
+static ssize_t fade_parameter_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	strncpy(fade_parameter, buf, FADE_PARAM_LEN);
+	sscanf(fade_parameter, "%d %d %d", &fade_time, &fullon_time, &fulloff_time);
+	ztemt_rgb_led_debug("%s : %d : fade_time=%d , fullon_time=%d , fulloff_time=%d\n",__func__,__LINE__,fade_time,fullon_time,fulloff_time);
+	return count;
+}
+
+static ssize_t fade_parameter_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+ 	snprintf(fade_parameter, FADE_PARAM_LEN,	"%4d %4d %4d\n",
+			fade_time, fullon_time, fulloff_time);
+	return sprintf(buf, "%s\n", fade_parameter);
+}
+
+static ssize_t grade_parameter_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	strncpy(grade_parameter, buf, GRADE_PARAM_LEN);
+	sscanf(grade_parameter, "%d %d", &min_grade, &max_grade);
+	ztemt_rgb_led_debug("%s : %d : min_grade=%d , max_grade=%d\n",__func__,__LINE__,min_grade,max_grade);
+	return count;
+}
+
+static ssize_t grade_parameter_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	snprintf(grade_parameter, GRADE_PARAM_LEN,	"%4d %4d\n",
+			min_grade, max_grade);
+	return sprintf(buf, "%s\n", grade_parameter);
+}
+
+static ssize_t outn_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	sscanf(buf, "%d", &ztemt_channel);
+	ztemt_rgb_led_debug("%s : %d : ztemt_channel=%d \n",__func__,__LINE__,ztemt_channel);
+	return count;
+}
+
+static ssize_t outn_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n",ztemt_channel);	
+}
+
+
+static void ztemt_qpnp_led_set(struct led_classdev *led_cdev,
+				enum led_brightness value)	
+	
+{
+    struct qpnp_led_data *led;
+    struct pwm_config_data *pwm_cfg;
+    ssize_t ret = -EINVAL;
+    u32 blinking=1;
+    u32 mode;
+    int brightness;
+    int end_brightness;
+    int temp_brightness;
+    int previous_brightness;
+    //int brightness_step=2;
+    int brightness_step=ztemt_lpg_brightness_step;
+       
+    int j = 0;
+    int num_duty_pcts = 0;
+    u32 previous_num_duty_pcts;
+    int *previous_duty_pcts;
+    u32 previous_idx_len=0;
+  
+    u32 start_idx=0;
+    u32 previous_start_idx=0;
+    u32 ramp_step_ms=0;
+    u32 ramp_ms=0;
+    u32 previous_ramp_step_ms=0;
+    u32 pause_lo=0;
+    u32 previous_pause_lo=0;  
+    u32 pause_hi=0;
+    u32 previous_pause_hi=0;
+    u32 previous_lut_flags=0;
+
+	if(ztemt_channel!=CHANNEL_MPP)return;
+	
+    mode=value;
+    ztemt_rgb_led_debug("%s : %d : mode=%d \n",__func__,__LINE__,mode);
+
+    ramp_ms=fade_parameter_convert(fade_time);
+    pause_hi=fade_parameter_convert(fullon_time);
+    pause_lo=fade_parameter_convert(fulloff_time);
+	
+	brightness=min_grade;
+    end_brightness=max_grade;
+	
+	led = container_of(led_cdev, struct qpnp_led_data, cdev);
+    
+	if(brightness<0){
+       brightness=0;
+    }else if(brightness>led->cdev.max_brightness){
+	   brightness=led->cdev.max_brightness;
+    }	
+    if(end_brightness<0){
+       end_brightness=0;
+    }else if(end_brightness>led->cdev.max_brightness){
+	   end_brightness=led->cdev.max_brightness;
+    }	
+    
+    switch (led->id) {
+	  case QPNP_ID_RGB_RED:
+	  case QPNP_ID_RGB_GREEN:
+	  case QPNP_ID_RGB_BLUE:
+		   pwm_cfg = led->rgb_cfg->pwm_cfg;
+		   break;
+	  case QPNP_ID_LED_MPP:
+		   pwm_cfg = led->mpp_cfg->pwm_cfg;
+		   break;	  	    
+	  default:
+	      dev_err(&led->spmi_dev->dev, "Invalid LED id type for ztemt_qpnp_led_set\n");
+		  return;
+    }
+	
+	
+	if((mode==RGB_LED_MODE_CLOSED )||(mode== RGB_LED_MODE_OFF)) 
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_CLOSED || RGB_LED_MODE_OFF \n",__func__,__LINE__);
+					
+		pwm_cfg->blinking = false;
+		pwm_cfg->mode = pwm_cfg->default_mode;
+		previous_brightness=led->cdev.brightness;
+		led->cdev.brightness =0;	
+
+		if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = led->mpp_cfg->pwm_cfg->default_mode;
+		
+		pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value 
+				
+	}
+	else if(mode==RGB_LED_MODE_NORMAL) //normal brightness
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_NORMAL\n",__func__,__LINE__);
+					
+		pwm_cfg->blinking = false;
+		pwm_cfg->mode = pwm_cfg->default_mode;
+		previous_brightness=led->cdev.brightness;
+		led->cdev.brightness =brightness;	
+		
+		if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = led->mpp_cfg->pwm_cfg->default_mode;
+		
+		pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value 
+				
+	}
+	else if(mode==RGB_LED_MODE_BREATH_BLINK)  //breath blink
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_BREATH_BLINK\n",__func__,__LINE__);
+		temp_brightness=brightness;
+		num_duty_pcts=0;
+				
+		for(j=0;j<PWM_LUT_MAX_SIZE;j++)
+		{
+		    pwm_cfg->old_duty_pcts[j] = temp_brightness;
+		    num_duty_pcts++;
+		    if(temp_brightness>=end_brightness){
+			    pwm_cfg->old_duty_pcts[j]=end_brightness;
+			    break;
+		    }
+	        temp_brightness=temp_brightness + brightness_step;
+		}
+		previous_num_duty_pcts = pwm_cfg->duty_cycles->num_duty_pcts;
+		previous_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+	
+		pwm_cfg->duty_cycles->num_duty_pcts = num_duty_pcts;
+		pwm_cfg->duty_cycles->duty_pcts = pwm_cfg->old_duty_pcts;
+		pwm_cfg->old_duty_pcts = previous_duty_pcts;
+		pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+
+
+        //ramp_step_ms*1000==num_duty_pcts*(ramp_ms*1000+ztemt_lpg_pm_pwm_period); 
+        ramp_step_ms=(ramp_ms*1000/num_duty_pcts-ztemt_lpg_pm_pwm_period)/1000; 
+        if(ramp_step_ms<=0)ramp_step_ms=0;
+
+	    previous_ramp_step_ms = pwm_cfg->lut_params.ramp_step_ms;
+	    pwm_cfg->lut_params.ramp_step_ms = ramp_step_ms;
+	    previous_start_idx = pwm_cfg->duty_cycles->start_idx; 
+		pwm_cfg->duty_cycles->start_idx = start_idx;
+		pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+		previous_pause_hi = pwm_cfg->lut_params.lut_pause_hi;
+		pwm_cfg->lut_params.lut_pause_hi = pause_hi;
+		previous_pause_lo = pwm_cfg->lut_params.lut_pause_lo;
+		pwm_cfg->lut_params.lut_pause_lo = pause_lo;
+
+		
+		previous_lut_flags=pwm_cfg->lut_params.flags;
+		pwm_cfg->lut_params.flags = (PM_PWM_LUT_REVERSE | PM_PWM_LUT_RAMP_UP | PM_PWM_LUT_PAUSE_LO_EN | PM_PWM_LUT_PAUSE_HI_EN);
+		
+		pwm_cfg->blinking = true;
+		pwm_cfg->mode = LPG_MODE;
+		led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;
+
+		if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = LPG_MODE;
+
+        pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value
+				
+	}
+	else if(mode==RGB_LED_MODE_CHARGE_BREATH)  //charge breath
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_CHARGE_BREATH\n",__func__,__LINE__);
+		temp_brightness=brightness;
+		num_duty_pcts=0;
+		
+		for(j=0;j<PWM_LUT_MAX_SIZE;j++)
+		{
+			pwm_cfg->old_duty_pcts[j] = temp_brightness;
+		    num_duty_pcts++;
+		    if(temp_brightness>=end_brightness){
+				pwm_cfg->old_duty_pcts[j]=end_brightness;
+				break;
+			}
+			temp_brightness=temp_brightness + brightness_step;
+		}
+		previous_num_duty_pcts = pwm_cfg->duty_cycles->num_duty_pcts;
+		previous_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+		previous_idx_len = pwm_cfg->lut_params.idx_len;
+	
+		pwm_cfg->duty_cycles->num_duty_pcts = num_duty_pcts;
+		pwm_cfg->duty_cycles->duty_pcts = pwm_cfg->old_duty_pcts;
+		pwm_cfg->old_duty_pcts = previous_duty_pcts;
+		pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+	
+        ramp_step_ms=(ramp_ms*1000/num_duty_pcts-ztemt_lpg_pm_pwm_period)/1000; 
+        if(ramp_step_ms<=0)ramp_step_ms=0;
+		
+		previous_ramp_step_ms = pwm_cfg->lut_params.ramp_step_ms;
+	    pwm_cfg->lut_params.ramp_step_ms = ramp_step_ms;
+	    previous_start_idx = pwm_cfg->duty_cycles->start_idx; 
+		pwm_cfg->duty_cycles->start_idx = start_idx;
+		pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+		previous_pause_hi = pwm_cfg->lut_params.lut_pause_hi;
+		pwm_cfg->lut_params.lut_pause_hi = pause_hi;
+		previous_pause_lo = pwm_cfg->lut_params.lut_pause_lo;
+		pwm_cfg->lut_params.lut_pause_lo = pause_lo;
+
+		previous_lut_flags=pwm_cfg->lut_params.flags;
+		pwm_cfg->lut_params.flags = (PM_PWM_LUT_LOOP | PM_PWM_LUT_REVERSE | PM_PWM_LUT_RAMP_UP | PM_PWM_LUT_PAUSE_LO_EN | PM_PWM_LUT_PAUSE_HI_EN);	
+		
+		pwm_cfg->blinking = true;
+		pwm_cfg->mode = LPG_MODE;
+		led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;
+
+		if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = LPG_MODE;
+		
+        pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value		
+				
+	}
+	else if(mode==RGB_LED_MODE_POWER_ON) //power on
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_POWER_ON\n",__func__,__LINE__);
+		temp_brightness=brightness;
+		num_duty_pcts=0;
+     
+		for(j=0;j<PWM_LUT_MAX_SIZE;j++)
+		{
+			pwm_cfg->old_duty_pcts[j] = temp_brightness;
+		    num_duty_pcts++;
+		    if(temp_brightness>=end_brightness){
+				pwm_cfg->old_duty_pcts[j]=end_brightness;
+				break;
+			}
+			temp_brightness=temp_brightness + brightness_step;
+		}
+			
+		previous_num_duty_pcts = pwm_cfg->duty_cycles->num_duty_pcts;
+		previous_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+	
+		pwm_cfg->duty_cycles->num_duty_pcts = num_duty_pcts;
+		pwm_cfg->duty_cycles->duty_pcts = pwm_cfg->old_duty_pcts;
+		pwm_cfg->old_duty_pcts = previous_duty_pcts;
+		pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+	
+        ramp_step_ms=(ramp_ms*1000/num_duty_pcts-ztemt_lpg_pm_pwm_period)/1000; 
+        if(ramp_step_ms<=0)ramp_step_ms=0;
+	    
+		previous_ramp_step_ms = pwm_cfg->lut_params.ramp_step_ms;
+	    pwm_cfg->lut_params.ramp_step_ms = ramp_step_ms;
+	    previous_start_idx = pwm_cfg->duty_cycles->start_idx; 
+		pwm_cfg->duty_cycles->start_idx = start_idx;
+		pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+		previous_pause_hi = pwm_cfg->lut_params.lut_pause_hi;
+		pwm_cfg->lut_params.lut_pause_hi = pause_hi;
+		previous_pause_lo = pwm_cfg->lut_params.lut_pause_lo;
+		pwm_cfg->lut_params.lut_pause_lo = pause_lo;
+
+        previous_lut_flags=pwm_cfg->lut_params.flags;
+		pwm_cfg->lut_params.flags = (PM_PWM_LUT_RAMP_UP | PM_PWM_LUT_PAUSE_LO_EN | PM_PWM_LUT_PAUSE_HI_EN);
+		
+		pwm_cfg->blinking = true;
+		pwm_cfg->mode = LPG_MODE;
+		led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;
+
+		if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = LPG_MODE;
+
+        pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value	
+		
+	}
+	else if(mode==RGB_LED_MODE_POWER_OFF) //power off
+	{
+		ztemt_rgb_led_debug("%s : %d : RGB_LED_MODE_POWER_OFF\n",__func__,__LINE__);
+		temp_brightness=end_brightness;
+		num_duty_pcts=0;
+		
+		for(j=0;j<PWM_LUT_MAX_SIZE;j++)
+		{
+		  if(j==PWM_LUT_MAX_SIZE-1)
+		  {
+		        pwm_cfg->old_duty_pcts[j] = 0;
+		        num_duty_pcts++;
+				break;
+		  }
+		  if(temp_brightness<=brightness){
+		        pwm_cfg->old_duty_pcts[j] = brightness;
+		        num_duty_pcts++;
+				break;
+			}
+		  pwm_cfg->old_duty_pcts[j] = temp_brightness;
+		  num_duty_pcts++;
+          temp_brightness=temp_brightness - brightness_step;
+		}
+						
+		previous_num_duty_pcts = pwm_cfg->duty_cycles->num_duty_pcts;
+		previous_duty_pcts = pwm_cfg->duty_cycles->duty_pcts;
+	
+		pwm_cfg->duty_cycles->num_duty_pcts = num_duty_pcts;
+		pwm_cfg->duty_cycles->duty_pcts = pwm_cfg->old_duty_pcts;
+		pwm_cfg->old_duty_pcts = previous_duty_pcts;
+		pwm_cfg->lut_params.idx_len = pwm_cfg->duty_cycles->num_duty_pcts;
+	
+        ramp_step_ms=(ramp_ms*1000/num_duty_pcts-ztemt_lpg_pm_pwm_period)/1000; 
+        if(ramp_step_ms<=0)ramp_step_ms=0;
+	    
+		previous_ramp_step_ms = pwm_cfg->lut_params.ramp_step_ms;
+	    pwm_cfg->lut_params.ramp_step_ms = ramp_step_ms;
+	    previous_start_idx = pwm_cfg->duty_cycles->start_idx; 
+		pwm_cfg->duty_cycles->start_idx = start_idx;
+		pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+		previous_pause_hi = pwm_cfg->lut_params.lut_pause_hi;
+		pwm_cfg->lut_params.lut_pause_hi = pause_hi;
+		previous_pause_lo = pwm_cfg->lut_params.lut_pause_lo;
+		pwm_cfg->lut_params.lut_pause_lo = pause_lo;
+	
+		previous_lut_flags=pwm_cfg->lut_params.flags;
+		pwm_cfg->lut_params.flags = (PM_PWM_LUT_RAMP_UP | PM_PWM_LUT_PAUSE_LO_EN | PM_PWM_LUT_PAUSE_HI_EN);
+		
+		pwm_cfg->blinking = true;
+		pwm_cfg->mode = LPG_MODE;
+		led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;
+		
+	    if (led->id == QPNP_ID_LED_MPP)led->mpp_cfg->pwm_mode = LPG_MODE;
+		
+        pwm_cfg->pwm_period_us=ztemt_lpg_pm_pwm_period;  //config RGB three pwm_period same value
+
+	}
+	else return;
+		
+    //mutex_lock(&led->lock);
+
+	switch (ztemt_channel) {
+		case CHANNEL_RED:
+			led->cdev.name="red";
+		    led->id=QPNP_ID_RGB_RED;
+		    led->rgb_cfg->enable=RGB_LED_ENABLE_RED;
+		    led->rgb_cfg->pwm_cfg->pwm_channel=6;
+		    led->rgb_cfg->pwm_cfg->pwm_dev=pwm_dev_red;
+			break;
+		case CHANNEL_GREEN:
+			led->cdev.name="led:rgb_green";
+		    led->id=QPNP_ID_RGB_GREEN;
+		    led->rgb_cfg->enable=RGB_LED_ENABLE_GREEN;
+		    led->rgb_cfg->pwm_cfg->pwm_channel=5;
+		    led->rgb_cfg->pwm_cfg->pwm_dev=pwm_dev_green;
+			break;
+		case CHANNEL_BULE:
+			led->cdev.name="led:rgb_blue";
+		    led->id=QPNP_ID_RGB_BLUE;
+		    led->rgb_cfg->enable=RGB_LED_ENABLE_BLUE;
+		    led->rgb_cfg->pwm_cfg->pwm_channel=4;
+		    led->rgb_cfg->pwm_cfg->pwm_dev=pwm_dev_blue;
+			break; 
+	    case CHANNEL_MPP:
+            //led->cdev.name="led:rgb_blue";
+            led->id=QPNP_ID_LED_MPP;
+			break; 
+		default:	
+	        dev_err(&led->spmi_dev->dev, "Invalid LED chnanel \n");
+	        break;
+	        
+		}
+		
+	//mutex_unlock(&led->lock);
+
+	pwm_free(pwm_cfg->pwm_dev);
+	ret = qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	if (ret) {
+	   ztemt_rgb_led_debug("%s : %d : qpnp_pwm_init failed...\n",__func__,__LINE__);
+       return; //ztemt modify when qpnp_pwm_init() failed 
+
+	   if (pwm_cfg->mode == LPG_MODE){		
+		  pwm_cfg->duty_cycles->num_duty_pcts=previous_num_duty_pcts;
+		  pwm_cfg->duty_cycles->duty_pcts=previous_duty_pcts;
+		  pwm_cfg->old_duty_pcts = previous_duty_pcts;
+		  pwm_cfg->lut_params.idx_len=previous_idx_len;
+					
+		  pwm_cfg->lut_params.ramp_step_ms=previous_ramp_step_ms;
+		  
+		  pwm_cfg->duty_cycles->start_idx=previous_start_idx;
+		  pwm_cfg->lut_params.start_idx = pwm_cfg->duty_cycles->start_idx;
+			
+		  pwm_cfg->lut_params.lut_pause_hi=previous_pause_hi;
+		  pwm_cfg->lut_params.lut_pause_lo=previous_pause_lo;
+		  pwm_cfg->lut_params.flags=previous_lut_flags;
+		  led->cdev.brightness = blinking ? led->cdev.max_brightness : 0;		
+	   }
+	   else { 
+		  led->cdev.brightness=previous_brightness;
+	   }
+	   pwm_free(pwm_cfg->pwm_dev);
+	   qpnp_pwm_init(pwm_cfg, led->spmi_dev, led->cdev.name);
+	   dev_err(&led->spmi_dev->dev,"Failed to initialize pwm with new lpg value\n");
+    }	 
+    
+	qpnp_led_set(&led->cdev, led->cdev.brightness);	
+	return;
+}
+
+#endif
+static DEVICE_ATTR(led_mode, 0664, NULL, led_mode_store);
+static DEVICE_ATTR(strobe, 0664, NULL, led_strobe_type_store);
+static DEVICE_ATTR(pwm_us, 0664, NULL, pwm_us_store);
+static DEVICE_ATTR(pause_lo, 0664, NULL, pause_lo_store);
+static DEVICE_ATTR(pause_hi, 0664, NULL, pause_hi_store);
+static DEVICE_ATTR(start_idx, 0664, NULL, start_idx_store);
+static DEVICE_ATTR(ramp_step_ms, 0664, NULL, ramp_step_ms_store);
+static DEVICE_ATTR(lut_flags, 0664, NULL, lut_flags_store);
+static DEVICE_ATTR(duty_pcts, 0664, NULL, duty_pcts_store);
+static DEVICE_ATTR(blink, 0664, NULL, blink_store);
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+static DEVICE_ATTR(fade_parameter, 0664, fade_parameter_show, fade_parameter_store);
+static DEVICE_ATTR(grade_parameter, 0664, grade_parameter_show, grade_parameter_store);
+static DEVICE_ATTR(outn, 0664, outn_show, outn_store);
+#endif
+
+static struct attribute *led_attrs[] = {
+	&dev_attr_led_mode.attr,
+	&dev_attr_strobe.attr,
+	NULL
+};
+
+static const struct attribute_group led_attr_group = {
+	.attrs = led_attrs,
+};
+
+static struct attribute *pwm_attrs[] = {
+	&dev_attr_pwm_us.attr,
+	NULL
+};
+
+static struct attribute *lpg_attrs[] = {
+	&dev_attr_pause_lo.attr,
+	&dev_attr_pause_hi.attr,
+	&dev_attr_start_idx.attr,
+	&dev_attr_ramp_step_ms.attr,
+	&dev_attr_lut_flags.attr,
+	&dev_attr_duty_pcts.attr,
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+	&dev_attr_fade_parameter.attr,
+	&dev_attr_grade_parameter.attr,
+	&dev_attr_outn.attr,
+	//&dev_attr_brightness_2.attr,
+#endif
+	NULL
+};
+
+static struct attribute *blink_attrs[] = {
+	&dev_attr_blink.attr,
+	NULL
+};
+
+static const struct attribute_group pwm_attr_group = {
+	.attrs = pwm_attrs,
+};
+
+static const struct attribute_group lpg_attr_group = {
+	.attrs = lpg_attrs,
+};
+
+static const struct attribute_group blink_attr_group = {
+	.attrs = blink_attrs,
+};
+
+static int __devinit qpnp_flash_init(struct qpnp_led_data *led)
+{
+	int rc;
+
+	led->flash_cfg->flash_on = false;
+
+	rc = qpnp_led_masked_write(led,
+		FLASH_LED_STROBE_CTRL(led->base),
+		FLASH_STROBE_MASK, FLASH_DISABLE_ALL);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"LED %d flash write failed(%d)\n", led->id, rc);
+		return rc;
+	}
+
+	/* Disable flash LED module */
+	rc = qpnp_led_masked_write(led, FLASH_ENABLE_CONTROL(led->base),
+		FLASH_ENABLE_MASK, FLASH_DISABLE_ALL);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Enable reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	if (led->flash_cfg->torch_enable)
+		return 0;
+
+	/* Set headroom */
+	rc = qpnp_led_masked_write(led, FLASH_HEADROOM(led->base),
+		FLASH_HEADROOM_MASK, led->flash_cfg->headroom);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Headroom reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* Set startup delay */
+	rc = qpnp_led_masked_write(led,
+		FLASH_STARTUP_DELAY(led->base), FLASH_STARTUP_DLY_MASK,
+		led->flash_cfg->startup_dly);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Startup delay reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* Set timer control - safety or watchdog */
+	if (led->flash_cfg->safety_timer) {
+		rc = qpnp_led_masked_write(led,
+			FLASH_LED_TMR_CTRL(led->base),
+			FLASH_TMR_MASK, FLASH_TMR_SAFETY);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"LED timer ctrl reg write failed(%d)\n",
+				rc);
+			return rc;
+		}
+	}
+
+	/* Set Vreg force */
+	rc = qpnp_led_masked_write(led,	FLASH_VREG_OK_FORCE(led->base),
+		FLASH_VREG_MASK, FLASH_HW_VREG_OK);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Vreg OK reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* Set self fault check */
+	rc = qpnp_led_masked_write(led, FLASH_FAULT_DETECT(led->base),
+		FLASH_FAULT_DETECT_MASK, FLASH_SELFCHECK_ENABLE);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Fault detect reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* Set mask enable */
+	rc = qpnp_led_masked_write(led, FLASH_MASK_ENABLE(led->base),
+		FLASH_MASK_REG_MASK, FLASH_MASK_1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Mask enable reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	/* Set current ramp */
+	rc = qpnp_led_masked_write(led, FLASH_CURRENT_RAMP(led->base),
+		FLASH_CURRENT_RAMP_MASK, FLASH_RAMP_STEP_27US);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Current ramp reg write failed(%d)\n", rc);
+		return rc;
+	}
+
+	led->flash_cfg->strobe_type = 0;
+
+	/* dump flash registers */
+	qpnp_dump_regs(led, flash_debug_regs, ARRAY_SIZE(flash_debug_regs));
+
+	return 0;
+}
+
+static int __devinit qpnp_kpdbl_init(struct qpnp_led_data *led)
+{
+	int rc;
+	u8 val;
+
+	/* select row source - vbst or vph */
+	rc = spmi_ext_register_readl(led->spmi_dev->ctrl, led->spmi_dev->sid,
+				KPDBL_ROW_SRC_SEL(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read from addr=%x, rc(%d)\n",
+			KPDBL_ROW_SRC_SEL(led->base), rc);
+		return rc;
+	}
+
+	if (led->kpdbl_cfg->row_src_vbst)
+		val |= 1 << led->kpdbl_cfg->row_id;
+	else
+		val &= ~(1 << led->kpdbl_cfg->row_id);
+
+	rc = spmi_ext_register_writel(led->spmi_dev->ctrl, led->spmi_dev->sid,
+				KPDBL_ROW_SRC_SEL(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read from addr=%x, rc(%d)\n",
+			KPDBL_ROW_SRC_SEL(led->base), rc);
+		return rc;
+	}
+
+	/* row source enable */
+	rc = spmi_ext_register_readl(led->spmi_dev->ctrl, led->spmi_dev->sid,
+				KPDBL_ROW_SRC(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read from addr=%x, rc(%d)\n",
+			KPDBL_ROW_SRC(led->base), rc);
+		return rc;
+	}
+
+	if (led->kpdbl_cfg->row_src_en)
+		val |= KPDBL_ROW_SCAN_EN_MASK | (1 << led->kpdbl_cfg->row_id);
+	else
+		val &= ~(1 << led->kpdbl_cfg->row_id);
+
+	rc = spmi_ext_register_writel(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		KPDBL_ROW_SRC(led->base), &val, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to write to addr=%x, rc(%d)\n",
+			KPDBL_ROW_SRC(led->base), rc);
+		return rc;
+	}
+
+	/* enable module */
+	rc = qpnp_led_masked_write(led, KPDBL_ENABLE(led->base),
+		KPDBL_MODULE_EN_MASK, KPDBL_MODULE_EN);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Enable module write failed(%d)\n", rc);
+		return rc;
+	}
+
+	rc = qpnp_pwm_init(led->kpdbl_cfg->pwm_cfg, led->spmi_dev,
+				led->cdev.name);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm\n");
+		return rc;
+	}
+
+	/* dump kpdbl registers */
+	qpnp_dump_regs(led, kpdbl_debug_regs, ARRAY_SIZE(kpdbl_debug_regs));
+
+	return 0;
+}
+
+static int __devinit qpnp_rgb_init(struct qpnp_led_data *led)
+{
+	int rc;
+
+	rc = qpnp_led_masked_write(led, RGB_LED_SRC_SEL(led->base),
+		RGB_LED_SRC_MASK, RGB_LED_SOURCE_VPH_PWR);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Failed to write led source select register\n");
+		return rc;
+	}
+
+	rc = qpnp_pwm_init(led->rgb_cfg->pwm_cfg, led->spmi_dev,
+				led->cdev.name);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Failed to initialize pwm\n");
+		return rc;
+	}
+	/* Initialize led for use in auto trickle charging mode */
+	rc = qpnp_led_masked_write(led, RGB_LED_ATC_CTL(led->base),
+		led->rgb_cfg->enable, led->rgb_cfg->enable);
+
+	return 0;
+}
+
+static int __devinit qpnp_mpp_init(struct qpnp_led_data *led)
+{
+	int rc, val;
+
+
+	if (led->max_current < LED_MPP_CURRENT_MIN ||
+		led->max_current > LED_MPP_CURRENT_MAX) {
+		dev_err(&led->spmi_dev->dev,
+			"max current for mpp is not valid\n");
+		return -EINVAL;
+	}
+
+	val = (led->mpp_cfg->current_setting / LED_MPP_CURRENT_PER_SETTING) - 1;
+
+	if (val < 0)
+		val = 0;
+
+	rc = qpnp_led_masked_write(led, LED_MPP_VIN_CTRL(led->base),
+		LED_MPP_VIN_MASK, led->mpp_cfg->vin_ctrl);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Failed to write led vin control reg\n");
+		return rc;
+	}
+
+	rc = qpnp_led_masked_write(led, LED_MPP_SINK_CTRL(led->base),
+		LED_MPP_SINK_MASK, val);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Failed to write sink control reg\n");
+		return rc;
+	}
+
+	if (led->mpp_cfg->pwm_mode != MANUAL_MODE) {
+		rc = qpnp_pwm_init(led->mpp_cfg->pwm_cfg, led->spmi_dev,
+					led->cdev.name);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Failed to initialize pwm\n");
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int __devinit qpnp_led_initialize(struct qpnp_led_data *led)
+{
+	int rc = 0;
+
+	switch (led->id) {
+	case QPNP_ID_WLED:
+		rc = qpnp_wled_init(led);
+		if (rc)
+			dev_err(&led->spmi_dev->dev,
+				"WLED initialize failed(%d)\n", rc);
+		break;
+	case QPNP_ID_FLASH1_LED0:
+	case QPNP_ID_FLASH1_LED1:
+		rc = qpnp_flash_init(led);
+		if (rc)
+			dev_err(&led->spmi_dev->dev,
+				"FLASH initialize failed(%d)\n", rc);
+		break;
+	case QPNP_ID_RGB_RED:
+	case QPNP_ID_RGB_GREEN:
+	case QPNP_ID_RGB_BLUE:
+		rc = qpnp_rgb_init(led);
+		if (rc)
+			dev_err(&led->spmi_dev->dev,
+				"RGB initialize failed(%d)\n", rc);
+		break;
+	case QPNP_ID_LED_MPP:
+		rc = qpnp_mpp_init(led);
+		if (rc)
+			dev_err(&led->spmi_dev->dev,
+				"MPP initialize failed(%d)\n", rc);
+		break;
+	case QPNP_ID_KPDBL:
+		rc = qpnp_kpdbl_init(led);
+		if (rc)
+			dev_err(&led->spmi_dev->dev,
+				"KPDBL initialize failed(%d)\n", rc);
+		break;
+	default:
+		dev_err(&led->spmi_dev->dev, "Invalid LED(%d)\n", led->id);
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static int __devinit qpnp_get_common_configs(struct qpnp_led_data *led,
+				struct device_node *node)
+{
+	int rc;
+	u32 val;
+	const char *temp_string;
+
+	led->cdev.default_trigger = LED_TRIGGER_DEFAULT;
+	rc = of_property_read_string(node, "linux,default-trigger",
+		&temp_string);
+	if (!rc)
+		led->cdev.default_trigger = temp_string;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->default_on = false;
+	rc = of_property_read_string(node, "qcom,default-state",
+		&temp_string);
+	if (!rc) {
+		if (strncmp(temp_string, "on", sizeof("on")) == 0)
+			led->default_on = true;
+	} else if (rc != -EINVAL)
+		return rc;
+
+	led->turn_off_delay_ms = 0;
+	rc = of_property_read_u32(node, "qcom,turn-off-delay-ms", &val);
+	if (!rc)
+		led->turn_off_delay_ms = val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	return 0;
+}
+
+/*
+ * Handlers for alternative sources of platform_data
+ */
+static int __devinit qpnp_get_config_wled(struct qpnp_led_data *led,
+				struct device_node *node)
+{
+	u32 val;
+	int rc;
+
+	led->wled_cfg = devm_kzalloc(&led->spmi_dev->dev,
+				sizeof(struct wled_config_data), GFP_KERNEL);
+	if (!led->wled_cfg) {
+		dev_err(&led->spmi_dev->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	rc = spmi_ext_register_readl(led->spmi_dev->ctrl, led->spmi_dev->sid,
+		PMIC_VERSION_REG, &led->wled_cfg->pmic_version, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read pmic ver, rc(%d)\n", rc);
+	}
+
+	led->wled_cfg->num_strings = WLED_DEFAULT_STRINGS;
+	rc = of_property_read_u32(node, "qcom,num-strings", &val);
+	if (!rc)
+		led->wled_cfg->num_strings = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->ovp_val = WLED_DEFAULT_OVP_VAL;
+	rc = of_property_read_u32(node, "qcom,ovp-val", &val);
+	if (!rc)
+		led->wled_cfg->ovp_val = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->boost_curr_lim = WLED_BOOST_LIM_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,boost-curr-lim", &val);
+	if (!rc)
+		led->wled_cfg->boost_curr_lim = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->cp_select = WLED_CP_SEL_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,cp-sel", &val);
+	if (!rc)
+		led->wled_cfg->cp_select = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->ctrl_delay_us = WLED_CTRL_DLY_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,ctrl-delay-us", &val);
+	if (!rc)
+		led->wled_cfg->ctrl_delay_us = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->op_fdbck = WLED_OP_FDBCK_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,op-fdbck", &val);
+	if (!rc)
+		led->wled_cfg->op_fdbck = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->switch_freq = WLED_SWITCH_FREQ_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,switch-freq", &val);
+	if (!rc)
+		led->wled_cfg->switch_freq = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->wled_cfg->dig_mod_gen_en =
+		of_property_read_bool(node, "qcom,dig-mod-gen-en");
+
+	led->wled_cfg->cs_out_en =
+		of_property_read_bool(node, "qcom,cs-out-en");
+
+	return 0;
+}
+
+static int __devinit qpnp_get_config_flash(struct qpnp_led_data *led,
+				struct device_node *node, bool *reg_set)
+{
+	int rc;
+	u32 val;
+
+	led->flash_cfg = devm_kzalloc(&led->spmi_dev->dev,
+				sizeof(struct flash_config_data), GFP_KERNEL);
+	if (!led->flash_cfg) {
+		dev_err(&led->spmi_dev->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	rc = spmi_ext_register_readl(led->spmi_dev->ctrl, led->spmi_dev->sid,
+			FLASH_PERIPHERAL_SUBTYPE(led->base),
+			&led->flash_cfg->peripheral_subtype, 1);
+	if (rc) {
+		dev_err(&led->spmi_dev->dev,
+			"Unable to read from addr=%x, rc(%d)\n",
+			FLASH_PERIPHERAL_SUBTYPE(led->base), rc);
+	}
+
+	led->flash_cfg->torch_enable =
+		of_property_read_bool(node, "qcom,torch-enable");
+
+	if (led->id == QPNP_ID_FLASH1_LED0) {
+		led->flash_cfg->enable_module = FLASH_ENABLE_LED_0;
+		led->flash_cfg->current_addr = FLASH_LED_0_CURR(led->base);
+		led->flash_cfg->trigger_flash = FLASH_LED_0_OUTPUT;
+		if (!*reg_set) {
+			led->flash_cfg->flash_boost_reg =
+				regulator_get(&led->spmi_dev->dev,
+							"flash-boost");
+			if (IS_ERR(led->flash_cfg->flash_boost_reg)) {
+				rc = PTR_ERR(led->flash_cfg->flash_boost_reg);
+				dev_err(&led->spmi_dev->dev,
+					"Regulator get failed(%d)\n", rc);
+				goto error_get_flash_reg;
+			}
+			led->flash_cfg->flash_reg_get = true;
+			*reg_set = true;
+		} else
+			led->flash_cfg->flash_reg_get = false;
+
+		if (led->flash_cfg->torch_enable) {
+			led->flash_cfg->second_addr =
+						FLASH_LED_1_CURR(led->base);
+		}
+	} else if (led->id == QPNP_ID_FLASH1_LED1) {
+		led->flash_cfg->enable_module = FLASH_ENABLE_LED_1;
+		led->flash_cfg->current_addr = FLASH_LED_1_CURR(led->base);
+		led->flash_cfg->trigger_flash = FLASH_LED_1_OUTPUT;
+		if (!*reg_set) {
+			led->flash_cfg->flash_boost_reg =
+					regulator_get(&led->spmi_dev->dev,
+								"flash-boost");
+			if (IS_ERR(led->flash_cfg->flash_boost_reg)) {
+				rc = PTR_ERR(led->flash_cfg->flash_boost_reg);
+				dev_err(&led->spmi_dev->dev,
+					"Regulator get failed(%d)\n", rc);
+				goto error_get_flash_reg;
+			}
+			led->flash_cfg->flash_reg_get = true;
+			*reg_set = true;
+		} else
+			led->flash_cfg->flash_reg_get = false;
+
+		if (led->flash_cfg->torch_enable) {
+			led->flash_cfg->second_addr =
+						FLASH_LED_0_CURR(led->base);
+		}
+	} else {
+		dev_err(&led->spmi_dev->dev, "Unknown flash LED name given\n");
+		return -EINVAL;
+	}
+
+	if (led->flash_cfg->torch_enable) {
+		if (of_find_property(of_get_parent(node), "torch-boost-supply",
+									NULL)) {
+			led->flash_cfg->torch_boost_reg =
+				regulator_get(&led->spmi_dev->dev,
+								"torch-boost");
+			if (IS_ERR(led->flash_cfg->torch_boost_reg)) {
+				rc = PTR_ERR(led->flash_cfg->torch_boost_reg);
+				dev_err(&led->spmi_dev->dev,
+					"Torch regulator get failed(%d)\n", rc);
+				goto error_get_torch_reg;
+			}
+			led->flash_cfg->enable_module = FLASH_ENABLE_MODULE;
+		} else
+			led->flash_cfg->enable_module = FLASH_ENABLE_ALL;
+		led->flash_cfg->trigger_flash = FLASH_TORCH_OUTPUT;
+	}
+
+	rc = of_property_read_u32(node, "qcom,current", &val);
+	if (!rc) {
+		if (led->flash_cfg->torch_enable) {
+			led->flash_cfg->current_prgm = (val *
+				TORCH_MAX_LEVEL / led->max_current);
+			return 0;
+		}
+		else
+			led->flash_cfg->current_prgm = (val *
+				FLASH_MAX_LEVEL / led->max_current);
+	} else
+		if (led->flash_cfg->torch_enable)
+			goto error_get_torch_reg;
+		else
+			goto error_get_flash_reg;
+
+	rc = of_property_read_u32(node, "qcom,headroom", &val);
+	if (!rc)
+		led->flash_cfg->headroom = (u8) val;
+	else if (rc == -EINVAL)
+		led->flash_cfg->headroom = HEADROOM_500mV;
+	else
+		goto error_get_flash_reg;
+
+	rc = of_property_read_u32(node, "qcom,duration", &val);
+	if (!rc)
+		led->flash_cfg->duration = (u8)((val - 10) / 10);
+	else if (rc == -EINVAL)
+		led->flash_cfg->duration = FLASH_DURATION_200ms;
+	else
+		goto error_get_flash_reg;
+
+	rc = of_property_read_u32(node, "qcom,clamp-curr", &val);
+	if (!rc)
+		led->flash_cfg->clamp_curr = (val *
+				FLASH_MAX_LEVEL / led->max_current);
+	else if (rc == -EINVAL)
+		led->flash_cfg->clamp_curr = FLASH_CLAMP_200mA;
+	else
+		goto error_get_flash_reg;
+
+	rc = of_property_read_u32(node, "qcom,startup-dly", &val);
+	if (!rc)
+		led->flash_cfg->startup_dly = (u8) val;
+	else if (rc == -EINVAL)
+		led->flash_cfg->startup_dly = DELAY_128us;
+	else
+		goto error_get_flash_reg;
+
+	led->flash_cfg->safety_timer =
+		of_property_read_bool(node, "qcom,safety-timer");
+
+	return 0;
+
+error_get_torch_reg:
+	regulator_put(led->flash_cfg->torch_boost_reg);
+
+error_get_flash_reg:
+	regulator_put(led->flash_cfg->flash_boost_reg);
+	return rc;
+
+}
+
+static int __devinit qpnp_get_config_pwm(struct pwm_config_data *pwm_cfg,
+				struct spmi_device *spmi_dev,
+				struct device_node *node)
+{
+	struct property *prop;
+	int rc, i;
+	u32 val;
+	u8 *temp_cfg;
+
+	rc = of_property_read_u32(node, "qcom,pwm-channel", &val);
+	if (!rc)
+		pwm_cfg->pwm_channel = val;
+	else
+		return rc;
+
+	if (pwm_cfg->mode == PWM_MODE) {
+		rc = of_property_read_u32(node, "qcom,pwm-us", &val);
+		if (!rc)
+			pwm_cfg->pwm_period_us = val;
+		else
+			return rc;
+	}
+
+	pwm_cfg->use_blink =
+		of_property_read_bool(node, "qcom,use-blink");
+
+	if (pwm_cfg->mode == LPG_MODE || pwm_cfg->use_blink) {
+		pwm_cfg->duty_cycles =
+			devm_kzalloc(&spmi_dev->dev,
+			sizeof(struct pwm_duty_cycles), GFP_KERNEL);
+		if (!pwm_cfg->duty_cycles) {
+			dev_err(&spmi_dev->dev,
+				"Unable to allocate memory\n");
+			rc = -ENOMEM;
+			goto bad_lpg_params;
+		}
+
+		prop = of_find_property(node, "qcom,duty-pcts",
+			&pwm_cfg->duty_cycles->num_duty_pcts);
+		if (!prop) {
+			dev_err(&spmi_dev->dev, "Looking up property " \
+				"node qcom,duty-pcts failed\n");
+			rc =  -ENODEV;
+			goto bad_lpg_params;
+		} else if (!pwm_cfg->duty_cycles->num_duty_pcts) {
+			dev_err(&spmi_dev->dev, "Invalid length of " \
+				"duty pcts\n");
+			rc =  -EINVAL;
+			goto bad_lpg_params;
+		}
+
+		pwm_cfg->duty_cycles->duty_pcts =
+			devm_kzalloc(&spmi_dev->dev,
+			sizeof(int) * PWM_LUT_MAX_SIZE,
+			GFP_KERNEL);
+		if (!pwm_cfg->duty_cycles->duty_pcts) {
+			dev_err(&spmi_dev->dev,
+				"Unable to allocate memory\n");
+			rc = -ENOMEM;
+			goto bad_lpg_params;
+		}
+
+		pwm_cfg->old_duty_pcts =
+			devm_kzalloc(&spmi_dev->dev,
+			sizeof(int) * PWM_LUT_MAX_SIZE,
+			GFP_KERNEL);
+		if (!pwm_cfg->old_duty_pcts) {
+			dev_err(&spmi_dev->dev,
+				"Unable to allocate memory\n");
+			rc = -ENOMEM;
+			goto bad_lpg_params;
+		}
+
+		temp_cfg = devm_kzalloc(&spmi_dev->dev,
+				pwm_cfg->duty_cycles->num_duty_pcts *
+				sizeof(u8), GFP_KERNEL);
+		if (!temp_cfg) {
+			dev_err(&spmi_dev->dev, "Failed to allocate " \
+				"memory for duty pcts\n");
+			rc = -ENOMEM;
+			goto bad_lpg_params;
+		}
+
+		memcpy(temp_cfg, prop->value,
+			pwm_cfg->duty_cycles->num_duty_pcts);
+
+		for (i = 0; i < pwm_cfg->duty_cycles->num_duty_pcts; i++)
+			pwm_cfg->duty_cycles->duty_pcts[i] =
+				(int) temp_cfg[i];
+
+		rc = of_property_read_u32(node, "qcom,start-idx", &val);
+		if (!rc) {
+			pwm_cfg->lut_params.start_idx = val;
+			pwm_cfg->duty_cycles->start_idx = val;
+		} else
+			goto bad_lpg_params;
+
+		pwm_cfg->lut_params.lut_pause_hi = 0;
+		rc = of_property_read_u32(node, "qcom,pause-hi", &val);
+		if (!rc)
+			pwm_cfg->lut_params.lut_pause_hi = val;
+		else if (rc != -EINVAL)
+			goto bad_lpg_params;
+
+		pwm_cfg->lut_params.lut_pause_lo = 0;
+		rc = of_property_read_u32(node, "qcom,pause-lo", &val);
+		if (!rc)
+			pwm_cfg->lut_params.lut_pause_lo = val;
+		else if (rc != -EINVAL)
+			goto bad_lpg_params;
+
+		pwm_cfg->lut_params.ramp_step_ms =
+				QPNP_LUT_RAMP_STEP_DEFAULT;
+		rc = of_property_read_u32(node, "qcom,ramp-step-ms", &val);
+		if (!rc)
+			pwm_cfg->lut_params.ramp_step_ms = val;
+		else if (rc != -EINVAL)
+			goto bad_lpg_params;
+
+		pwm_cfg->lut_params.flags = QPNP_LED_PWM_FLAGS;
+		rc = of_property_read_u32(node, "qcom,lut-flags", &val);
+		if (!rc)
+			pwm_cfg->lut_params.flags = (u8) val;
+		else if (rc != -EINVAL)
+			goto bad_lpg_params;
+
+		pwm_cfg->lut_params.idx_len =
+			pwm_cfg->duty_cycles->num_duty_pcts;
+	}
+	return 0;
+
+bad_lpg_params:
+	pwm_cfg->use_blink = false;
+	if (pwm_cfg->mode == PWM_MODE) {
+		dev_err(&spmi_dev->dev, "LPG parameters not set for" \
+			" blink mode, defaulting to PWM mode\n");
+		return 0;
+	}
+	return rc;
+};
+
+static int qpnp_led_get_mode(const char *mode)
+{
+	if (strncmp(mode, "manual", strlen(mode)) == 0)
+		return MANUAL_MODE;
+	else if (strncmp(mode, "pwm", strlen(mode)) == 0)
+		return PWM_MODE;
+	else if (strncmp(mode, "lpg", strlen(mode)) == 0)
+		return LPG_MODE;
+	else
+		return -EINVAL;
+};
+
+static int __devinit qpnp_get_config_kpdbl(struct qpnp_led_data *led,
+				struct device_node *node)
+{
+	int rc;
+	u32 val;
+	u8 led_mode;
+	const char *mode;
+
+	led->kpdbl_cfg = devm_kzalloc(&led->spmi_dev->dev,
+				sizeof(struct kpdbl_config_data), GFP_KERNEL);
+	if (!led->kpdbl_cfg) {
+		dev_err(&led->spmi_dev->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	rc = of_property_read_string(node, "qcom,mode", &mode);
+	if (!rc) {
+		led_mode = qpnp_led_get_mode(mode);
+		if ((led_mode == MANUAL_MODE) || (led_mode == -EINVAL)) {
+			dev_err(&led->spmi_dev->dev, "Selected mode not " \
+				"supported for kpdbl.\n");
+			return -EINVAL;
+		}
+		led->kpdbl_cfg->pwm_cfg = devm_kzalloc(&led->spmi_dev->dev,
+					sizeof(struct pwm_config_data),
+					GFP_KERNEL);
+		if (!led->kpdbl_cfg->pwm_cfg) {
+			dev_err(&led->spmi_dev->dev,
+				"Unable to allocate memory\n");
+			return -ENOMEM;
+		}
+		led->kpdbl_cfg->pwm_cfg->mode = led_mode;
+		led->kpdbl_cfg->pwm_cfg->default_mode = led_mode;
+	} else
+		return rc;
+
+	rc = qpnp_get_config_pwm(led->kpdbl_cfg->pwm_cfg, led->spmi_dev,  node);
+	if (rc < 0)
+		return rc;
+
+	rc = of_property_read_u32(node, "qcom,row-id", &val);
+	if (!rc)
+		led->kpdbl_cfg->row_id = val;
+	else
+		return rc;
+
+	led->kpdbl_cfg->row_src_vbst =
+			of_property_read_bool(node, "qcom,row-src-vbst");
+
+	led->kpdbl_cfg->row_src_en =
+			of_property_read_bool(node, "qcom,row-src-en");
+
+	led->kpdbl_cfg->always_on =
+			of_property_read_bool(node, "qcom,always-on");
+
+	return 0;
+}
+
+static int __devinit qpnp_get_config_rgb(struct qpnp_led_data *led,
+				struct device_node *node)
+{
+	int rc;
+	u8 led_mode;
+	const char *mode;
+
+	led->rgb_cfg = devm_kzalloc(&led->spmi_dev->dev,
+				sizeof(struct rgb_config_data), GFP_KERNEL);
+	if (!led->rgb_cfg) {
+		dev_err(&led->spmi_dev->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	if (led->id == QPNP_ID_RGB_RED)
+		led->rgb_cfg->enable = RGB_LED_ENABLE_RED;
+	else if (led->id == QPNP_ID_RGB_GREEN)
+		led->rgb_cfg->enable = RGB_LED_ENABLE_GREEN;
+	else if (led->id == QPNP_ID_RGB_BLUE)
+		led->rgb_cfg->enable = RGB_LED_ENABLE_BLUE;
+	else
+		return -EINVAL;
+
+	rc = of_property_read_string(node, "qcom,mode", &mode);
+	if (!rc) {
+		led_mode = qpnp_led_get_mode(mode);
+		if ((led_mode == MANUAL_MODE) || (led_mode == -EINVAL)) {
+			dev_err(&led->spmi_dev->dev, "Selected mode not " \
+				"supported for rgb.\n");
+			return -EINVAL;
+		}
+		led->rgb_cfg->pwm_cfg = devm_kzalloc(&led->spmi_dev->dev,
+					sizeof(struct pwm_config_data),
+					GFP_KERNEL);
+		if (!led->rgb_cfg->pwm_cfg) {
+			dev_err(&led->spmi_dev->dev,
+				"Unable to allocate memory\n");
+			return -ENOMEM;
+		}
+		led->rgb_cfg->pwm_cfg->mode = led_mode;
+		led->rgb_cfg->pwm_cfg->default_mode = led_mode;
+	} else
+		return rc;
+
+	rc = qpnp_get_config_pwm(led->rgb_cfg->pwm_cfg, led->spmi_dev, node);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static int __devinit qpnp_get_config_mpp(struct qpnp_led_data *led,
+		struct device_node *node)
+{
+	int rc;
+	u32 val;
+	u8 led_mode;
+	const char *mode;
+
+	led->mpp_cfg = devm_kzalloc(&led->spmi_dev->dev,
+			sizeof(struct mpp_config_data), GFP_KERNEL);
+	if (!led->mpp_cfg) {
+		dev_err(&led->spmi_dev->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	led->mpp_cfg->current_setting = LED_MPP_CURRENT_MIN;
+	rc = of_property_read_u32(node, "qcom,current-setting", &val);
+	if (!rc) {
+		if (led->mpp_cfg->current_setting < LED_MPP_CURRENT_MIN)
+			led->mpp_cfg->current_setting = LED_MPP_CURRENT_MIN;
+		else if (led->mpp_cfg->current_setting > LED_MPP_CURRENT_MAX)
+			led->mpp_cfg->current_setting = LED_MPP_CURRENT_MAX;
+		else
+			led->mpp_cfg->current_setting = (u8) val;
+	} else if (rc != -EINVAL)
+		return rc;
+
+	led->mpp_cfg->source_sel = LED_MPP_SOURCE_SEL_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,source-sel", &val);
+	if (!rc)
+		led->mpp_cfg->source_sel = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->mpp_cfg->mode_ctrl = LED_MPP_MODE_SINK;
+	rc = of_property_read_u32(node, "qcom,mode-ctrl", &val);
+	if (!rc)
+		led->mpp_cfg->mode_ctrl = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->mpp_cfg->vin_ctrl = LED_MPP_VIN_CTRL_DEFAULT;
+	rc = of_property_read_u32(node, "qcom,vin-ctrl", &val);
+	if (!rc)
+		led->mpp_cfg->vin_ctrl = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	led->mpp_cfg->min_brightness = 0;
+	rc = of_property_read_u32(node, "qcom,min-brightness", &val);
+	if (!rc)
+		led->mpp_cfg->min_brightness = (u8) val;
+	else if (rc != -EINVAL)
+		return rc;
+
+	rc = of_property_read_string(node, "qcom,mode", &mode);
+	if (!rc) {
+		led_mode = qpnp_led_get_mode(mode);
+		led->mpp_cfg->pwm_mode = led_mode;
+		if (led_mode == MANUAL_MODE)
+			return MANUAL_MODE;
+		else if (led_mode == -EINVAL) {
+			dev_err(&led->spmi_dev->dev, "Selected mode not " \
+				"supported for mpp.\n");
+			return -EINVAL;
+		}
+		led->mpp_cfg->pwm_cfg = devm_kzalloc(&led->spmi_dev->dev,
+					sizeof(struct pwm_config_data),
+					GFP_KERNEL);
+		if (!led->mpp_cfg->pwm_cfg) {
+			dev_err(&led->spmi_dev->dev,
+				"Unable to allocate memory\n");
+			return -ENOMEM;
+		}
+		led->mpp_cfg->pwm_cfg->mode = led_mode;
+		led->mpp_cfg->pwm_cfg->default_mode = led_mode;
+	} else
+		return rc;
+
+	rc = qpnp_get_config_pwm(led->mpp_cfg->pwm_cfg, led->spmi_dev, node);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+static int __devinit qpnp_leds_probe(struct spmi_device *spmi)
+{
+	struct qpnp_led_data *led, *led_array;
+	struct resource *led_resource;
+	struct device_node *node, *temp;
+	int rc, i, num_leds = 0, parsed_leds = 0;
+	const char *led_label;
+	bool regulator_probe = false;
+
+	node = spmi->dev.of_node;
+	if (node == NULL)
+		return -ENODEV;
+
+	temp = NULL;
+	while ((temp = of_get_next_child(node, temp)))
+		num_leds++;
+
+	if (!num_leds)
+		return -ECHILD;
+
+	led_array = devm_kzalloc(&spmi->dev,
+		(sizeof(struct qpnp_led_data) * num_leds), GFP_KERNEL);
+	if (!led_array) {
+		dev_err(&spmi->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	for_each_child_of_node(node, temp) {
+		led = &led_array[parsed_leds];
+		led->num_leds = num_leds;
+		led->spmi_dev = spmi;
+
+		led_resource = spmi_get_resource(spmi, NULL, IORESOURCE_MEM, 0);
+		if (!led_resource) {
+			dev_err(&spmi->dev, "Unable to get LED base address\n");
+			rc = -ENXIO;
+			goto fail_id_check;
+		}
+		led->base = led_resource->start;
+
+		rc = of_property_read_string(temp, "label", &led_label);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev,
+				"Failure reading label, rc = %d\n", rc);
+			goto fail_id_check;
+		}
+
+		rc = of_property_read_string(temp, "linux,name",
+			&led->cdev.name);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev,
+				"Failure reading led name, rc = %d\n", rc);
+			goto fail_id_check;
+		}
+
+		rc = of_property_read_u32(temp, "qcom,max-current",
+			&led->max_current);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev,
+				"Failure reading max_current, rc =  %d\n", rc);
+			goto fail_id_check;
+		}
+
+		rc = of_property_read_u32(temp, "qcom,id", &led->id);
+		if (rc < 0) {
+			dev_err(&led->spmi_dev->dev,
+				"Failure reading led id, rc =  %d\n", rc);
+			goto fail_id_check;
+		}
+
+		rc = qpnp_get_common_configs(led, temp);
+		if (rc) {
+			dev_err(&led->spmi_dev->dev,
+				"Failure reading common led configuration," \
+				" rc = %d\n", rc);
+			goto fail_id_check;
+		}
+
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+		led->cdev.brightness_set    = ztemt_qpnp_led_set;
+#else		
+		led->cdev.brightness_set    = qpnp_led_set;
+#endif
+		led->cdev.brightness_get    = qpnp_led_get;
+
+		if (strncmp(led_label, "wled", sizeof("wled")) == 0) {
+			rc = qpnp_get_config_wled(led, temp);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+					"Unable to read wled config data\n");
+				goto fail_id_check;
+			}
+		} else if (strncmp(led_label, "flash", sizeof("flash"))
+				== 0) {
+			if (!of_find_property(node, "flash-boost-supply", NULL))
+				regulator_probe = true;
+			rc = qpnp_get_config_flash(led, temp, &regulator_probe);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+					"Unable to read flash config data\n");
+				goto fail_id_check;
+			}
+		} else if (strncmp(led_label, "rgb", sizeof("rgb")) == 0) {
+			rc = qpnp_get_config_rgb(led, temp);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+					"Unable to read rgb config data\n");
+				goto fail_id_check;
+			}
+		} else if (strncmp(led_label, "mpp", sizeof("mpp")) == 0) {
+			rc = qpnp_get_config_mpp(led, temp);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+						"Unable to read mpp config data\n");
+				goto fail_id_check;
+			}
+		} else if (strncmp(led_label, "kpdbl", sizeof("kpdbl")) == 0) {
+			num_kpbl_leds_on = 0;
+			rc = qpnp_get_config_kpdbl(led, temp);
+			if (rc < 0) {
+				dev_err(&led->spmi_dev->dev,
+					"Unable to read kpdbl config data\n");
+				goto fail_id_check;
+			}
+		} else {
+			dev_err(&led->spmi_dev->dev, "No LED matching label\n");
+			rc = -EINVAL;
+			goto fail_id_check;
+		}
+
+		mutex_init(&led->lock);
+		INIT_WORK(&led->work, qpnp_led_work);
+
+		rc =  qpnp_led_initialize(led);
+		if (rc < 0)
+			goto fail_id_check;
+
+		rc = qpnp_led_set_max_brightness(led);
+		if (rc < 0)
+			goto fail_id_check;
+
+		rc = led_classdev_register(&spmi->dev, &led->cdev);
+		if (rc) {
+			dev_err(&spmi->dev, "unable to register led %d,rc=%d\n",
+						 led->id, rc);
+			goto fail_id_check;
+		}
+
+		if (led->id == QPNP_ID_FLASH1_LED0 ||
+			led->id == QPNP_ID_FLASH1_LED1) {
+			rc = sysfs_create_group(&led->cdev.dev->kobj,
+							&led_attr_group);
+			if (rc)
+				goto fail_id_check;
+
+		}
+
+		if (led->id == QPNP_ID_LED_MPP) {
+			if (!led->mpp_cfg->pwm_cfg)
+				break;
+			if (led->mpp_cfg->pwm_cfg->mode == PWM_MODE) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&pwm_attr_group);
+				if (rc)
+					goto fail_id_check;
+			}
+			if (led->mpp_cfg->pwm_cfg->use_blink) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&blink_attr_group);
+				if (rc)
+					goto fail_id_check;
+
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&lpg_attr_group);
+				if (rc)
+					goto fail_id_check;
+			} else if (led->mpp_cfg->pwm_cfg->mode == LPG_MODE) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&lpg_attr_group);
+				if (rc)
+					goto fail_id_check;
+			}
+		} else if ((led->id == QPNP_ID_RGB_RED) ||
+			(led->id == QPNP_ID_RGB_GREEN) ||
+			(led->id == QPNP_ID_RGB_BLUE)) {
+			if (led->rgb_cfg->pwm_cfg->mode == PWM_MODE) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&pwm_attr_group);
+				if (rc)
+					goto fail_id_check;
+			}
+			if (led->rgb_cfg->pwm_cfg->use_blink) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&blink_attr_group);
+				if (rc)
+					goto fail_id_check;
+
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&lpg_attr_group);
+				if (rc)
+					goto fail_id_check;
+			} else if (led->rgb_cfg->pwm_cfg->mode == LPG_MODE) {
+				rc = sysfs_create_group(&led->cdev.dev->kobj,
+					&lpg_attr_group);
+				if (rc)
+					goto fail_id_check;
+			}
+		}
+
+		/* configure default state */
+		if (led->default_on) {
+			led->cdev.brightness = led->cdev.max_brightness;
+			__qpnp_led_work(led, led->cdev.brightness);
+			if (led->turn_off_delay_ms > 0)
+				qpnp_led_turn_off(led);
+		} else
+			led->cdev.brightness = LED_OFF;
+
+		parsed_leds++;
+	}
+	dev_set_drvdata(&spmi->dev, led_array);
+	return 0;
+
+fail_id_check:
+	for (i = 0; i < parsed_leds; i++) {
+		mutex_destroy(&led_array[i].lock);
+		led_classdev_unregister(&led_array[i].cdev);
+	}
+
+	return rc;
+}
+
+static int __devexit qpnp_leds_remove(struct spmi_device *spmi)
+{
+	struct qpnp_led_data *led_array  = dev_get_drvdata(&spmi->dev);
+	int i, parsed_leds = led_array->num_leds;
+
+	for (i = 0; i < parsed_leds; i++) {
+		cancel_work_sync(&led_array[i].work);
+		mutex_destroy(&led_array[i].lock);
+		led_classdev_unregister(&led_array[i].cdev);
+		switch (led_array[i].id) {
+		case QPNP_ID_WLED:
+			break;
+		case QPNP_ID_FLASH1_LED0:
+		case QPNP_ID_FLASH1_LED1:
+			if (led_array[i].flash_cfg->flash_reg_get)
+				regulator_put(led_array[i].flash_cfg-> \
+							flash_boost_reg);
+			if (led_array[i].flash_cfg->torch_enable)
+				regulator_put(led_array[i].flash_cfg->\
+							torch_boost_reg);
+			sysfs_remove_group(&led_array[i].cdev.dev->kobj,
+							&led_attr_group);
+			break;
+		case QPNP_ID_RGB_RED:
+		case QPNP_ID_RGB_GREEN:
+		case QPNP_ID_RGB_BLUE:
+			if (led_array[i].rgb_cfg->pwm_cfg->mode == PWM_MODE)
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &pwm_attr_group);
+			if (led_array[i].rgb_cfg->pwm_cfg->use_blink) {
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &blink_attr_group);
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &lpg_attr_group);
+			} else if (led_array[i].rgb_cfg->pwm_cfg->mode\
+					== LPG_MODE)
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &lpg_attr_group);
+			break;
+		case QPNP_ID_LED_MPP:
+			if (!led_array[i].mpp_cfg->pwm_cfg)
+				break;
+			if (led_array[i].mpp_cfg->pwm_cfg->mode == PWM_MODE)
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &pwm_attr_group);
+			if (led_array[i].mpp_cfg->pwm_cfg->use_blink) {
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &blink_attr_group);
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &lpg_attr_group);
+			} else if (led_array[i].mpp_cfg->pwm_cfg->mode\
+					== LPG_MODE)
+				sysfs_remove_group(&led_array[i].cdev.dev->\
+					kobj, &lpg_attr_group);
+			break;
+		default:
+			dev_err(&led_array[i].spmi_dev->dev,
+					"Invalid LED(%d)\n",
+					led_array[i].id);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id spmi_match_table[] = {
+	{ .compatible = "qcom,ztemt-leds-qpnp",},
+	{ },
+};
+#else
+#define spmi_match_table NULL
+#endif
+
+static struct spmi_driver qpnp_leds_driver = {
+	.driver		= {
+		.name	= "qcom,ztemt-leds-qpnp",
+		.of_match_table = spmi_match_table,
+	},
+	.probe		= qpnp_leds_probe,
+	.remove		= __devexit_p(qpnp_leds_remove),
+};
+
+static int __init qpnp_led_init(void)
+{
+	return spmi_driver_register(&qpnp_leds_driver);
+}
+module_init(qpnp_led_init);
+
+static void __exit qpnp_led_exit(void)
+{
+	spmi_driver_unregister(&qpnp_leds_driver);
+}
+module_exit(qpnp_led_exit);
+
+MODULE_DESCRIPTION("QPNP LEDs driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("leds:ztemt-leds-qpnp");
+
diff --git a/drivers/platform/msm/qpnp-power-on.c b/drivers/platform/msm/qpnp-power-on.c
old mode 100644
new mode 100755
index b937a3c..59a7882
--- a/drivers/platform/msm/qpnp-power-on.c
+++ b/drivers/platform/msm/qpnp-power-on.c
@@ -23,6 +23,10 @@
 #include <linux/input.h>
 #include <linux/log2.h>
 #include <linux/qpnp/power-on.h>
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+#include <linux/io.h>
+#include <mach/restart.h>
+#endif
 
 #define PMIC_VER_8941           0x01
 #define PMIC_VERSION_REG        0x0105
@@ -1069,6 +1073,54 @@ static int __devinit qpnp_pon_config_init(struct qpnp_pon *pon)
 	return rc;
 }
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+int  poweron_reason_index=0;
+int  zte_reboot_reason=0;
+
+static ssize_t poweron_reason_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    if(buf)
+		
+	*buf = (char)poweron_reason_index;
+	return 1;
+}
+
+static ssize_t poweron_reason_info_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+     return count;
+}
+
+static DEVICE_ATTR(info, 0444, poweron_reason_info_show, poweron_reason_info_store);
+
+static ssize_t reboot_reason_info_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    if(buf)	
+	*buf = (char)zte_reboot_reason;
+    return 1;
+	//return snprintf(buf, PAGE_SIZE, "%d\n",zte_reboot_reason);
+}
+
+void qpnp_get_reboot_reason(void){
+
+ unsigned long reboot_reason=0;
+ 
+   reboot_reason=__raw_readl(restart_reason);
+      
+  if(0x77665503==reboot_reason)
+  	{
+	  zte_reboot_reason=3;
+    }
+   __raw_writel(0,restart_reason); 
+}
+
+static DEVICE_ATTR(rb_reason, 0444, reboot_reason_info_show, NULL);
+
+
+#endif
+
 static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 {
 	struct qpnp_pon *pon;
@@ -1079,6 +1131,10 @@ static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 	u8 pon_sts = 0;
 	const char *s3_src;
 	u8 s3_src_reg;
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+	static struct kobject *poweron_reason_kobject = NULL;
+	int ret;
+#endif
 
 	pon = devm_kzalloc(&spmi->dev, sizeof(struct qpnp_pon),
 							GFP_KERNEL);
@@ -1137,6 +1193,27 @@ static int __devinit qpnp_pon_probe(struct spmi_device *spmi)
 		pon->spmi->sid, index ? qpnp_pon_reason[index - 1] :
 		"Unknown", cold_boot ? "cold" : "warm");
 
+#ifdef CONFIG_ZTE_POWEROFF_ALARM
+
+        if(qpnp_pon_is_warm_reset())
+			index=0;		
+		poweron_reason_kobject = kobject_create_and_add("zte_poweron_reason", NULL);
+		if(poweron_reason_kobject == NULL) {
+			ret = -ENOMEM;
+			return ret;
+		}	
+		ret = sysfs_create_file(poweron_reason_kobject, &dev_attr_info.attr);
+		if(ret){
+			return ret;
+		}
+		poweron_reason_index=index;
+
+       qpnp_get_reboot_reason();
+       ret = sysfs_create_file(poweron_reason_kobject, &dev_attr_rb_reason.attr);
+		if(ret){
+			return ret;
+		}		
+#endif
 	rc = of_property_read_u32(pon->spmi->dev.of_node,
 				"qcom,pon-dbc-delay", &delay);
 	if (rc) {
diff --git a/drivers/platform/msm/qpnp-pwm.c b/drivers/platform/msm/qpnp-pwm.c
old mode 100644
new mode 100755
index 588afc6..6536ea9
--- a/drivers/platform/msm/qpnp-pwm.c
+++ b/drivers/platform/msm/qpnp-pwm.c
@@ -27,6 +27,12 @@
 #include <linux/radix-tree.h>
 #include <linux/qpnp/pwm.h>
 
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+#include <linux/delay.h>
+static int ztemt_duty_pct_len;
+static int ztemt_duty_pct_start;
+static int ztemt_duty_pct_end;
+#endif
 #define QPNP_LPG_DRIVER_NAME	"qcom,qpnp-pwm"
 #define QPNP_LPG_CHANNEL_BASE	"qpnp-lpg-channel-base"
 #define QPNP_LPG_LUT_BASE	"qpnp-lpg-lut-base"
@@ -580,7 +586,13 @@ static int qpnp_lpg_change_table(struct pwm_device *pwm,
 		if (raw_value)
 			pwm_value = duty_pct[i];
 		else
+		{
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+			pwm_value = (duty_pct[i] << pwm_size) / 255;
+#else
 			pwm_value = (duty_pct[i] << pwm_size) / 100;
+#endif 
+		}
 
 		if (pwm_value > max_pwm_value)
 			pwm_value = max_pwm_value;
@@ -1033,6 +1045,10 @@ static int qpnp_lpg_configure_lut_state(struct pwm_device *pwm,
 	addr = SPMI_LPG_REG_ADDR(lpg_config->base_addr,
 				QPNP_ENABLE_CONTROL);
 
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+    //mdelay(1);//modify by ttwang for LPG bug,the Qualcomm suggest insert 1 ms delay here
+    udelay(30); 
+#endif
 	rc = qpnp_lpg_save_and_write(value2, mask2, reg2,
 					addr, 1, chip);
 	if (rc)
@@ -1190,11 +1206,25 @@ static int _pwm_lut_config(struct pwm_device *pwm, int period_us,
 	lut_config->lo_index = start_idx + 1;
 	lut_config->hi_index = start_idx + len;
 
-	rc = qpnp_lpg_change_table(pwm, duty_pct, raw_lut);
-	if (rc) {
+#ifdef CONFIG_ZTEMT_RGB_BREATH_LEDS
+    if(!((ztemt_duty_pct_len==len)&&(ztemt_duty_pct_start==duty_pct[start_idx])&&(ztemt_duty_pct_end==duty_pct[start_idx+len-1])))
+    {   
+	   rc = qpnp_lpg_change_table(pwm, duty_pct, raw_lut);
+	   if (rc) {
 		pr_err("qpnp_lpg_change_table: rc=%d\n", rc);
 		return -EINVAL;
-	}
+	   }
+    }
+    ztemt_duty_pct_len=len;
+    ztemt_duty_pct_start=duty_pct[start_idx];
+    ztemt_duty_pct_end=duty_pct[start_idx+len-1];	
+#else
+	rc = qpnp_lpg_change_table(pwm, duty_pct, raw_lut);
+	if (rc) {
+	pr_err("qpnp_lpg_change_table: rc=%d\n", rc);
+	return -EINVAL;
+    }
+#endif
 
 after_table_write:
 	ramp_step_ms = lut_params.ramp_step_ms;
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
old mode 100644
new mode 100755
index e744d04..9b37fd6
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -13,7 +13,11 @@ config POWER_SUPPLY_DEBUG
 	help
 	  Say Y here to enable debugging messages for power supply class
 	  and drivers.
-
+config ZTEMT_POWER_DEBUG
+	bool "ZTEMT Power Debug Feature"
+	default y
+	help
+	  ZTEMT Power Debug Feature
 config PDA_POWER
 	tristate "Generic PDA/phone power driver"
 	depends on !S390
@@ -485,6 +489,24 @@ config CHARGER_SMB347
 	  Say Y to include support for Summit Microelectronics SMB347
 	  Battery Charger.
 
+config ZTEMT_CHARGE
+	bool "ZTEMT Charge Feature"
+	default y
+	help
+	  ZTEMT Charge Feature
+
+config ZTEMT_2000AMH_BATTERY
+	bool "ZTEMT 2000AMH BATTERY"
+	default n
+	help
+	  ZTEMT 2000AMH Battery Feature
+	  
+config ZTEMT_2400AMH_BATTERY
+	bool "ZTEMT 2400AMH BATTERY"
+	default n
+	help
+	  ZTEMT 2400AMH Battery Feature
+	  
 config AB8500_BM
 	bool "AB8500 Battery Management Driver"
 	depends on AB8500_CORE && AB8500_GPADC
@@ -506,4 +528,39 @@ config QPNP_BMS
 	  Say Y here to enable support for QPNP chip bms device.
 	  It registers a fuelgauge bms power supply to report
 	  State of Charge.
+#ztemt add by ttwang for hw version 2014/03/21
+config ZTEMT_HW_VERSION
+	bool "ZTEMT HW VERSION"
+	default n
+	help
+	  ZTEMT HW VERSION
+	
+config ZTEMT_HW_VERSION_GPIO
+	bool "ZTEMT HW VERSION GPIO"
+	default n
+	depends on ZTEMT_HW_VERSION
+	help
+	  ZTEMT HW VERSION GPIO
+
+config ZTEMT_HW_VERSION_ADC
+	bool "ZTEMT HW VERSION ADC"
+	default n
+	depends on ZTEMT_HW_VERSION
+	help
+	  ZTEMT HW VERSION ADC
+	  
+config ZTEMT_HW_VERSION_NX601J
+	bool "ZTEMT HW VERSION NX601J"
+	depends on ZTEMT_HW_VERSION_ADC
+	default n
+	help
+	  ZTEMT HW VERSION NX601J	  
+
+config ZTEMT_HW_VERSION_NX504J
+	bool "ZTEMT HW VERSION NX504J"
+	depends on ZTEMT_HW_VERSION_ADC
+	default n
+	help
+	  ZTEMT HW VERSION NX504J
+#ztemt end	  
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
old mode 100644
new mode 100755
index 8f152aa..84d7644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -65,3 +65,4 @@ obj-$(CONFIG_QPNP_CHARGER)	+= qpnp-charger.o
 obj-$(CONFIG_LTC4088_CHARGER)	+= ltc4088-charger.o
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_BATTERY_BCL)	+= battery_current_limit.o
+obj-$(CONFIG_ZTEMT_HW_VERSION)	+= ztemt_hw_version.o
diff --git a/drivers/power/power_supply_core.c b/drivers/power/power_supply_core.c
old mode 100644
new mode 100755
index f10e1d4..508920e
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@ -103,6 +103,20 @@ int power_supply_set_present(struct power_supply *psy, bool enable)
 }
 EXPORT_SYMBOL_GPL(power_supply_set_present);
 
+#ifdef CONFIG_ZTEMT_CHARGE
+int power_supply_set_charger_online(struct power_supply *psy, bool enable)
+{
+	const union power_supply_propval ret = {enable,};
+
+	if (psy->set_property)
+		return psy->set_property(psy, POWER_SUPPLY_PROP_CHARGER_ONLINE,
+								&ret);
+
+	return -ENXIO;
+}
+EXPORT_SYMBOL_GPL(power_supply_set_charger_online);
+#endif
+
 /**
  * power_supply_set_online - set online state of the power supply
  * @psy:	the power supply to control
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
old mode 100644
new mode 100755
index 4688514..2c24d19
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -133,7 +133,12 @@ static ssize_t power_supply_store_property(struct device *dev,
 /* Must be in the same order as POWER_SUPPLY_PROP_* */
 static struct device_attribute power_supply_attrs[] = {
 	/* Properties of type `int' */
+	#ifdef CONFIG_ZTEMT_CHARGE	
+	POWER_SUPPLY_ATTR(charger_online),
 	POWER_SUPPLY_ATTR(status),
+	#else	
+	POWER_SUPPLY_ATTR(status),
+	#endif
 	POWER_SUPPLY_ATTR(charge_type),
 	POWER_SUPPLY_ATTR(health),
 	POWER_SUPPLY_ATTR(present),
diff --git a/drivers/power/qpnp-bms.c b/drivers/power/qpnp-bms.c
old mode 100644
new mode 100755
index e227ecd..58eeec9
--- a/drivers/power/qpnp-bms.c
+++ b/drivers/power/qpnp-bms.c
@@ -2350,7 +2350,6 @@ static int calculate_raw_soc(struct qpnp_bms_chip *chip,
 					- params->cc_uah
 					- params->uuc_uah;
 	pr_debug("RUC = %duAh\n", remaining_usable_charge_uah);
-
 	soc = DIV_ROUND_CLOSEST((remaining_usable_charge_uah * 100),
 				(params->fcc_uah - params->uuc_uah));
 
@@ -3385,7 +3384,13 @@ static void battery_insertion_check(struct qpnp_bms_chip *chip)
 /* Returns capacity as a SoC percentage between 0 and 100 */
 static int get_prop_bms_capacity(struct qpnp_bms_chip *chip)
 {
+#ifdef CONFIG_ZTEMT_CHARGE
+	int soc = report_state_of_charge(chip);
+	soc = bound_soc(soc);
+	return soc;
+#else
 	return report_state_of_charge(chip);
+#endif
 }
 
 static void qpnp_bms_external_power_changed(struct power_supply *psy)
@@ -3648,7 +3653,13 @@ static int set_battery_data(struct qpnp_bms_chip *chip)
 	if (chip->batt_type == BATT_DESAY) {
 		batt_data = &desay_5200_data;
 	} else if (chip->batt_type == BATT_PALLADIUM) {
+#ifdef CONFIG_ZTEMT_2400AMH_BATTERY
+		batt_data = &ztemt_2400mAh_data;
+#elif defined(CONFIG_ZTEMT_2000AMH_BATTERY)
+		batt_data = &ztemt_2000mAh_data;
+#else
 		batt_data = &palladium_1500_data;
+#endif
 	} else if (chip->batt_type == BATT_OEM) {
 		batt_data = &oem_batt_data;
 	} else if (chip->batt_type == BATT_QRD_4V35_2000MAH) {
diff --git a/drivers/power/qpnp-charger.c b/drivers/power/qpnp-charger.c
old mode 100644
new mode 100755
index 3e060b8..ee145e7
--- a/drivers/power/qpnp-charger.c
+++ b/drivers/power/qpnp-charger.c
@@ -220,6 +220,25 @@
 #define BOOST_FLASH_WA			BIT(1)
 #define POWER_STAGE_WA			BIT(2)
 
+#ifdef CONFIG_ZTEMT_CHARGE
+static int debug_mask_charger  = 0;
+module_param_named(debug_mask_charger, debug_mask_charger, int, S_IRUGO | S_IWUSR | S_IWGRP);
+#define DBG_CHARGE(x...) do {if (debug_mask_charger) pr_info(">>ZTEMT_CHARGE>>  " x); } while (0)
+#endif
+
+#ifdef CONFIG_ZTEMT_CHARGE
+	struct qpnp_chg_chip	*g_chip = NULL;
+
+enum  dwc3_chg_type {
+	DWC3_INVALID_CHARGER = 0,
+	DWC3_SDP_CHARGER,
+	DWC3_DCP_CHARGER,
+	DWC3_CDP_CHARGER,
+	DWC3_PROPRIETARY_CHARGER,
+	DWC3_FLOATED_CHARGER,
+};
+#endif
+
 struct qpnp_chg_irq {
 	int		irq;
 	unsigned long		disabled;
@@ -389,8 +408,85 @@ struct qpnp_chg_chip {
 	struct work_struct		reduce_power_stage_work;
 	bool				power_stage_workaround_running;
 	bool				power_stage_workaround_enable;
+#ifdef CONFIG_ZTEMT_CHARGE
+	struct delayed_work battery_monitor_work;
+	unsigned int	 current_capacity ;
+#endif
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	struct delayed_work power_debug_work;
+#endif
+};
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+#include <../../arch/arm/mach-msm/clock.h>
+#define POWER_MONITOR_PERIOD_MS	10000
+#define DRV_NAME "zte_power_debug"
+static int power_debug_switch=1;
+static struct qpnp_chg_chip *chip_temp;
+extern int msm_show_resume_irq_mask; //used to print the resume irq
+extern void global_print_active_locks( void );
+//print suspend_states
+//extern int suspend_stats_debug(void);
+#endif
+
+#ifdef CONFIG_ZTEMT_CHARGE
+struct monitor_status {
+    bool  is_charger_online;
+    bool  is_temp_abnormal;
+	int  batt_temp;
+};
+
+static struct monitor_status monitor_st = {
+    .is_charger_online = 0,
+	.is_temp_abnormal = 0,
+	.batt_temp = 25,
+};
+enum batt_temp_st {
+	BATT_TEMP_GOOD = 0,
+	BATT_TEMP_ABNORMAL = 1,
 };
 
+static bool 
+is_charger_online(void)
+{
+    return monitor_st.is_charger_online;
+}
+static void
+set_charger_status(bool present)
+{
+    monitor_st.is_charger_online = present;
+}
+
+static bool
+is_chg_batt_temp_abnormal(void)
+{
+    return monitor_st.is_temp_abnormal;
+}
+
+static void 
+set_chg_batt_temp_st(enum batt_temp_st temp_status)
+{
+    monitor_st.is_temp_abnormal =(bool) temp_status;
+}
+
+static void 
+set_batt_temp(int temp)
+{
+    monitor_st.batt_temp = temp;
+}
+/*
+*  ���������¶��Ƿ��쳣
+*  �����¶��Ƿ���[-6 , 48] ��Χ�ڣ�
+*/
+#define BATT_TEMP_HIGH   530
+#define BATT_TEMP_LOW    -60
+static int is_batt_temp_abnormal(void)
+{
+    int ret = 0;
+    if(monitor_st.batt_temp<BATT_TEMP_LOW || monitor_st.batt_temp>BATT_TEMP_HIGH )
+		ret = 1;
+	return ret;
+}
+#endif
 static void
 qpnp_chg_set_appropriate_battery_current(struct qpnp_chg_chip *chip);
 
@@ -789,6 +885,21 @@ qpnp_chg_is_dc_chg_plugged_in(struct qpnp_chg_chip *chip)
 	return (dcin_valid_rt_sts & DCIN_VALID_IRQ) ? 1 : 0;
 }
 
+#ifdef CONFIG_ZTEMT_CHARGE
+int  qpnp_chg_is_chg_plugged_in(void)
+{
+       int is_plugged = false ;
+	if (!g_chip) {
+		pr_err("%s:called before init\n",__func__);
+		return 0;
+	}
+  is_plugged = (g_chip->usb_present) || (g_chip->dc_present) ||  \
+ 		          qpnp_chg_is_usb_chg_plugged_in(g_chip) ||  \
+ 	            qpnp_chg_is_dc_chg_plugged_in(g_chip);
+	return is_plugged;
+}
+#endif
+
 static int
 qpnp_chg_is_ichg_loop_active(struct qpnp_chg_chip *chip)
 {
@@ -1124,6 +1235,14 @@ qpnp_chg_charge_en(struct qpnp_chg_chip *chip, int enable)
 		pr_debug("Battery not present, skipping\n");
 		return 0;
 	}
+
+#ifdef CONFIG_ZTEMT_CHARGE
+	if(is_chg_batt_temp_abnormal() ){
+			enable = 0 ;
+	return 0;
+	}
+#endif
+
 	pr_debug("charging %s\n", enable ? "enabled" : "disabled");
 	return qpnp_chg_masked_write(chip, chip->chgr_base + CHGR_CHG_CTRL,
 			CHGR_CHG_EN,
@@ -1599,6 +1718,11 @@ qpnp_chg_regulator_batfet_set(struct qpnp_chg_chip *chip, bool enable)
 	return rc;
 }
 
+#ifdef CONFIG_ZTEMT_CHARGE
+static void  
+check_start_monitor_work(struct qpnp_chg_chip *chip);
+#endif
+
 #define USB_WALL_THRESHOLD_MA	500
 #define ENUM_T_STOP_BIT		BIT(0)
 #define USB_5V_UV	5000000
@@ -1681,6 +1805,12 @@ qpnp_chg_usb_usbin_valid_irq_handler(int irq, void *_chip)
 				chip->delta_vddmax_mv = 0;
 				qpnp_chg_set_appropriate_vddmax(chip);
 			}
+
+	#ifdef CONFIG_ZTEMT_CHARGE
+	set_chg_batt_temp_st(BATT_TEMP_GOOD);
+	check_start_monitor_work(chip);
+#endif
+	
 			schedule_delayed_work(&chip->eoc_work,
 				msecs_to_jiffies(EOC_CHECK_PERIOD_MS));
 			schedule_work(&chip->soc_check_work);
@@ -2196,6 +2326,9 @@ static enum power_supply_property msm_batt_power_props[] = {
 	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	#ifdef CONFIG_ZTEMT_CHARGE
+	POWER_SUPPLY_PROP_CHARGER_ONLINE,
+  #endif
 };
 
 static char *pm_power_supplied_to[] = {
@@ -2280,6 +2413,34 @@ get_prop_battery_voltage_now(struct qpnp_chg_chip *chip)
 	}
 }
 
+#ifdef CONFIG_ZTEMT_CHARGE
+/*
+* Get The Charger Voltage
+*/
+static int
+get_prop_charger_voltage_now(struct qpnp_chg_chip *chip)
+{
+	int rc = 0;
+	struct qpnp_vadc_result results;
+
+	if (!qpnp_chg_is_usb_chg_plugged_in(chip) &&
+			!qpnp_chg_is_dc_chg_plugged_in(chip)) {
+		pr_debug("no chg connected, stopping\n");
+		goto default_voltage;
+	}
+
+		rc = qpnp_vadc_read(chip->vadc_dev,USBIN, &results);
+		if (rc) {
+			pr_err("Unable to read charger rc=%d\n", rc);
+			return 0;
+		}
+		return results.physical;
+		
+default_voltage:
+	 return 0;
+}
+#endif
+
 #define BATT_PRES_BIT BIT(7)
 static int
 get_prop_batt_present(struct qpnp_chg_chip *chip)
@@ -2304,6 +2465,14 @@ get_prop_batt_health(struct qpnp_chg_chip *chip)
 	u8 batt_health;
 	int rc;
 
+/*
+* Temperature Protection Range [-6 , 48]
+*/
+  #ifdef CONFIG_ZTEMT_CHARGE
+    if( is_chg_batt_temp_abnormal() || is_batt_temp_abnormal() )
+		return POWER_SUPPLY_HEALTH_OVERHEAT;
+	#endif
+	
 	rc = qpnp_chg_read(chip, &batt_health,
 				chip->bat_if_base + CHGR_STATUS, 1);
 	if (rc) {
@@ -2360,7 +2529,9 @@ get_batt_capacity(struct qpnp_chg_chip *chip)
 	}
 	return DEFAULT_CAPACITY;
 }
-
+#ifdef CONFIG_ZTEMT_CHARGE
+#define SOC_RESUME_LIMIT 99
+#endif
 static int
 get_prop_batt_status(struct qpnp_chg_chip *chip)
 {
@@ -2396,7 +2567,31 @@ get_prop_batt_status(struct qpnp_chg_chip *chip)
 		return POWER_SUPPLY_STATUS_FULL;
 	}
 
+/*
+* Battery Present; Charger Present; 
+*/
+#ifdef CONFIG_ZTEMT_CHARGE
+	if (!chip->use_default_batt_values  && 
+			get_prop_batt_present(chip)&&
+			(qpnp_chg_is_usb_chg_plugged_in(chip) || qpnp_chg_is_dc_chg_plugged_in(chip)) &&
+			chip->bms_psy && chip->soc_resume_limit  ){
+						   /* Temperature Abnormal */
+	    if(is_chg_batt_temp_abnormal())
+	    	return POWER_SUPPLY_STATUS_NOT_CHARGING;
+			     /* ����soc,�ڸú������ֻᵼ�µ��øú���,����Ƕ�׵���*/
+			     /*
+			 	chip->bms_psy->get_property(chip->bms_psy,
+							  POWER_SUPPLY_PROP_CAPACITY, &ret);*/
+			  if(chip->current_capacity > SOC_RESUME_LIMIT)  //chip->soc_resume_limit
+				  				return POWER_SUPPLY_STATUS_FULL;
+	}
+#endif
+
+#ifdef CONFIG_ZTEMT_CHARGE
+   	return POWER_SUPPLY_STATUS_NOT_CHARGING;
+#else
 	return POWER_SUPPLY_STATUS_DISCHARGING;
+#endif
 }
 
 static int
@@ -2500,6 +2695,26 @@ get_prop_capacity(struct qpnp_chg_chip *chip)
 	return DEFAULT_CAPACITY;
 }
 
+/**
+    ����ԭ��:�����¶��쳣ƫ�ߵ��¹ػ�
+    ���������������¶ȴﵽ�ػ��¶�ʱ������PMIC�¶��ж�
+
+*/
+#ifdef CONFIG_ZTEMT_CHARGE
+#define BATT_THERM_MIN_MV 260
+int batt_therm_mv = 800;
+int
+get_batt_therm_mv(void)
+{
+    return batt_therm_mv;
+}
+void
+store_batt_therm_mv(int batt_temp_mv)
+{
+    batt_therm_mv = batt_temp_mv;
+}
+#endif
+
 #define DEFAULT_TEMP		250
 #define MAX_TOLERABLE_BATT_TEMP_DDC	680
 static int
@@ -2522,6 +2737,28 @@ get_prop_batt_temp(struct qpnp_chg_chip *chip)
 	return (int)results.physical;
 }
 
+#ifdef CONFIG_ZTEMT_CHARGE
+/*
+* PMIC Temperature
+*/
+static int
+get_prop_pmic_temp(struct qpnp_chg_chip *chip)
+{
+	int rc = 0;
+	struct qpnp_vadc_result results;
+
+	rc = qpnp_vadc_read(chip->vadc_dev,DIE_TEMP, &results);
+	if (rc) {
+		pr_debug("Unable to read batt temperature rc=%d\n", rc);
+		return 0;
+	}
+	pr_debug("get_pmic_temp %d %lld\n",
+		results.adc_code, results.physical);
+
+	return (int)results.physical;
+}
+#endif
+
 static int get_prop_cycle_count(struct qpnp_chg_chip *chip)
 {
 	union power_supply_propval ret = {0,};
@@ -2670,6 +2907,9 @@ qpnp_batt_power_get_property(struct power_supply *psy,
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
 		val->intval = get_prop_capacity(chip);
+	#ifdef CONFIG_ZTEMT_CHARGE
+	 chip->current_capacity = val->intval ;
+#endif			
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		val->intval = get_prop_current_now(chip);
@@ -2707,6 +2947,11 @@ qpnp_batt_power_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = get_prop_online(chip);
 		break;
+		#ifdef CONFIG_ZTEMT_CHARGE
+	case POWER_SUPPLY_PROP_CHARGER_ONLINE:
+	   val->intval = qpnp_chg_is_chg_plugged_in();
+		break;
+	#endif	
 	default:
 		return -EINVAL;
 	}
@@ -3504,7 +3749,11 @@ qpnp_eoc_work(struct work_struct *work)
 			if (vbat_low_count >= CONSECUTIVE_COUNT) {
 				pr_debug("woke up too early stopping\n");
 				qpnp_chg_enable_irq(&chip->chg_vbatdet_lo);
+				#ifdef CONFIG_ZTEMT_CHARGE
+		 //Charging And Not Sleeping
+	   #else	
 				goto stop_eoc;
+	   #endif
 			} else {
 				goto check_again_later;
 			}
@@ -3545,6 +3794,7 @@ qpnp_eoc_work(struct work_struct *work)
 				pr_debug("psy changed batt_psy\n");
 				power_supply_changed(&chip->batt_psy);
 				qpnp_chg_enable_irq(&chip->chg_vbatdet_lo);
+			/*Chargfing End And To Sleep */	
 				goto stop_eoc;
 			} else {
 				count += 1;
@@ -3598,8 +3848,11 @@ qpnp_chg_soc_check_work(struct work_struct *work)
 {
 	struct qpnp_chg_chip *chip = container_of(work,
 				struct qpnp_chg_chip, soc_check_work);
-
+#ifdef CONFIG_ZTEMT_CHARGE
+	chip->current_capacity = get_prop_capacity(chip);
+#else		
 	get_prop_capacity(chip);
+#endif
 }
 
 #define HYSTERISIS_DECIDEGC 20
@@ -4856,6 +5109,357 @@ qpnp_charger_read_dt_props(struct qpnp_chg_chip *chip)
 	return rc;
 }
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+
+static void print_battery_information(struct qpnp_chg_chip *chip)
+{
+  printk("BMS capacity=%d current=%d vbat_uv=%d temp =%d dc_chg_in=%d usb_chg_in=%d\n",
+    get_prop_capacity(chip),
+    get_prop_current_now(chip),
+    get_prop_battery_voltage_now(chip),
+    get_prop_batt_temp(chip),
+    qpnp_chg_is_dc_chg_plugged_in(chip),
+    qpnp_chg_is_usb_chg_plugged_in(chip));
+}
+
+static void power_debug_work_func(struct work_struct *work)
+{
+	int rc =0;
+	u8 reg;
+	struct qpnp_chg_chip *chip = container_of(work,
+	                                          struct qpnp_chg_chip,
+	                                          power_debug_work.work);
+	printk("power_debug_work_func_______start!\n");
+
+    // add for qualcomm case ID 01353411/01330511
+	rc = qpnp_chg_read(chip, &reg, 0x12DF, 1);
+	if (rc) {
+		pr_err("==wifi== spmi read failed:  rc=%d\n", rc);
+	}
+	pr_err("==wifi==  read 0x%x\n", reg);
+	// add end
+	
+	//print battery related information
+	print_battery_information(chip);
+	//print wakelocks
+	global_print_active_locks();
+	//wakelock_stats_show_debug();
+	schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+	printk("power_debug_work_func_________over!\n");
+
+}
+
+static int power_debug_work_control(int on)
+{
+	int ret;
+	struct qpnp_chg_chip *chip = chip_temp; 
+	if(1==on)
+	{
+		if(1==power_debug_switch)
+		{
+			printk("%s:The power_debug_work is already on\n",__func__);
+			ret=1;
+		}
+		else
+		{
+			power_debug_switch=1;
+			msm_show_resume_irq_mask=1;
+			INIT_DELAYED_WORK(&chip->power_debug_work,  power_debug_work_func);
+			schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+
+			printk("%s:enable power_debug_work.\n",__func__);
+		}
+	}
+	else
+	{
+
+		if(0==power_debug_switch)
+		{
+			printk("%s:The power_debu_timer is already off\n",__func__);
+			ret=1;
+		}
+		else
+		{
+			power_debug_switch=0;
+			msm_show_resume_irq_mask=0;
+			cancel_delayed_work(&chip->power_debug_work);
+			printk("%s:disable power_debug_work.\n",__func__);
+		}
+
+	}
+	return ret;
+}
+
+
+static ssize_t po_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	sprintf(buf, "%u\n", power_debug_switch);
+	return 1;
+}
+static ssize_t po_info_store(struct device *dev, 
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	unsigned int val;
+
+	if (sscanf(buf, "%u", &val) == 1) {
+		if (power_debug_work_control(val))
+			return count;
+	}
+	return -EINVAL;
+}
+
+static ssize_t clock_dump_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+
+	sprintf(buf, "%u\n", power_debug_switch);
+	clock_debug_print_enabled();
+	return 1;
+}
+
+static DEVICE_ATTR(switch, 0644, po_info_show, po_info_store);
+static DEVICE_ATTR(clock_dump, 0644,  clock_dump_show, NULL);
+static struct kobject *po_kobject = NULL;
+
+static int power_debug_init(struct qpnp_chg_chip *chip)
+{
+	int ret;
+	chip_temp = chip;
+	po_kobject = kobject_create_and_add(DRV_NAME, NULL);
+	if(po_kobject == NULL) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	ret = sysfs_create_file(po_kobject, &dev_attr_switch.attr);
+	ret |= sysfs_create_file(po_kobject, &dev_attr_clock_dump.attr);
+	if(ret){
+		goto err;
+	}
+
+	INIT_DELAYED_WORK(&chip->power_debug_work,  power_debug_work_func);
+
+	if(power_debug_switch) {
+	  msm_show_resume_irq_mask=1; //on in default, deleted is allow.
+	  schedule_delayed_work(&chip->power_debug_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(POWER_MONITOR_PERIOD_MS)));
+	}
+	return 0;
+
+err:
+	kobject_del(po_kobject);
+err1:
+	printk(DRV_NAME": Failed to create sys file\n");
+	return ret;
+}
+#endif
+#ifdef CONFIG_ZTEMT_CHARGE
+/*
+* Set iusbMax Current 
+*/
+#define DWC3_IDEV_CHG_MAX 1500
+void qpnp_notify_charger_of_the_charger_type(int i_chg_type)
+{
+		enum  dwc3_chg_type chg_type = i_chg_type;
+		DBG_CHARGE("chg_type =%d" , chg_type);
+
+    if(!g_chip)
+    	return ;
+   
+		if ( (qpnp_chg_is_usb_chg_plugged_in(g_chip) ||
+		      qpnp_chg_is_dc_chg_plugged_in(g_chip))&&
+		       ( !(g_chip->chg_done)) ) { 
+      if (	qpnp_chg_usb_iusbmax_get(g_chip) < USB_WALL_THRESHOLD_MA ||
+      	   (chg_type == DWC3_SDP_CHARGER)	) 
+            qpnp_chg_iusbmax_set( g_chip , USB_WALL_THRESHOLD_MA);
+      else if(chg_type == DWC3_DCP_CHARGER||
+						chg_type == DWC3_CDP_CHARGER||
+						chg_type == DWC3_PROPRIETARY_CHARGER||
+						chg_type == DWC3_FLOATED_CHARGER)
+						   qpnp_chg_iusbmax_set( g_chip , DWC3_IDEV_CHG_MAX);
+		}
+		
+		//qpnp_chg_state_machine_reset(g_chip);
+}
+/*
+* Print The Debug Information
+*/
+static void 
+qpnp_print_debug_info(struct qpnp_chg_chip *chip ){
+	bool is_usb_in = false  ;
+	bool is_dc_in =   false ;
+	 
+	if( qpnp_chg_is_usb_chg_plugged_in(chip) ) {
+		is_usb_in = true ;
+	}
+	else if (qpnp_chg_is_dc_chg_plugged_in(chip)) {
+		is_dc_in = true ;
+	}
+	
+	DBG_CHARGE( "Charger:  Batt_Current = %d, Batt_Voltage = %d,Charger_Voltage = %d, Batt_Temperature = %d , \
+		                     Pmic_Temperature = %d,Capacity = %d  \n" ,
+		get_prop_current_now(chip),
+		get_prop_battery_voltage_now(chip),
+		get_prop_charger_voltage_now(chip),
+		get_prop_batt_temp(chip),
+		get_prop_pmic_temp(chip),
+		get_prop_capacity(chip) );	        
+}
+
+/*
+* �����¶ȼ���
+*/
+#define CHG_TEMP_HIGH1   530
+#define CHG_TEMP_LOW1     -60
+
+#define CHG_TEMP_HIGH2   500
+#define CHG_TEMP_LOW2     -50
+
+#ifdef CONFIG_ZTEMT_CHARGE_MODE_ADJUST
+#define CHG_PMIC_TEMP_LOW1     -60
+#define CHG_PMIC_TEMP_LOW2     -60
+#define CHG_PMIC_TEMP_LEVEL_DELTA     -60
+#define CHG_PMIC_TEMP_LEVEL_1     -60
+#define CHG_PMIC_TEMP_HIGH1     -60
+#endif
+
+#define CHG_MONITOR_PERIOD_MS	10000
+
+static void 
+batt_monitor_worker(struct work_struct *work)
+{
+    int batt_temperature;
+    int batt_currtent;
+#ifdef CONFIG_ZTEMT_CHARGE_MODE_ADJUST
+		int pmic_temperature;
+    int delta_temp;
+#endif
+
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct qpnp_chg_chip *chip = container_of(dwork,
+				struct qpnp_chg_chip, battery_monitor_work );
+
+	qpnp_print_debug_info(chip);
+
+	batt_temperature = get_prop_batt_temp(chip);
+	set_batt_temp(batt_temperature); 
+
+	batt_currtent = get_prop_current_now(chip);
+
+	if( is_charger_online() == 0){
+		return;
+	}
+
+#ifdef CONFIG_ZTEMT_CHARGE_MODE_ADJUST
+  if( CHG_PMIC_TEMP_LEVEL_1 < CHG_PMIC_TEMP_LOW2)
+  	CHG_PMIC_TEMP_LEVEL_1 = CHG_PMIC_TEMP_LOW2;
+  
+	pmic_temperature = get_prop_pmic_temp(chip);
+	delta_temp = pmic_temperature/1000 - batt_temperature/10;
+	if(delta_temp <=0)
+		 delta_temp = 0;
+
+/*Adjust Charging Current Accoding To The Temperature Level Value */
+	if((pmic_temperature > CHG_PMIC_TEMP_LOW1 )&& 
+	(pmic_temperature <= (CHG_PMIC_TEMP_LEVEL_1-CHG_PMIC_TEMP_LEVEL_DELTA))){
+		chip->therm_lvl_sel = 0;
+	}else if ((pmic_temperature >= ( CHG_PMIC_TEMP_LEVEL_1+CHG_PMIC_TEMP_LEVEL_DELTA ))&& 
+			(pmic_temperature < CHG_PMIC_TEMP_HIGH1)){
+		chip->therm_lvl_sel = 1;
+	}
+	else if((pmic_temperature >= CHG_PMIC_TEMP_HIGH1) ||
+		 (pmic_temperature <= CHG_PMIC_TEMP_LOW1)){
+		chip->therm_lvl_sel  = chip->thermal_levels-1;
+	}
+	else {
+		//Using The Previous Thermal Level 
+		chip->therm_lvl_sel  = chip->post_thermal_levels ;
+		if( chip->post_thermal_levels >= chip->thermal_levels)
+		{
+			  if(pmic_temperature > CHG_PMIC_TEMP_LEVEL_1)
+			  	chip->therm_lvl_sel = 1;
+			  else
+			  	chip->therm_lvl_sel = 0;
+		}
+	}
+
+    DBG_CHARGE("delta_temp = %d \n" , delta_temp);
+    DBG_CHARGE("therm_lvl_sel = %d , thermal_levels = %d, post_thermal_levels = %d \n" , 
+	  	chip->therm_lvl_sel, chip->thermal_levels,chip->post_thermal_levels);
+	
+	if((chip->therm_lvl_sel  != chip->post_thermal_levels) ) {
+		 chip->post_thermal_levels = chip->therm_lvl_sel ;
+		if(	chip->therm_lvl_sel  >= chip->thermal_levels-1)
+		{
+		//Should Be Setting Current Again,Except The High Or Low Temperature
+				chip->post_thermal_levels  = chip->thermal_levels-1;
+				chip->therm_lvl_sel = 1;
+		 }
+		qpnp_batt_system_temp_level_set(chip , chip->therm_lvl_sel);
+	}
+/* End */
+#endif
+
+
+	/*
+	*�����¶��ڡ�-5, 47��֮���������繦�ܡ�
+	  �����¶��ڡ�-6, 50���ⲿ,ֹͣ���硣
+	*/
+	if( batt_temperature > CHG_TEMP_LOW2 && batt_temperature < CHG_TEMP_HIGH2 &&
+		 is_chg_batt_temp_abnormal() ){
+		 
+			DBG_CHARGE(" batt_temperature =%d &&  start charging! \n",batt_temperature);
+			set_chg_batt_temp_st(BATT_TEMP_GOOD);
+			qpnp_chg_charge_en(chip, 1);
+
+	}else if( (batt_temperature > CHG_TEMP_HIGH1 || batt_temperature < CHG_TEMP_LOW1) &&
+	             !is_chg_batt_temp_abnormal() ){
+		DBG_CHARGE(" batt_temperature =%d && stop charging! \n",batt_temperature);
+		//
+		qpnp_chg_charge_en(chip, 0);
+		chip->chg_done = false;
+		power_supply_changed(&chip->batt_psy);
+		//
+		set_chg_batt_temp_st(BATT_TEMP_ABNORMAL);
+	}
+
+	schedule_delayed_work(&chip->battery_monitor_work,
+			  round_jiffies_relative(msecs_to_jiffies
+						(CHG_MONITOR_PERIOD_MS)));
+
+}
+
+/*
+* Charger Is Present
+*/
+static void  
+check_start_monitor_work(struct qpnp_chg_chip *chip)
+{
+//���ó�����״̬
+   if( chip->usb_present ||chip->dc_present ) {
+		set_charger_status(1);
+   	}
+	else {
+		set_charger_status(0);
+	 }
+	
+	if(is_charger_online()){
+		qpnp_chg_charge_en(chip, 1);
+        schedule_delayed_work(&chip->battery_monitor_work,
+				  round_jiffies_relative(msecs_to_jiffies
+							(CHG_MONITOR_PERIOD_MS)));
+	}
+}
+#endif
+
 static int __devinit
 qpnp_charger_probe(struct spmi_device *spmi)
 {
@@ -5124,6 +5728,10 @@ qpnp_charger_probe(struct spmi_device *spmi)
 	INIT_WORK(&chip->soc_check_work, qpnp_chg_soc_check_work);
 	INIT_DELAYED_WORK(&chip->aicl_check_work, qpnp_aicl_check_work);
 
+	#ifdef CONFIG_ZTEMT_CHARGE
+	INIT_DELAYED_WORK(&chip->battery_monitor_work, batt_monitor_worker);
+	#endif
+	
 	if (chip->dc_chgpth_base) {
 		chip->dc_psy.name = "qpnp-dc";
 		chip->dc_psy.type = POWER_SUPPLY_TYPE_MAINS;
@@ -5213,8 +5821,17 @@ qpnp_charger_probe(struct spmi_device *spmi)
 	if (qpnp_chg_is_usb_chg_plugged_in(chip))
 		power_supply_set_online(chip->usb_psy, 1);
 
+	#ifdef CONFIG_ZTEMT_CHARGE
+		check_start_monitor_work(chip);
+	#endif
+
 	schedule_delayed_work(&chip->aicl_check_work,
 		msecs_to_jiffies(EOC_CHECK_PERIOD_MS));
+
+	#ifdef CONFIG_ZTEMT_CHARGE
+		g_chip = chip;
+ #endif
+
 	pr_info("success chg_dis = %d, bpd = %d, usb = %d, dc = %d b_health = %d batt_present = %d\n",
 			chip->charging_disabled,
 			chip->bpd_detection,
@@ -5222,6 +5839,9 @@ qpnp_charger_probe(struct spmi_device *spmi)
 			qpnp_chg_is_dc_chg_plugged_in(chip),
 			get_prop_batt_present(chip),
 			get_prop_batt_health(chip));
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	power_debug_init(chip);
+	#endif
 	return 0;
 
 unregister_dc_psy:
diff --git a/drivers/power/ztemt_hw_version.c b/drivers/power/ztemt_hw_version.c
new file mode 100755
index 0000000..d520af7
--- /dev/null
+++ b/drivers/power/ztemt_hw_version.c
@@ -0,0 +1,402 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/spmi.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <ztemt_hw_version.h>
+
+
+//#define CONFIG_ZTEMT_HW_VERSION_DEBUG
+#ifdef CONFIG_ZTEMT_HW_VERSION_DEBUG
+#define ztemt_hw_version_debug(fmt, args...) printk(KERN_DEBUG "[ztemt_hw_version_debug]"fmt, ##args)
+#else
+#define ztemt_hw_version_debug(fmt, args...) do {} while(0)
+#endif
+
+#define QPNP_ZTEMT_HW_VERSION_DEV_NAME	"qcom,qpnp-ztemt_hw_version"
+
+/**
+ * struct qpnp_chg_chip - device information
+ * @dev:			device pointer to access the parent
+ * @spmi:			spmi pointer to access spmi information
+ */
+struct qpnp_ztemt_hw_version_chip {
+	struct device	     *dev;
+	struct spmi_device	 *spmi;
+	struct work_struct	 work;
+	struct mutex	     lock;
+};
+
+
+
+//#define CONFIG_ZTEMT_HW_VERSION_GPIO
+#ifdef CONFIG_ZTEMT_HW_VERSION_GPIO
+
+#define GPIO_A 51
+#define GPIO_B 52
+#define GPIO_C 63
+#define VER_GPIO_A GPIO_CFG(GPIO_A, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA)
+#define VER_GPIO_B GPIO_CFG(GPIO_B, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA)
+#define VER_GPIO_C GPIO_CFG(GPIO_C, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA)
+//#define VER_GPIO_A GPIO_CFG(GPIO_A, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+//#define VER_GPIO_B GPIO_CFG(GPIO_B, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+//#define VER_GPIO_C GPIO_CFG(GPIO_C, 0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA)
+#define VER_GPIO_A_S GPIO_CFG(GPIO_A, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA)
+#define VER_GPIO_B_S GPIO_CFG(GPIO_B, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA)
+#define VER_GPIO_C_S GPIO_CFG(GPIO_C, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA)
+
+struct ztemt_gpio_state{
+int gpio_A;
+int gpio_B;	
+int gpio_C;	
+};	
+struct ztemt_gpio_state ztemt_gpio_st;
+
+static const struct hardware_id_map_st hardware_id_map[] = {
+	{HW_A,"ZTE_U9180","CM","ZTE U9180"},      //GPIO value: 0,0,0
+	{HW_B,"ZTE_V9180","CU","ZTE V9180"},      //GPIO value: 0,1,0
+	{HW_C,"ZTE_N9180","CT","ZTE N9180"},      //GPIO value: 1,0,0
+	{HW_D,"NE501J","COMMON","NE501J"},        //GPIO value: 1,1,0
+};
+
+static int ztemt_hw_id=-1;
+static int gpio_init_flag=false;
+static int ztemt_gpio_init(void)
+{
+		int rc=0;
+		if(gpio_init_flag ==true)
+	    return rc; 
+		rc = gpio_request(GPIO_A, "GPIO_A");
+		if (rc < 0) {
+			pr_err("Failed request GPIO_A.\n");
+			return rc;
+		}
+	  gpio_tlmm_config(VER_GPIO_A,GPIO_CFG_ENABLE);
+	  
+	  rc = gpio_request(GPIO_B, "GPIO_B");
+		if (rc < 0) {
+			pr_err("Failed request GPIO_B.\n");
+			return rc;
+		} 
+	  gpio_tlmm_config(VER_GPIO_B,GPIO_CFG_ENABLE);
+	      
+	  rc = gpio_request(GPIO_C, "GPIO_C");
+		if (rc < 0) {
+			pr_err("Failed request GPIO_C.\n");
+			return rc;
+		}
+	  gpio_tlmm_config(VER_GPIO_C,GPIO_CFG_ENABLE);
+	  
+	  gpio_init_flag=true;
+	  return rc;
+}
+
+static int ztemt_get_hw_id(void)
+{
+  if((ztemt_hw_id >= 0)&&(ztemt_hw_id!=HW_UN))
+	    return ztemt_hw_id;
+	ztemt_gpio_init();
+	ztemt_gpio_st.gpio_A=gpio_get_value(GPIO_A);
+	ztemt_gpio_st.gpio_B=gpio_get_value(GPIO_B);
+	ztemt_gpio_st.gpio_C=gpio_get_value(GPIO_C);
+	
+	if((ztemt_gpio_st.gpio_A==0)&&(ztemt_gpio_st.gpio_B==0)&&(ztemt_gpio_st.gpio_C==0)){  
+	  ztemt_hw_id=HW_A;
+	}else if ((ztemt_gpio_st.gpio_A==0)&&(ztemt_gpio_st.gpio_B==1)&&(ztemt_gpio_st.gpio_C==0)){
+	  ztemt_hw_id=HW_B;
+	}else if ((ztemt_gpio_st.gpio_A==1)&&(ztemt_gpio_st.gpio_B==0)&&(ztemt_gpio_st.gpio_C==0)){
+	  ztemt_hw_id=HW_C;
+	}else if ((ztemt_gpio_st.gpio_A==1)&&(ztemt_gpio_st.gpio_B==1)&&(ztemt_gpio_st.gpio_C==0)){
+	  ztemt_hw_id=HW_D;
+	}else{ 
+	  ztemt_hw_id=HW_UN;
+	}	
+  ztemt_hw_version_debug("hw_id=%d\n",ztemt_hw_id);
+  return ztemt_hw_id;
+}
+
+static void ztemt_get_hw_version(char* result)
+{
+    int hw_id;
+    if(!result)
+		return;
+
+    hw_id = ztemt_get_hw_id();
+	
+    if(hw_id != HW_UN){
+        strcpy(result,hardware_id_map[hw_id].hw_ver); 
+     }else
+	    sprintf(result, "%s","unknow");
+}
+
+static void ztemt_get_hw_operators(char* result)
+{
+    int hw_id;
+    if(!result)
+		return;
+
+    hw_id = ztemt_get_hw_id();
+
+    if(hw_id != HW_UN){
+        strcpy(result,hardware_id_map[hw_id].hw_operators);
+     }else
+	    sprintf(result, "%s","unknow");
+}
+
+static void ztemt_get_hw_projects(char* result)
+{
+    int hw_id;
+    if(!result)
+		return;
+
+    hw_id = ztemt_get_hw_id();
+
+    if(hw_id != HW_UN){
+        strcpy(result,hardware_id_map[hw_id].hw_projects);
+     }else
+	    sprintf(result, "%s","unknow");
+}
+
+
+static ssize_t ztemt_hw_version_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    ztemt_get_hw_version(buf);
+    //printk("%s : %d : ztemt_hw_version=%s\n",__func__,__LINE__,buf);
+    ztemt_hw_version_debug("ztemt_hw_version=%s\n",buf);
+    return sprintf(buf,"%s",buf);
+}
+
+static ssize_t ztemt_hw_operators_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    ztemt_get_hw_operators(buf);
+    //printk("%s : %d : ztemt_hw_operators=%s\n",__func__,__LINE__,buf);
+    ztemt_hw_version_debug("ztemt_hw_operators=%s\n",buf);
+    return sprintf(buf,"%s",buf);
+}
+
+static ssize_t ztemt_hw_projects_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    ztemt_get_hw_projects(buf);
+    //printk("%s : %d : ztemt_hw_projects=%s\n",__func__,__LINE__,buf);
+    ztemt_hw_version_debug("ztemt_hw_projects=%s\n",buf);
+    return sprintf(buf,"%s",buf);
+}
+
+static DEVICE_ATTR(ztemt_hw_version, 0664, ztemt_hw_version_show, NULL);
+static DEVICE_ATTR(ztemt_hw_operators, 0664, ztemt_hw_operators_show, NULL);
+static DEVICE_ATTR(ztemt_hw_projects, 0664, ztemt_hw_projects_show, NULL);
+#endif /*CONFIG_ZTEMT_HW_VERSION_GPIO*/
+
+
+#ifdef CONFIG_ZTEMT_HW_VERSION_ADC
+
+#ifdef CONFIG_ZTEMT_HW_VERSION_NX601J
+static const struct hardware_id_map_st hardware_id_map[] = {
+	{0, 200,NX601J_HW_A,"ZTEMT_NX601J_A"},  //id_mv=0
+	{700, 1100,NX601J_HW_B,"ZTEMT_NX601J_B"},  //id_mv=900
+};
+#elif defined CONFIG_ZTEMT_HW_VERSION_NX504J
+static const struct hardware_id_map_st hardware_id_map[] = {
+	{0, 200,NX504J_HW_A,"ZTEMT_NX504J_A"},  //id_mv=0
+	{200, 550,NX504J_HW_B,"ZTEMT_NX504J_B"},  //id_mv=416
+	{550, 900,NX504J_HW_C,"ZTEMT_NX504J_C"},  //id_mv=720
+	{900, 1300,NX504J_HW_D,"ZTEMT_NX504J_D"},  //id_mv=1120
+	{1300, 1650,NX504J_HW_E,"ZTEMT_NX504J_E"},  //id_mv=1475
+	{1650, 1900,NX504J_HW_F,"ZTEMT_NX504J_F"},  //id_mv=1800
+};
+#else 
+static const struct hardware_id_map_st hardware_id_map[] = {
+	{0, 200,HW_A,"ZTEMT_UN_A"},  //id_mv=0
+	{700, 1100,HW_B,"ZTEMT_UN_B"},  //id_mv=900
+};
+#endif
+
+static int ztemt_hw_id = -1;
+static int ztemt_hw_mv = 900;
+
+static int  ztemt_board_type_setup(char *param)
+{
+	int magic_num = 0;
+    get_option(&param, &magic_num);
+	ztemt_hw_mv = magic_num;
+    return 0;
+}
+early_param("board_type", ztemt_board_type_setup);
+
+static int32_t ztemt_get_hardware_type(const struct hardware_id_map_st *pts,
+		uint32_t tablesize, int input)
+{
+	uint32_t i = 0;
+
+	if ( pts == NULL )
+		return -EINVAL;
+
+	while (i < tablesize) {
+		if ( (pts[i].low_mv <= input) && (input <= pts[i].high_mv) ) 
+			break;
+		else 
+			i++;
+	}
+
+	if ( i < tablesize ) 
+		return pts[i].hw_type;
+    else 
+		return HW_UN;
+}
+
+int ztemt_get_hw_id(void)
+{
+	if(ztemt_hw_id >= 0)
+	    return ztemt_hw_id;
+	    
+    ztemt_hw_id = ztemt_get_hardware_type(
+		                hardware_id_map,
+						ARRAY_SIZE(hardware_id_map),
+						ztemt_hw_mv);
+	
+	//printk("hw_id_mv=%d mv hw_id=%d hw_ver=%s\n",
+	    //ztemt_hw_mv,ztemt_hw_id,hardware_id_map[ztemt_hw_id].hw_ver);
+    ztemt_hw_version_debug("hw_id_mv=%d mv hw_id=%d hw_ver=%s\n",
+		ztemt_hw_mv,ztemt_hw_id,hardware_id_map[ztemt_hw_id].hw_ver);
+  
+	return ztemt_hw_id;
+}
+
+EXPORT_SYMBOL_GPL(ztemt_get_hw_id);
+
+void ztemt_get_hw_version(char* result)
+{
+    int hw_id;
+    if(!result)
+		return;
+
+    hw_id = ztemt_get_hw_id();
+	
+    if(hw_id != HW_UN){
+        strcpy(result,hardware_id_map[hw_id].hw_ver); 
+     }else
+	    sprintf(result, "%s","unknow");
+}
+EXPORT_SYMBOL_GPL(ztemt_get_hw_version);
+
+static ssize_t ztemt_hw_version_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    ztemt_get_hw_version(buf);
+    //printk("%s : %d : ztemt_hw_version=%s\n",__func__,__LINE__,buf);
+    ztemt_hw_version_debug("ztemt_hw_version=%s\n",buf);
+    return sprintf(buf,"%s\n",buf);
+}
+
+static DEVICE_ATTR(ztemt_hw_version, 0664, ztemt_hw_version_show, NULL);
+#endif /*CONFIG_ZTEMT_HW_VERSION_ADC*/
+
+
+/*
+static struct attribute *ztemt_hw_version_attrs[] = {
+    &dev_attr_ztemt_hw_version.attr,
+    NULL
+};
+static const struct attribute_group ztemt_hw_version_attr_group = {
+	.attrs = ztemt_hw_version_attrs,
+};
+*/
+
+static int __devinit
+qpnp_ztemt_hw_version_probe(struct spmi_device *spmi)
+{
+	
+	struct qpnp_ztemt_hw_version_chip	*chip;
+	int rc = 0;
+
+	chip = devm_kzalloc(&spmi->dev,
+			sizeof(struct qpnp_ztemt_hw_version_chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pr_err("qpnp_ztemt_hw_version_probe : kzalloc() failed.\n");
+		return -ENOMEM;
+	}
+    dev_set_drvdata(&spmi->dev, chip);
+	chip->dev = &(spmi->dev);
+	chip->spmi = spmi;
+	
+    rc=sysfs_create_file(&chip->dev->kobj,&dev_attr_ztemt_hw_version.attr);
+#ifdef CONFIG_ZTEMT_HW_VERSION_GPIO
+	rc |=sysfs_create_file(&chip->dev->kobj,&dev_attr_ztemt_hw_operators.attr);
+    rc |=sysfs_create_file(&chip->dev->kobj,&dev_attr_ztemt_hw_projects.attr);
+#endif
+	//rc=sysfs_create_group(&chip->dev->kobj,&ztemt_hw_version_attr_group);
+
+	if(rc)pr_err("failed to register sysfs node...\n");
+	return rc;
+}
+
+static int __devexit
+qpnp_ztemt_hw_version_remove(struct spmi_device *spmi)
+{
+	struct qpnp_ztemt_hw_version_chip *chip = dev_get_drvdata(&spmi->dev);
+  devm_kfree(&spmi->dev,chip);
+    
+#ifdef CONFIG_ZTEMT_HW_VERSION_GPIO
+  gpio_free(GPIO_A);
+  gpio_free(GPIO_B);
+  gpio_free(GPIO_C);
+#endif
+  
+	return 0;
+}
+
+static struct of_device_id qpnp_ztemt_hw_version_match_table[] = {
+	{ .compatible = QPNP_ZTEMT_HW_VERSION_DEV_NAME, },
+	{}
+};
+
+static struct spmi_driver qpnp_ztemt_hw_version_driver = {
+	.probe		= qpnp_ztemt_hw_version_probe,
+	.remove		= __devexit_p(qpnp_ztemt_hw_version_remove),
+	.driver		= {
+		.name		    = QPNP_ZTEMT_HW_VERSION_DEV_NAME,
+		.owner		    = THIS_MODULE,
+		.of_match_table	= qpnp_ztemt_hw_version_match_table,
+	},
+};
+
+/**
+ * qpnp_ztemt_hw_version_init() - register spmi driver for qpnp-ztemt_hw_version
+ */
+int __init
+qpnp_ztemt_hw_version_init(void)
+{
+	return spmi_driver_register(&qpnp_ztemt_hw_version_driver);
+}
+module_init(qpnp_ztemt_hw_version_init);
+
+static void __exit
+qpnp_ztemt_hw_version_exit(void)
+{
+	spmi_driver_unregister(&qpnp_ztemt_hw_version_driver);
+}
+module_exit(qpnp_ztemt_hw_version_exit);
+
+MODULE_DESCRIPTION("qpnp ztemt_hw_version driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" QPNP_ZTEMT_HW_VERSION_DEV_NAME);
diff --git a/drivers/power/ztemt_hw_version.h b/drivers/power/ztemt_hw_version.h
new file mode 100755
index 0000000..a9f55b7
--- /dev/null
+++ b/drivers/power/ztemt_hw_version.h
@@ -0,0 +1,65 @@
+#ifndef __ZTEMT_HW_VERSION_H__
+#define __ZTEMT_HW_VERSION_H__
+
+
+#ifdef CONFIG_ZTEMT_HW_VERSION_ADC
+
+#ifdef CONFIG_ZTEMT_HW_VERSION_NX601J
+typedef enum
+{
+	NX601J_HW_A,
+	NX601J_HW_B,
+	HW_UN// unknow, fail read
+}hw_version_type;
+#elif defined CONFIG_ZTEMT_HW_VERSION_NX504J
+typedef enum
+{
+	NX504J_HW_A,
+	NX504J_HW_B,
+	NX504J_HW_C,
+	NX504J_HW_D,
+	NX504J_HW_E,
+	NX504J_HW_F,
+	HW_UN// unknow, fail read
+}hw_version_type;
+#else
+typedef enum
+{
+	HW_A,
+	HW_B,
+	HW_UN// unknow, fail read
+}hw_version_type;
+#endif
+
+struct hardware_id_map_st {
+	int low_mv;
+	int high_mv;
+	hw_version_type hw_type;
+	char hw_ver[20];
+};
+#endif /*CONFIG_ZTEMT_HW_VERSION_ADC*/
+
+
+//#define CONFIG_ZTEMT_HW_VERSION_GPIO
+#ifdef CONFIG_ZTEMT_HW_VERSION_GPIO
+
+typedef enum
+{
+	HW_A,
+	HW_B,
+	HW_C,
+	HW_D,
+	HW_UN// unknow, fail read
+}hw_version_type;
+
+struct hardware_id_map_st {
+	hw_version_type hw_type;
+	char hw_ver[20];
+	char hw_operators[20];
+	char hw_projects[20];
+};
+
+#endif /*CONFIG_ZTEMT_HW_VERSION_GPIO*/
+
+
+#endif
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
old mode 100644
new mode 100755
index 7a559a6..0d1edf0
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1144,4 +1144,9 @@ config RTC_DRV_QPNP
 	  To compile this driver as a module, choose M here: the
 	  module will be called qpnp-rtc.
 
+config ZTE_POWEROFF_ALARM
+    tristate "zte poweroff alarm macro"
+    depends on RTC_CLASS
+    help 
+       open poweroffalarm function when is "y"
 endif # RTC_CLASS
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
old mode 100644
new mode 100755
index 8531de9..3869651
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -25,7 +25,7 @@
 
 #include <asm/mach/time.h>
 
-#define ALARM_DELTA 120
+#define ALARM_DELTA 60
 #define ANDROID_ALARM_PRINT_ERROR (1U << 0)
 #define ANDROID_ALARM_PRINT_INIT_STATUS (1U << 1)
 #define ANDROID_ALARM_PRINT_TSET (1U << 2)
@@ -541,6 +541,24 @@ static int set_alarm_time_to_rtc(const long power_on_time)
 	rtc_read_time(alarm_rtc_dev, &rtc_time);
 	getnstimeofday(&wall_time);
 	rtc_tm_to_time(&rtc_time, &rtc_secs);
+	if((power_on_time-rtc_secs)<(2*365*8*24*3600L)&&power_on_time>rtc_secs)
+    	{
+		alarm_time = power_on_time - ALARM_DELTA;
+		if (alarm_time <= rtc_secs)
+				goto disable_alarm;
+		rtc_time_to_tm(alarm_time, &alarm.time);
+		alarm.enabled = 1;
+		rc = rtc_set_alarm(alarm_rtc_dev, &alarm);
+		if (rc){
+			pr_alarm(ERROR, "Unable to set power-on alarm\n");
+			goto disable_alarm;
+		}
+		else
+			pr_alarm(FLOW, "Power-on alarm set to %lu\n",
+					alarm_time);
+		return 0;
+	}else
+		{
 	alarm_delta = wall_time.tv_sec - rtc_secs;
 	alarm_time = power_on_time - alarm_delta;
 
@@ -567,7 +585,7 @@ static int set_alarm_time_to_rtc(const long power_on_time)
 				alarm_time);
 
 	return 0;
-
+		}
 disable_alarm:
 	rtc_alarm_irq_enable(alarm_rtc_dev, 0);
 	return rc;
diff --git a/drivers/rtc/qpnp-rtc.c b/drivers/rtc/qpnp-rtc.c
old mode 100644
new mode 100755
index de86577..64cdf72
--- a/drivers/rtc/qpnp-rtc.c
+++ b/drivers/rtc/qpnp-rtc.c
@@ -608,6 +608,57 @@ static int __devinit qpnp_rtc_probe(struct spmi_device *spmi)
 	return rc;
 }
 
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+static time_t rtc_suspend_sec = 0;
+static time_t rtc_resume_sec = 0;
+static unsigned long all_sleep_time = 0;
+static unsigned long all_wake_time = 0;
+
+static int print_suspend_time(struct device *dev)
+{
+	int rc, diff=0;
+	struct rtc_time tm;
+	unsigned long now;
+
+	rc = qpnp_rtc_read_time(dev,&tm);  
+ 	if(rc) {
+	  printk("%s: Unable to read from RTC\n", __func__);
+	}
+
+	rtc_tm_to_time(&tm, &now);
+	rtc_suspend_sec = now;
+	diff = rtc_suspend_sec - rtc_resume_sec;
+	all_wake_time += diff;
+	printk("I have work %d seconds all_wake_time %lu seconds\n",diff,all_wake_time);
+
+	return 0;
+}
+
+static int print_resume_time(struct device *dev)
+{
+	int rc, diff=0;
+	struct rtc_time tm;
+	unsigned long now;
+
+	rc = qpnp_rtc_read_time(dev,&tm);
+ 	if (rc) {
+	  printk("%s: Unable to read from RTC\n", __func__);
+	}
+
+	rtc_tm_to_time(&tm, &now);
+	rtc_resume_sec = now;
+	diff = rtc_resume_sec - rtc_suspend_sec;
+	all_sleep_time += diff;
+	printk("I have sleep %d seconds all_sleep_time %lu seconds\n",diff,all_sleep_time);
+
+	return 0;
+}
+
+static const struct dev_pm_ops qpnp_rtc_pm_ops = {
+	.suspend = print_suspend_time,
+	.resume = print_resume_time,
+};
+#endif
 static int __devexit qpnp_rtc_remove(struct spmi_device *spmi)
 {
 	struct qpnp_rtc *rtc_dd = dev_get_drvdata(&spmi->dev);
@@ -670,6 +721,9 @@ static struct spmi_driver qpnp_rtc_driver = {
 		.name   = "qcom,qpnp-rtc",
 		.owner  = THIS_MODULE,
 		.of_match_table = spmi_match_table,
+		#ifdef CONFIG_ZTEMT_POWER_DEBUG
+		.pm	= &qpnp_rtc_pm_ops,
+		#endif
 	},
 };
 
diff --git a/drivers/spmi/spmi.c b/drivers/spmi/spmi.c
old mode 100644
new mode 100755
index 43f2710..2843d00
--- a/drivers/spmi/spmi.c
+++ b/drivers/spmi/spmi.c
@@ -251,8 +251,18 @@ int spmi_add_device(struct spmi_device *spmidev)
 		return -EINVAL;
 	}
 
-	/* Set the device name */
-	dev_set_name(dev, "%s-%p", spmidev->name, spmidev);
+//#ifdef CONFIG_ZTEMT_HW_VERSION
+	if(strncmp(spmidev->name,"qpnp-ztemt_hw_version",strlen("qpnp-ztemt_hw_version"))==0)
+	{
+	   dev_set_name(dev, "%s", spmidev->name);
+    }else{	
+	   /* Set the device name */
+	   dev_set_name(dev, "%s-%p", spmidev->name, spmidev);
+	}
+//#else
+//	/* Set the device name */
+//	dev_set_name(dev, "%s-%p", spmidev->name, spmidev);
+//#endif
 
 	/* Device may be bound to an active driver when this returns */
 	rc = device_add(dev);
diff --git a/drivers/usb/dwc3/dwc3-msm.c b/drivers/usb/dwc3/dwc3-msm.c
old mode 100644
new mode 100755
index 7eed125..00eaa45
--- a/drivers/usb/dwc3/dwc3-msm.c
+++ b/drivers/usb/dwc3/dwc3-msm.c
@@ -74,7 +74,16 @@ module_param(ss_phy_override_deemphasis, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(ss_phy_override_deemphasis, "Override SSPHY demphasis value");
 
 /* Enable Proprietary charger detection */
+#ifdef CONFIG_ZTEMT_CHARGE
+static bool prop_chg_detect = 1;
+#else
 static bool prop_chg_detect;
+#endif
+
+#ifdef CONFIG_ZTEMT_CHARGE
+extern int qpnp_chg_is_chg_plugged_in(void);
+#endif
+
 module_param(prop_chg_detect, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(prop_chg_detect, "Enable Proprietary charger detection");
 
@@ -2296,12 +2305,19 @@ static int dwc3_msm_power_get_property_usb(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
 		val->intval = mdwc->current_max;
 		break;
+	#ifdef CONFIG_ZTEMT_CHARGE
+		case POWER_SUPPLY_PROP_PRESENT:
+  	case POWER_SUPPLY_PROP_ONLINE:
+  		val->intval = qpnp_chg_is_chg_plugged_in();
+		break;
+	#else
 	case POWER_SUPPLY_PROP_PRESENT:
 		val->intval = mdwc->vbus_active;
 		break;
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = mdwc->online;
 		break;
+	#endif
 	case POWER_SUPPLY_PROP_TYPE:
 		val->intval = psy->type;
 		break;
diff --git a/drivers/usb/dwc3/dwc3_otg.c b/drivers/usb/dwc3/dwc3_otg.c
old mode 100644
new mode 100755
index 8a034d6..c0a9826
--- a/drivers/usb/dwc3/dwc3_otg.c
+++ b/drivers/usb/dwc3/dwc3_otg.c
@@ -24,6 +24,10 @@
 #include "io.h"
 #include "xhci.h"
 
+#ifdef CONFIG_ZTEMT_CHARGE
+#include <linux/qpnp/qpnp-adc.h>
+#endif
+
 #define VBUS_REG_CHECK_DELAY	(msecs_to_jiffies(1000))
 #define MAX_INVALID_CHRGR_RETRY 3
 static int max_chgr_retry_count = MAX_INVALID_CHRGR_RETRY;
@@ -382,6 +386,10 @@ static void dwc3_ext_chg_det_done(struct usb_otg *otg, struct dwc3_charger *chg)
 {
 	struct dwc3_otg *dotg = container_of(otg, struct dwc3_otg, otg);
 
+#ifdef CONFIG_ZTEMT_CHARGE
+	 qpnp_notify_charger_of_the_charger_type((int)chg->chg_type);
+#endif
+
 	/*
 	 * Ignore chg_detection notification if BSV has gone off by this time.
 	 * STOP chg_det as part of !BSV handling would reset the chg_det flags
@@ -538,6 +546,9 @@ static int dwc3_otg_set_power(struct usb_phy *phy, unsigned mA)
 	else if (dotg->charger->chg_type == DWC3_CDP_CHARGER)
 		power_supply_type = POWER_SUPPLY_TYPE_USB_CDP;
 	else if (dotg->charger->chg_type == DWC3_DCP_CHARGER ||
+						#ifdef CONFIG_ZTEMT_CHARGE
+	          dotg->charger->chg_type == DWC3_FLOATED_CHARGER ||
+        		#endif
 			dotg->charger->chg_type == DWC3_PROPRIETARY_CHARGER)
 		power_supply_type = POWER_SUPPLY_TYPE_USB_DCP;
 	else
@@ -771,6 +782,12 @@ static void dwc3_otg_sm_work(struct work_struct *w)
 					work = 1;
 					break;
 				case DWC3_FLOATED_CHARGER:
+				#ifdef CONFIG_ZTEMT_CHARGE
+					dev_dbg(phy->dev, "lpm, FLOATED charger\n");
+					dwc3_otg_set_power(phy,
+							DWC3_IDEV_CHG_MAX);
+					pm_runtime_put_sync(phy->dev);		
+				#else									
 					if (dotg->charger_retry_count <
 							max_chgr_retry_count)
 						dotg->charger_retry_count++;
@@ -791,6 +808,7 @@ static void dwc3_otg_sm_work(struct work_struct *w)
 					}
 					charger->start_detection(dotg->charger,
 									false);
+     #endif
 
 				default:
 					dev_dbg(phy->dev, "chg_det started\n");
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
old mode 100644
new mode 100755
index 6b01472..9939574
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -1790,7 +1790,7 @@ static int mass_storage_function_init(struct android_usb_function *f,
 		snprintf(name[config->fsg.nluns], MAX_LUN_NAME, "lun0");
 		config->fsg.nluns++;
 	}
-	if (dev->pdata && dev->pdata->internal_ums) {
+	if (dev->pdata && dev->pdata->external_ums) {
 		config->fsg.luns[config->fsg.nluns].cdrom = 0;
 		config->fsg.luns[config->fsg.nluns].ro = 0;
 		config->fsg.luns[config->fsg.nluns].removable = 1;
@@ -2958,8 +2958,8 @@ static int __devinit android_probe(struct platform_device *pdev)
 				&pdata->swfi_latency);
 		pdata->cdrom = of_property_read_bool(pdev->dev.of_node,
 				"qcom,android-usb-cdrom");
-		pdata->internal_ums = of_property_read_bool(pdev->dev.of_node,
-				"qcom,android-usb-internal-ums");
+		pdata->external_ums = of_property_read_bool(pdev->dev.of_node,
+				"qcom,android-usb-external-ums");
 		len = of_property_count_strings(pdev->dev.of_node,
 				"qcom,streaming-func");
 		if (len > MAX_STREAMING_FUNCS) {
diff --git a/drivers/usb/otg/msm_otg.c b/drivers/usb/otg/msm_otg.c
old mode 100644
new mode 100755
index c6287ea..3b5cb94
--- a/drivers/usb/otg/msm_otg.c
+++ b/drivers/usb/otg/msm_otg.c
@@ -72,6 +72,14 @@
 
 #define USB_SUSPEND_DELAY_TIME	(500 * HZ/1000) /* 500 msec */
 
+#ifdef CONFIG_ZTEMT_CHARGE
+#define zte_dev_dbg(dev, format, ...)		     \
+dev_printk(KERN_DEBUG, dev, format, ##__VA_ARGS__)
+#undef dev_dbg
+#define dev_dbg   zte_dev_dbg
+#endif
+
+
 enum msm_otg_phy_reg_mode {
 	USB_PHY_REG_OFF,
 	USB_PHY_REG_ON,
@@ -79,6 +87,10 @@ enum msm_otg_phy_reg_mode {
 	USB_PHY_REG_LPM_OFF,
 };
 
+#ifdef CONFIG_ZTEMT_CHARGE
+extern int qpnp_chg_is_chg_plugged_in(void);
+#endif
+
 static char *override_phy_init;
 module_param(override_phy_init, charp, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(override_phy_init,
@@ -3357,6 +3369,12 @@ static void msm_otg_set_vbus_state(int online)
 	static bool init;
 	struct msm_otg *motg = the_msm_otg;
 
+	#ifdef CONFIG_ZTEMT_CHARGE
+    if(online){
+		msm_otg_notify_charger(motg, 500);
+    }
+	#endif
+
 	if (online) {
 		pr_debug("PMIC: BSV set\n");
 		set_bit(B_SESS_VLD, &motg->inputs);
@@ -3706,10 +3724,17 @@ static int otg_power_get_property_usb(struct power_supply *psy,
 		val->intval = motg->current_max;
 		break;
 	/* Reflect USB enumeration */
+	#ifdef CONFIG_ZTEMT_CHARGE
+		case POWER_SUPPLY_PROP_PRESENT:
+  	case POWER_SUPPLY_PROP_ONLINE:
+  		val->intval = qpnp_chg_is_chg_plugged_in();
+		break;
+	#else
 	case POWER_SUPPLY_PROP_PRESENT:
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = motg->online;
 		break;
+	#endif	
 	case POWER_SUPPLY_PROP_TYPE:
 		val->intval = psy->type;
 		break;
diff --git a/drivers/video/msm/mdss/Kconfig b/drivers/video/msm/mdss/Kconfig
index 01edf92..497c5f5 100644
--- a/drivers/video/msm/mdss/Kconfig
+++ b/drivers/video/msm/mdss/Kconfig
@@ -35,3 +35,38 @@ config FB_MSM_MDSS_MDP3
 	---help---
 	The MDP3 provides support for an older version display controller
 	included in latest display sub-system, known as MDSS.
+#mayu 2012.12.19
+menu "ZTEMT lcd driver support"
+config ZTEMT_LCD_MIPI_COMMON
+	bool "ztemt lcd MIPI interface driver module"
+	default n
+
+config ZTEMT_NE501_LCD
+	bool "ztemt NE501J LCD driver module"
+	default n
+
+config ZTEMT_LCD_POWER_CONTRL
+	bool "ztemt lcd AVDD IOVDD contrl"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+config ZTEMT_LCD_DISP_ENHANCE
+	bool "LCD disp color enhance"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+config ZTEMT_MIPI_720P_R69431_SHARP_IPS_4P7
+	bool "MIPI 720P R69431 SHARP IPS 4P7"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+config ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P
+	bool "MIPI 720P NT35592 SHARP IPS 5P"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+config ZTEMT_LCD_ESD_TE_CHECK
+	bool "LCD esd te check"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+config ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
+	bool "ztemt lcd backlight linear control methold"
+	depends on ZTEMT_LCD_MIPI_COMMON
+	default n
+endmenu
diff --git a/drivers/video/msm/mdss/Makefile b/drivers/video/msm/mdss/Makefile
old mode 100644
new mode 100755
index cba7c22b..d10eef3
--- a/drivers/video/msm/mdss/Makefile
+++ b/drivers/video/msm/mdss/Makefile
@@ -47,3 +47,5 @@ obj-$(CONFIG_FB_MSM_MDSS_DSI_CTRL_STATUS) += dsi_status_v2.o
 else
 obj-$(CONFIG_FB_MSM_MDSS_DSI_CTRL_STATUS) += mdss_dsi_status.o
 endif
+
+obj-$(CONFIG_ZTEMT_LCD_DISP_ENHANCE) += zte_disp_enhance.o
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
old mode 100644
new mode 100755
index 660e400..7f8d185
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -27,8 +27,47 @@
 #include "mdss_dsi.h"
 #include "mdss_debug.h"
 
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+extern void zte_disp_enhance(void);
+#endif
 static unsigned char *mdss_dsi_base;
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+/*esd check faild check,mayu add*/
+int zte_lcd_te_check_flag =0;
 
+static irqreturn_t zte_lcd_te_irq_handler(int irq, void *ptr)
+{
+   struct mdss_dsi_ctrl_pdata *ctrl = (struct mdss_dsi_ctrl_pdata *)ptr;
+
+   disable_irq_nosync(ctrl->lcd_te_irq);
+   zte_lcd_te_check_flag++;
+  
+   //printk("lcd:%s zte_lcd_te_check_flag=%d\n",__func__,zte_lcd_te_check_flag);
+   return IRQ_HANDLED;
+}
+
+int zte_check_status_by_te(struct mdss_dsi_ctrl_pdata *ctrl)
+{
+	int ret=1;
+
+	if(zte_lcd_te_check_flag > 0) {
+		zte_lcd_te_check_flag = 0;
+		enable_irq(ctrl->lcd_te_irq);
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+}
+int success_hx83920b_check_status(struct mdss_dsi_ctrl_pdata *ctrl)
+{
+  return -1;
+}
+int zte_check_status_ok(struct mdss_dsi_ctrl_pdata *ctrl)
+{
+  return 1;
+}
+#endif
 static int mdss_dsi_regulator_init(struct platform_device *pdev)
 {
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
@@ -542,6 +581,9 @@ static int mdss_dsi_unblank(struct mdss_panel_data *pdata)
 		}
 		ctrl_pdata->ctrl_state |= CTRL_STATE_PANEL_INIT;
 	}
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+	zte_disp_enhance();
+#endif
 
 	if (pdata->panel_info.type == MIPI_CMD_PANEL) {
 		if (mipi->vsync_enable && mipi->hw_vsync_mode
@@ -1046,6 +1088,18 @@ static int __devinit mdss_dsi_ctrl_probe(struct platform_device *pdev)
 		goto error_pan_node;
 	}
 
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+/*esd check faild check,mayu add*/
+  //printk("lcd:%s disp_te_gpio=%d\n",__func__,ctrl_pdata->disp_te_gpio);
+  ctrl_pdata->lcd_te_irq = gpio_to_irq(ctrl_pdata->disp_te_gpio);
+  rc = request_irq(ctrl_pdata->lcd_te_irq, zte_lcd_te_irq_handler, \
+                 IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, "LCD_TE", ctrl_pdata);
+	if (rc < 0) {
+		printk("lcd:%s : request_irq failed\n", __func__);
+	}
+#endif
+
+
 	pr_debug("%s: Dsi Ctrl->%d initialized\n", __func__, index);
 	return 0;
 
@@ -1277,6 +1331,51 @@ int dsi_panel_device_register(struct device_node *pan_node,
 		pr_err("%s:%d, Disp_en gpio not specified\n",
 						__func__, __LINE__);
 
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+	ctrl_pdata->avdd_neg_en_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
+						     "qcom,platform-avddn-enable-gpio", 0);
+	if (!gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio)) {
+		pr_err("%s:%d, avdd_neg_en_gpio gpio not specified\n",
+						__func__, __LINE__);
+	} else {
+		rc = gpio_request(ctrl_pdata->avdd_neg_en_gpio, "lcd_avdd_neg_enable");
+		if (rc) {
+			pr_err("request reset gpio failed, rc=%d\n",
+			       rc);
+			gpio_free(ctrl_pdata->avdd_neg_en_gpio);
+			return -ENODEV;
+		}
+	}
+#endif
+
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+/*esd check faild check,mayu add*/
+	if (pinfo->type != MIPI_CMD_PANEL) {
+    ctrl_pdata->disp_te_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
+						"qcom,platform-te-gpio", 0);
+		if (!gpio_is_valid(ctrl_pdata->disp_te_gpio)) {
+			pr_err("lcd:%s:%d, Disp_te gpio not specified\n",
+						__func__, __LINE__);
+		}
+    rc = gpio_request(ctrl_pdata->disp_te_gpio, "disp_te");
+		if (rc) {
+			pr_err("request TE gpio failed, rc=%d\n",
+			       rc);
+			gpio_free(ctrl_pdata->disp_te_gpio);
+			return -ENODEV;
+		}
+		rc = gpio_tlmm_config(GPIO_CFG(
+				ctrl_pdata->disp_te_gpio, 1,
+				GPIO_CFG_INPUT,
+				GPIO_CFG_PULL_DOWN,
+				GPIO_CFG_2MA),
+				GPIO_CFG_ENABLE);
+
+	rc = gpio_direction_input(ctrl_pdata->disp_te_gpio);
+	}
+#endif
+
 	if (pinfo->type == MIPI_CMD_PANEL) {
 		ctrl_pdata->disp_te_gpio = of_get_named_gpio(ctrl_pdev->dev.of_node,
 						"qcom,platform-te-gpio", 0);
@@ -1348,7 +1447,33 @@ int dsi_panel_device_register(struct device_node *pan_node,
 	}
 
 	ctrl_pdata->panel_data.event_handler = mdss_dsi_event_handler;
+
+	/*qcom ori*/
 	ctrl_pdata->check_status = mdss_dsi_bta_status_check;
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+#if defined(CONFIG_ZTEMT_NE501_LCD)
+/*esd check faild check,mayu add*/
+    if (ctrl_pdata->panel_name
+           && (!strcmp(ctrl_pdata->panel_name, "cs nt35592 720p video mode dsi panel")
+                || !strcmp(ctrl_pdata->panel_name, "lianchuang nt35592 720p video mode dsi panel"))) {
+		ctrl_pdata->check_status = zte_check_status_by_te;
+		printk("nt35592 check by te\n");
+
+	} else if (ctrl_pdata->panel_name 
+		&& !strcmp(ctrl_pdata->panel_name, "success hx8392b 720p video mode dsi panel")) {
+		ctrl_pdata->check_status = success_hx83920b_check_status;
+		printk("hx83920b check faled always\n");
+	}
+#elif defined(CONFIG_ZTEMT_NX404H_LCD)
+	if (ctrl_pdata->panel_name
+           && !strcmp(ctrl_pdata->panel_name, "otm1282a 720p command mode dsi panel")) {
+		ctrl_pdata->check_status = zte_check_status_by_te;
+	}else{
+    //other lcd run empty fun
+    ctrl_pdata->check_status = zte_check_status_ok;
+	}
+#endif
+#endif //CONFIG_ZTEMT_LCD_ESD_TE_CHECK
 
 	if (ctrl_pdata->bklt_ctrl == BL_PWM)
 		mdss_dsi_panel_pwm_cfg(ctrl_pdata);
diff --git a/drivers/video/msm/mdss/mdss_dsi.h b/drivers/video/msm/mdss/mdss_dsi.h
old mode 100644
new mode 100755
index a50f740..27e32ba
--- a/drivers/video/msm/mdss/mdss_dsi.h
+++ b/drivers/video/msm/mdss/mdss_dsi.h
@@ -231,6 +231,9 @@ enum {
 
 struct mdss_dsi_ctrl_pdata {
 	int ndx;	/* panel_num */
+#if defined(CONFIG_ZTEMT_NE501_LCD) || defined(CONFIG_ZTEMT_NX404H_LCD)
+	char *panel_name;
+#endif
 	int (*on) (struct mdss_panel_data *pdata);
 	int (*off) (struct mdss_panel_data *pdata);
 	int (*partial_update_fnc) (struct mdss_panel_data *pdata);
@@ -254,6 +257,14 @@ struct mdss_dsi_ctrl_pdata {
 	int mdss_dsi_clk_on;
 	int rst_gpio;
 	int disp_en_gpio;
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*avdd neg ctl board2 add ,mayu 6.25*/
+  int avdd_neg_en_gpio;
+#endif
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+/*esd check faild check,mayu add*/
+  int lcd_te_irq;
+#endif
 	int disp_te_gpio;
 	int mode_gpio;
 	int disp_te_gpio_requested;
@@ -274,7 +285,13 @@ struct mdss_dsi_ctrl_pdata {
 	struct mdss_panel_recovery *recovery;
 
 	struct dsi_panel_cmds on_cmds;
+#ifdef CONFIG_ZTEMT_NX404H_LCD
+	struct dsi_panel_cmds on_cmds_post;
+#endif
 	struct dsi_panel_cmds off_cmds;
+#if defined(CONFIG_ZTEMT_NE501_LCD)
+	struct dsi_panel_cmds on_cmds_esd;
+#endif
 
 	struct dcs_cmd_list cmdlist;
 	struct completion dma_comp;
@@ -352,4 +369,6 @@ int mdss_dsi_bta_status_check(struct mdss_dsi_ctrl_pdata *ctrl);
 int mdss_dsi_panel_init(struct device_node *node,
 		struct mdss_dsi_ctrl_pdata *ctrl_pdata,
 		bool cmd_cfg_cont_splash);
+
+
 #endif /* MDSS_DSI_H */
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index d68b178..b0e36c7 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -24,8 +24,30 @@
 
 #include "mdss_dsi.h"
 
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+extern struct mdss_dsi_ctrl_pdata *zte_mdss_dsi_ctrl;
+#endif
+#if defined(CONFIG_ZTEMT_NX404H_LCD) || defined(CONFIG_ZTEMT_NE501_LCD)
+struct mdss_dsi_ctrl_pdata *zte_ctrl_post;
+#endif
+
 #define DT_CMD_HDR 6
 
+#ifdef CONFIG_ZTEMT_MIPI_720P_R69431_SHARP_IPS_4P7
+/*NX404 mayu*/
+#define PW_ON_AVDD_EN_SLEEP   2
+#define PW_ON_AVDD_NEG_SLEEP  6
+
+#define PW_OFF_AVDD_NEG_SLEEP 10
+#define PW_OFF_AVDD_EN_SLEEP  10
+#define PW_OFF_RESET_SLEEP    5
+#endif
+
+#ifdef CONFIG_ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P
+/*NE501 mayu*/
+#define PW_OFF_RESET_SLEEP    11
+#endif
+
 DEFINE_LED_TRIGGER(bl_led_trigger);
 
 void mdss_dsi_panel_pwm_cfg(struct mdss_dsi_ctrl_pdata *ctrl)
@@ -135,13 +157,16 @@ static struct dsi_cmd_desc backlight_cmd = {
 	led_pwm1
 };
 
+#ifdef CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
 static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 {
 	struct dcs_cmd_req cmdreq;
+    pr_debug("%s: level = %d\n", __func__, level);
 
-	pr_debug("%s: level=%d\n", __func__, level);
 
-	led_pwm1[1] = (unsigned char)level;
+            led_pwm1[1] = level & 0xff;
+ 
+	pr_err("\n%s: ---------------level=%d. after\n", __func__, led_pwm1[1]);
 
 	memset(&cmdreq, 0, sizeof(cmdreq));
 	cmdreq.cmds = &backlight_cmd;
@@ -152,6 +177,31 @@ static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
 
 	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
 }
+#else
+static void mdss_dsi_panel_bklt_dcs(struct mdss_dsi_ctrl_pdata *ctrl, int level)
+{
+	struct dcs_cmd_req cmdreq;
+
+	//pr_err("%s: level=%d\n", __func__, level);
+
+	led_pwm1[1] = (unsigned char)level;
+	
+	if (led_pwm1[1] <= 0) led_pwm1[1] = 0;
+	else if (led_pwm1[1] <= 185) led_pwm1[1] = 10 + led_pwm1[1] *176/186 ;
+	//else led_pwm1[1] = 185 + (led_pwm1[1] - 185 ) /2 ; a maximum limit backlight in 420 nit  for htian
+		
+	pr_err("\n%s: ---------------level=%d. after\n", __func__, led_pwm1[1]);
+	
+	memset(&cmdreq, 0, sizeof(cmdreq));
+	cmdreq.cmds = &backlight_cmd;
+	cmdreq.cmds_cnt = 1;
+	cmdreq.flags = CMD_REQ_COMMIT | CMD_CLK_CTRL;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
+
+	mdss_dsi_cmdlist_put(ctrl, &cmdreq);
+}
+#endif
 
 static int mdss_dsi_request_gpios(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
 {
@@ -229,15 +279,27 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 			if (gpio_is_valid(ctrl_pdata->disp_en_gpio))
 				gpio_set_value((ctrl_pdata->disp_en_gpio), 1);
 
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+/*mayu add ,12.19*/
+    mdelay(PW_ON_AVDD_EN_SLEEP);
+
+		if (gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio))
+			gpio_set_value((ctrl_pdata->avdd_neg_en_gpio), 1);
+
+    mdelay(PW_ON_AVDD_NEG_SLEEP);
+#endif
+
 			for (i = 0; i < pdata->panel_info.rst_seq_len; ++i) {
 				gpio_set_value((ctrl_pdata->rst_gpio),
 					pdata->panel_info.rst_seq[i]);
 				if (pdata->panel_info.rst_seq[++i])
+#ifdef CONFIG_ZTEMT_NE501_LCD
+					udelay(pinfo->rst_seq[i]);
+#else
 					usleep(pinfo->rst_seq[i] * 1000);
+#endif
 			}
-
 		}
-
 		if (gpio_is_valid(ctrl_pdata->mode_gpio)) {
 			if (pinfo->mode_gpio_state == MODE_GPIO_HIGH)
 				gpio_set_value((ctrl_pdata->mode_gpio), 1);
@@ -251,6 +313,22 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 			pr_debug("%s: Reset panel done\n", __func__);
 		}
 	} else {
+#ifdef CONFIG_ZTEMT_LCD_POWER_CONTRL
+		if (gpio_is_valid(ctrl_pdata->avdd_neg_en_gpio))
+			gpio_set_value((ctrl_pdata->avdd_neg_en_gpio), 0);
+
+		mdelay(PW_OFF_AVDD_NEG_SLEEP);
+		if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
+			gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
+			gpio_free(ctrl_pdata->disp_en_gpio);
+		}
+		mdelay(PW_OFF_AVDD_NEG_SLEEP);
+		gpio_set_value((ctrl_pdata->rst_gpio), 0);
+		gpio_free(ctrl_pdata->rst_gpio);
+		mdelay(PW_OFF_RESET_SLEEP);
+		if (gpio_is_valid(ctrl_pdata->mode_gpio))
+			gpio_free(ctrl_pdata->mode_gpio);
+#else
 		if (gpio_is_valid(ctrl_pdata->disp_en_gpio)) {
 			gpio_set_value((ctrl_pdata->disp_en_gpio), 0);
 			gpio_free(ctrl_pdata->disp_en_gpio);
@@ -259,6 +337,7 @@ int mdss_dsi_panel_reset(struct mdss_panel_data *pdata, int enable)
 		gpio_free(ctrl_pdata->rst_gpio);
 		if (gpio_is_valid(ctrl_pdata->mode_gpio))
 			gpio_free(ctrl_pdata->mode_gpio);
+#endif
 	}
 	return rc;
 }
@@ -392,14 +471,56 @@ static int mdss_dsi_panel_on(struct mdss_panel_data *pdata)
 				panel_data);
 	mipi  = &pdata->panel_info.mipi;
 
+#if defined(CONFIG_ZTEMT_NX404H_LCD) || defined(CONFIG_ZTEMT_NE501_LCD)
+	zte_ctrl_post = ctrl;
+#endif
+
+	printk("lcd:%s \n",__func__);
 	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
 
 	if (ctrl->on_cmds.cmd_cnt)
 		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
 
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*disp color enhance,mayu add*/
+	zte_mdss_dsi_ctrl = ctrl;
+#endif
+
 	pr_debug("%s:-\n", __func__);
 	return 0;
 }
+#ifdef CONFIG_ZTEMT_NX404H_LCD
+int mipi_lcd_on_post(void)
+{
+	static bool is_firsttime = true;
+	if (is_firsttime) {
+		is_firsttime = false;
+		return 0;
+	}
+
+	if (zte_ctrl_post && zte_ctrl_post->on_cmds_post.cmd_cnt) {
+		mdss_dsi_panel_cmds_send(zte_ctrl_post, &zte_ctrl_post->on_cmds_post);
+	}
+
+	 return 0;
+}
+#endif
+
+#ifdef CONFIG_ZTEMT_NE501_LCD
+int mipi_lcd_esd_command(struct mdss_dsi_ctrl_pdata *ctrl_pdata)
+{
+	if (ctrl_pdata 
+		&& (ctrl_pdata->panel_name 
+			&& !strcmp(ctrl_pdata->panel_name, "success hx8392b 720p video mode dsi panel"))
+		&& ctrl_pdata->on_cmds_esd.cmd_cnt) {
+		mdss_dsi_panel_cmds_send(ctrl_pdata, &ctrl_pdata->on_cmds_esd);
+		printk("sleep exit & display on reset panel\n");
+		return 0;
+	}
+	
+	return 1;
+}
+#endif
 
 static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 {
@@ -415,12 +536,18 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 				panel_data);
 
 	pr_debug("%s: ctrl=%p ndx=%d\n", __func__, ctrl, ctrl->ndx);
+	printk("lcd:%s \n",__func__);
 
 	mipi  = &pdata->panel_info.mipi;
 
 	if (ctrl->off_cmds.cmd_cnt)
 		mdss_dsi_panel_cmds_send(ctrl, &ctrl->off_cmds);
 
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*disp color enhance,mayu add*/
+	zte_mdss_dsi_ctrl = NULL;
+#endif
+
 	pr_debug("%s:-\n", __func__);
 	return 0;
 }
@@ -852,6 +979,22 @@ static int mdss_panel_parse_dt(struct device_node *np,
 	rc = of_property_read_u32(np, "qcom,mdss-dsi-bl-max-level", &tmp);
 	pinfo->bl_max = (!rc ? tmp : 255);
 	ctrl_pdata->bklt_max = pinfo->bl_max;
+    #ifdef CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-a1", &tmp);
+	pinfo->brig_to_bl_lvl_para_a1 = (!rc ? tmp : 0);
+
+    rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-a2", &tmp);
+	pinfo->brig_to_bl_lvl_para_a2 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-b1", &tmp);
+	pinfo->brig_to_bl_lvl_para_b1 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-para-b2", &tmp);
+	pinfo->brig_to_bl_lvl_para_b2 = (!rc ? tmp : 0);
+
+	rc = of_property_read_u32(np, "qcom,mdss-dsi-bright-to-bl-lvl-turn-point", &tmp);
+	pinfo->brig_to_bl_lvl_turn_point = (!rc ? tmp : 0);
+    #endif
 
 	rc = of_property_read_u32(np, "qcom,mdss-dsi-interleave-mode", &tmp);
 	pinfo->mipi.interleave_mode = (!rc ? tmp : 0);
@@ -980,6 +1123,15 @@ static int mdss_panel_parse_dt(struct device_node *np,
 
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds,
 		"qcom,mdss-dsi-on-command", "qcom,mdss-dsi-on-command-state");
+#ifdef CONFIG_ZTEMT_NX404H_LCD
+	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds_post,
+		"qcom,mdss-dsi-on-command_post", "qcom,mdss-dsi-on-command-state");
+#endif
+
+#ifdef CONFIG_ZTEMT_NE501_LCD
+	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds_esd,
+		"qcom,mdss-dsi-esd-command", "qcom,mdss-dsi-on-command-state");
+#endif
 
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->off_cmds,
 		"qcom,mdss-dsi-off-command", "qcom,mdss-dsi-off-command-state");
@@ -1012,6 +1164,15 @@ int mdss_dsi_panel_init(struct device_node *node,
 	else
 		pr_info("%s: Panel Name = %s\n", __func__, panel_name);
 
+#if defined(CONFIG_ZTEMT_NE501_LCD) || defined(CONFIG_ZTEMT_NX404H_LCD)
+		if (panel_name) ctrl_pdata->panel_name = (char *)panel_name;
+#endif
+
+#ifdef CONFIG_ZTEMT_LCD_DISP_ENHANCE
+/*disp color enhance,tangjun add*/
+	zte_mdss_dsi_ctrl = ctrl_pdata;
+#endif
+
 	rc = mdss_panel_parse_dt(node, ctrl_pdata);
 	if (rc) {
 		pr_err("%s:%d panel dt parse failed\n", __func__, __LINE__);
diff --git a/drivers/video/msm/mdss/mdss_dsi_status.c b/drivers/video/msm/mdss/mdss_dsi_status.c
old mode 100644
new mode 100755
index fd7f3fd..a8f62a3
--- a/drivers/video/msm/mdss/mdss_dsi_status.c
+++ b/drivers/video/msm/mdss/mdss_dsi_status.c
@@ -30,7 +30,11 @@
 #include "mdss_panel.h"
 #include "mdss_mdp.h"
 
+#ifdef CONFIG_ZTEMT_LCD_ESD_TE_CHECK
+#define STATUS_CHECK_INTERVAL 2000
+#else
 #define STATUS_CHECK_INTERVAL 5000
+#endif
 
 struct dsi_status_data {
 	struct notifier_block fb_notifier;
@@ -49,6 +53,9 @@ static uint32_t interval = STATUS_CHECK_INTERVAL;
  * command. If DSI controller fails to acknowledge the BTA command, it sends
  * the PANEL_ALIVE=0 status to HAL layer.
  */
+#ifdef CONFIG_ZTEMT_NE501_LCD
+extern int mipi_lcd_esd_command(struct mdss_dsi_ctrl_pdata *ctrl_pdata);
+#endif
 static void check_dsi_ctrl_status(struct work_struct *work)
 {
 	struct dsi_status_data *pdsi_status = NULL;
@@ -65,6 +72,12 @@ static void check_dsi_ctrl_status(struct work_struct *work)
 		return;
 	}
 
+  //patch + case1481899 mayu 3.27
+	if(!pdsi_status->mfd){
+	  pr_err("%s:mfd is NULL \n",__func__);
+	  return;
+	}
+  //patch - case1481899 mayu 3.27
 	pdata = dev_get_platdata(&pdsi_status->mfd->pdev->dev);
 	if (!pdata) {
 		pr_err("%s: Panel data not available\n", __func__);
@@ -79,6 +92,15 @@ static void check_dsi_ctrl_status(struct work_struct *work)
 		return;
 	}
 
+//+++duguowei,crash if no lcd
+	if(ctrl_pdata->panel_name == NULL || !strcmp("",ctrl_pdata->panel_name)){
+		fb_unregister_client(&pstatus_data->fb_notifier);
+		cancel_delayed_work_sync(&pstatus_data->check_status);
+		kfree(pstatus_data);
+		pr_debug("%s: DSI ctrl status work queue removed\n", __func__);
+		return;
+	}
+//---duguowei,crash if no lcd
 	mdp5_data = mfd_to_mdp5_data(pdsi_status->mfd);
 	ctl = mfd_to_ctl(pdsi_status->mfd);
 
@@ -123,6 +145,18 @@ static void check_dsi_ctrl_status(struct work_struct *work)
 			schedule_delayed_work(&pdsi_status->check_status,
 				msecs_to_jiffies(pdsi_status->check_interval));
 		} else {
+#ifdef CONFIG_ZTEMT_NE501_LCD
+			if (mipi_lcd_esd_command(ctrl_pdata)) {
+				char *envp[2] = {"PANEL_ALIVE=0", NULL};
+				pdata->panel_info.panel_dead = true;
+				ret = kobject_uevent_env(
+					&pdsi_status->mfd->fbi->dev->kobj,
+								KOBJ_CHANGE, envp);
+				pr_err("%s: Panel has gone bad, sending uevent - %s\n",
+								__func__, envp[0]);
+				printk("default reset panel\n");
+			}
+#else
 			char *envp[2] = {"PANEL_ALIVE=0", NULL};
 			pdata->panel_info.panel_dead = true;
 			ret = kobject_uevent_env(
@@ -130,6 +164,7 @@ static void check_dsi_ctrl_status(struct work_struct *work)
 							KOBJ_CHANGE, envp);
 			pr_err("%s: Panel has gone bad, sending uevent - %s\n",
 							__func__, envp[0]);
+#endif
 		}
 	}
 }
@@ -151,10 +186,13 @@ static int fb_event_callback(struct notifier_block *self,
 	struct fb_event *evdata = data;
 	struct dsi_status_data *pdata = container_of(self,
 				struct dsi_status_data, fb_notifier);
-	pdata->mfd = evdata->info->par;
+  //patch move down case1481899 mayu 3.27
+	//pdata->mfd = evdata->info->par;
 
 	if (event == FB_EVENT_BLANK && evdata) {
 		int *blank = evdata->data;
+ //patch move down case1481899 mayu 3.27
+	pdata->mfd = evdata->info->par;
 		switch (*blank) {
 		case FB_BLANK_UNBLANK:
 			schedule_delayed_work(&pdata->check_status,
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
index d4a236a..7a67ef3 100644
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -197,6 +197,45 @@ static int mdss_fb_splash_thread(void *data)
 
 static int lcd_backlight_registered;
 
+#ifdef CONFIG_ZTEMT_LCD_BACKLIGHT_LINEAR_CONTROL_METHOLD
+static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	struct msm_fb_data_type *mfd = dev_get_drvdata(led_cdev->dev->parent);
+	int bl_lvl = 0;
+
+    mfd->panel_info->bl_level = value;
+
+    if (value>0)
+    {
+    	if (value > mfd->panel_info->brightness_max)
+    		value = mfd->panel_info->brightness_max;
+
+        if (value < mfd->panel_info->brig_to_bl_lvl_turn_point)
+        {
+            bl_lvl = (mfd->panel_info->brig_to_bl_lvl_para_a1) * value + mfd->panel_info->brig_to_bl_lvl_para_b1;
+        }
+        else
+        {
+            bl_lvl = (mfd->panel_info->brig_to_bl_lvl_para_a2) * value + mfd->panel_info->brig_to_bl_lvl_para_b2;
+        }
+
+        bl_lvl = bl_lvl>0 ? bl_lvl/100 : 0;
+        bl_lvl = bl_lvl>mfd->panel_info->bl_max ? mfd->panel_info->bl_max : bl_lvl;
+    }
+
+	if (!bl_lvl && value)
+		bl_lvl = 1;
+
+	if (!IS_CALIB_MODE_BL(mfd) && (!mfd->ext_bl_ctrl || !value ||
+							!mfd->bl_level)) {
+		mutex_lock(&mfd->bl_lock);
+		mdss_fb_set_backlight(mfd, bl_lvl);
+		mutex_unlock(&mfd->bl_lock);
+	}
+}
+
+#else
 static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev,
 				      enum led_brightness value)
 {
@@ -221,6 +260,7 @@ static void mdss_fb_set_bl_brightness(struct led_classdev *led_cdev,
 		mutex_unlock(&mfd->bl_lock);
 	}
 }
+#endif
 
 static struct led_classdev backlight_led = {
 	.name           = "lcd-backlight",
@@ -832,6 +872,9 @@ void mdss_fb_update_backlight(struct msm_fb_data_type *mfd)
 	}
 }
 
+#ifdef CONFIG_ZTEMT_NX404H_LCD
+extern int mipi_lcd_on_post(void);
+#endif
 static int mdss_fb_blank_sub(int blank_mode, struct fb_info *info,
 			     int op_enable)
 {
@@ -848,6 +891,9 @@ static int mdss_fb_blank_sub(int blank_mode, struct fb_info *info,
 	case FB_BLANK_UNBLANK:
 		if (!mfd->panel_power_on && mfd->mdp.on_fnc) {
 			ret = mfd->mdp.on_fnc(mfd);
+#ifdef CONFIG_ZTEMT_NX404H_LCD
+			mipi_lcd_on_post();
+#endif
 			if (ret == 0) {
 				mfd->panel_power_on = true;
 				mfd->panel_info->panel_dead = false;
diff --git a/drivers/video/msm/mdss/mdss_mdp.c b/drivers/video/msm/mdss/mdss_mdp.c
index 7bddc21..1bc23e4 100644
--- a/drivers/video/msm/mdss/mdss_mdp.c
+++ b/drivers/video/msm/mdss/mdss_mdp.c
@@ -1509,6 +1509,7 @@ static int mdss_mdp_parse_bootarg(struct platform_device *pdev)
 	}
 
 get_dt_pan:
+	if (!rc)
 	rc = mdss_mdp_parse_dt_pan_intf(pdev);
 	/* if pref pan intf is not present */
 	if (rc)
diff --git a/drivers/video/msm/mdss/mdss_mdp_rotator.c b/drivers/video/msm/mdss/mdss_mdp_rotator.c
old mode 100644
new mode 100755
index 91e6373..8f33af5
--- a/drivers/video/msm/mdss/mdss_mdp_rotator.c
+++ b/drivers/video/msm/mdss/mdss_mdp_rotator.c
@@ -37,6 +37,7 @@ static int mdss_mdp_rotator_queue_helper(struct mdss_mdp_rotator_session *rot);
 static struct msm_sync_pt_data *mdss_mdp_rotator_sync_pt_create(
 			struct mdss_mdp_rotator_session *rot);
 
+static u32 count;
 static struct mdss_mdp_rotator_session *mdss_mdp_rotator_session_alloc(void)
 {
 	struct mdss_mdp_rotator_session *rot;
@@ -147,6 +148,12 @@ static int mdss_mdp_rotator_kickoff(struct mdss_mdp_ctl *ctl,
 
 	mutex_lock(&rot->lock);
 	rot->busy = true;
+	/* fRist kickoff change vbif settings */
+	if (!count) {
+		writel_relaxed(0x08010808, mdss_res->vbif_base + 0xB0);
+		writel_relaxed(0x02101010, mdss_res->vbif_base + 0xC0);
+		count++;
+	}
 	ret = mdss_mdp_writeback_display_commit(ctl, &wb_args);
 	if (ret) {
 		rot->busy = false;
@@ -650,6 +657,9 @@ static int mdss_mdp_rotator_finish(struct mdss_mdp_rotator_session *rot)
 		else
 			mixer = tmp->mixer_left;
 		mdss_mdp_wb_mixer_destroy(mixer);
+		writel_relaxed(0x08080808, mdss_res->vbif_base + 0xB0);
+		writel_relaxed(0x10101010, mdss_res->vbif_base + 0xC0);
+		count = 0;
 	}
 	return ret;
 }
diff --git a/drivers/video/msm/mdss/mdss_panel.h b/drivers/video/msm/mdss/mdss_panel.h
index 274c523..167a2fe 100644
--- a/drivers/video/msm/mdss/mdss_panel.h
+++ b/drivers/video/msm/mdss/mdss_panel.h
@@ -278,8 +278,14 @@ struct mdss_panel_info {
 	u32 wait_cycle;
 	u32 pdest;
 	u32 brightness_max;
+    u32 bl_level;
 	u32 bl_max;
 	u32 bl_min;
+    int brig_to_bl_lvl_para_a1;
+    int brig_to_bl_lvl_para_a2;
+    int brig_to_bl_lvl_para_b1;
+    int brig_to_bl_lvl_para_b2;
+    int brig_to_bl_lvl_turn_point;
 	u32 fb_num;
 	u32 clk_rate;
 	u32 clk_min;
diff --git a/drivers/video/msm/mdss/zte_disp_enhance.c b/drivers/video/msm/mdss/zte_disp_enhance.c
new file mode 100755
index 0000000..7efa1b4
--- /dev/null
+++ b/drivers/video/msm/mdss/zte_disp_enhance.c
@@ -0,0 +1,241 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/timer.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include "mdss_dsi.h"
+
+enum {
+	INTENSITY_NORMAL=24,
+	INTENSITY_01,
+	INTENSITY_02
+};
+
+#define ZTE_DISP_ENHANCE_DEBUG
+
+unsigned int zte_intensity_value;
+struct mdss_dsi_ctrl_pdata *zte_mdss_dsi_ctrl = NULL;
+void zte_send_cmd(struct dsi_cmd_desc *cmds, int len);
+
+#if defined(CONFIG_ZTEMT_NE501_LCD)
+#if defined(CONFIG_ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P)
+static char nt35592_55B0[] = {0x55, 0xb0};
+static char nt35592_5580[] = {0x55, 0x80};
+static char nt35592_55[] = {0x55, 0x00};
+
+static char nt35592_FF03[] = {0xFF, 0x03};
+static char nt35592_1A[] = {0x1A, 0x77};
+static char nt35592_56[] = {0x56, 0x00};
+static char nt35592_68[] = {0x68, 0x00};
+static char nt35592_FB[] = {0xFB, 0x01};
+static char nt35592_FF00[] = {0xFF, 0x00};
+static struct dsi_cmd_desc sharp_nt35592_720p_enhance2[] = {
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FF03)}, nt35592_FF03},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_1A)}, nt35592_1A}, 
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_56)}, nt35592_56},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_68)}, nt35592_68},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FB)}, nt35592_FB}, 
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FF00)}, nt35592_FF00},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_55B0)}, nt35592_55B0}, 	
+
+};
+static struct dsi_cmd_desc sharp_nt35592_720p_default[] = {
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_55)}, nt35592_55}, 	
+
+};
+static struct dsi_cmd_desc sharp_nt35592_720p_enhance1[] = {
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FF03)}, nt35592_FF03},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_1A)}, nt35592_1A}, 
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_56)}, nt35592_56},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_68)}, nt35592_68},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FB)}, nt35592_FB}, 
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_FF00)}, nt35592_FF00},
+	{{DTYPE_DCS_WRITE1, 1, 0, 0, 0, sizeof(nt35592_5580)}, nt35592_5580},	
+};
+#endif
+
+static char hx8392b_ce_off[] = {0xE4, 0x00, 0x00};//
+static struct dsi_cmd_desc sharp_hx8392b_720p_default[] = {
+	{{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(hx8392b_ce_off)}, hx8392b_ce_off},
+};
+
+static char hx8392b_ce_low[] = {0xE4, 0x55, 0x01};//
+static struct dsi_cmd_desc sharp_hx8392b_720p_enhance0[] = {
+	{{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(hx8392b_ce_low)}, hx8392b_ce_low},
+};
+/*
+static char hx8392b_ce_medium[] = {0xE4, 0xAA, 0x01};//
+static struct dsi_cmd_desc sharp_hx8392b_720p_enhance1[] = {
+	{{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(hx8392b_ce_medium)}, hx8392b_ce_medium},
+};*/
+
+static char hx8392b_ce_high[] = {0xE4, 0xff, 0x01};//
+static struct dsi_cmd_desc sharp_hx8392b_720p_enhance2[] = {
+	{{DTYPE_DCS_LWRITE, 1, 0, 0, 0, sizeof(hx8392b_ce_high)}, hx8392b_ce_high},
+};
+
+void zte_NE501J_disp_inc(unsigned int state)
+{
+	unsigned int value;
+	value =state;
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s value=%d\n", __func__, value);
+#endif
+#if defined(CONFIG_ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P)
+	if(!zte_mdss_dsi_ctrl)
+	{
+		pr_err("lcd:faild:%s zte_mdss_dsi_ctrl is null\n",__func__);
+		return;
+	}
+	// lianchuang LCM's IC is the same as cs LCM's IC--nt35592
+	if (zte_mdss_dsi_ctrl->panel_name 
+		&& (!strcmp(zte_mdss_dsi_ctrl->panel_name, "cs nt35592 720p video mode dsi panel")
+			|| !strcmp(zte_mdss_dsi_ctrl->panel_name, "lianchuang nt35592 720p video mode dsi panel"))) {
+		switch (value) {
+		case INTENSITY_NORMAL:
+			zte_send_cmd(sharp_nt35592_720p_default
+				, sizeof(sharp_nt35592_720p_default)/sizeof(sharp_nt35592_720p_default[0]));
+			break;
+		case INTENSITY_01:
+			zte_send_cmd(sharp_nt35592_720p_enhance1
+				, sizeof(sharp_nt35592_720p_enhance1)/sizeof(sharp_nt35592_720p_enhance1[0]));
+			break;
+		case INTENSITY_02:
+			zte_send_cmd(sharp_nt35592_720p_enhance2
+				, sizeof(sharp_nt35592_720p_enhance2)/sizeof(sharp_nt35592_720p_enhance2[0]));
+			break;
+		default:
+			zte_send_cmd(sharp_nt35592_720p_enhance1
+				, sizeof(sharp_nt35592_720p_enhance1)/sizeof(sharp_nt35592_720p_enhance1[0]));
+			break;
+		}
+	} else {
+#endif
+		switch (value) {
+		case INTENSITY_NORMAL:
+			zte_send_cmd(sharp_hx8392b_720p_default
+				, sizeof(sharp_hx8392b_720p_default)/sizeof(sharp_hx8392b_720p_default[0]));
+			break;
+		case INTENSITY_01:
+			zte_send_cmd(sharp_hx8392b_720p_enhance0
+			, sizeof(sharp_hx8392b_720p_enhance0)/sizeof(sharp_hx8392b_720p_enhance0[0]));
+			/*zte_send_cmd(sharp_hx8392b_720p_enhance1
+				, sizeof(sharp_hx8392b_720p_enhance1)/sizeof(sharp_hx8392b_720p_enhance1[0]));*/
+			break;
+		case INTENSITY_02:
+			zte_send_cmd(sharp_hx8392b_720p_enhance2
+				, sizeof(sharp_hx8392b_720p_enhance2)/sizeof(sharp_hx8392b_720p_enhance2[0]));
+			break;
+		default:
+			zte_send_cmd(sharp_hx8392b_720p_enhance0
+				, sizeof(sharp_hx8392b_720p_enhance0)/sizeof(sharp_hx8392b_720p_enhance0[0]));
+			break;
+		}
+#if defined(CONFIG_ZTEMT_MIPI_720P_NT35592_SHARP_IPS_5P)
+	}
+#endif
+}
+#endif
+
+void zte_send_cmd(struct dsi_cmd_desc *cmds, int len)
+{
+	struct dcs_cmd_req cmdreq;
+
+
+	if(!zte_mdss_dsi_ctrl)
+	{
+		pr_err("lcd:faild:%s zte_mdss_dsi_ctrl is null\n",__func__);
+		return;
+	}
+	
+	memset(&cmdreq, 0, sizeof(cmdreq));
+	cmdreq.cmds = cmds;
+	cmdreq.cmds_cnt = len;
+	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
+
+	mdss_dsi_cmdlist_put(zte_mdss_dsi_ctrl, &cmdreq);
+}
+
+void zte_mipi_disp_inc(unsigned int state)
+{
+#if defined(CONFIG_ZTEMT_NE501_LCD)
+  zte_NE501J_disp_inc(state);
+#endif
+}
+
+void zte_disp_enhance(void)
+{
+  zte_mipi_disp_inc(zte_intensity_value);
+}
+static ssize_t intensity_show(struct kobject *kobj, struct kobj_attribute *attr,
+   char *buf)
+{
+	snprintf(buf, 50, "%u\n", zte_intensity_value);
+
+	return 0;
+}
+static ssize_t intensity_store(struct kobject *kobj, struct kobj_attribute *attr,
+    const char *buf, size_t size)
+{
+	ssize_t ret = 0;
+	int val;
+	static bool is_firsttime = true;
+	sscanf(buf, "%d", &val);
+
+#ifdef ZTE_DISP_ENHANCE_DEBUG
+	printk("lcd:%s state=%d size=%d\n", __func__, (int)val, (int)size);
+#endif
+	zte_intensity_value = val;
+	if (is_firsttime) {
+		is_firsttime = false;
+		return ret;
+	}
+	zte_mipi_disp_inc(val);
+
+	return ret;
+}
+
+static struct kobj_attribute disptype_attribute =
+ __ATTR(saturation, 0664, intensity_show, intensity_store);
+
+ static struct attribute *attrs[] = {
+  &disptype_attribute.attr,
+  NULL, /* need to NULL terminate the list of attributes */
+ };
+ static struct attribute_group attr_group = {
+  .attrs = attrs,
+ };
+ 
+ static struct kobject *id_kobj;
+ 
+ static int __init id_init(void)
+ {
+  int retval;
+ 
+  id_kobj = kobject_create_and_add("lcd_enhance", kernel_kobj);
+  if (!id_kobj)
+   return -ENOMEM;
+ 
+  /* Create the files associated with this kobject */
+  retval = sysfs_create_group(id_kobj, &attr_group);
+  if (retval)
+   kobject_put(id_kobj);
+ 
+  return retval;
+ }
+ 
+ static void __exit id_exit(void)
+ {
+  kobject_put(id_kobj);
+ }
+ 
+ module_init(id_init);
+ module_exit(id_exit);
+ 
diff --git a/include/linux/batterydata-lib.h b/include/linux/batterydata-lib.h
old mode 100644
new mode 100755
index f556236..66d781f
--- a/include/linux/batterydata-lib.h
+++ b/include/linux/batterydata-lib.h
@@ -135,6 +135,12 @@ extern struct bms_battery_data  desay_5200_data;
 extern struct bms_battery_data  oem_batt_data;
 extern struct bms_battery_data QRD_4v35_2000mAh_data;
 extern struct bms_battery_data  qrd_4v2_1300mah_data;
+#ifdef CONFIG_ZTEMT_2400AMH_BATTERY
+extern struct bms_battery_data  ztemt_2400mAh_data;
+#endif
+#ifdef CONFIG_ZTEMT_2000AMH_BATTERY
+extern struct bms_battery_data  ztemt_2000mAh_data;
+#endif
 
 int interpolate_fcc(struct single_row_lut *fcc_temp_lut, int batt_temp);
 int interpolate_scalingfactor(struct sf_lut *sf_lut, int row_entry, int pc);
diff --git a/include/linux/i2c/sensor_common.h b/include/linux/i2c/sensor_common.h
new file mode 100644
index 0000000..30d99c1
--- /dev/null
+++ b/include/linux/i2c/sensor_common.h
@@ -0,0 +1,16 @@
+
+#ifndef __SENSOR_COMMON_H_
+#define __SENSOR_COMMON_H_
+
+
+struct sensor_common_data {
+    struct i2c_client *client;
+    struct device *sensor_compass_dev;
+};
+
+#define COMPASS_INT_PIN     64
+
+
+static int __devinit sensor_common_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int __devexit sensor_common_remove(struct i2c_client *client);
+#endif
diff --git a/include/linux/i2c/shtc1.h b/include/linux/i2c/shtc1.h
new file mode 100644
index 0000000..3006874
--- /dev/null
+++ b/include/linux/i2c/shtc1.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2012 Sensirion AG, Switzerland
+ * Author: Johannes Winkelmann <johannes.winkelmann@sensirion.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SHTC1_H_
+#define __SHTC1_H_
+
+struct shtc1_pdata {
+	bool blocking_io;
+	bool high_precision;
+};
+
+struct shtc1_data {
+
+    struct mutex lock;
+
+    struct i2c_client *client;
+    struct shtc1_pdata pdata;
+
+    struct device *temperature_dev;
+    struct device *humidity_dev;
+
+	struct input_dev *t_idev;
+	struct input_dev *h_idev;
+
+    const char *input_dev_t_name;
+    const char *input_dev_h_name;
+
+
+	struct delayed_work poll_work;
+
+    unsigned int temperature_poll_time;
+    unsigned int humidity_poll_time;
+    unsigned int poll_time;
+    unsigned int poll_time_minimum;
+
+
+    bool valid;
+    unsigned long last_updated; /* In jiffies */
+
+    const unsigned char *command;
+    unsigned int nonblocking_wait_time;
+
+
+    int temperature_data;
+    int humidity_data;
+
+    bool temperature_state;
+    bool humidity_state;
+    
+    bool temperature_debug;
+    bool humidity_debug;
+
+};
+
+static int __devinit shtc1_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int __devexit shtc1_remove(struct i2c_client *client);
+static void shtc1_input_humidity(struct shtc1_data *chip_data);
+static void shtc1_input_temperature(struct shtc1_data *chip_data);
+
+#endif
diff --git a/include/linux/i2c/taos_common.h b/include/linux/i2c/taos_common.h
new file mode 100755
index 0000000..90bff12
--- /dev/null
+++ b/include/linux/i2c/taos_common.h
@@ -0,0 +1,85 @@
+/*******************************************************************************
+*                                                                              *
+*       File Name:      taos_common.h                                          *
+*       Description:    Common file for ioctl and configuration definitions.   *
+*       		Used by kernel driver and driver access applications.  *
+*       		Please include this file, and <sys/ioctl.h> in your    * 
+*                       driver access application program source.	       *
+*       Author:         John Koshi                                             *
+*       History:        09/16/2009 - Initial creation                          *
+*       		02/07/2010 - Add proximity			       *
+*                                                                              *
+********************************************************************************
+*       Proprietary to Taos Inc., 1001 Klein Road #300, Plano, TX 75074        *
+*******************************************************************************/
+// ioctl numbers
+//#include <types.h>
+#include <linux/wakelock.h>
+
+#define TAOS_IOCTL_MAGIC        	0XCF
+#define TAOS_IOCTL_ALS_ON       	_IO(TAOS_IOCTL_MAGIC, 1)
+#define TAOS_IOCTL_ALS_OFF      	_IO(TAOS_IOCTL_MAGIC, 2)
+#define TAOS_IOCTL_ALS_DATA     	_IOR(TAOS_IOCTL_MAGIC, 3, short)
+#define TAOS_IOCTL_ALS_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 4)
+#define TAOS_IOCTL_CONFIG_GET   	_IOR(TAOS_IOCTL_MAGIC, 5, struct taos_cfg *)
+#define TAOS_IOCTL_CONFIG_SET		_IOW(TAOS_IOCTL_MAGIC, 6, struct taos_cfg)
+#define TAOS_IOCTL_PROX_ON		    _IO(TAOS_IOCTL_MAGIC, 7)
+#define TAOS_IOCTL_PROX_OFF		    _IO(TAOS_IOCTL_MAGIC, 8)
+#define TAOS_IOCTL_PROX_DATA		_IOR(TAOS_IOCTL_MAGIC, 9, struct taos_prox_info)
+#define TAOS_IOCTL_PROX_EVENT       _IO(TAOS_IOCTL_MAGIC, 10)
+#define TAOS_IOCTL_PROX_CALIBRATE	_IO(TAOS_IOCTL_MAGIC, 11)
+
+#define TAOS_IOCTL_SENSOR_ON	    (TAOS_IOCTL_MAGIC, 12)
+#define TAOS_IOCTL_SENSOR_OFF	    _IO(TAOS_IOCTL_MAGIC, 13)
+#define TAOS_IOCTL_SENSOR_CONFIG	_IOW(TAOS_IOCTL_MAGIC, 14, struct taos_cfg)
+#define TAOS_IOCTL_SENSOR_CHECK	    _IO(TAOS_IOCTL_MAGIC, 15)
+#define TAOS_IOCTL_SENSOR_test	    _IO(TAOS_IOCTL_MAGIC, 16)
+
+#define TAOS_IOCTL_ALS_SET_DELAY	_IO(TAOS_IOCTL_MAGIC, 17)
+
+// device configuration
+struct taos_cfg 
+{
+    u32 calibrate_target;
+    u16 als_time;
+    u16 scale_factor_als;
+	u16 scale_factor_prox;
+    u16 gain_trim;
+    u8  filter_history;
+    u8  filter_count;
+    u8  gain;
+	u16	prox_threshold_hi;
+	u16 prox_threshold_lo;
+	u16	als_threshold_hi;
+	u16 als_threshold_lo;
+	u8	prox_int_time;
+	u8	prox_adc_time;
+	u8	prox_wait_time;
+	u8	prox_intr_filter;
+	u8	prox_config;
+	u8	prox_pulse_cnt;
+	u8	prox_gain;
+	u8	prox_config_offset;
+};
+
+// proximity data
+struct taos_prox_info 
+{
+        u16 prox_clear;
+        u16 prox_data;
+        int prox_event;
+};
+
+struct taos_wake_lock{
+    struct wake_lock lock;
+    bool   locked;
+    char   *name;
+};
+
+// add by clli2 for proximity debug
+enum
+{
+	DEBUG_DEFAULT = 1U << 0,
+	DEBUG_CRITICAL = 1U << 2,
+	DEBUG_ABNORMAL = 1U << 3, //don't modify it
+};
diff --git a/include/linux/i2c/tmg399x.h b/include/linux/i2c/tmg399x.h
new file mode 100644
index 0000000..0f69676
--- /dev/null
+++ b/include/linux/i2c/tmg399x.h
@@ -0,0 +1,458 @@
+/*
+ * Device driver for monitoring ambient light intensity in (lux)
+ * proximity detection (prox), and Gesture functionality within the
+ * AMS-TAOS TMG399X family of devices.
+ *
+ * Copyright (c) 2013, AMS-TAOS USA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __TMG399X_H
+#define __TMG399X_H
+
+#include <linux/types.h>
+#include <linux/wakelock.h>
+
+/* Max number of segments allowable in LUX table */
+#define TMG399X_MAX_LUX_TABLE_SIZE		9
+#define MAX_DEFAULT_TABLE_BYTES (sizeof(int) * TMG399X_MAX_LUX_TABLE_SIZE)
+
+/* Default LUX and Color coefficients */
+
+#define D_Factor	241
+#define R_Coef		144
+#define G_Coef		1000
+#define B_Coef		400
+#define CT_Coef		(3972)
+#define CT_Offset	(1672)
+
+#define D_Factor1	615*2
+#define R_Coef1		443
+#define G_Coef1		1000
+#define B_Coef1		180
+#define CT_Coef1	(2042)
+#define CT_Offset1	(2396)
+
+#define TMG399X_INT_PIN    49
+
+struct device;
+
+#define TMG399X_CMD_IRBEAM_INT_CLR	0xE3
+#define TMG399X_CMD_PROX_INT_CLR	0xE5
+#define TMG399X_CMD_ALS_INT_CLR		0xE6
+#define TMG399X_CMD_NON_GES_INT_CLR	0xE7
+
+#define PRX_PERSIST(p) (((p) & 0xf) << 4)
+#define ALS_PERSIST(p) (((p) & 0xf) << 0)
+#define PRX_PULSE_CNT(p) (((p-1) & 0x3f) << 0)
+#define GES_PULSE_CNT(p) (((p-1) & 0x3f) << 0)
+
+#define I2C_ADDR_OFFSET	0X80
+
+enum tmg399x_regs {
+	TMG399X_CONTROL,
+	TMG399X_ALS_TIME,
+	TMG399X_RESV_1,
+	TMG399X_WAIT_TIME,
+	TMG399X_ALS_MINTHRESHLO,
+	TMG399X_ALS_MINTHRESHHI,
+	TMG399X_ALS_MAXTHRESHLO,
+	TMG399X_ALS_MAXTHRESHHI,
+	TMG399X_RESV_2,
+	TMG399X_PRX_THRES_LOW,
+	TMG399X_RESV_3,
+	TMG399X_PRX_THRES_HIGH,
+	TMG399X_PERSISTENCE,
+	TMG399X_CONFIG_1,
+	TMG399X_PRX_PULSE,
+	TMG399X_GAIN,
+
+	TMG399X_CONFIG_2,
+	TMG399X_REVID,
+	TMG399X_CHIPID,
+	TMG399X_STATUS,
+	TMG399X_CLR_CHANLO,
+	TMG399X_CLR_CHANHI,
+	TMG399X_RED_CHANLO,
+	TMG399X_RED_CHANHI,
+	TMG399X_GRN_CHANLO,
+	TMG399X_GRN_CHANHI,
+	TMG399X_BLU_CHANLO,
+	TMG399X_BLU_CHANHI,
+	TMG399X_PRX_CHAN,
+	TMG399X_PRX_OFFSET_NE,
+	TMG399X_PRX_OFFSET_SW,
+	TMG399X_CONFIG_3,
+
+	TMG399X_GES_ENTH,
+	TMG399X_GES_EXTH,
+	TMG399X_GES_CFG_1,
+	TMG399X_GES_CFG_2,
+	TMG399X_GES_OFFSET_N,
+	TMG399X_GES_OFFSET_S,
+	TMG399X_GES_PULSE,
+	TMG399X_GES_OFFSET_W,
+	TMG399X_GES_RESV,
+	TMG399X_GES_OFFSET_E,
+	TMG399X_GES_CFG_3,
+	TMG399X_GES_CFG_4,
+	TMG399X_RESV_4,
+	TMG399X_RESV_5,
+	TMG399X_GES_FLVL,
+	TMG399X_GES_STAT,
+
+	TMG399X_REG_MAX,
+};
+
+enum tmg399x_irbeam_regs {
+	TMG399X_IRBEAM_CFG = 0x20,
+	TMG399X_IRBEAM_RESV,
+	TMG399X_IRBEAM_NS,
+	TMG399X_IRBEAM_ISD,
+	TMG399X_IRBEAM_NP,
+	TMG399X_IRBEAM_IPD,
+	TMG399X_IRBEAM_DIV,
+	TMG399X_IRBEAM_LEN,
+	TMG399X_IRBEAM_STAT,
+};
+
+enum tmg399x_gesfifo_regs {
+	TMG399X_GES_NFIFO = 0x7C,
+	TMG399X_GES_SFIFO,
+	TMG399X_GES_WFIFO,
+	TMG399X_GES_EFIFO,
+};
+
+enum tmg399x_remote_regs {
+	TMG399X_REMOTE_CFG = 0x20,
+	TMG399X_REMOTE_CARR,
+	TMG399X_REMOTE_NS,
+	TMG399X_REMOTE_DLY2T,
+	TMG399X_REMOTE_NCP,
+	TMG399X_REMOTE_CPOFF,
+	TMG399X_REMOTE_DIV,
+	TMG399X_REMOTE_LEN,
+	TMG399X_REMOTE_STAT,
+	TMG399X_REMOTE_SLEN,
+};
+
+enum tmg399x_pwr_state {
+	POWER_ON,
+	POWER_OFF,
+	POWER_STANDBY,
+};
+
+enum tmg399x_en_reg {
+	TMG399X_EN_PWR_ON   = (1 << 0),
+	TMG399X_EN_ALS      = (1 << 1),
+	TMG399X_EN_PRX      = (1 << 2),
+	TMG399X_EN_WAIT     = (1 << 3),
+	TMG399X_EN_ALS_IRQ  = (1 << 4),
+	TMG399X_EN_PRX_IRQ  = (1 << 5),
+	TMG399X_EN_GES      = (1 << 6),
+	TMG399X_EN_BEAM     = (1 << 7),
+};
+
+enum tmg399x_cfgl_reg {
+	WLONG          = (1 << 1),
+};
+
+enum tmg399x_ppulse_reg {
+	PPLEN_4US      = (0 << 6),
+	PPLEN_8US      = (1 << 6),
+	PPLEN_16US     = (2 << 6),
+	PPLEN_32US     = (3 << 6),
+};
+
+enum tmg399x_ctrl_reg {
+	AGAIN_1        = (0 << 0),
+	AGAIN_4        = (1 << 0),
+	AGAIN_16       = (2 << 0),
+	AGAIN_64       = (3 << 0),
+	PGAIN_1        = (0 << 2),
+	PGAIN_2        = (1 << 2),
+	PGAIN_4        = (2 << 2),
+	PGAIN_8        = (3 << 2),
+	PDRIVE_100MA   = (0 << 6),
+	PDRIVE_50MA    = (1 << 6),
+	PDRIVE_25MA    = (2 << 6),
+	PDRIVE_12MA    = (3 << 6),
+};
+
+
+enum tmg399x_cfg2_reg {
+	LEDBOOST_100   = (0 << 4),
+	LEDBOOST_150   = (1 << 4),
+	LEDBOOST_200   = (2 << 4),
+	LEDBOOST_300   = (3 << 4),
+	CPSIEN         = (1 << 6),
+	PSIEN          = (1 << 7),
+};
+
+enum tmg399x_status {
+	TMG399X_ST_ALS_VALID  = (1 << 0),
+	TMG399X_ST_PRX_VALID  = (1 << 1),
+	TMG399X_ST_GES_IRQ    = (1 << 2),
+	TMG399X_ST_BEAM_IRQ   = (1 << 3),
+	TMG399X_ST_ALS_IRQ    = (1 << 4),
+	TMG399X_ST_PRX_IRQ    = (1 << 5),
+	TMG399X_ST_PRX_SAT    = (1 << 6),
+	TMG399X_ST_CP_SAT     = (1 << 7),
+};
+
+enum tmg399x_cfg3_reg {
+	PMASK_E        = (1 << 0),
+	PMASK_W        = (1 << 1),
+	PMASK_S        = (1 << 2),
+	PMASK_N        = (1 << 3),
+	SAI            = (1 << 4),
+	PCMP           = (1 << 5),
+};
+
+enum tmg399x_ges_cfg1_reg {
+	GEXPERS_1      = (0 << 0),
+	GEXPERS_2      = (1 << 0),
+	GEXPERS_4      = (2 << 0),
+	GEXPERS_7      = (3 << 0),
+	GEXMSK_E       = (1 << 2),
+	GEXMSK_W       = (1 << 3),
+	GEXMSK_S       = (1 << 4),
+	GEXMSK_N       = (1 << 5),
+	FIFOTH_1       = (0 << 6),
+	FIFOTH_4       = (1 << 6),
+	FIFOTH_8       = (2 << 6),
+	FIFOTH_16      = (3 << 6),
+};
+
+enum tmg399x_ges_cfg2_reg {
+	GWTIME_0       = (0 << 0),
+	GWTIME_3       = (1 << 0),
+	GWTIME_6       = (2 << 0),
+	GWTIME_8       = (3 << 0),
+	GWTIME_14      = (4 << 0),
+	GWTIME_22      = (5 << 0),
+	GWTIME_30      = (6 << 0),
+	GWTIME_39      = (7 << 0),
+	GLDRIVE_100    = (0 << 3),
+	GLDRIVE_50     = (1 << 3),
+	GLDRIVE_25     = (2 << 3),
+	GLDRIVE_12     = (3 << 3),
+	GGAIN_1        = (0 << 5),
+	GGAIN_2        = (1 << 5),
+	GGAIN_4        = (2 << 5),
+	GGAIN_8        = (3 << 5),
+};
+
+enum tmg399x_gpulse_reg {
+	GPLEN_4US      = (0 << 6),
+	GPLEN_8US      = (1 << 6),
+	GPLEN_16US     = (2 << 6),
+	GPLEN_32US     = (3 << 6),
+};
+
+enum tmg399x_ges_cfg3_reg {
+	GBOTH_PAIR     = (0 << 0),
+	GONLY_NS       = (1 << 0),
+	GONLY_WE       = (2 << 0),
+};
+
+enum tmg399x_ges_cfg4 {
+	TMG399X_GES_MODE     = (1 << 0),
+	TMG399X_GES_EN_IRQ   = (1 << 1),
+	TMG399X_GES_INT_CLR  = (1 << 2),
+};
+
+enum tmg399x_ges_status {
+	TMG399X_GES_VALID     = (1 << 0),
+	TMG399X_GES_FOV       = (1 << 1),
+};
+
+enum {
+	TMG399X_ALS_GAIN_MASK = (3 << 0),
+	TMG399X_PRX_GAIN_MASK = (3 << 2),
+	TMG399X_LDRIVE_MASK   = (3 << 6),
+	TMG399X_ALS_AGL_MASK  = (1 << 2),
+	TMG399X_ALS_AGL_BOOST = 2,
+	TMG399X_ATIME_PER_100 = 278,
+	//TMG399X_ATIME_DEFAULT_MS = 50,
+	SCALE_SHIFT = 11,
+	RATIO_SHIFT = 10,
+	MAX_ALS_VALUE = 0xffff,
+	MIN_ALS_VALUE = 0,
+	GAIN_SWITCH_LEVEL = 100,
+	//GAIN_AUTO_INIT_VALUE = AGAIN_16,
+	TMG399X_GES_ST_MASK   = (3 << 0),
+    TMG399X_GES_GAIN_MASK = (3 << 5)
+};
+
+struct tmg399x_als_info {
+	u32 cpl;
+	u32 saturation;
+	u16 clear_raw;
+	u16 red_raw;
+	u16 green_raw;
+	u16 blue_raw;
+	u16 lux;
+	u16 cct;
+	s16 ir;
+};
+
+struct tmg399x_prox_info {
+	int raw;
+	int detected;
+};
+
+struct tmg399x_parameters {
+	u8 als_time;
+	u8 als_gain;
+	u16 als_deltaP;
+	u8 wait_time;
+	u8 prox_th_low;
+	u8 prox_th_high;
+	u8 persist;
+	u8 als_prox_cfg1;
+	u8 prox_pulse;
+	u8 prox_gain;
+	u8 ldrive;
+	u8 als_prox_cfg2;
+	s8 prox_offset_ne;
+	s8 prox_offset_sw;
+	u8 als_prox_cfg3;
+	
+	u8 ges_entry_th;
+	u8 ges_exit_th;
+	u8 ges_cfg1;
+	u8 ges_cfg2;
+	s8 ges_offset_n;
+	s8 ges_offset_s;
+	u8 ges_pulse;
+	s8 ges_offset_w;
+	s8 ges_offset_e;
+	u8 ges_dimension;
+};
+
+struct tmg399x_ges_raw_data {
+	int north;
+	int south;
+	int west;
+	int east;
+};
+
+struct sGesture_Result
+{
+    int  gesture_style;
+    long enter_time;
+    long exit_time;
+    int  enter_angle;
+    int  exit_angle;
+};
+
+struct tmg399x_wake_lock{
+    struct wake_lock lock;
+    bool   locked;
+    char   *name;
+};
+
+struct tmg399x_chip {
+	struct mutex lock;
+    struct tmg399x_wake_lock proximity_wakelock;
+    struct tmg399x_wake_lock display_power_controller;
+	struct i2c_client *client;
+	struct work_struct irq_work;
+	struct delayed_work als_poll_work;
+	struct delayed_work prox_calibrate_work;
+	struct hrtimer prox_unwakelock_timer;
+
+	struct tmg399x_prox_info prx_inf;
+	struct tmg399x_als_info als_inf;
+	struct tmg399x_parameters params;
+	struct tmg399x_i2c_platform_data *pdata;
+    struct tmg399x_ges_raw_data gesture_data[32];
+	struct lux_segment *segment;
+
+	struct input_dev *a_idev;
+	struct input_dev *p_idev;
+	struct input_dev *g_idev;
+
+    struct device *proximity_dev;
+    struct device *light_dev;
+    struct device *gesture_dev;
+
+	u8 shadow[48];
+	u8 device_index;
+
+	int  in_suspend;
+	int  wake_irq;
+	int  irq_pending;
+	int  segment_num;
+	int  seg_num_max;
+    int  light_poll_time;
+
+    int  prox_calibrate_times;
+    int  prox_thres_hi_max;
+    int  prox_thres_lo_min;
+    int  prox_data_max;
+    int prox_manual_calibrate_threshold;
+
+    char *chip_name;
+    
+
+
+	bool unpowered;
+	bool als_enabled;
+	bool wait_enabled;
+	bool prx_enabled;
+	bool ges_enabled;
+	bool ges_debug_enable;
+	bool light_debug_enable;
+	bool prox_debug_enable;
+	bool prox_calibrate_result;
+	bool prox_calibrate_start;
+	bool als_gain_auto;
+	bool wakeup_from_sleep;
+	bool wakelock_locked;
+	bool irq_enabled;
+	bool irq_work_status;
+	bool gesture_start; 
+	bool phone_is_sleep;
+};
+
+struct lux_segment {
+	int d_factor;
+	int r_coef;
+	int g_coef;
+	int b_coef;
+	int ct_coef;
+	int ct_offset;
+};
+
+struct tmg399x_i2c_platform_data {
+	/* The following callback for power events received and handled by
+	   the driver.  Currently only for SUSPEND and RESUME */
+	int (*platform_power)(struct device *dev, enum tmg399x_pwr_state state);
+	int (*platform_init)(void);
+	void (*platform_teardown)(struct device *dev);
+	char const *prox_name;
+	char const *als_name;
+	char const *ges_name;
+	struct tmg399x_parameters parameters;
+	bool proximity_can_wake;
+	bool als_can_wake;
+	struct lux_segment *segment;
+	int segment_num;
+};
+
+#endif /* __TMG399X_H */
diff --git a/include/linux/mfd/wcd9xxx/wcd9306_registers.h b/include/linux/mfd/wcd9xxx/wcd9306_registers.h
index 564e5b3..673679d 100644
--- a/include/linux/mfd/wcd9xxx/wcd9306_registers.h
+++ b/include/linux/mfd/wcd9xxx/wcd9306_registers.h
@@ -186,9 +186,17 @@
 #define TAPAN_A_MICB_CFILT_1_PRECHRG			(0x12A)
 #define TAPAN_A_MICB_CFILT_1_PRECHRG__POR				(0x00)
 #define TAPAN_A_MICB_1_CTL			(0x12B)
+#if defined(CONFIG_ZTEMT_AUDIO)
+#define TAPAN_A_MICB_1_CTL__POR				(0x12)
+#else
 #define TAPAN_A_MICB_1_CTL__POR				(0x02)
+#endif
 #define TAPAN_A_MICB_1_INT_RBIAS			(0x12C)
+#if defined(CONFIG_ZTEMT_AUDIO)
+#define TAPAN_A_MICB_1_INT_RBIAS__POR				(0x00)
+#else 
 #define TAPAN_A_MICB_1_INT_RBIAS__POR				(0x24)
+#endif
 #define TAPAN_A_MICB_1_MBHC			(0x12D)
 #define TAPAN_A_MICB_1_MBHC__POR				(0x01)
 #define TAPAN_A_MICB_CFILT_2_CTL			(0x12E)
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
old mode 100644
new mode 100755
index 0c89a42..4f9108a
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -87,7 +87,12 @@ enum {
 
 enum power_supply_property {
 	/* Properties of type `int' */
+#ifdef CONFIG_ZTEMT_CHARGE	
+		POWER_SUPPLY_PROP_CHARGER_ONLINE = 0,
+		POWER_SUPPLY_PROP_STATUS ,
+#else	
 	POWER_SUPPLY_PROP_STATUS = 0,
+#endif
 	POWER_SUPPLY_PROP_CHARGE_TYPE,
 	POWER_SUPPLY_PROP_HEALTH,
 	POWER_SUPPLY_PROP_PRESENT,
diff --git a/include/linux/usb/android.h b/include/linux/usb/android.h
old mode 100644
new mode 100755
index 4accfa0..449ec0f
--- a/include/linux/usb/android.h
+++ b/include/linux/usb/android.h
@@ -26,7 +26,8 @@ struct android_usb_platform_data {
 	u32 swfi_latency;
 	u8 usb_core_id;
 	bool cdrom;
-	bool internal_ums;
+	//bool internal_ums;
+	bool external_ums;
 	char streaming_func[MAX_STREAMING_FUNCS][FUNC_NAME_LEN];
 	int  streaming_func_count;
 	u32 uicc_nluns;
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
old mode 100644
new mode 100755
index 172e415..936e4e3
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -36,7 +36,9 @@ const char *const pm_states[PM_SUSPEND_MAX] = {
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 };
-
+#ifdef CONFIG_ZTEMT_POWER_DEBUG
+bool wakeup_wake_lock_debug = false;
+#endif
 static const struct platform_suspend_ops *suspend_ops;
 
 /**
@@ -215,6 +217,9 @@ int suspend_devices_and_enter(suspend_state_t state)
 		if (error)
 			goto Close;
 	}
+	#ifdef CONFIG_ZTEMT_POWER_DEBUG
+	wakeup_wake_lock_debug = true;
+	#endif
 	suspend_console();
 	suspend_test_start();
 	error = dpm_suspend_start(PMSG_SUSPEND);
diff --git a/sound/Kconfig b/sound/Kconfig
index 261a03c..d6fc0d5 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -59,6 +59,16 @@ config SOUND_OSS_CORE_PRECLAIM
 
 source "sound/oss/dmasound/Kconfig"
 
+config ZTEMT_AUDIO_NX404H
+       bool "AUDIO MACRO for ZTEMT NX404H"
+       default n
+       help 
+              AUDIO MACRO for ZTEMT NX404H
+config ZTEMT_AUDIO
+       bool "AUDIO MACRO for ZTEMT"
+       default n
+       help 
+              AUDIO MACRO for ZTEMT
 if !M68K && !UML
 
 menuconfig SND
diff --git a/sound/soc/codecs/wcd9306.c b/sound/soc/codecs/wcd9306.c
index 89e54bb..97f97ee 100644
--- a/sound/soc/codecs/wcd9306.c
+++ b/sound/soc/codecs/wcd9306.c
@@ -2230,7 +2230,13 @@ static int tapan_codec_enable_micbias(struct snd_soc_dapm_widget *w,
 		wcd9xxx_resmgr_cfilt_get(&tapan->resmgr, cfilt_sel_val);
 
 		if (strnstr(w->name, internal1_text, 30))
+                {
+                #if defined(CONFIG_ZTEMT_AUDIO)
+			snd_soc_update_bits(codec, micb_int_reg, 0xE0, 0x00);
+                #else
 			snd_soc_update_bits(codec, micb_int_reg, 0xE0, 0xE0);
+                #endif
+                }
 		else if (strnstr(w->name, internal2_text, 30))
 			snd_soc_update_bits(codec, micb_int_reg, 0x1C, 0x1C);
 		else if (strnstr(w->name, internal3_text, 30))
@@ -4943,8 +4949,13 @@ static int tapan_handle_pdata(struct tapan_priv *tapan)
 	}
 
 	/* Set micbias capless mode with tail current */
+        #if defined(CONFIG_ZTEMT_AUDIO)
+	value = (pdata->micbias.bias1_cap_mode == MICBIAS_EXT_BYP_CAP ?
+		 0x10 : 0x10);
+        #else
 	value = (pdata->micbias.bias1_cap_mode == MICBIAS_EXT_BYP_CAP ?
 		 0x00 : 0x10);
+        #endif
 	snd_soc_update_bits(codec, TAPAN_A_MICB_1_CTL, 0x10, value);
 	value = (pdata->micbias.bias2_cap_mode == MICBIAS_EXT_BYP_CAP ?
 		 0x00 : 0x10);
diff --git a/sound/soc/codecs/wcd9xxx-mbhc.c b/sound/soc/codecs/wcd9xxx-mbhc.c
index 4b7625a..49d36c6 100644
--- a/sound/soc/codecs/wcd9xxx-mbhc.c
+++ b/sound/soc/codecs/wcd9xxx-mbhc.c
@@ -99,7 +99,7 @@
  * Invalid voltage range for the detection
  * of plug type with current source
  */
-#define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV 160
+#define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV 266
 #define WCD9XXX_CS_MEAS_INVALD_RANGE_HIGH_MV 265
 
 /*
diff --git a/sound/soc/msm/msm8226.c b/sound/soc/msm/msm8226.c
index cc27fc0..93fc4dc 100644
--- a/sound/soc/msm/msm8226.c
+++ b/sound/soc/msm/msm8226.c
@@ -49,7 +49,7 @@
 #define EXT_CLASS_D_DIS_DELAY 3000
 #define EXT_CLASS_D_DELAY_DELTA 2000
 
-#define WCD9XXX_MBHC_DEF_BUTTONS 8
+#define WCD9XXX_MBHC_DEF_BUTTONS 3
 #define WCD9XXX_MBHC_DEF_RLOADS 5
 #define TAPAN_EXT_CLK_RATE 9600000
 
@@ -1093,21 +1093,11 @@ void *def_tapan_mbhc_cal(void)
 	btn_high = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg,
 					       MBHC_BTN_DET_V_BTN_HIGH);
 	btn_low[0] = -50;
-	btn_high[0] = 20;
-	btn_low[1] = 21;
-	btn_high[1] = 61;
-	btn_low[2] = 62;
-	btn_high[2] = 104;
-	btn_low[3] = 105;
-	btn_high[3] = 148;
-	btn_low[4] = 149;
-	btn_high[4] = 189;
-	btn_low[5] = 190;
-	btn_high[5] = 228;
-	btn_low[6] = 229;
-	btn_high[6] = 269;
-	btn_low[7] = 270;
-	btn_high[7] = 500;
+	btn_high[0] = 150;
+	btn_low[1] = 151;
+	btn_high[1] = 320;
+	btn_low[2] = 321;
+	btn_high[2] = 500;
 	n_ready = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg, MBHC_BTN_DET_N_READY);
 	n_ready[0] = 80;
 	n_ready[1] = 12;
Find people


Search
